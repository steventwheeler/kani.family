var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value2) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField2 = (obj, key, value2) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod4) => function __require2() {
  return mod4 || (0, cb[__getOwnPropNames(cb)[0]])((mod4 = { exports: {} }).exports, mod4), mod4.exports;
};
var __export = (target, all4) => {
  for (var name9 in all4)
    __defProp(target, name9, { get: all4[name9], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod4, isNodeMode, target) => (target = mod4 != null ? __create(__getProtoOf(mod4)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod4 || !mod4.__esModule ? __defProp(target, "default", { value: mod4, enumerable: true }) : target,
  mod4
));
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value2) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
};
var __privateSet = (obj, member, value2, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value2) : member.set(obj, value2);
  return value2;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value2) {
    __privateSet(obj, member, value2, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    exports2.byteLength = byteLength2;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup3 = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code8 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i2 = 0, len = code8.length; i2 < len; ++i2) {
      lookup3[i2] = code8[i2];
      revLookup[code8.charCodeAt(i2)] = i2;
    }
    var i2;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength2(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i22;
      for (i22 = 0; i22 < len2; i22 += 4) {
        tmp = revLookup[b64.charCodeAt(i22)] << 18 | revLookup[b64.charCodeAt(i22 + 1)] << 12 | revLookup[b64.charCodeAt(i22 + 2)] << 6 | revLookup[b64.charCodeAt(i22 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i22)] << 2 | revLookup[b64.charCodeAt(i22 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i22)] << 10 | revLookup[b64.charCodeAt(i22 + 1)] << 4 | revLookup[b64.charCodeAt(i22 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup3[num >> 18 & 63] + lookup3[num >> 12 & 63] + lookup3[num >> 6 & 63] + lookup3[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i22 = start; i22 < end; i22 += 3) {
        tmp = (uint8[i22] << 16 & 16711680) + (uint8[i22 + 1] << 8 & 65280) + (uint8[i22 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts2 = [];
      var maxChunkLength = 16383;
      for (var i22 = 0, len22 = len2 - extraBytes; i22 < len22; i22 += maxChunkLength) {
        parts2.push(encodeChunk(uint8, i22, i22 + maxChunkLength > len22 ? len22 : i22 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts2.push(
          lookup3[tmp >> 2] + lookup3[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts2.push(
          lookup3[tmp >> 10] + lookup3[tmp >> 4 & 63] + lookup3[tmp << 2 & 63] + "="
        );
      }
      return parts2.join("");
    }
  }
});
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer2[offset + i2];
      i2 += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer2, value2, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
      value2 = Math.abs(value2);
      if (isNaN(value2) || value2 === Infinity) {
        m = isNaN(value2) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value2) / Math.LN2);
        if (value2 * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value2 += rt / c;
        } else {
          value2 += rt * Math.pow(2, 1 - eBias);
        }
        if (value2 * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value2 * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
      }
      buffer2[offset + i2 - d] |= s * 128;
    };
  }
});
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports2) {
    var base642 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer2;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length3) {
      if (length3 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length3 + '" is invalid for option "size"');
      }
      const buf2 = new Uint8Array(length3);
      Object.setPrototypeOf(buf2, Buffer2.prototype);
      return buf2;
    }
    function Buffer2(arg, encodingOrOffset, length3) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe5(arg);
      }
      return from2(arg, encodingOrOffset, length3);
    }
    Buffer2.poolSize = 8192;
    function from2(value2, encodingOrOffset, length3) {
      if (typeof value2 === "string") {
        return fromString5(value2, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value2)) {
        return fromArrayView(value2);
      }
      if (value2 == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
        );
      }
      if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value2, encodingOrOffset, length3);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value2, encodingOrOffset, length3);
      }
      if (typeof value2 === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value2.valueOf && value2.valueOf();
      if (valueOf != null && valueOf !== value2) {
        return Buffer2.from(valueOf, encodingOrOffset, length3);
      }
      const b = fromObject(value2);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value2[Symbol.toPrimitive]("string"), encodingOrOffset, length3);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
      );
    }
    Buffer2.from = function(value2, encodingOrOffset, length3) {
      return from2(value2, encodingOrOffset, length3);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc3(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc3(size, fill, encoding);
    };
    function allocUnsafe5(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe5(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe5(size);
    };
    function fromString5(string2, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length3 = byteLength2(string2, encoding) | 0;
      let buf2 = createBuffer(length3);
      const actual = buf2.write(string2, encoding);
      if (actual !== length3) {
        buf2 = buf2.slice(0, actual);
      }
      return buf2;
    }
    function fromArrayLike(array) {
      const length3 = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf2 = createBuffer(length3);
      for (let i2 = 0; i2 < length3; i2 += 1) {
        buf2[i2] = array[i2] & 255;
      }
      return buf2;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length3) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length3 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf2;
      if (byteOffset === void 0 && length3 === void 0) {
        buf2 = new Uint8Array(array);
      } else if (length3 === void 0) {
        buf2 = new Uint8Array(array, byteOffset);
      } else {
        buf2 = new Uint8Array(array, byteOffset, length3);
      }
      Object.setPrototypeOf(buf2, Buffer2.prototype);
      return buf2;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf2 = createBuffer(len);
        if (buf2.length === 0) {
          return buf2;
        }
        obj.copy(buf2, 0, 0, len);
        return buf2;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length3) {
      if (length3 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length3 | 0;
    }
    function SlowBuffer(length3) {
      if (+length3 != length3) {
        length3 = 0;
      }
      return Buffer2.alloc(+length3);
    }
    Buffer2.isBuffer = function isBuffer3(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare3(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i2 = 0, len = Math.min(x, y); i2 < len; ++i2) {
        if (a[i2] !== b[i2]) {
          x = a[i2];
          y = b[i2];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat3(list, length3) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i2;
      if (length3 === void 0) {
        length3 = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          length3 += list[i2].length;
        }
      }
      const buffer2 = Buffer2.allocUnsafe(length3);
      let pos = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        let buf2 = list[i2];
        if (isInstance(buf2, Uint8Array)) {
          if (pos + buf2.length > buffer2.length) {
            if (!Buffer2.isBuffer(buf2))
              buf2 = Buffer2.from(buf2);
            buf2.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf2,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf2)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf2.copy(buffer2, pos);
        }
        pos += buf2.length;
      }
      return buffer2;
    };
    function byteLength2(string2, encoding) {
      if (Buffer2.isBuffer(string2)) {
        return string2.length;
      }
      if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
        );
      }
      const len = string2.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes2(string2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string2).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes2(string2).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength2;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice2(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i2 = b[n];
      b[n] = b[m];
      b[m] = i2;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 2) {
        swap(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 4) {
        swap(this, i2, i2 + 3);
        swap(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 8) {
        swap(this, i2, i2 + 7);
        swap(this, i2 + 1, i2 + 6);
        swap(this, i2 + 2, i2 + 5);
        swap(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString7() {
      const length3 = this.length;
      if (length3 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice2(this, 0, length3);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals3(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect3() {
      let str = "";
      const max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare3(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i2 = 0; i2 < len; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x = thisCopy[i2];
          y = targetCopy[i2];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf2, i22) {
        if (indexSize === 1) {
          return buf2[i22];
        } else {
          return buf2.readUInt16BE(i22 * indexSize);
        }
      }
      let i2;
      if (dir) {
        let foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read2(arr, i2 + j) !== read2(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i2;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf2, string2, offset, length3) {
      offset = Number(offset) || 0;
      const remaining = buf2.length - offset;
      if (!length3) {
        length3 = remaining;
      } else {
        length3 = Number(length3);
        if (length3 > remaining) {
          length3 = remaining;
        }
      }
      const strLen = string2.length;
      if (length3 > strLen / 2) {
        length3 = strLen / 2;
      }
      let i2;
      for (i2 = 0; i2 < length3; ++i2) {
        const parsed = parseInt(string2.substr(i2 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i2;
        buf2[offset + i2] = parsed;
      }
      return i2;
    }
    function utf8Write(buf2, string2, offset, length3) {
      return blitBuffer(utf8ToBytes2(string2, buf2.length - offset), buf2, offset, length3);
    }
    function asciiWrite(buf2, string2, offset, length3) {
      return blitBuffer(asciiToBytes(string2), buf2, offset, length3);
    }
    function base64Write(buf2, string2, offset, length3) {
      return blitBuffer(base64ToBytes(string2), buf2, offset, length3);
    }
    function ucs2Write(buf2, string2, offset, length3) {
      return blitBuffer(utf16leToBytes(string2, buf2.length - offset), buf2, offset, length3);
    }
    Buffer2.prototype.write = function write3(string2, offset, length3, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length3 = this.length;
        offset = 0;
      } else if (length3 === void 0 && typeof offset === "string") {
        encoding = offset;
        length3 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length3)) {
          length3 = length3 >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length3;
          length3 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length3 === void 0 || length3 > remaining)
        length3 = remaining;
      if (string2.length > 0 && (length3 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string2, offset, length3);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string2, offset, length3);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string2, offset, length3);
          case "base64":
            return base64Write(this, string2, offset, length3);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string2, offset, length3);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON2() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf2, start, end) {
      if (start === 0 && end === buf2.length) {
        return base642.fromByteArray(buf2);
      } else {
        return base642.fromByteArray(buf2.slice(start, end));
      }
    }
    function utf8Slice2(buf2, start, end) {
      end = Math.min(buf2.length, end);
      const res = [];
      let i2 = start;
      while (i2 < end) {
        const firstByte = buf2[i2];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf2[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf2[i2 + 1];
              thirdByte = buf2[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf2[i2 + 1];
              thirdByte = buf2[i2 + 2];
              fourthByte = buf2[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray2(res);
    }
    var MAX_ARGUMENTS_LENGTH2 = 4096;
    function decodeCodePointsArray2(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH2) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i2 = 0;
      while (i2 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH2)
        );
      }
      return res;
    }
    function asciiSlice(buf2, start, end) {
      let ret = "";
      end = Math.min(buf2.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf2[i2] & 127);
      }
      return ret;
    }
    function latin1Slice(buf2, start, end) {
      let ret = "";
      end = Math.min(buf2.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf2[i2]);
      }
      return ret;
    }
    function hexSlice(buf2, start, end) {
      const len = buf2.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i2 = start; i2 < end; ++i2) {
        out += hexSliceLookupTable[buf2[i2]];
      }
      return out;
    }
    function utf16leSlice(buf2, start, end) {
      const bytes = buf2.slice(start, end);
      let res = "";
      for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice2(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length3) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length3)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength22, noAssert) {
      offset = offset >>> 0;
      byteLength22 = byteLength22 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength22, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength22 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength22, noAssert) {
      offset = offset >>> 0;
      byteLength22 = byteLength22 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength22, this.length);
      }
      let val = this[offset + --byteLength22];
      let mul = 1;
      while (byteLength22 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength22] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first2 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength22, noAssert) {
      offset = offset >>> 0;
      byteLength22 = byteLength22 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength22, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength22 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength22);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength22, noAssert) {
      offset = offset >>> 0;
      byteLength22 = byteLength22 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength22, this.length);
      let i2 = byteLength22;
      let mul = 1;
      let val = this[offset + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val += this[offset + --i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength22);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first2 << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf2, value2, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf2))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value2 > max || value2 < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf2.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value2, offset, byteLength22, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      byteLength22 = byteLength22 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength22) - 1;
        checkInt(this, value2, offset, byteLength22, maxBytes, 0);
      }
      let mul = 1;
      let i2 = 0;
      this[offset] = value2 & 255;
      while (++i2 < byteLength22 && (mul *= 256)) {
        this[offset + i2] = value2 / mul & 255;
      }
      return offset + byteLength22;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset, byteLength22, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      byteLength22 = byteLength22 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength22) - 1;
        checkInt(this, value2, offset, byteLength22, maxBytes, 0);
      }
      let i2 = byteLength22 - 1;
      let mul = 1;
      this[offset + i2] = value2 & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset + i2] = value2 / mul & 255;
      }
      return offset + byteLength22;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 1, 255, 0);
      this[offset] = value2 & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 65535, 0);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 65535, 0);
      this[offset] = value2 >>> 8;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 4294967295, 0);
      this[offset + 3] = value2 >>> 24;
      this[offset + 2] = value2 >>> 16;
      this[offset + 1] = value2 >>> 8;
      this[offset] = value2 & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 4294967295, 0);
      this[offset] = value2 >>> 24;
      this[offset + 1] = value2 >>> 16;
      this[offset + 2] = value2 >>> 8;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf2, value2, offset, min, max) {
      checkIntBI(value2, min, max, buf2, offset, 7);
      let lo = Number(value2 & BigInt(4294967295));
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      let hi = Number(value2 >> BigInt(32) & BigInt(4294967295));
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf2, value2, offset, min, max) {
      checkIntBI(value2, min, max, buf2, offset, 7);
      let lo = Number(value2 & BigInt(4294967295));
      buf2[offset + 7] = lo;
      lo = lo >> 8;
      buf2[offset + 6] = lo;
      lo = lo >> 8;
      buf2[offset + 5] = lo;
      lo = lo >> 8;
      buf2[offset + 4] = lo;
      let hi = Number(value2 >> BigInt(32) & BigInt(4294967295));
      buf2[offset + 3] = hi;
      hi = hi >> 8;
      buf2[offset + 2] = hi;
      hi = hi >> 8;
      buf2[offset + 1] = hi;
      hi = hi >> 8;
      buf2[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value2, offset = 0) {
      return wrtBigUInt64LE(this, value2, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value2, offset = 0) {
      return wrtBigUInt64BE(this, value2, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value2, offset, byteLength22, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength22 - 1);
        checkInt(this, value2, offset, byteLength22, limit - 1, -limit);
      }
      let i2 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value2 & 255;
      while (++i2 < byteLength22 && (mul *= 256)) {
        if (value2 < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value2 / mul >> 0) - sub & 255;
      }
      return offset + byteLength22;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset, byteLength22, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength22 - 1);
        checkInt(this, value2, offset, byteLength22, limit - 1, -limit);
      }
      let i2 = byteLength22 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i2] = value2 & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value2 < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value2 / mul >> 0) - sub & 255;
      }
      return offset + byteLength22;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 1, 127, -128);
      if (value2 < 0)
        value2 = 255 + value2 + 1;
      this[offset] = value2 & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 32767, -32768);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 32767, -32768);
      this[offset] = value2 >>> 8;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 2147483647, -2147483648);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      this[offset + 2] = value2 >>> 16;
      this[offset + 3] = value2 >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 2147483647, -2147483648);
      if (value2 < 0)
        value2 = 4294967295 + value2 + 1;
      this[offset] = value2 >>> 24;
      this[offset + 1] = value2 >>> 16;
      this[offset + 2] = value2 >>> 8;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value2, offset = 0) {
      return wrtBigUInt64LE(this, value2, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value2, offset = 0) {
      return wrtBigUInt64BE(this, value2, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf2, value2, offset, ext, max, min) {
      if (offset + ext > buf2.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf2, value2, offset, littleEndian, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value2, offset, 4);
      }
      ieee754.write(buf2, value2, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, false, noAssert);
    };
    function writeDouble(buf2, value2, offset, littleEndian, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value2, offset, 8);
      }
      ieee754.write(buf2, value2, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code8 = val.charCodeAt(0);
          if (encoding === "utf8" && code8 < 128 || encoding === "latin1") {
            val = code8;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i2;
      if (typeof val === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes[i2 % len];
        }
      }
      return this;
    };
    var errors2 = {};
    function E(sym, getMessage, Base) {
      errors2[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value2) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value: value2,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name9) {
        if (name9) {
          return `${name9} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name9, actual) {
        return `The "${name9}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i2 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i2 >= start + 4; i2 -= 3) {
        res = `_${val.slice(i2 - 3, i2)}${res}`;
      }
      return `${val.slice(0, i2)}${res}`;
    }
    function checkBounds(buf2, offset, byteLength22) {
      validateNumber(offset, "offset");
      if (buf2[offset] === void 0 || buf2[offset + byteLength22] === void 0) {
        boundsError(offset, buf2.length - (byteLength22 + 1));
      }
    }
    function checkIntBI(value2, min, max, buf2, offset, byteLength22) {
      if (value2 > max || value2 < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength22 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength22 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength22 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength22 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors2.ERR_OUT_OF_RANGE("value", range, value2);
      }
      checkBounds(buf2, offset, byteLength22);
    }
    function validateNumber(value2, name9) {
      if (typeof value2 !== "number") {
        throw new errors2.ERR_INVALID_ARG_TYPE(name9, "number", value2);
      }
    }
    function boundsError(value2, length3, type) {
      if (Math.floor(value2) !== value2) {
        validateNumber(value2, type);
        throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value2);
      }
      if (length3 < 0) {
        throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors2.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length3}`,
        value2
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes2(string2, units) {
      units = units || Infinity;
      let codePoint;
      const length3 = string2.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i2 = 0; i2 < length3; ++i2) {
        codePoint = string2.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length3) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        byteArray.push(str.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i2);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base642.toByteArray(base64clean(str));
    }
    function blitBuffer(src2, dst, offset, length3) {
      let i2;
      for (i2 = 0; i2 < length3; ++i2) {
        if (i2 + offset >= dst.length || i2 >= src2.length)
          break;
        dst[i2 + offset] = src2[i2];
      }
      return i2;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet3 = "0123456789abcdef";
      const table2 = new Array(256);
      for (let i2 = 0; i2 < 16; ++i2) {
        const i16 = i2 * 16;
        for (let j = 0; j < 16; ++j) {
          table2[i16 + j] = alphabet3[i2] + alphabet3[j];
        }
      }
      return table2;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
const __vite__cjsImport0_buffer = require_buffer();
const Buffer$1 = __vite__cjsImport0_buffer["Buffer"];
window.Buffer = Buffer$1;
function asUint8Array(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}
function alloc(size = 0) {
  if (globalThis.Buffer?.alloc != null) {
    return asUint8Array(globalThis.Buffer.alloc(size));
  }
  return new Uint8Array(size);
}
function allocUnsafe(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}
function concat(arrays, length3) {
  if (length3 == null) {
    length3 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length3);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output);
}
async function toBuffer(stream) {
  let buffer2 = new Uint8Array(0);
  for await (const buf2 of stream) {
    buffer2 = concat([buffer2, buf2], buffer2.length + buf2.length);
  }
  return buffer2;
}
var require_crypto = __commonJS({
  "browser-external:crypto"(exports2, module2) {
    module2.exports = {};
  }
});
var bytes_exports = {};
__export(bytes_exports, {
  coerce: () => coerce,
  empty: () => empty$1,
  equals: () => equals$1,
  fromHex: () => fromHex,
  fromString: () => fromString,
  isBinary: () => isBinary$1,
  toHex: () => toHex,
  toString: () => toString$2
});
var empty$1 = new Uint8Array(0);
var toHex = (d) => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
var fromHex = (hex) => {
  const hexes3 = hex.match(/../g);
  return hexes3 ? new Uint8Array(hexes3.map((b) => parseInt(b, 16))) : empty$1;
};
var equals$1 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var isBinary$1 = (o) => o instanceof ArrayBuffer || ArrayBuffer.isView(o);
var fromString = (str) => new TextEncoder().encode(str);
var toString$2 = (b) => new TextDecoder().decode(b);
var encode_1 = encode$3;
var MSB$1 = 128;
var REST$1 = 127;
var MSBALL = ~REST$1;
var INT = Math.pow(2, 31);
function encode$3(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB$1;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB$1;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$3.bytes = offset - oldOffset + 1;
  return out;
}
var decode = read$1;
var MSB$1$1 = 128;
var REST$1$1 = 127;
function read$1(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read$1.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$1$1) << shift : (b & REST$1$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1$1);
  read$1.bytes = counter - offset;
  return res;
}
var N1$1 = Math.pow(2, 7);
var N2$1 = Math.pow(2, 14);
var N3$1 = Math.pow(2, 21);
var N4$1 = Math.pow(2, 28);
var N5$1 = Math.pow(2, 35);
var N6$1 = Math.pow(2, 42);
var N7$1 = Math.pow(2, 49);
var N8$1 = Math.pow(2, 56);
var N9$1 = Math.pow(2, 63);
var length$1 = function(value2) {
  return value2 < N1$1 ? 1 : value2 < N2$1 ? 2 : value2 < N3$1 ? 3 : value2 < N4$1 ? 4 : value2 < N5$1 ? 5 : value2 < N6$1 ? 6 : value2 < N7$1 ? 7 : value2 < N8$1 ? 8 : value2 < N9$1 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode,
  encodingLength: length$1
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;
var decode2$2 = (data, offset = 0) => {
  const code8 = varint_default.decode(data, offset);
  return [code8, varint_default.decode.bytes];
};
var encodeTo = (int, target, offset = 0) => {
  varint_default.encode(int, target, offset);
  return target;
};
var encodingLength = (int) => {
  return varint_default.encodingLength(int);
};
var create = (code8, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength(code8);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code8, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest2, digestOffset);
  return new Digest(code8, size, digest2, bytes);
};
var decode3$3 = (multihash) => {
  const bytes = coerce(multihash);
  const [code8, sizeOffset] = decode2$2(bytes);
  const [size, digestOffset] = decode2$2(bytes.subarray(sizeOffset));
  const digest2 = bytes.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code8, size, digest2, bytes);
};
var equals2 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals$1(a.bytes, data.bytes);
  }
};
var Digest = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code8, size, digest2, bytes) {
    this.code = code8;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes;
  }
};
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});
var from$1 = ({ name: name9, code: code8, encode: encode20 }) => new Hasher(name9, code8, encode20);
var Hasher = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name9, code8, encode20) {
    this.name = name9;
    this.code = code8;
    this.encode = encode20;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var sha = (name9) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name9, data))
);
var sha256 = from$1({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
var sha512 = from$1({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
function base$1(ALPHABET, name9) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode23(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length3 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i22 = 0;
      for (var it1 = size - 1; (carry !== 0 || i22 < length3) && it1 !== -1; it1--, i22++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length3 = i22;
      pbegin++;
    }
    var it2 = size - length3;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length3 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i22 = 0;
      for (var it3 = size - 1; (carry !== 0 || i22 < length3) && it3 !== -1; it3--, i22++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length3 = i22;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length3;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode42(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name9} character`);
  }
  return {
    encode: encode23,
    decodeUnsafe,
    decode: decode42
  };
}
var src = base$1;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;
var Encoder$1 = class Encoder3 {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name9, prefix, baseEncode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder$1 = class Decoder3 {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name9, prefix, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or$1(this, decoder);
  }
};
var ComposedDecoder = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or$1(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or$1 = (left, right) => new ComposedDecoder(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name9, prefix, baseEncode, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder$1(name9, prefix, baseEncode);
    this.decoder = new Decoder$1(name9, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from = ({ name: name9, prefix, encode: encode23, decode: decode42 }) => new Codec(name9, prefix, encode23, decode42);
var baseX = ({ prefix, name: name9, alphabet: alphabet3 }) => {
  const { encode: encode23, decode: decode42 } = base_x_default(alphabet3, name9);
  return from({
    prefix,
    name: name9,
    encode: encode23,
    /**
     * @param {string} text
     */
    decode: (text) => coerce(decode42(text))
  });
};
var decode3$2 = (string2, alphabet3, bitsPerChar, name9) => {
  const codes3 = {};
  for (let i2 = 0; i2 < alphabet3.length; ++i2) {
    codes3[alphabet3[i2]] = i2;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes3[string2[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name9} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer2 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer2 << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode$2 = (data, alphabet3, bitsPerChar) => {
  const pad = alphabet3[alphabet3.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet3[mask & buffer2 >> bits2];
    }
  }
  if (bits2) {
    out += alphabet3[mask & buffer2 << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = ({ name: name9, prefix, bitsPerChar, alphabet: alphabet3 }) => {
  return from({
    prefix,
    name: name9,
    encode(input) {
      return encode$2(input, alphabet3, bitsPerChar);
    },
    decode(input) {
      return decode3$2(input, alphabet3, bitsPerChar, name9);
    }
  });
};
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
var format$1 = (link, base22) => {
  const { bytes, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV0(
        bytes,
        baseCache(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base22 || base58btc.encoder
      );
    default:
      return toStringV1(
        bytes,
        baseCache(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base22 || base32.encoder
      );
  }
};
var cache$1 = /* @__PURE__ */ new WeakMap();
var baseCache = (cid) => {
  const baseCache2 = cache$1.get(cid);
  if (baseCache2 == null) {
    const baseCache3 = /* @__PURE__ */ new Map();
    cache$1.set(cid, baseCache3);
    return baseCache3;
  }
  return baseCache2;
};
var CID = class {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version3, code8, multihash, bytes) {
    this.code = code8;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code8, multihash } = this;
        if (code8 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code8, digest: digest2 } = this.multihash;
        const multihash = create(code8, digest2);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals2(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base22) {
    return format$1(this, base22);
  }
  toJSON() {
    return { "/": format$1(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = (
      /** @type {any} */
      input
    );
    if (value2 instanceof CID) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version3, code: code8, multihash, bytes } = value2;
      return new CID(
        version3,
        code8,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes || encodeCID$1(version3, code8, multihash.bytes)
      );
    } else if (value2[cidSymbol] === true) {
      const { version: version3, multihash, code: code8 } = value2;
      const digest2 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode3$3(multihash)
      );
      return CID.create(version3, code8, digest2);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version3, code8, digest2) {
    if (typeof code8 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest2.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code8 !== DAG_PB_CODE) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`
          );
        } else {
          return new CID(version3, code8, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID$1(version3, code8, digest2.bytes);
        return new CID(version3, code8, digest2, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest2) {
    return CID.create(0, DAG_PB_CODE, digest2);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code8, digest2) {
    return CID.create(1, code8, digest2);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes) {
    const [cid, remainder] = CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes) {
    const specs = CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(
      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest2 = new Digest(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest2
    ) : CID.createV1(specs.codec, digest2);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length3] = decode2$2(initialBytes.subarray(offset));
      offset += length3;
      return i2;
    };
    let version3 = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE
    );
    if (
      /** @type {number} */
      version3 === 18
    ) {
      version3 = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base22) {
    const [prefix, bytes] = parseCIDtoBytes(source, base22);
    const cid = CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes = (source, base22) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base22 || base58btc;
      return [
        /** @type {Prefix} */
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base22 || base58btc;
      return [
        /** @type {Prefix} */
        base58btc.prefix,
        decoder.decode(source)
      ];
    }
    case base32.prefix: {
      const decoder = base22 || base32;
      return [
        /** @type {Prefix} */
        base32.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base22 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base22.decode(source)
      ];
    }
  }
};
var toStringV0 = (bytes, cache22, base22) => {
  const { prefix } = base22;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base22.name} encoding`);
  }
  const cid = cache22.get(prefix);
  if (cid == null) {
    const cid2 = base22.encode(bytes).slice(1);
    cache22.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV1 = (bytes, cache22, base22) => {
  const { prefix } = base22;
  const cid = cache22.get(prefix);
  if (cid == null) {
    const cid2 = base22.encode(bytes);
    cache22.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
var encodeCID$1 = (version3, code8, multihash) => {
  const codeOffset = encodingLength(version3);
  const hashOffset = codeOffset + encodingLength(code8);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version3, bytes, 0);
  encodeTo(code8, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol = Symbol.for("@ipld/js-cid/CID");
var require_is_plain_obj = __commonJS({
  "node_modules/is-plain-obj/index.js"(exports2, module2) {
    module2.exports = (value2) => {
      if (Object.prototype.toString.call(value2) !== "[object Object]") {
        return false;
      }
      const prototype3 = Object.getPrototypeOf(value2);
      return prototype3 === null || prototype3 === Object.prototype;
    };
  }
});
var require_merge_options = __commonJS({
  "node_modules/merge-options/index.js"(exports2, module2) {
    var isOptionObject = require_is_plain_obj();
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    var { propertyIsEnumerable } = Object;
    var defineProperty = (object, name9, value2) => Object.defineProperty(object, name9, {
      value: value2,
      writable: true,
      enumerable: true,
      configurable: true
    });
    var globalThis2 = exports2;
    var defaultMergeOptions = {
      concatArrays: false,
      ignoreUndefined: false
    };
    var getEnumerableOwnPropertyKeys = (value2) => {
      const keys = [];
      for (const key in value2) {
        if (hasOwnProperty2.call(value2, key)) {
          keys.push(key);
        }
      }
      if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value2);
        for (const symbol7 of symbols) {
          if (propertyIsEnumerable.call(value2, symbol7)) {
            keys.push(symbol7);
          }
        }
      }
      return keys;
    };
    function clone(value2) {
      if (Array.isArray(value2)) {
        return cloneArray(value2);
      }
      if (isOptionObject(value2)) {
        return cloneOptionObject(value2);
      }
      return value2;
    }
    function cloneArray(array) {
      const result = array.slice(0, 0);
      getEnumerableOwnPropertyKeys(array).forEach((key) => {
        defineProperty(result, key, clone(array[key]));
      });
      return result;
    }
    function cloneOptionObject(object) {
      const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
      getEnumerableOwnPropertyKeys(object).forEach((key) => {
        defineProperty(result, key, clone(object[key]));
      });
      return result;
    }
    var mergeKeys = (merged, source, keys, config2) => {
      keys.forEach((key) => {
        if (typeof source[key] === "undefined" && config2.ignoreUndefined) {
          return;
        }
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
          defineProperty(merged, key, merge3(merged[key], source[key], config2));
        } else {
          defineProperty(merged, key, clone(source[key]));
        }
      });
      return merged;
    };
    var concatArrays2 = (merged, source, config2) => {
      let result = merged.slice(0, 0);
      let resultIndex = 0;
      [merged, source].forEach((array) => {
        const indices = [];
        for (let k = 0; k < array.length; k++) {
          if (!hasOwnProperty2.call(array, k)) {
            continue;
          }
          indices.push(String(k));
          if (array === merged) {
            defineProperty(result, resultIndex++, array[k]);
          } else {
            defineProperty(result, resultIndex++, clone(array[k]));
          }
        }
        result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config2);
      });
      return result;
    };
    function merge3(merged, source, config2) {
      if (config2.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
        return concatArrays2(merged, source, config2);
      }
      if (!isOptionObject(source) || !isOptionObject(merged)) {
        return clone(source);
      }
      return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config2);
    }
    module2.exports = function(...options) {
      const config2 = merge3(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
      let merged = { _: {} };
      for (const option of options) {
        if (option === void 0) {
          continue;
        }
        if (!isOptionObject(option)) {
          throw new TypeError("`" + option + "` is not an Option Object");
        }
        merged = merge3(merged, { _: option }, config2);
      }
      return merged._;
    };
  }
});
var require_is_electron = __commonJS({
  "node_modules/is-electron/index.js"(exports2, module2) {
    function isElectron2() {
      if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
        return true;
      }
      if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
        return true;
      }
      if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
        return true;
      }
      return false;
    }
    module2.exports = isElectron2;
  }
});
var require_env = __commonJS({
  "node_modules/ipfs-utils/src/env.js"(exports2, module2) {
    var isElectron2 = require_is_electron();
    var IS_ENV_WITH_DOM = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
    var IS_ELECTRON = isElectron2();
    var IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
    var IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
    var IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
    var IS_NODE = typeof __require === "function" && typeof process !== "undefined" && typeof process.release !== "undefined" && process.release.name === "node" && !IS_ELECTRON;
    var IS_WEBWORKER = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
    var IS_TEST = typeof process !== "undefined" && typeof process.env !== "undefined" && false;
    var IS_REACT_NATIVE = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    module2.exports = {
      isTest: IS_TEST,
      isElectron: IS_ELECTRON,
      isElectronMain: IS_ELECTRON_MAIN,
      isElectronRenderer: IS_ELECTRON_RENDERER,
      isNode: IS_NODE,
      /**
       * Detects browser main thread  **NOT** web worker or service worker
       */
      isBrowser: IS_BROWSER,
      isWebWorker: IS_WEBWORKER,
      isEnvWithDom: IS_ENV_WITH_DOM,
      isReactNative: IS_REACT_NATIVE
    };
  }
});
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse5(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse5(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name9) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name9 + (isPlural ? "s" : "");
    }
  }
});
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace3) {
        let hash3 = 0;
        for (let i2 = 0; i2 < namespace3.length; i2++) {
          hash3 = (hash3 << 5) - hash3 + namespace3.charCodeAt(i2);
          hash3 |= 0;
        }
        return createDebug.colors[Math.abs(hash3) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace3) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug12(...args) {
          if (!debug12.enabled) {
            return;
          }
          const self2 = debug12;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index2];
              match = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug12.namespace = namespace3;
        debug12.useColors = createDebug.useColors();
        debug12.color = createDebug.selectColor(namespace3);
        debug12.extend = extend2;
        debug12.destroy = createDebug.destroy;
        Object.defineProperty(debug12, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace3);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug12);
        }
        return debug12;
      }
      function extend2(namespace3, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace3);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i2;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i2 = 0; i2 < len; i2++) {
          if (!split[i2]) {
            continue;
          }
          namespaces = split[i2].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace3) => "-" + namespace3)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name9) {
        if (name9[name9.length - 1] === "*") {
          return true;
        }
        let i2;
        let len;
        for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
          if (createDebug.skips[i2].test(name9)) {
            return false;
          }
        }
        for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
          if (createDebug.names[i2].test(name9)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});
var require_browser$1 = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = {}.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});
var require_err_code = __commonJS({
  "node_modules/err-code/index.js"(exports2, module2) {
    function assign2(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err2, code8, props) {
      if (!err2 || typeof err2 === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code8 === "object") {
        props = code8;
        code8 = "";
      }
      if (code8) {
        props.code = code8;
      }
      try {
        return assign2(err2, props);
      } catch (_) {
        props.message = err2.message;
        props.stack = err2.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err2));
        const output = assign2(new ErrClass(), props);
        return output;
      }
    }
    module2.exports = createError;
  }
});
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index2 = 2, pending = true;
      while (index2 < arguments.length)
        params[offset++] = arguments[index2++];
      return new Promise(function executor(resolve7, reject) {
        params[offset] = function callback(err2) {
          if (pending) {
            pending = false;
            if (err2)
              reject(err2);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve7.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err2) {
          if (pending) {
            pending = false;
            reject(err2);
          }
        }
      });
    }
  }
});
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    var base642 = exports2;
    base642.length = function length3(string2) {
      var p = string2.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string2.charAt(p) === "=")
        ++n;
      return Math.ceil(string2.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i2 = 0; i2 < 64; )
      s64[b64[i2] = i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 - 59 | 43] = i2++;
    var i2;
    base642.encode = function encode21(buffer2, start, end) {
      var parts2 = null, chunk = [];
      var i3 = 0, j = 0, t;
      while (start < end) {
        var b = buffer2[start++];
        switch (j) {
          case 0:
            chunk[i3++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i3++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i3++] = b64[t | b >> 6];
            chunk[i3++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i3 > 8191) {
          (parts2 || (parts2 = [])).push(String.fromCharCode.apply(String, chunk));
          i3 = 0;
        }
      }
      if (j) {
        chunk[i3++] = b64[t];
        chunk[i3++] = 61;
        if (j === 1)
          chunk[i3++] = 61;
      }
      if (parts2) {
        if (i3)
          parts2.push(String.fromCharCode.apply(String, chunk.slice(0, i3)));
        return parts2.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i3));
    };
    var invalidEncoding = "invalid encoding";
    base642.decode = function decode17(string2, buffer2, offset) {
      var start = offset;
      var j = 0, t;
      for (var i3 = 0; i3 < string2.length; ) {
        var c = string2.charCodeAt(i3++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer2[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer2[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer2[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base642.test = function test(string2) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string2);
    };
  }
});
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    module2.exports = EventEmitter6;
    function EventEmitter6() {
      this._listeners = {};
    }
    EventEmitter6.prototype.on = function on2(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter6.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i2 = 0; i2 < listeners.length; )
            if (listeners[i2].fn === fn)
              listeners.splice(i2, 1);
            else
              ++i2;
        }
      }
      return this;
    };
    EventEmitter6.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i2 = 1;
        for (; i2 < arguments.length; )
          args.push(arguments[i2++]);
        for (i2 = 0; i2 < listeners.length; )
          listeners[i2].fn.apply(listeners[i2++].ctx, args);
      }
      return this;
    };
  }
});
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf2, pos) {
            f32[0] = val;
            buf2[pos] = f8b[0];
            buf2[pos + 1] = f8b[1];
            buf2[pos + 2] = f8b[2];
            buf2[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf2, pos) {
            f32[0] = val;
            buf2[pos] = f8b[3];
            buf2[pos + 1] = f8b[2];
            buf2[pos + 2] = f8b[1];
            buf2[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf2, pos) {
            f8b[0] = buf2[pos];
            f8b[1] = buf2[pos + 1];
            f8b[2] = buf2[pos + 2];
            f8b[3] = buf2[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf2, pos) {
            f8b[3] = buf2[pos];
            f8b[2] = buf2[pos + 1];
            f8b[1] = buf2[pos + 2];
            f8b[0] = buf2[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf2, pos) {
            var sign4 = val < 0 ? 1 : 0;
            if (sign4)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf2, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf2, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign4 << 31 | 2139095040) >>> 0, buf2, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign4 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf2, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign4 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf2, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf2, pos) {
            var uint = readUint(buf2, pos), sign4 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign4 * Infinity : exponent === 0 ? sign4 * 1401298464324817e-60 * mantissa : sign4 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf2, pos) {
            f64[0] = val;
            buf2[pos] = f8b[0];
            buf2[pos + 1] = f8b[1];
            buf2[pos + 2] = f8b[2];
            buf2[pos + 3] = f8b[3];
            buf2[pos + 4] = f8b[4];
            buf2[pos + 5] = f8b[5];
            buf2[pos + 6] = f8b[6];
            buf2[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf2, pos) {
            f64[0] = val;
            buf2[pos] = f8b[7];
            buf2[pos + 1] = f8b[6];
            buf2[pos + 2] = f8b[5];
            buf2[pos + 3] = f8b[4];
            buf2[pos + 4] = f8b[3];
            buf2[pos + 5] = f8b[2];
            buf2[pos + 6] = f8b[1];
            buf2[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf2, pos) {
            f8b[0] = buf2[pos];
            f8b[1] = buf2[pos + 1];
            f8b[2] = buf2[pos + 2];
            f8b[3] = buf2[pos + 3];
            f8b[4] = buf2[pos + 4];
            f8b[5] = buf2[pos + 5];
            f8b[6] = buf2[pos + 6];
            f8b[7] = buf2[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf2, pos) {
            f8b[7] = buf2[pos];
            f8b[6] = buf2[pos + 1];
            f8b[5] = buf2[pos + 2];
            f8b[4] = buf2[pos + 3];
            f8b[3] = buf2[pos + 4];
            f8b[2] = buf2[pos + 5];
            f8b[1] = buf2[pos + 6];
            f8b[0] = buf2[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf2, pos) {
            var sign4 = val < 0 ? 1 : 0;
            if (sign4)
              val = -val;
            if (val === 0) {
              writeUint(0, buf2, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf2, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf2, pos + off0);
              writeUint(2146959360, buf2, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf2, pos + off0);
              writeUint((sign4 << 31 | 2146435072) >>> 0, buf2, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf2, pos + off0);
                writeUint((sign4 << 31 | mantissa / 4294967296) >>> 0, buf2, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf2, pos + off0);
                writeUint((sign4 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf2, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf2, pos) {
            var lo = readUint(buf2, pos + off0), hi = readUint(buf2, pos + off1);
            var sign4 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign4 * Infinity : exponent === 0 ? sign4 * 5e-324 * mantissa : sign4 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf2, pos) {
      buf2[pos] = val >>> 24;
      buf2[pos + 1] = val >>> 16 & 255;
      buf2[pos + 2] = val >>> 8 & 255;
      buf2[pos + 3] = val & 255;
    }
    function readUintLE(buf2, pos) {
      return (buf2[pos] | buf2[pos + 1] << 8 | buf2[pos + 2] << 16 | buf2[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf2, pos) {
      return (buf2[pos] << 24 | buf2[pos + 1] << 16 | buf2[pos + 2] << 8 | buf2[pos + 3]) >>> 0;
    }
  }
});
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    var utf8 = exports2;
    utf8.length = function utf8_length(string2) {
      var len = 0, c = 0;
      for (var i2 = 0; i2 < string2.length; ++i2) {
        c = string2.charCodeAt(i2);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string2.charCodeAt(i2 + 1) & 64512) === 56320) {
          ++i2;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer2, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts2 = null, chunk = [], i2 = 0, t;
      while (start < end) {
        t = buffer2[start++];
        if (t < 128)
          chunk[i2++] = t;
        else if (t > 191 && t < 224)
          chunk[i2++] = (t & 31) << 6 | buffer2[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
          chunk[i2++] = 55296 + (t >> 10);
          chunk[i2++] = 56320 + (t & 1023);
        } else
          chunk[i2++] = (t & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
        if (i2 > 8191) {
          (parts2 || (parts2 = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (parts2) {
        if (i2)
          parts2.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts2.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    utf8.write = function utf8_write(string2, buffer2, offset) {
      var start = offset, c1, c2;
      for (var i2 = 0; i2 < string2.length; ++i2) {
        c1 = string2.charCodeAt(i2);
        if (c1 < 128) {
          buffer2[offset++] = c1;
        } else if (c1 < 2048) {
          buffer2[offset++] = c1 >> 6 | 192;
          buffer2[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i2 + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i2;
          buffer2[offset++] = c1 >> 18 | 240;
          buffer2[offset++] = c1 >> 12 & 63 | 128;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        } else {
          buffer2[offset++] = c1 >> 12 | 224;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    module2.exports = pool;
    function pool(alloc3, slice2, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc3(size2);
        if (offset + size2 > SIZE) {
          slab = alloc3(SIZE);
          offset = 0;
        }
        var buf2 = slice2.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf2;
      };
    }
  }
});
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    module2.exports = LongBits2;
    var util2 = require_minimal();
    function LongBits2(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero2 = LongBits2.zero = new LongBits2(0, 0);
    zero2.toNumber = function() {
      return 0;
    };
    zero2.zzEncode = zero2.zzDecode = function() {
      return this;
    };
    zero2.length = function() {
      return 1;
    };
    var zeroHash = LongBits2.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits2.fromNumber = function fromNumber(value2) {
      if (value2 === 0)
        return zero2;
      var sign4 = value2 < 0;
      if (sign4)
        value2 = -value2;
      var lo = value2 >>> 0, hi = (value2 - lo) / 4294967296 >>> 0;
      if (sign4) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits2(lo, hi);
    };
    LongBits2.from = function from3(value2) {
      if (typeof value2 === "number")
        return LongBits2.fromNumber(value2);
      if (util2.isString(value2)) {
        if (util2.Long)
          value2 = util2.Long.fromString(value2);
        else
          return LongBits2.fromNumber(parseInt(value2, 10));
      }
      return value2.low || value2.high ? new LongBits2(value2.low >>> 0, value2.high >>> 0) : zero2;
    };
    LongBits2.prototype.toNumber = function toNumber(unsigned2) {
      if (!unsigned2 && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits2.prototype.toLong = function toLong(unsigned2) {
      return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned2)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned2) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits2.fromHash = function fromHash(hash3) {
      if (hash3 === zeroHash)
        return zero2;
      return new LongBits2(
        (charCodeAt.call(hash3, 0) | charCodeAt.call(hash3, 1) << 8 | charCodeAt.call(hash3, 2) << 16 | charCodeAt.call(hash3, 3) << 24) >>> 0,
        (charCodeAt.call(hash3, 4) | charCodeAt.call(hash3, 5) << 8 | charCodeAt.call(hash3, 6) << 16 | charCodeAt.call(hash3, 7) << 24) >>> 0
      );
    };
    LongBits2.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits2.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits2.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits2.prototype.length = function length3() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    var util2 = exports2;
    util2.asPromise = require_aspromise();
    util2.base64 = require_base64();
    util2.EventEmitter = require_eventemitter();
    util2.float = require_float();
    util2.inquire = require_inquire();
    util2.utf8 = require_utf8();
    util2.pool = require_pool();
    util2.LongBits = require_longbits();
    util2.isNode = Boolean(typeof globalThis !== "undefined" && globalThis && globalThis.process && globalThis.process.versions && globalThis.process.versions.node);
    util2.global = util2.isNode && globalThis || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util2.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util2.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util2.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value2) {
      return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2;
    };
    util2.isString = function isString2(value2) {
      return typeof value2 === "string" || value2 instanceof String;
    };
    util2.isObject = function isObject2(value2) {
      return value2 && typeof value2 === "object";
    };
    util2.isset = /**
    * Checks if a property on a message is considered to be present.
    * @param {Object} obj Plain object or message instance
    * @param {string} prop Property name
    * @returns {boolean} `true` if considered to be present, otherwise `false`
    */
    util2.isSet = function isSet(obj, prop) {
      var value2 = obj[prop];
      if (value2 != null && obj.hasOwnProperty(prop))
        return typeof value2 !== "object" || (Array.isArray(value2) ? value2.length : Object.keys(value2).length) > 0;
      return false;
    };
    util2.Buffer = function() {
      try {
        var Buffer2 = util2.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util2._Buffer_from = null;
    util2._Buffer_allocUnsafe = null;
    util2.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util2.Long = /* istanbul ignore next */
    util2.global.dcodeIO && /* istanbul ignore next */
    util2.global.dcodeIO.Long || /* istanbul ignore next */
    util2.global.Long || util2.inquire("long");
    util2.key2Re = /^true|false|0|1$/;
    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util2.longToHash = function longToHash(value2) {
      return value2 ? util2.LongBits.from(value2).toHash() : util2.LongBits.zeroHash;
    };
    util2.longFromHash = function longFromHash(hash3, unsigned2) {
      var bits2 = util2.LongBits.fromHash(hash3);
      if (util2.Long)
        return util2.Long.fromBits(bits2.lo, bits2.hi, unsigned2);
      return bits2.toNumber(Boolean(unsigned2));
    };
    function merge3(dst, src2, ifNotSet) {
      for (var keys = Object.keys(src2), i2 = 0; i2 < keys.length; ++i2)
        if (dst[keys[i2]] === void 0 || !ifNotSet)
          dst[keys[i2]] = src2[keys[i2]];
      return dst;
    }
    util2.merge = merge3;
    util2.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name9) {
      function CustomError(message2, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message2, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message2;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge3(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get() {
            return name9;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util2.newError = newError;
    util2.ProtocolError = newError("ProtocolError");
    util2.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        fieldMap[fieldNames[i2]] = 1;
      return function() {
        for (var keys = Object.keys(this), i3 = keys.length - 1; i3 > -1; --i3)
          if (fieldMap[keys[i3]] === 1 && this[keys[i3]] !== void 0 && this[keys[i3]] !== null)
            return keys[i3];
      };
    };
    util2.oneOfSetter = function setOneOf(fieldNames) {
      return function(name9) {
        for (var i2 = 0; i2 < fieldNames.length; ++i2)
          if (fieldNames[i2] !== name9)
            delete this[fieldNames[i2]];
      };
    };
    util2.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util2._configure = function() {
      var Buffer2 = util2.Buffer;
      if (!Buffer2) {
        util2._Buffer_from = util2._Buffer_allocUnsafe = null;
        return;
      }
      util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value2, encoding) {
        return new Buffer2(value2, encoding);
      };
      util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    module2.exports = Writer;
    var util2 = require_minimal();
    var BufferWriter;
    var LongBits2 = util2.LongBits;
    var base642 = util2.base64;
    var utf8 = util2.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop5() {
    }
    function State(writer2) {
      this.head = writer2.head;
      this.tail = writer2.tail;
      this.len = writer2.len;
      this.next = writer2.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop5, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create10 = function create11() {
      return util2.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create10();
    Writer.alloc = function alloc3(size) {
      return new util2.Array(size);
    };
    if (util2.Array !== Array)
      Writer.alloc = util2.pool(Writer.alloc, util2.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf2, pos) {
      buf2[pos] = val & 255;
    }
    function writeVarint32(val, buf2, pos) {
      while (val > 127) {
        buf2[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf2[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value2) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value2 = value2 >>> 0) < 128 ? 1 : value2 < 16384 ? 2 : value2 < 2097152 ? 3 : value2 < 268435456 ? 4 : 5,
        value2
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value2) {
      return value2 < 0 ? this._push(writeVarint64, 10, LongBits2.fromNumber(value2)) : this.uint32(value2);
    };
    Writer.prototype.sint32 = function write_sint32(value2) {
      return this.uint32((value2 << 1 ^ value2 >> 31) >>> 0);
    };
    function writeVarint64(val, buf2, pos) {
      while (val.hi) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf2[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value2) {
      var bits2 = LongBits2.from(value2);
      return this._push(writeVarint64, bits2.length(), bits2);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value2) {
      var bits2 = LongBits2.from(value2).zzEncode();
      return this._push(writeVarint64, bits2.length(), bits2);
    };
    Writer.prototype.bool = function write_bool(value2) {
      return this._push(writeByte, 1, value2 ? 1 : 0);
    };
    function writeFixed32(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value2) {
      return this._push(writeFixed32, 4, value2 >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value2) {
      var bits2 = LongBits2.from(value2);
      return this._push(writeFixed32, 4, bits2.lo)._push(writeFixed32, 4, bits2.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value2) {
      return this._push(util2.float.writeFloatLE, 4, value2);
    };
    Writer.prototype.double = function write_double(value2) {
      return this._push(util2.float.writeDoubleLE, 8, value2);
    };
    var writeBytes = util2.Array.prototype.set ? function writeBytes_set(val, buf2, pos) {
      buf2.set(val, pos);
    } : function writeBytes_for(val, buf2, pos) {
      for (var i2 = 0; i2 < val.length; ++i2)
        buf2[pos + i2] = val[i2];
    };
    Writer.prototype.bytes = function write_bytes(value2) {
      var len = value2.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util2.isString(value2)) {
        var buf2 = Writer.alloc(len = base642.length(value2));
        base642.decode(value2, buf2, 0);
        value2 = buf2;
      }
      return this.uint32(len)._push(writeBytes, len, value2);
    };
    Writer.prototype.string = function write_string(value2) {
      var len = utf8.length(value2);
      return len ? this.uint32(len)._push(utf8.write, len, value2) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop5, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop5, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf2 = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf2, pos);
        pos += head.len;
        head = head.next;
      }
      return buf2;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create10();
      BufferWriter._configure();
    };
  }
});
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util2 = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util2._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util2.Buffer && util2.Buffer.prototype instanceof Uint8Array && util2.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf2, pos) {
        buf2.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf2, pos) {
        if (val.copy)
          val.copy(buf2, pos, 0, val.length);
        else
          for (var i2 = 0; i2 < val.length; )
            buf2[pos++] = val[i2++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value2) {
      if (util2.isString(value2))
        value2 = util2._Buffer_from(value2, "base64");
      var len = value2.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value2);
      return this;
    };
    function writeStringBuffer(val, buf2, pos) {
      if (val.length < 40)
        util2.utf8.write(val, buf2, pos);
      else if (buf2.utf8Write)
        buf2.utf8Write(val, pos);
      else
        buf2.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value2) {
      var len = util2.Buffer.byteLength(value2);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value2);
      return this;
    };
    BufferWriter._configure();
  }
});
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    module2.exports = Reader;
    var util2 = require_minimal();
    var BufferReader;
    var LongBits2 = util2.LongBits;
    var utf8 = util2.utf8;
    function indexOutOfRange(reader3, writeLength) {
      return RangeError("index out of range: " + reader3.pos + " + " + (writeLength || 1) + " > " + reader3.len);
    }
    function Reader(buffer2) {
      this.buf = buffer2;
      this.pos = 0;
      this.len = buffer2.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
      if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    } : function create_array2(buffer2) {
      if (Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    };
    var create10 = function create11() {
      return util2.Buffer ? function create_buffer_setup(buffer2) {
        return (Reader.create = function create_buffer(buffer3) {
          return util2.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
        })(buffer2);
      } : create_array;
    };
    Reader.create = create10();
    Reader.prototype._slice = util2.Array.prototype.subarray || /* istanbul ignore next */
    util2.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value2 = 4294967295;
      return function read_uint32() {
        value2 = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        value2 = (value2 | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        value2 = (value2 | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        value2 = (value2 | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        value2 = (value2 | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value2;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value2 = this.uint32();
      return value2 >>> 1 ^ -(value2 & 1) | 0;
    };
    function readLongVarint() {
      var bits2 = new LongBits2(0, 0);
      var i2 = 0;
      if (this.len - this.pos > 4) {
        for (; i2 < 4; ++i2) {
          bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits2;
        }
        bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits2;
        i2 = 0;
      } else {
        for (; i2 < 3; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits2;
        }
        bits2.lo = (bits2.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
        return bits2;
      }
      if (this.len - this.pos > 4) {
        for (; i2 < 5; ++i2) {
          bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits2;
        }
      } else {
        for (; i2 < 5; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits2;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf2, end) {
      return (buf2[end - 4] | buf2[end - 3] << 8 | buf2[end - 2] << 16 | buf2[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits2(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value2 = util2.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value2;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value2 = util2.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value2;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length3 = this.uint32(), start = this.pos, end = this.pos + length3;
      if (end > this.len)
        throw indexOutOfRange(this, length3);
      this.pos += length3;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes2 = this.bytes();
      return utf8.read(bytes2, 0, bytes2.length);
    };
    Reader.prototype.skip = function skip(length3) {
      if (typeof length3 === "number") {
        if (this.pos + length3 > this.len)
          throw indexOutOfRange(this, length3);
        this.pos += length3;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create10();
      BufferReader._configure();
      var fn = util2.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util2.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util2 = require_minimal();
    function BufferReader(buffer2) {
      Reader.call(this, buffer2);
    }
    BufferReader._configure = function() {
      if (util2.Buffer)
        BufferReader.prototype._slice = util2.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    module2.exports = Service2;
    var util2 = require_minimal();
    (Service2.prototype = Object.create(util2.EventEmitter.prototype)).constructor = Service2;
    function Service2(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util2.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service2.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request2, callback) {
      if (!request2)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util2.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request2);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request2).finish(),
          function rpcCallback(err2, response) {
            if (err2) {
              self2.emit("error", err2, method);
              return callback(err2);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err3) {
                self2.emit("error", err3, method);
                return callback(err3);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err2) {
        self2.emit("error", err2, method);
        setTimeout(function() {
          callback(err2);
        }, 0);
        return void 0;
      }
    };
    Service2.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    var rpc = exports2;
    rpc.Service = require_service();
  }
});
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    module2.exports = {};
  }
});
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    var protobuf2 = exports2;
    protobuf2.build = "minimal";
    protobuf2.Writer = require_writer();
    protobuf2.BufferWriter = require_writer_buffer();
    protobuf2.Reader = require_reader();
    protobuf2.BufferReader = require_reader_buffer();
    protobuf2.util = require_minimal();
    protobuf2.rpc = require_rpc();
    protobuf2.roots = require_roots();
    protobuf2.configure = configure3;
    function configure3() {
      protobuf2.util._configure();
      protobuf2.Writer._configure(protobuf2.BufferWriter);
      protobuf2.Reader._configure(protobuf2.BufferReader);
    }
    configure3();
  }
});
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    module2.exports = require_index_minimal();
  }
});
var require_time_browser = __commonJS({
  "node_modules/retimer/time-browser.js"(exports2, module2) {
    module2.exports = function getTime() {
      return Date.now();
    };
  }
});
var require_retimer = __commonJS({
  "node_modules/retimer/retimer.js"(exports2, module2) {
    var getTime = require_time_browser();
    var Retimer = class {
      constructor(callback, timeout, args) {
        const that = this;
        this._started = getTime();
        this._rescheduled = 0;
        this._scheduled = timeout;
        this._args = args;
        this._triggered = false;
        this._timerWrapper = () => {
          if (that._rescheduled > 0) {
            that._scheduled = that._rescheduled - (getTime() - that._started);
            that._schedule(that._scheduled);
          } else {
            that._triggered = true;
            callback.apply(null, that._args);
          }
        };
        this._timer = setTimeout(this._timerWrapper, timeout);
      }
      reschedule(timeout) {
        if (!timeout) {
          timeout = this._scheduled;
        }
        const now = getTime();
        if (now + timeout - (this._started + this._scheduled) < 0) {
          clearTimeout(this._timer);
          this._schedule(timeout);
        } else if (!this._triggered) {
          this._started = now;
          this._rescheduled = timeout;
        } else {
          this._schedule(timeout);
        }
      }
      _schedule(timeout) {
        this._triggered = false;
        this._started = getTime();
        this._rescheduled = 0;
        this._scheduled = timeout;
        this._timer = setTimeout(this._timerWrapper, timeout);
      }
      clear() {
        clearTimeout(this._timer);
      }
    };
    function retimer2() {
      if (typeof arguments[0] !== "function") {
        throw new Error("callback needed");
      }
      if (typeof arguments[1] !== "number") {
        throw new Error("timeout needed");
      }
      let args;
      if (arguments.length > 0) {
        args = new Array(arguments.length - 2);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2 + 2];
        }
      }
      return new Retimer(arguments[0], arguments[1], args);
    }
    module2.exports = retimer2;
  }
});
var require_timeout_abort_controller = __commonJS({
  "node_modules/timeout-abort-controller/index.js"(exports2, module2) {
    var { AbortController: AbortController2 } = globalThis;
    var retimer2 = require_retimer();
    var TimeoutController19 = class extends AbortController2 {
      /**
       * @constructor
       * @param {number} ms milliseconds
       */
      constructor(ms) {
        super();
        this._ms = ms;
        this._timer = retimer2(() => this.abort(), ms);
        Object.setPrototypeOf(this, TimeoutController19.prototype);
      }
      /**
       * Aborts the controller and clears the timer
       */
      abort() {
        this._timer.clear();
        return super.abort();
      }
      /**
       * Clears the timer
       */
      clear() {
        this._timer.clear();
      }
      /**
       * Resets the timer
       */
      reset() {
        this._timer.clear();
        this._timer = retimer2(() => this.abort(), this._ms);
      }
    };
    module2.exports = {
      TimeoutController: TimeoutController19
    };
  }
});
var require_encode = __commonJS({
  "node_modules/varint/encode.js"(exports2, module2) {
    module2.exports = encode21;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode21(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode21.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode21.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});
var require_decode = __commonJS({
  "node_modules/varint/decode.js"(exports2, module2) {
    module2.exports = read2;
    var MSB2 = 128;
    var REST2 = 127;
    function read2(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l || shift > 49) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB2);
      read2.bytes = counter - offset;
      return res;
    }
  }
});
var require_length = __commonJS({
  "node_modules/varint/length.js"(exports2, module2) {
    var N12 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N32 = Math.pow(2, 21);
    var N42 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    module2.exports = function(value2) {
      return value2 < N12 ? 1 : value2 < N22 ? 2 : value2 < N32 ? 3 : value2 < N42 ? 4 : value2 < N52 ? 5 : value2 < N62 ? 6 : value2 < N72 ? 7 : value2 < N82 ? 8 : value2 < N92 ? 9 : 10;
    };
  }
});
var require_varint = __commonJS({
  "node_modules/varint/index.js"(exports2, module2) {
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});
var require_url_browser = __commonJS({
  "node_modules/iso-url/src/url-browser.js"(exports2, module2) {
    var isReactNative3 = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    function getDefaultBase() {
      if (isReactNative3) {
        return "http://localhost";
      }
      if (!self.location) {
        return "";
      }
      return self.location.protocol + "//" + self.location.host;
    }
    var URL3 = self.URL;
    var defaultBase = getDefaultBase();
    var URLWithLegacySupport = class {
      constructor(url2 = "", base3 = defaultBase) {
        this.super = new URL3(url2, base3);
        this.path = this.pathname + this.search;
        this.auth = this.username && this.password ? this.username + ":" + this.password : null;
        this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
      }
      get hash() {
        return this.super.hash;
      }
      get host() {
        return this.super.host;
      }
      get hostname() {
        return this.super.hostname;
      }
      get href() {
        return this.super.href;
      }
      get origin() {
        return this.super.origin;
      }
      get password() {
        return this.super.password;
      }
      get pathname() {
        return this.super.pathname;
      }
      get port() {
        return this.super.port;
      }
      get protocol() {
        return this.super.protocol;
      }
      get search() {
        return this.super.search;
      }
      get searchParams() {
        return this.super.searchParams;
      }
      get username() {
        return this.super.username;
      }
      set hash(hash3) {
        this.super.hash = hash3;
      }
      set host(host) {
        this.super.host = host;
      }
      set hostname(hostname) {
        this.super.hostname = hostname;
      }
      set href(href) {
        this.super.href = href;
      }
      set password(password) {
        this.super.password = password;
      }
      set pathname(pathname) {
        this.super.pathname = pathname;
      }
      set port(port) {
        this.super.port = port;
      }
      set protocol(protocol4) {
        this.super.protocol = protocol4;
      }
      set search(search) {
        this.super.search = search;
      }
      set username(username) {
        this.super.username = username;
      }
      /**
       * @param {any} o
       */
      static createObjectURL(o) {
        return URL3.createObjectURL(o);
      }
      /**
       * @param {string} o
       */
      static revokeObjectURL(o) {
        URL3.revokeObjectURL(o);
      }
      toJSON() {
        return this.super.toJSON();
      }
      toString() {
        return this.super.toString();
      }
      format() {
        return this.toString();
      }
    };
    function format2(obj) {
      if (typeof obj === "string") {
        const url2 = new URL3(obj);
        return url2.toString();
      }
      if (!(obj instanceof URL3)) {
        const userPass = (
          // @ts-ignore its not supported in node but we normalise
          obj.username && obj.password ? `${obj.username}:${obj.password}@` : ""
        );
        const auth = obj.auth ? obj.auth + "@" : "";
        const port = obj.port ? ":" + obj.port : "";
        const protocol4 = obj.protocol ? obj.protocol + "//" : "";
        const host = obj.host || "";
        const hostname = obj.hostname || "";
        const search = obj.search || (obj.query ? "?" + obj.query : "");
        const hash3 = obj.hash || "";
        const pathname = obj.pathname || "";
        const path2 = obj.path || pathname + search;
        return `${protocol4}${userPass || auth}${host || hostname + port}${path2}${hash3}`;
      }
    }
    module2.exports = {
      URLWithLegacySupport,
      URLSearchParams: self.URLSearchParams,
      defaultBase,
      format: format2
    };
  }
});
var require_relative = __commonJS({
  "node_modules/iso-url/src/relative.js"(exports2, module2) {
    var { URLWithLegacySupport, format: format2 } = require_url_browser();
    module2.exports = (url2, location2 = {}, protocolMap = {}, defaultProtocol) => {
      let protocol4 = location2.protocol ? location2.protocol.replace(":", "") : "http";
      protocol4 = (protocolMap[protocol4] || defaultProtocol || protocol4) + ":";
      let urlParsed;
      try {
        urlParsed = new URLWithLegacySupport(url2);
      } catch (err2) {
        urlParsed = {};
      }
      const base3 = Object.assign({}, location2, {
        protocol: protocol4 || urlParsed.protocol,
        host: location2.host || urlParsed.host
      });
      return new URLWithLegacySupport(url2, format2(base3)).toString();
    };
  }
});
var require_iso_url = __commonJS({
  "node_modules/iso-url/index.js"(exports2, module2) {
    var {
      URLWithLegacySupport,
      format: format2,
      URLSearchParams: URLSearchParams2,
      defaultBase
    } = require_url_browser();
    var relative2 = require_relative();
    module2.exports = {
      URL: URLWithLegacySupport,
      URLSearchParams: URLSearchParams2,
      format: format2,
      relative: relative2,
      defaultBase
    };
  }
});
var require_any_signal = __commonJS({
  "node_modules/any-signal/index.js"(exports2, module2) {
    function anySignal14(signals) {
      const controller = new globalThis.AbortController();
      function onAbort() {
        controller.abort();
        for (const signal of signals) {
          if (!signal || !signal.removeEventListener)
            continue;
          signal.removeEventListener("abort", onAbort);
        }
      }
      for (const signal of signals) {
        if (!signal || !signal.addEventListener)
          continue;
        if (signal.aborted) {
          onAbort();
          break;
        }
        signal.addEventListener("abort", onAbort);
      }
      return controller.signal;
    }
    module2.exports = anySignal14;
    module2.exports.anySignal = anySignal14;
  }
});
var require_hashlru = __commonJS({
  "node_modules/hashlru/index.js"(exports2, module2) {
    module2.exports = function(max) {
      if (!max)
        throw Error("hashlru must have a max value, of type number, greater than 0");
      var size = 0, cache4 = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
      function update(key, value2) {
        cache4[key] = value2;
        size++;
        if (size >= max) {
          size = 0;
          _cache = cache4;
          cache4 = /* @__PURE__ */ Object.create(null);
        }
      }
      return {
        has: function(key) {
          return cache4[key] !== void 0 || _cache[key] !== void 0;
        },
        remove: function(key) {
          if (cache4[key] !== void 0)
            cache4[key] = void 0;
          if (_cache[key] !== void 0)
            _cache[key] = void 0;
        },
        get: function(key) {
          var v = cache4[key];
          if (v !== void 0)
            return v;
          if ((v = _cache[key]) !== void 0) {
            update(key, v);
            return v;
          }
        },
        set: function(key, value2) {
          if (cache4[key] !== void 0)
            cache4[key] = value2;
          else
            update(key, value2);
        },
        clear: function() {
          cache4 = /* @__PURE__ */ Object.create(null);
          _cache = /* @__PURE__ */ Object.create(null);
        }
      };
    };
  }
});
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter6() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter6.prototype.eventNames = function eventNames() {
      var names3 = [], events2, name9;
      if (this._eventsCount === 0)
        return names3;
      for (name9 in events2 = this._events) {
        if (has.call(events2, name9))
          names3.push(prefix ? name9.slice(1) : name9);
      }
      if (Object.getOwnPropertySymbols) {
        return names3.concat(Object.getOwnPropertySymbols(events2));
      }
      return names3;
    };
    EventEmitter6.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i2 = 0, l = handlers.length, ee = new Array(l); i2 < l; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter6.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter6.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length3 = listeners.length, j;
        for (i2 = 0; i2 < length3; i2++) {
          if (listeners[i2].once)
            this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter6.prototype.on = function on2(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter6.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter6.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events2 = [], length3 = listeners.length; i2 < length3; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
            events2.push(listeners[i2]);
          }
        }
        if (events2.length)
          this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter6.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter6.prototype.off = EventEmitter6.prototype.removeListener;
    EventEmitter6.prototype.addListener = EventEmitter6.prototype.on;
    EventEmitter6.prefixed = prefix;
    EventEmitter6.EventEmitter = EventEmitter6;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter6;
    }
  }
});
var require_error = __commonJS({
  "node_modules/ipfs-utils/src/http/error.js"(exports2) {
    var TimeoutError5 = class extends Error {
      constructor(message2 = "Request timed out") {
        super(message2);
        this.name = "TimeoutError";
      }
    };
    exports2.TimeoutError = TimeoutError5;
    var AbortError7 = class extends Error {
      constructor(message2 = "The operation was aborted.") {
        super(message2);
        this.name = "AbortError";
      }
    };
    exports2.AbortError = AbortError7;
    var HTTPError2 = class extends Error {
      /**
       * @param {Response} response
       */
      constructor(response) {
        super(response.statusText);
        this.name = "HTTPError";
        this.response = response;
      }
    };
    exports2.HTTPError = HTTPError2;
  }
});
var require_browser2 = __commonJS({
  "node_modules/ipfs-utils/node_modules/node-fetch/browser.js"(exports2, module2) {
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof globalThis !== "undefined") {
        return globalThis;
      }
      throw new Error("unable to locate globalThis object");
    };
    var globalObject = getGlobal();
    module2.exports = exports2 = globalObject.fetch;
    if (globalObject.fetch) {
      exports2.default = globalObject.fetch.bind(globalThis);
    }
    exports2.Headers = globalObject.Headers;
    exports2.Request = globalObject.Request;
    exports2.Response = globalObject.Response;
  }
});
var require_src = __commonJS({
  "node_modules/ipfs-utils/node_modules/native-fetch/src/index.js"(exports2, module2) {
    if (globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response) {
      module2.exports = {
        default: globalThis.fetch,
        Headers: globalThis.Headers,
        Request: globalThis.Request,
        Response: globalThis.Response
      };
    } else {
      module2.exports = {
        default: require_browser2().default,
        Headers: require_browser2().Headers,
        Request: require_browser2().Request,
        Response: require_browser2().Response
      };
    }
  }
});
var require_fetch_browser = __commonJS({
  "node_modules/ipfs-utils/src/fetch.browser.js"(exports2, module2) {
    module2.exports = require_src();
  }
});
var require_fetch_browser2 = __commonJS({
  "node_modules/ipfs-utils/src/http/fetch.browser.js"(exports2, module2) {
    var { TimeoutError: TimeoutError5, AbortError: AbortError7 } = require_error();
    var { Response: Response2, Request: Request2, Headers, default: fetch2 } = require_fetch_browser();
    var fetchWithProgress = (url2, options = {}) => {
      const request2 = new XMLHttpRequest();
      request2.open(options.method || "GET", url2.toString(), true);
      const { timeout, headers } = options;
      if (timeout && timeout > 0 && timeout < Infinity) {
        request2.timeout = timeout;
      }
      if (options.overrideMimeType != null) {
        request2.overrideMimeType(options.overrideMimeType);
      }
      if (headers) {
        for (const [name9, value2] of new Headers(headers)) {
          request2.setRequestHeader(name9, value2);
        }
      }
      if (options.signal) {
        options.signal.onabort = () => request2.abort();
      }
      if (options.onUploadProgress) {
        request2.upload.onprogress = options.onUploadProgress;
      }
      request2.responseType = "arraybuffer";
      return new Promise((resolve7, reject) => {
        const handleEvent = (event) => {
          switch (event.type) {
            case "error": {
              resolve7(Response2.error());
              break;
            }
            case "load": {
              resolve7(
                new ResponseWithURL(request2.responseURL, request2.response, {
                  status: request2.status,
                  statusText: request2.statusText,
                  headers: parseHeaders(request2.getAllResponseHeaders())
                })
              );
              break;
            }
            case "timeout": {
              reject(new TimeoutError5());
              break;
            }
            case "abort": {
              reject(new AbortError7());
              break;
            }
          }
        };
        request2.onerror = handleEvent;
        request2.onload = handleEvent;
        request2.ontimeout = handleEvent;
        request2.onabort = handleEvent;
        request2.send(options.body);
      });
    };
    var fetchWithStreaming = fetch2;
    var fetchWith = (url2, options = {}) => options.onUploadProgress != null ? fetchWithProgress(url2, options) : fetchWithStreaming(url2, options);
    var parseHeaders = (input) => {
      const headers = new Headers();
      for (const line of input.trim().split(/[\r\n]+/)) {
        const index2 = line.indexOf(": ");
        if (index2 > 0) {
          headers.set(line.slice(0, index2), line.slice(index2 + 1));
        }
      }
      return headers;
    };
    var ResponseWithURL = class extends Response2 {
      /**
       * @param {string} url
       * @param {BodyInit} body
       * @param {ResponseInit} options
       */
      constructor(url2, body, options) {
        super(body, options);
        Object.defineProperty(this, "url", { value: url2 });
      }
    };
    module2.exports = {
      fetch: fetchWith,
      Request: Request2,
      Headers
    };
  }
});
var require_browser_readablestream_to_it = __commonJS({
  "node_modules/ipfs-utils/node_modules/browser-readablestream-to-it/index.js"(exports2, module2) {
    async function* browserReadableStreamToIt2(stream, options = {}) {
      const reader3 = stream.getReader();
      try {
        while (true) {
          const result = await reader3.read();
          if (result.done) {
            return;
          }
          yield result.value;
        }
      } finally {
        if (options.preventCancel !== true) {
          reader3.cancel();
        }
        reader3.releaseLock();
      }
    }
    module2.exports = browserReadableStreamToIt2;
  }
});
var require_it_all = __commonJS({
  "node_modules/ipfs-utils/node_modules/it-all/index.js"(exports2, module2) {
    var all32 = async (source) => {
      const arr = [];
      for await (const entry of source) {
        arr.push(entry);
      }
      return arr;
    };
    module2.exports = all32;
  }
});
var require_http = __commonJS({
  "node_modules/ipfs-utils/src/http.js"(exports2, module2) {
    var { fetch: fetch2, Request: Request2, Headers } = require_fetch_browser2();
    var { TimeoutError: TimeoutError5, HTTPError: HTTPError2 } = require_error();
    var merge3 = require_merge_options().bind({ ignoreUndefined: true });
    var { URL: URL3, URLSearchParams: URLSearchParams2 } = require_iso_url();
    var anySignal14 = require_any_signal();
    var browserReableStreamToIt = require_browser_readablestream_to_it();
    var { isBrowser: isBrowser4, isWebWorker: isWebWorker3 } = require_env();
    var all32 = require_it_all();
    var timeout = (promise, ms, abortController) => {
      if (ms === void 0) {
        return promise;
      }
      const start = Date.now();
      const timedOut = () => {
        const time = Date.now() - start;
        return time >= ms;
      };
      return new Promise((resolve7, reject) => {
        const timeoutID = setTimeout(() => {
          if (timedOut()) {
            reject(new TimeoutError5());
            abortController.abort();
          }
        }, ms);
        const after = (next) => {
          const fn = (res) => {
            clearTimeout(timeoutID);
            if (timedOut()) {
              reject(new TimeoutError5());
              return;
            }
            next(res);
          };
          return fn;
        };
        promise.then(after(resolve7), after(reject));
      });
    };
    var defaults2 = {
      throwHttpErrors: true,
      credentials: "same-origin"
    };
    var HTTP6 = class {
      /**
       *
       * @param {HTTPOptions} options
       */
      constructor(options = {}) {
        this.opts = merge3(defaults2, options);
      }
      /**
       * Fetch
       *
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       * @returns {Promise<ExtendedResponse>}
       */
      async fetch(resource, options = {}) {
        const opts = merge3(this.opts, options);
        const headers = new Headers(opts.headers);
        if (typeof resource !== "string" && !(resource instanceof URL3 || resource instanceof Request2)) {
          throw new TypeError("`resource` must be a string, URL, or Request");
        }
        const url2 = new URL3(resource.toString(), opts.base);
        const {
          searchParams,
          transformSearchParams,
          json
        } = opts;
        if (searchParams) {
          if (typeof transformSearchParams === "function") {
            url2.search = transformSearchParams(new URLSearchParams2(opts.searchParams));
          } else {
            url2.search = new URLSearchParams2(opts.searchParams);
          }
        }
        if (json) {
          opts.body = JSON.stringify(opts.json);
          headers.set("content-type", "application/json");
        }
        const abortController = new AbortController();
        const signal = anySignal14([abortController.signal, opts.signal]);
        if (globalThis.ReadableStream != null && opts.body instanceof globalThis.ReadableStream && (isBrowser4 || isWebWorker3)) {
          opts.body = new Blob(await all32(browserReableStreamToIt(opts.body)));
        }
        const response = await timeout(
          fetch2(
            url2.toString(),
            {
              ...opts,
              signal,
              // @ts-expect-error non-browser fetch implementations may take extra options
              timeout: void 0,
              headers,
              // https://fetch.spec.whatwg.org/#dom-requestinit-duplex
              // https://github.com/whatwg/fetch/issues/1254
              duplex: "half"
            }
          ),
          opts.timeout,
          abortController
        );
        if (!response.ok && opts.throwHttpErrors) {
          if (opts.handleError) {
            await opts.handleError(response);
          }
          throw new HTTPError2(response);
        }
        response.iterator = async function* () {
          yield* fromStream(response.body);
        };
        response.ndjson = async function* () {
          for await (const chunk of ndjson(response.iterator())) {
            if (options.transform) {
              yield options.transform(chunk);
            } else {
              yield chunk;
            }
          }
        };
        return response;
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      post(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "POST" });
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      get(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "GET" });
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      put(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "PUT" });
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      delete(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "DELETE" });
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      options(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "OPTIONS" });
      }
    };
    var ndjson = async function* (source) {
      const decoder = new TextDecoder();
      let buf2 = "";
      for await (const chunk of source) {
        buf2 += decoder.decode(chunk, { stream: true });
        const lines = buf2.split(/\r?\n/);
        for (let i2 = 0; i2 < lines.length - 1; i2++) {
          const l = lines[i2].trim();
          if (l.length > 0) {
            yield JSON.parse(l);
          }
        }
        buf2 = lines[lines.length - 1];
      }
      buf2 += decoder.decode();
      buf2 = buf2.trim();
      if (buf2.length !== 0) {
        yield JSON.parse(buf2);
      }
    };
    var fromStream = (source) => {
      if (isAsyncIterable3(source)) {
        return source;
      }
      if (isNodeReadableStream(source)) {
        const iter = source[Symbol.asyncIterator]();
        return {
          [Symbol.asyncIterator]() {
            return {
              next: iter.next.bind(iter),
              return(value2) {
                source.destroy();
                if (typeof iter.return === "function") {
                  return iter.return();
                }
                return Promise.resolve({ done: true, value: value2 });
              }
            };
          }
        };
      }
      if (isWebReadableStream(source)) {
        const reader3 = source.getReader();
        return async function* () {
          try {
            while (true) {
              const { done, value: value2 } = await reader3.read();
              if (done)
                return;
              if (value2) {
                yield value2;
              }
            }
          } finally {
            reader3.releaseLock();
          }
        }();
      }
      throw new TypeError("Body can't be converted to AsyncIterable");
    };
    var isAsyncIterable3 = (value2) => {
      return typeof value2 === "object" && value2 !== null && typeof /** @type {any} */
      value2[Symbol.asyncIterator] === "function";
    };
    var isWebReadableStream = (value2) => {
      return value2 && typeof /** @type {any} */
      value2.getReader === "function";
    };
    var isNodeReadableStream = (value2) => Object.prototype.hasOwnProperty.call(value2, "readable") && Object.prototype.hasOwnProperty.call(value2, "writable");
    HTTP6.HTTPError = HTTPError2;
    HTTP6.TimeoutError = TimeoutError5;
    HTTP6.streamToAsyncIterator = fromStream;
    HTTP6.post = (resource, options) => new HTTP6(options).post(resource, options);
    HTTP6.get = (resource, options) => new HTTP6(options).get(resource, options);
    HTTP6.put = (resource, options) => new HTTP6(options).put(resource, options);
    HTTP6.delete = (resource, options) => new HTTP6(options).delete(resource, options);
    HTTP6.options = (resource, options) => new HTTP6(options).options(resource, options);
    module2.exports = HTTP6;
  }
});
var require_timestamp_min = __commonJS({
  "node_modules/timestamp-nano/dist/timestamp.min.js"(exports2, module2) {
    (function() {
      "undefined" != typeof module2 && (module2.exports = d);
      var l = 86400, s = 3200, T = 146097 * s / 400, e = l * T, f = 1e3 * e, c = 864e13, g = 4294967296, h = 1e6, u = "000000000", m = Math.trunc || function(n2) {
        var t2 = n2 - n2 % 1;
        return 0 == t2 && (n2 < 0 || 0 === n2 && 1 / n2 != 1 / 0) ? -0 : t2;
      }, n = d.prototype, o = (d.fromDate = function(n2) {
        return new d(+n2);
      }, d.fromInt64BE = r(0, 1, 2, 3, 0, 4), d.fromInt64LE = r(3, 2, 1, 0, 4, 0), d.fromString = function(n2) {
        var e2, r2 = new d(), n2 = (n2 += "").replace(/^\s*[+\-]?\d+/, function(n3) {
          var n3 = +n3, t2 = 1970 + (n3 - 1970) % 400;
          return r2.year = n3 - t2, t2;
        }).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/, function(n3, t2, r3) {
          return t2 < 0 && (r3 *= -1), e2 = 6e4 * (60 * +t2 + +r3), "";
        }).replace(/\.\d+$/, function(n3) {
          return r2.nano = +(n3 + u).substr(1, 9), "";
        }).split(/\D+/);
        1 < n2.length ? n2[1]-- : n2[1] = 0;
        if (r2.time = e2 = Date.UTC.apply(Date, n2) - (e2 || 0), isNaN(e2))
          throw new TypeError("Invalid Date");
        return p(r2);
      }, d.fromTimeT = function(n2) {
        return y(n2, 0);
      }, n.year = 0, n.time = 0, n.nano = 0, n.addNano = function(n2) {
        return this.nano += +n2 || 0, this;
      }, n.getNano = function() {
        var n2 = p(this);
        return (n2.time % 1e3 * h + +n2.nano + 1e9) % 1e9;
      }, n.getTimeT = function() {
        var n2 = p(this), t2 = Math.floor(n2.time / 1e3), n2 = n2.year;
        n2 && (t2 += n2 * T * l / s);
        return t2;
      }, n.getYear = function() {
        return this.toDate().getUTCFullYear() + this.year;
      }, n.toDate = function() {
        return M(p(this).time);
      }, n.toJSON = function() {
        return this.toString().replace(/0{1,6}Z$/, "Z");
      }, n.toString = function(n2) {
        var t2 = this, r2 = t2.toDate(), u2 = { H: function() {
          return C(r2.getUTCHours());
        }, L: function() {
          return D(r2.getUTCMilliseconds(), 3);
        }, M: function() {
          return C(r2.getUTCMinutes());
        }, N: function() {
          return D(t2.getNano(), 9);
        }, S: function() {
          return C(r2.getUTCSeconds());
        }, Y: function() {
          var n3 = t2.getYear();
          return 999999 < n3 ? "+" + n3 : 9999 < n3 ? "+" + D(n3, 6) : 0 <= n3 ? D(n3, 4) : -999999 <= n3 ? "-" + D(-n3, 6) : n3;
        }, a: function() {
          return a[r2.getUTCDay()];
        }, b: function() {
          return i2[r2.getUTCMonth()];
        }, d: function() {
          return C(r2.getUTCDate());
        }, e: function() {
          return function(n3) {
            return (9 < n3 ? "" : " ") + (0 | n3);
          }(r2.getUTCDate());
        }, m: function() {
          return C(r2.getUTCMonth() + 1);
        } };
        return function e2(n3) {
          return n3.replace(/%./g, function(n4) {
            var t3 = n4[1], r3 = v[t3], t3 = u2[t3];
            return r3 ? e2(r3) : t3 ? t3() : n4;
          });
        }(n2 || o);
      }, n.writeInt64BE = t(0, 1, 2, 3, 0, 4), n.writeInt64LE = t(3, 2, 1, 0, 4, 0), "%Y-%m-%dT%H:%M:%S.%NZ"), i2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], a = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], v = { "%": "%", F: "%Y-%m-%d", n: "\n", R: "%H:%M", T: "%H:%M:%S", t: "	", X: "%T", Z: "GMT", z: "+0000" };
      return d;
      function d(n2, t2, r2) {
        var e2 = this;
        if (!(e2 instanceof d))
          return new d(n2, t2, r2);
        e2.time = +n2 || 0, e2.nano = +t2 || 0, e2.year = +r2 || 0, p(e2);
      }
      function p(n2) {
        var t2, r2, e2, u2 = n2.year, o2 = n2.time, i3 = n2.nano, a2 = ((i3 < 0 || h <= i3) && (i3 -= (r2 = Math.floor(i3 / h)) * h, o2 += r2, r2 = 1), u2 % s);
        return (o2 < -c || c < o2 || a2) && ((t2 = m(o2 / f)) && (u2 += t2 * s, o2 -= t2 * f), (e2 = M(o2)).setUTCFullYear(a2 + e2.getUTCFullYear()), e2 = (o2 = +e2) + (t2 = m((u2 -= a2) / s)) * f, t2 && -c <= e2 && e2 <= c && (u2 -= t2 * s, o2 = e2), r2 = 1), r2 && (n2.year = u2, n2.time = o2, n2.nano = i3), n2;
      }
      function M(n2) {
        var t2 = new Date(0);
        return t2.setTime(n2), t2;
      }
      function y(n2, t2) {
        n2 = +n2 || 0;
        var r2 = m((t2 = (t2 | 0) * g) / e) + m(n2 / e), t2 = t2 % e + n2 % e, n2 = m(t2 / e);
        return n2 && (r2 += n2, t2 -= n2 * e), new d(1e3 * t2, 0, r2 * s);
      }
      function t(e2, u2, o2, i3, a2, f2) {
        return function(n2, t2) {
          var r2 = p(this);
          n2 = n2 || new Array(8);
          w(n2, t2 |= 0);
          var e3 = Math.floor(r2.time / 1e3), r2 = r2.year * (T * l / s), u3 = m(r2 / g) + m(e3 / g), r2 = r2 % g + e3 % g, e3 = Math.floor(r2 / g);
          e3 && (u3 += e3, r2 -= e3 * g);
          return c2(n2, t2 + a2, u3), c2(n2, t2 + f2, r2), n2;
        };
        function c2(n2, t2, r2) {
          n2[t2 + e2] = r2 >> 24 & 255, n2[t2 + u2] = r2 >> 16 & 255, n2[t2 + o2] = r2 >> 8 & 255, n2[t2 + i3] = 255 & r2;
        }
      }
      function r(r2, e2, u2, o2, i3, a2) {
        return function(n2, t2) {
          w(n2, t2 |= 0);
          var r3 = f2(n2, t2 + i3);
          return y(f2(n2, t2 + a2), r3);
        };
        function f2(n2, t2) {
          return 16777216 * n2[t2 + r2] + (n2[t2 + e2] << 16 | n2[t2 + u2] << 8 | n2[t2 + o2]);
        }
      }
      function w(n2, t2) {
        n2 = n2 && n2.length;
        if (null == n2)
          throw new TypeError("Invalid Buffer");
        if (n2 < t2 + 8)
          throw new RangeError("Out of range");
      }
      function C(n2) {
        return (9 < n2 ? "" : "0") + (0 | n2);
      }
      function D(n2, t2) {
        return (u + (0 | n2)).substr(-t2);
      }
    })();
  }
});
var require_forge = __commonJS({
  "node_modules/node-forge/lib/forge.js"(exports2, module2) {
    module2.exports = {
      // default options
      options: {
        usePureJavaScript: false
      }
    };
  }
});
var require_baseN = __commonJS({
  "node_modules/node-forge/lib/baseN.js"(exports2, module2) {
    var api = {};
    module2.exports = api;
    var _reverseAlphabets = {};
    api.encode = function(input, alphabet3, maxline) {
      if (typeof alphabet3 !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      if (maxline !== void 0 && typeof maxline !== "number") {
        throw new TypeError('"maxline" must be a number.');
      }
      var output = "";
      if (!(input instanceof Uint8Array)) {
        output = _encodeWithByteBuffer(input, alphabet3);
      } else {
        var i2 = 0;
        var base3 = alphabet3.length;
        var first2 = alphabet3.charAt(0);
        var digits = [0];
        for (i2 = 0; i2 < input.length; ++i2) {
          for (var j = 0, carry = input[i2]; j < digits.length; ++j) {
            carry += digits[j] << 8;
            digits[j] = carry % base3;
            carry = carry / base3 | 0;
          }
          while (carry > 0) {
            digits.push(carry % base3);
            carry = carry / base3 | 0;
          }
        }
        for (i2 = 0; input[i2] === 0 && i2 < input.length - 1; ++i2) {
          output += first2;
        }
        for (i2 = digits.length - 1; i2 >= 0; --i2) {
          output += alphabet3[digits[i2]];
        }
      }
      if (maxline) {
        var regex = new RegExp(".{1," + maxline + "}", "g");
        output = output.match(regex).join("\r\n");
      }
      return output;
    };
    api.decode = function(input, alphabet3) {
      if (typeof input !== "string") {
        throw new TypeError('"input" must be a string.');
      }
      if (typeof alphabet3 !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      var table2 = _reverseAlphabets[alphabet3];
      if (!table2) {
        table2 = _reverseAlphabets[alphabet3] = [];
        for (var i2 = 0; i2 < alphabet3.length; ++i2) {
          table2[alphabet3.charCodeAt(i2)] = i2;
        }
      }
      input = input.replace(/\s/g, "");
      var base3 = alphabet3.length;
      var first2 = alphabet3.charAt(0);
      var bytes2 = [0];
      for (var i2 = 0; i2 < input.length; i2++) {
        var value2 = table2[input.charCodeAt(i2)];
        if (value2 === void 0) {
          return;
        }
        for (var j = 0, carry = value2; j < bytes2.length; ++j) {
          carry += bytes2[j] * base3;
          bytes2[j] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes2.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k = 0; input[k] === first2 && k < input.length - 1; ++k) {
        bytes2.push(0);
      }
      if (typeof Buffer !== "undefined") {
        return Buffer.from(bytes2.reverse());
      }
      return new Uint8Array(bytes2.reverse());
    };
    function _encodeWithByteBuffer(input, alphabet3) {
      var i2 = 0;
      var base3 = alphabet3.length;
      var first2 = alphabet3.charAt(0);
      var digits = [0];
      for (i2 = 0; i2 < input.length(); ++i2) {
        for (var j = 0, carry = input.at(i2); j < digits.length; ++j) {
          carry += digits[j] << 8;
          digits[j] = carry % base3;
          carry = carry / base3 | 0;
        }
        while (carry > 0) {
          digits.push(carry % base3);
          carry = carry / base3 | 0;
        }
      }
      var output = "";
      for (i2 = 0; input.at(i2) === 0 && i2 < input.length() - 1; ++i2) {
        output += first2;
      }
      for (i2 = digits.length - 1; i2 >= 0; --i2) {
        output += alphabet3[digits[i2]];
      }
      return output;
    }
  }
});
var require_util = __commonJS({
  "node_modules/node-forge/lib/util.js"(exports2, module2) {
    var forge9 = require_forge();
    var baseN = require_baseN();
    var util2 = module2.exports = forge9.util = forge9.util || {};
    (function() {
      if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        util2.nextTick = process.nextTick;
        if (typeof setImmediate === "function") {
          util2.setImmediate = setImmediate;
        } else {
          util2.setImmediate = util2.nextTick;
        }
        return;
      }
      if (typeof setImmediate === "function") {
        util2.setImmediate = function() {
          return setImmediate.apply(void 0, arguments);
        };
        util2.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util2.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        let handler2 = function(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        };
        var msg = "forge.setImmediate";
        var callbacks = [];
        util2.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, "*");
          }
        };
        window.addEventListener("message", handler2, true);
      }
      if (typeof MutationObserver !== "undefined") {
        var now = Date.now();
        var attr = true;
        var div = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div, { attributes: true });
        var oldSetImmediate = util2.setImmediate;
        util2.setImmediate = function(callback) {
          if (Date.now() - now > 15) {
            now = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div.setAttribute("a", attr = !attr);
            }
          }
        };
      }
      util2.nextTick = util2.setImmediate;
    })();
    util2.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    util2.globalScope = function() {
      if (util2.isNodejs) {
        return globalThis;
      }
      return typeof self === "undefined" ? window : self;
    }();
    util2.isArray = Array.isArray || function(x) {
      return Object.prototype.toString.call(x) === "[object Array]";
    };
    util2.isArrayBuffer = function(x) {
      return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
    };
    util2.isArrayBufferView = function(x) {
      return x && util2.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
    };
    function _checkBitsParam(n) {
      if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
        throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
      }
    }
    util2.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b) {
      this.data = "";
      this.read = 0;
      if (typeof b === "string") {
        this.data = b;
      } else if (util2.isArrayBuffer(b) || util2.isArrayBufferView(b)) {
        if (typeof Buffer !== "undefined" && b instanceof Buffer) {
          this.data = b.toString("binary");
        } else {
          var arr = new Uint8Array(b);
          try {
            this.data = String.fromCharCode.apply(null, arr);
          } catch (e) {
            for (var i2 = 0; i2 < arr.length; ++i2) {
              this.putByte(arr[i2]);
            }
          }
        }
      } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
        this.data = b.data;
        this.read = b.read;
      }
      this._constructedStringLength = 0;
    }
    util2.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util2.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
      this._constructedStringLength += x;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util2.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util2.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util2.ByteStringBuffer.prototype.putByte = function(b) {
      return this.putBytes(String.fromCharCode(b));
    };
    util2.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
      b = String.fromCharCode(b);
      var d = this.data;
      while (n > 0) {
        if (n & 1) {
          d += b;
        }
        n >>>= 1;
        if (n > 0) {
          b += b;
        }
      }
      this.data = d;
      this._optimizeConstructedString(n);
      return this;
    };
    util2.ByteStringBuffer.prototype.putBytes = function(bytes2) {
      this.data += bytes2;
      this._optimizeConstructedString(bytes2.length);
      return this;
    };
    util2.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util2.encodeUtf8(str));
    };
    util2.ByteStringBuffer.prototype.putInt16 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt24 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt32 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt16Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt24Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt32Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 24 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt = function(i2, n) {
      _checkBitsParam(n);
      var bytes2 = "";
      do {
        n -= 8;
        bytes2 += String.fromCharCode(i2 >> n & 255);
      } while (n > 0);
      return this.putBytes(bytes2);
    };
    util2.ByteStringBuffer.prototype.putSignedInt = function(i2, n) {
      if (i2 < 0) {
        i2 += 2 << n - 1;
      }
      return this.putInt(i2, n);
    };
    util2.ByteStringBuffer.prototype.putBuffer = function(buffer2) {
      return this.putBytes(buffer2.getBytes());
    };
    util2.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util2.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      this.read += 2;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      this.read += 3;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      this.read += 4;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      this.read += 2;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      this.read += 3;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      this.read += 4;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util2.ByteStringBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util2.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util2.ByteStringBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util2.ByteStringBuffer.prototype.at = function(i2) {
      return this.data.charCodeAt(this.read + i2);
    };
    util2.ByteStringBuffer.prototype.setAt = function(i2, b) {
      this.data = this.data.substr(0, this.read + i2) + String.fromCharCode(b) + this.data.substr(this.read + i2 + 1);
      return this;
    };
    util2.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util2.ByteStringBuffer.prototype.copy = function() {
      var c = util2.createBuffer(this.data);
      c.read = this.read;
      return c;
    };
    util2.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util2.ByteStringBuffer.prototype.clear = function() {
      this.data = "";
      this.read = 0;
      return this;
    };
    util2.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util2.ByteStringBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i2 = this.read; i2 < this.data.length; ++i2) {
        var b = this.data.charCodeAt(i2);
        if (b < 16) {
          rval += "0";
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util2.ByteStringBuffer.prototype.toString = function() {
      return util2.decodeUtf8(this.bytes());
    };
    function DataBuffer(b, options) {
      options = options || {};
      this.read = options.readOffset || 0;
      this.growSize = options.growSize || 1024;
      var isArrayBuffer2 = util2.isArrayBuffer(b);
      var isArrayBufferView2 = util2.isArrayBufferView(b);
      if (isArrayBuffer2 || isArrayBufferView2) {
        if (isArrayBuffer2) {
          this.data = new DataView(b);
        } else {
          this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
        }
        this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b !== null && b !== void 0) {
        this.putBytes(b);
      }
      if ("writeOffset" in options) {
        this.write = options.writeOffset;
      }
    }
    util2.DataBuffer = DataBuffer;
    util2.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util2.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util2.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src2 = new Uint8Array(
        this.data.buffer,
        this.data.byteOffset,
        this.data.byteLength
      );
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src2);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util2.DataBuffer.prototype.putByte = function(b) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b);
      return this;
    };
    util2.DataBuffer.prototype.fillWithByte = function(b, n) {
      this.accommodate(n);
      for (var i2 = 0; i2 < n; ++i2) {
        this.data.setUint8(b);
      }
      return this;
    };
    util2.DataBuffer.prototype.putBytes = function(bytes2, encoding) {
      if (util2.isArrayBufferView(bytes2)) {
        var src2 = new Uint8Array(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
        var len = src2.byteLength - src2.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src2);
        this.write += len;
        return this;
      }
      if (util2.isArrayBuffer(bytes2)) {
        var src2 = new Uint8Array(bytes2);
        this.accommodate(src2.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src2, this.write);
        this.write += src2.byteLength;
        return this;
      }
      if (bytes2 instanceof util2.DataBuffer || typeof bytes2 === "object" && typeof bytes2.read === "number" && typeof bytes2.write === "number" && util2.isArrayBufferView(bytes2.data)) {
        var src2 = new Uint8Array(bytes2.data.byteLength, bytes2.read, bytes2.length());
        this.accommodate(src2.byteLength);
        var dst = new Uint8Array(bytes2.data.byteLength, this.write);
        dst.set(src2);
        this.write += src2.byteLength;
        return this;
      }
      if (bytes2 instanceof util2.ByteStringBuffer) {
        bytes2 = bytes2.data;
        encoding = "binary";
      }
      encoding = encoding || "binary";
      if (typeof bytes2 === "string") {
        var view;
        if (encoding === "hex") {
          this.accommodate(Math.ceil(bytes2.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util2.binary.hex.decode(bytes2, view, this.write);
          return this;
        }
        if (encoding === "base64") {
          this.accommodate(Math.ceil(bytes2.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util2.binary.base64.decode(bytes2, view, this.write);
          return this;
        }
        if (encoding === "utf8") {
          bytes2 = util2.encodeUtf8(bytes2);
          encoding = "binary";
        }
        if (encoding === "binary" || encoding === "raw") {
          this.accommodate(bytes2.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util2.binary.raw.decode(view);
          return this;
        }
        if (encoding === "utf16") {
          this.accommodate(bytes2.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util2.text.utf16.encode(view);
          return this;
        }
        throw new Error("Invalid encoding: " + encoding);
      }
      throw Error("Invalid parameter: " + bytes2);
    };
    util2.DataBuffer.prototype.putBuffer = function(buffer2) {
      this.putBytes(buffer2);
      buffer2.clear();
      return this;
    };
    util2.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, "utf16");
    };
    util2.DataBuffer.prototype.putInt16 = function(i2) {
      this.accommodate(2);
      this.data.setInt16(this.write, i2);
      this.write += 2;
      return this;
    };
    util2.DataBuffer.prototype.putInt24 = function(i2) {
      this.accommodate(3);
      this.data.setInt16(this.write, i2 >> 8 & 65535);
      this.data.setInt8(this.write, i2 >> 16 & 255);
      this.write += 3;
      return this;
    };
    util2.DataBuffer.prototype.putInt32 = function(i2) {
      this.accommodate(4);
      this.data.setInt32(this.write, i2);
      this.write += 4;
      return this;
    };
    util2.DataBuffer.prototype.putInt16Le = function(i2) {
      this.accommodate(2);
      this.data.setInt16(this.write, i2, true);
      this.write += 2;
      return this;
    };
    util2.DataBuffer.prototype.putInt24Le = function(i2) {
      this.accommodate(3);
      this.data.setInt8(this.write, i2 >> 16 & 255);
      this.data.setInt16(this.write, i2 >> 8 & 65535, true);
      this.write += 3;
      return this;
    };
    util2.DataBuffer.prototype.putInt32Le = function(i2) {
      this.accommodate(4);
      this.data.setInt32(this.write, i2, true);
      this.write += 4;
      return this;
    };
    util2.DataBuffer.prototype.putInt = function(i2, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      do {
        n -= 8;
        this.data.setInt8(this.write++, i2 >> n & 255);
      } while (n > 0);
      return this;
    };
    util2.DataBuffer.prototype.putSignedInt = function(i2, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      if (i2 < 0) {
        i2 += 2 << n - 1;
      }
      return this.putInt(i2, n);
    };
    util2.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util2.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util2.DataBuffer.prototype.getInt24 = function() {
      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      this.read += 3;
      return rval;
    };
    util2.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util2.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util2.DataBuffer.prototype.getInt24Le = function() {
      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
      this.read += 3;
      return rval;
    };
    util2.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util2.DataBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util2.DataBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util2.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util2.DataBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util2.DataBuffer.prototype.at = function(i2) {
      return this.data.getUint8(this.read + i2);
    };
    util2.DataBuffer.prototype.setAt = function(i2, b) {
      this.data.setUint8(i2, b);
      return this;
    };
    util2.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util2.DataBuffer.prototype.copy = function() {
      return new util2.DataBuffer(this);
    };
    util2.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src2 = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src2.byteLength);
        dst.set(src2);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util2.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util2.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util2.DataBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i2 = this.read; i2 < this.data.byteLength; ++i2) {
        var b = this.data.getUint8(i2);
        if (b < 16) {
          rval += "0";
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util2.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || "utf8";
      if (encoding === "binary" || encoding === "raw") {
        return util2.binary.raw.encode(view);
      }
      if (encoding === "hex") {
        return util2.binary.hex.encode(view);
      }
      if (encoding === "base64") {
        return util2.binary.base64.encode(view);
      }
      if (encoding === "utf8") {
        return util2.text.utf8.decode(view);
      }
      if (encoding === "utf16") {
        return util2.text.utf16.decode(view);
      }
      throw new Error("Invalid encoding: " + encoding);
    };
    util2.createBuffer = function(input, encoding) {
      encoding = encoding || "raw";
      if (input !== void 0 && encoding === "utf8") {
        input = util2.encodeUtf8(input);
      }
      return new util2.ByteBuffer(input);
    };
    util2.fillString = function(c, n) {
      var s = "";
      while (n > 0) {
        if (n & 1) {
          s += c;
        }
        n >>>= 1;
        if (n > 0) {
          c += c;
        }
      }
      return s;
    };
    util2.xorBytes = function(s1, s2, n) {
      var s3 = "";
      var b = "";
      var t = "";
      var i2 = 0;
      var c = 0;
      for (; n > 0; --n, ++i2) {
        b = s1.charCodeAt(i2) ^ s2.charCodeAt(i2);
        if (c >= 10) {
          s3 += t;
          t = "";
          c = 0;
        }
        t += String.fromCharCode(b);
        ++c;
      }
      s3 += t;
      return s3;
    };
    util2.hexToBytes = function(hex) {
      var rval = "";
      var i2 = 0;
      if (hex.length & true) {
        i2 = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
      }
      for (; i2 < hex.length; i2 += 2) {
        rval += String.fromCharCode(parseInt(hex.substr(i2, 2), 16));
      }
      return rval;
    };
    util2.bytesToHex = function(bytes2) {
      return util2.createBuffer(bytes2).toHex();
    };
    util2.int32ToBytes = function(i2) {
      return String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255);
    };
    var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var _base64Idx = [
      /*43 -43 = 0*/
      /*'+',  1,  2,  3,'/' */
      62,
      -1,
      -1,
      -1,
      63,
      /*'0','1','2','3','4','5','6','7','8','9' */
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      /*15, 16, 17,'=', 19, 20, 21 */
      -1,
      -1,
      -1,
      64,
      -1,
      -1,
      -1,
      /*65 - 43 = 22*/
      /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      /*91 - 43 = 48 */
      /*48, 49, 50, 51, 52, 53 */
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      /*97 - 43 = 54*/
      /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    util2.encode64 = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i2 = 0;
      while (i2 < input.length) {
        chr1 = input.charCodeAt(i2++);
        chr2 = input.charCodeAt(i2++);
        chr3 = input.charCodeAt(i2++);
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util2.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var output = "";
      var enc1, enc2, enc3, enc4;
      var i2 = 0;
      while (i2 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
        if (enc3 !== 64) {
          output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
          if (enc4 !== 64) {
            output += String.fromCharCode((enc3 & 3) << 6 | enc4);
          }
        }
      }
      return output;
    };
    util2.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util2.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util2.binary = {
      raw: {},
      hex: {},
      base64: {},
      base58: {},
      baseN: {
        encode: baseN.encode,
        decode: baseN.decode
      }
    };
    util2.binary.raw.encode = function(bytes2) {
      return String.fromCharCode.apply(null, bytes2);
    };
    util2.binary.raw.decode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        out[j++] = str.charCodeAt(i2);
      }
      return output ? j - offset : out;
    };
    util2.binary.hex.encode = util2.bytesToHex;
    util2.binary.hex.decode = function(hex, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(hex.length / 2));
      }
      offset = offset || 0;
      var i2 = 0, j = offset;
      if (hex.length & 1) {
        i2 = 1;
        out[j++] = parseInt(hex[0], 16);
      }
      for (; i2 < hex.length; i2 += 2) {
        out[j++] = parseInt(hex.substr(i2, 2), 16);
      }
      return output ? j - offset : out;
    };
    util2.binary.base64.encode = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i2 = 0;
      while (i2 < input.byteLength) {
        chr1 = input[i2++];
        chr2 = input[i2++];
        chr3 = input[i2++];
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util2.binary.base64.decode = function(input, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      offset = offset || 0;
      var enc1, enc2, enc3, enc4;
      var i2 = 0, j = offset;
      while (i2 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
        out[j++] = enc1 << 2 | enc2 >> 4;
        if (enc3 !== 64) {
          out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
          if (enc4 !== 64) {
            out[j++] = (enc3 & 3) << 6 | enc4;
          }
        }
      }
      return output ? j - offset : out.subarray(0, j);
    };
    util2.binary.base58.encode = function(input, maxline) {
      return util2.binary.baseN.encode(input, _base58, maxline);
    };
    util2.binary.base58.decode = function(input, maxline) {
      return util2.binary.baseN.decode(input, _base58, maxline);
    };
    util2.text = {
      utf8: {},
      utf16: {}
    };
    util2.text.utf8.encode = function(str, output, offset) {
      str = util2.encodeUtf8(str);
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        out[j++] = str.charCodeAt(i2);
      }
      return output ? j - offset : out;
    };
    util2.text.utf8.decode = function(bytes2) {
      return util2.decodeUtf8(String.fromCharCode.apply(null, bytes2));
    };
    util2.text.utf16.encode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length * 2);
      }
      var view = new Uint16Array(out.buffer);
      offset = offset || 0;
      var j = offset;
      var k = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        view[k++] = str.charCodeAt(i2);
        j += 2;
      }
      return output ? j - offset : out;
    };
    util2.text.utf16.decode = function(bytes2) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes2.buffer));
    };
    util2.deflate = function(api, bytes2, raw) {
      bytes2 = util2.decode64(api.deflate(util2.encode64(bytes2)).rval);
      if (raw) {
        var start = 2;
        var flg = bytes2.charCodeAt(1);
        if (flg & 32) {
          start = 6;
        }
        bytes2 = bytes2.substring(start, bytes2.length - 4);
      }
      return bytes2;
    };
    util2.inflate = function(api, bytes2, raw) {
      var rval = api.inflate(util2.encode64(bytes2)).rval;
      return rval === null ? null : util2.decode64(rval);
    };
    var _setStorageObject = function(api, id, obj) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval;
      if (obj === null) {
        rval = api.removeItem(id);
      } else {
        obj = util2.encode64(JSON.stringify(obj));
        rval = api.setItem(id, obj);
      }
      if (typeof rval !== "undefined" && rval.rval !== true) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
    };
    var _getStorageObject = function(api, id) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval = api.getItem(id);
      if (api.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util2.decode64(rval));
      }
      return rval;
    };
    var _setItem = function(api, id, key, data) {
      var obj = _getStorageObject(api, id);
      if (obj === null) {
        obj = {};
      }
      obj[key] = data;
      _setStorageObject(api, id, obj);
    };
    var _getItem = function(api, id, key) {
      var rval = _getStorageObject(api, id);
      if (rval !== null) {
        rval = key in rval ? rval[key] : null;
      }
      return rval;
    };
    var _removeItem = function(api, id, key) {
      var obj = _getStorageObject(api, id);
      if (obj !== null && key in obj) {
        delete obj[key];
        var empty2 = true;
        for (var prop in obj) {
          empty2 = false;
          break;
        }
        if (empty2) {
          obj = null;
        }
        _setStorageObject(api, id, obj);
      }
    };
    var _clearItems = function(api, id) {
      _setStorageObject(api, id, null);
    };
    var _callStorageFunction = function(func, args, location2) {
      var rval = null;
      if (typeof location2 === "undefined") {
        location2 = ["web", "flash"];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location2) {
        type = location2[idx];
        try {
          if (type === "flash" || type === "both") {
            if (args[0] === null) {
              throw new Error("Flash local storage not available.");
            }
            rval = func.apply(this, args);
            done = type === "flash";
          }
          if (type === "web" || type === "both") {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    };
    util2.setItem = function(api, id, key, data, location2) {
      _callStorageFunction(_setItem, arguments, location2);
    };
    util2.getItem = function(api, id, key, location2) {
      return _callStorageFunction(_getItem, arguments, location2);
    };
    util2.removeItem = function(api, id, key, location2) {
      _callStorageFunction(_removeItem, arguments, location2);
    };
    util2.clearItems = function(api, id, location2) {
      _callStorageFunction(_clearItems, arguments, location2);
    };
    util2.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util2.format = function(format2) {
      var re2 = /%./g;
      var match;
      var part;
      var argi = 0;
      var parts2 = [];
      var last2 = 0;
      while (match = re2.exec(format2)) {
        part = format2.substring(last2, re2.lastIndex - 2);
        if (part.length > 0) {
          parts2.push(part);
        }
        last2 = re2.lastIndex;
        var code8 = match[0][1];
        switch (code8) {
          case "s":
          case "o":
            if (argi < arguments.length) {
              parts2.push(arguments[argi++ + 1]);
            } else {
              parts2.push("<?>");
            }
            break;
          case "%":
            parts2.push("%");
            break;
          default:
            parts2.push("<%" + code8 + "?>");
        }
      }
      parts2.push(format2.substring(last2));
      return parts2.join("");
    };
    util2.formatNumber = function(number, decimals, dec_point, thousands_sep) {
      var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d = dec_point === void 0 ? "," : dec_point;
      var t = thousands_sep === void 0 ? "." : thousands_sep, s = n < 0 ? "-" : "";
      var i2 = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
      var j = i2.length > 3 ? i2.length % 3 : 0;
      return s + (j ? i2.substr(0, j) + t : "") + i2.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i2).toFixed(c).slice(2) : "");
    };
    util2.formatSize = function(size) {
      if (size >= 1073741824) {
        size = util2.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
      } else if (size >= 1048576) {
        size = util2.formatNumber(size / 1048576, 2, ".", "") + " MiB";
      } else if (size >= 1024) {
        size = util2.formatNumber(size / 1024, 0) + " KiB";
      } else {
        size = util2.formatNumber(size, 0) + " bytes";
      }
      return size;
    };
    util2.bytesFromIP = function(ip) {
      if (ip.indexOf(".") !== -1) {
        return util2.bytesFromIPv4(ip);
      }
      if (ip.indexOf(":") !== -1) {
        return util2.bytesFromIPv6(ip);
      }
      return null;
    };
    util2.bytesFromIPv4 = function(ip) {
      ip = ip.split(".");
      if (ip.length !== 4) {
        return null;
      }
      var b = util2.createBuffer();
      for (var i2 = 0; i2 < ip.length; ++i2) {
        var num = parseInt(ip[i2], 10);
        if (isNaN(num)) {
          return null;
        }
        b.putByte(num);
      }
      return b.getBytes();
    };
    util2.bytesFromIPv6 = function(ip) {
      var blanks = 0;
      ip = ip.split(":").filter(function(e) {
        if (e.length === 0)
          ++blanks;
        return true;
      });
      var zeros = (8 - ip.length + blanks) * 2;
      var b = util2.createBuffer();
      for (var i2 = 0; i2 < 8; ++i2) {
        if (!ip[i2] || ip[i2].length === 0) {
          b.fillWithByte(0, zeros);
          zeros = 0;
          continue;
        }
        var bytes2 = util2.hexToBytes(ip[i2]);
        if (bytes2.length < 2) {
          b.putByte(0);
        }
        b.putBytes(bytes2);
      }
      return b.getBytes();
    };
    util2.bytesToIP = function(bytes2) {
      if (bytes2.length === 4) {
        return util2.bytesToIPv4(bytes2);
      }
      if (bytes2.length === 16) {
        return util2.bytesToIPv6(bytes2);
      }
      return null;
    };
    util2.bytesToIPv4 = function(bytes2) {
      if (bytes2.length !== 4) {
        return null;
      }
      var ip = [];
      for (var i2 = 0; i2 < bytes2.length; ++i2) {
        ip.push(bytes2.charCodeAt(i2));
      }
      return ip.join(".");
    };
    util2.bytesToIPv6 = function(bytes2) {
      if (bytes2.length !== 16) {
        return null;
      }
      var ip = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i2 = 0; i2 < bytes2.length; i2 += 2) {
        var hex = util2.bytesToHex(bytes2[i2] + bytes2[i2 + 1]);
        while (hex[0] === "0" && hex !== "0") {
          hex = hex.substr(1);
        }
        if (hex === "0") {
          var last2 = zeroGroups[zeroGroups.length - 1];
          var idx = ip.length;
          if (!last2 || idx !== last2.end + 1) {
            zeroGroups.push({ start: idx, end: idx });
          } else {
            last2.end = idx;
            if (last2.end - last2.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip.push(hex);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip.splice(group.start, group.end - group.start + 1, "");
          if (group.start === 0) {
            ip.unshift("");
          }
          if (group.end === 7) {
            ip.push("");
          }
        }
      }
      return ip.join(":");
    };
    util2.estimateCores = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      if ("cores" in util2 && !options.update) {
        return callback(null, util2.cores);
      }
      if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
        util2.cores = navigator.hardwareConcurrency;
        return callback(null, util2.cores);
      }
      if (typeof Worker === "undefined") {
        util2.cores = 1;
        return callback(null, util2.cores);
      }
      if (typeof Blob === "undefined") {
        util2.cores = 2;
        return callback(null, util2.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob([
        "(",
        function() {
          self.addEventListener("message", function(e) {
            var st = Date.now();
            var et = st + 4;
            self.postMessage({ st, et });
          });
        }.toString(),
        ")()"
      ], { type: "application/javascript" }));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg2, x) {
            return avg2 + x;
          }, 0) / max.length);
          util2.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util2.cores);
        }
        map4(numWorkers, function(err2, results) {
          max.push(reduce2(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      function map4(numWorkers, callback2) {
        var workers = [];
        var results = [];
        for (var i2 = 0; i2 < numWorkers; ++i2) {
          var worker = new Worker(blobUrl);
          worker.addEventListener("message", function(e) {
            results.push(e.data);
            if (results.length === numWorkers) {
              for (var i3 = 0; i3 < numWorkers; ++i3) {
                workers[i3].terminate();
              }
              callback2(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i2 = 0; i2 < numWorkers; ++i2) {
          workers[i2].postMessage(i2);
        }
      }
      function reduce2(numWorkers, results) {
        var overlaps = [];
        for (var n = 0; n < numWorkers; ++n) {
          var r1 = results[n];
          var overlap = overlaps[n] = [];
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            if (n === i2) {
              continue;
            }
            var r2 = results[i2];
            if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
              overlap.push(i2);
            }
          }
        }
        return overlaps.reduce(function(max, overlap2) {
          return Math.max(max, overlap2.length);
        }, 0);
      }
    };
  }
});
var require_oids = __commonJS({
  "node_modules/node-forge/lib/oids.js"(exports2, module2) {
    var forge9 = require_forge();
    forge9.pki = forge9.pki || {};
    var oids = module2.exports = forge9.pki.oids = forge9.oids = forge9.oids || {};
    function _IN(id, name9) {
      oids[id] = name9;
      oids[name9] = id;
    }
    function _I_(id, name9) {
      oids[id] = name9;
    }
    _IN("1.2.840.113549.1.1.1", "rsaEncryption");
    _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
    _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
    _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
    _IN("1.2.840.113549.1.1.8", "mgf1");
    _IN("1.2.840.113549.1.1.9", "pSpecified");
    _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
    _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
    _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
    _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
    _IN("1.3.101.112", "EdDSA25519");
    _IN("1.2.840.10040.4.3", "dsa-with-sha1");
    _IN("1.3.14.3.2.7", "desCBC");
    _IN("1.3.14.3.2.26", "sha1");
    _IN("1.3.14.3.2.29", "sha1WithRSASignature");
    _IN("2.16.840.1.101.3.4.2.1", "sha256");
    _IN("2.16.840.1.101.3.4.2.2", "sha384");
    _IN("2.16.840.1.101.3.4.2.3", "sha512");
    _IN("2.16.840.1.101.3.4.2.4", "sha224");
    _IN("2.16.840.1.101.3.4.2.5", "sha512-224");
    _IN("2.16.840.1.101.3.4.2.6", "sha512-256");
    _IN("1.2.840.113549.2.2", "md2");
    _IN("1.2.840.113549.2.5", "md5");
    _IN("1.2.840.113549.1.7.1", "data");
    _IN("1.2.840.113549.1.7.2", "signedData");
    _IN("1.2.840.113549.1.7.3", "envelopedData");
    _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
    _IN("1.2.840.113549.1.7.5", "digestedData");
    _IN("1.2.840.113549.1.7.6", "encryptedData");
    _IN("1.2.840.113549.1.9.1", "emailAddress");
    _IN("1.2.840.113549.1.9.2", "unstructuredName");
    _IN("1.2.840.113549.1.9.3", "contentType");
    _IN("1.2.840.113549.1.9.4", "messageDigest");
    _IN("1.2.840.113549.1.9.5", "signingTime");
    _IN("1.2.840.113549.1.9.6", "counterSignature");
    _IN("1.2.840.113549.1.9.7", "challengePassword");
    _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
    _IN("1.2.840.113549.1.9.14", "extensionRequest");
    _IN("1.2.840.113549.1.9.20", "friendlyName");
    _IN("1.2.840.113549.1.9.21", "localKeyId");
    _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
    _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
    _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
    _IN("1.2.840.113549.1.12.10.1.3", "certBag");
    _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
    _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
    _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
    _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
    _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
    _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
    _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
    _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
    _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
    _IN("1.2.840.113549.2.7", "hmacWithSHA1");
    _IN("1.2.840.113549.2.8", "hmacWithSHA224");
    _IN("1.2.840.113549.2.9", "hmacWithSHA256");
    _IN("1.2.840.113549.2.10", "hmacWithSHA384");
    _IN("1.2.840.113549.2.11", "hmacWithSHA512");
    _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
    _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
    _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
    _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
    _IN("2.5.4.3", "commonName");
    _IN("2.5.4.4", "surname");
    _IN("2.5.4.5", "serialNumber");
    _IN("2.5.4.6", "countryName");
    _IN("2.5.4.7", "localityName");
    _IN("2.5.4.8", "stateOrProvinceName");
    _IN("2.5.4.9", "streetAddress");
    _IN("2.5.4.10", "organizationName");
    _IN("2.5.4.11", "organizationalUnitName");
    _IN("2.5.4.12", "title");
    _IN("2.5.4.13", "description");
    _IN("2.5.4.15", "businessCategory");
    _IN("2.5.4.17", "postalCode");
    _IN("2.5.4.42", "givenName");
    _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
    _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
    _IN("2.16.840.1.113730.1.1", "nsCertType");
    _IN("2.16.840.1.113730.1.13", "nsComment");
    _I_("2.5.29.1", "authorityKeyIdentifier");
    _I_("2.5.29.2", "keyAttributes");
    _I_("2.5.29.3", "certificatePolicies");
    _I_("2.5.29.4", "keyUsageRestriction");
    _I_("2.5.29.5", "policyMapping");
    _I_("2.5.29.6", "subtreesConstraint");
    _I_("2.5.29.7", "subjectAltName");
    _I_("2.5.29.8", "issuerAltName");
    _I_("2.5.29.9", "subjectDirectoryAttributes");
    _I_("2.5.29.10", "basicConstraints");
    _I_("2.5.29.11", "nameConstraints");
    _I_("2.5.29.12", "policyConstraints");
    _I_("2.5.29.13", "basicConstraints");
    _IN("2.5.29.14", "subjectKeyIdentifier");
    _IN("2.5.29.15", "keyUsage");
    _I_("2.5.29.16", "privateKeyUsagePeriod");
    _IN("2.5.29.17", "subjectAltName");
    _IN("2.5.29.18", "issuerAltName");
    _IN("2.5.29.19", "basicConstraints");
    _I_("2.5.29.20", "cRLNumber");
    _I_("2.5.29.21", "cRLReason");
    _I_("2.5.29.22", "expirationDate");
    _I_("2.5.29.23", "instructionCode");
    _I_("2.5.29.24", "invalidityDate");
    _I_("2.5.29.25", "cRLDistributionPoints");
    _I_("2.5.29.26", "issuingDistributionPoint");
    _I_("2.5.29.27", "deltaCRLIndicator");
    _I_("2.5.29.28", "issuingDistributionPoint");
    _I_("2.5.29.29", "certificateIssuer");
    _I_("2.5.29.30", "nameConstraints");
    _IN("2.5.29.31", "cRLDistributionPoints");
    _IN("2.5.29.32", "certificatePolicies");
    _I_("2.5.29.33", "policyMappings");
    _I_("2.5.29.34", "policyConstraints");
    _IN("2.5.29.35", "authorityKeyIdentifier");
    _I_("2.5.29.36", "policyConstraints");
    _IN("2.5.29.37", "extKeyUsage");
    _I_("2.5.29.46", "freshestCRL");
    _I_("2.5.29.54", "inhibitAnyPolicy");
    _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
    _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
    _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
    _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
    _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
    _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
    _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
  }
});
var require_asn1 = __commonJS({
  "node_modules/node-forge/lib/asn1.js"(exports2, module2) {
    var forge9 = require_forge();
    require_util();
    require_oids();
    var asn1 = module2.exports = forge9.asn1 = forge9.asn1 || {};
    asn1.Class = {
      UNIVERSAL: 0,
      APPLICATION: 64,
      CONTEXT_SPECIFIC: 128,
      PRIVATE: 192
    };
    asn1.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn1.create = function(tagClass, type, constructed, value2, options) {
      if (forge9.util.isArray(value2)) {
        var tmp = [];
        for (var i2 = 0; i2 < value2.length; ++i2) {
          if (value2[i2] !== void 0) {
            tmp.push(value2[i2]);
          }
        }
        value2 = tmp;
      }
      var obj = {
        tagClass,
        type,
        constructed,
        composed: constructed || forge9.util.isArray(value2),
        value: value2
      };
      if (options && "bitStringContents" in options) {
        obj.bitStringContents = options.bitStringContents;
        obj.original = asn1.copy(obj);
      }
      return obj;
    };
    asn1.copy = function(obj, options) {
      var copy;
      if (forge9.util.isArray(obj)) {
        copy = [];
        for (var i2 = 0; i2 < obj.length; ++i2) {
          copy.push(asn1.copy(obj[i2], options));
        }
        return copy;
      }
      if (typeof obj === "string") {
        return obj;
      }
      copy = {
        tagClass: obj.tagClass,
        type: obj.type,
        constructed: obj.constructed,
        composed: obj.composed,
        value: asn1.copy(obj.value, options)
      };
      if (options && !options.excludeBitStringContents) {
        copy.bitStringContents = obj.bitStringContents;
      }
      return copy;
    };
    asn1.equals = function(obj1, obj2, options) {
      if (forge9.util.isArray(obj1)) {
        if (!forge9.util.isArray(obj2)) {
          return false;
        }
        if (obj1.length !== obj2.length) {
          return false;
        }
        for (var i2 = 0; i2 < obj1.length; ++i2) {
          if (!asn1.equals(obj1[i2], obj2[i2])) {
            return false;
          }
        }
        return true;
      }
      if (typeof obj1 !== typeof obj2) {
        return false;
      }
      if (typeof obj1 === "string") {
        return obj1 === obj2;
      }
      var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
      if (options && options.includeBitStringContents) {
        equal = equal && obj1.bitStringContents === obj2.bitStringContents;
      }
      return equal;
    };
    asn1.getBerValueLength = function(b) {
      var b2 = b.getByte();
      if (b2 === 128) {
        return void 0;
      }
      var length3;
      var longForm = b2 & 128;
      if (!longForm) {
        length3 = b2;
      } else {
        length3 = b.getInt((b2 & 127) << 3);
      }
      return length3;
    };
    function _checkBufferLength(bytes2, remaining, n) {
      if (n > remaining) {
        var error = new Error("Too few bytes to parse DER.");
        error.available = bytes2.length();
        error.remaining = remaining;
        error.requested = n;
        throw error;
      }
    }
    var _getValueLength = function(bytes2, remaining) {
      var b2 = bytes2.getByte();
      remaining--;
      if (b2 === 128) {
        return void 0;
      }
      var length3;
      var longForm = b2 & 128;
      if (!longForm) {
        length3 = b2;
      } else {
        var longFormBytes = b2 & 127;
        _checkBufferLength(bytes2, remaining, longFormBytes);
        length3 = bytes2.getInt(longFormBytes << 3);
      }
      if (length3 < 0) {
        throw new Error("Negative length: " + length3);
      }
      return length3;
    };
    asn1.fromDer = function(bytes2, options) {
      if (options === void 0) {
        options = {
          strict: true,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (typeof options === "boolean") {
        options = {
          strict: options,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (!("strict" in options)) {
        options.strict = true;
      }
      if (!("parseAllBytes" in options)) {
        options.parseAllBytes = true;
      }
      if (!("decodeBitStrings" in options)) {
        options.decodeBitStrings = true;
      }
      if (typeof bytes2 === "string") {
        bytes2 = forge9.util.createBuffer(bytes2);
      }
      var byteCount = bytes2.length();
      var value2 = _fromDer(bytes2, bytes2.length(), 0, options);
      if (options.parseAllBytes && bytes2.length() !== 0) {
        var error = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
        error.byteCount = byteCount;
        error.remaining = bytes2.length();
        throw error;
      }
      return value2;
    };
    function _fromDer(bytes2, remaining, depth, options) {
      var start;
      _checkBufferLength(bytes2, remaining, 2);
      var b1 = bytes2.getByte();
      remaining--;
      var tagClass = b1 & 192;
      var type = b1 & 31;
      start = bytes2.length();
      var length3 = _getValueLength(bytes2, remaining);
      remaining -= start - bytes2.length();
      if (length3 !== void 0 && length3 > remaining) {
        if (options.strict) {
          var error = new Error("Too few bytes to read ASN.1 value.");
          error.available = bytes2.length();
          error.remaining = remaining;
          error.requested = length3;
          throw error;
        }
        length3 = remaining;
      }
      var value2;
      var bitStringContents;
      var constructed = (b1 & 32) === 32;
      if (constructed) {
        value2 = [];
        if (length3 === void 0) {
          for (; ; ) {
            _checkBufferLength(bytes2, remaining, 2);
            if (bytes2.bytes(2) === String.fromCharCode(0, 0)) {
              bytes2.getBytes(2);
              remaining -= 2;
              break;
            }
            start = bytes2.length();
            value2.push(_fromDer(bytes2, remaining, depth + 1, options));
            remaining -= start - bytes2.length();
          }
        } else {
          while (length3 > 0) {
            start = bytes2.length();
            value2.push(_fromDer(bytes2, length3, depth + 1, options));
            remaining -= start - bytes2.length();
            length3 -= start - bytes2.length();
          }
        }
      }
      if (value2 === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {
        bitStringContents = bytes2.bytes(length3);
      }
      if (value2 === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
      // .. other parts of forge expect to decode OCTET STRINGs manually
      type === asn1.Type.BITSTRING && length3 > 1) {
        var savedRead = bytes2.read;
        var savedRemaining = remaining;
        var unused = 0;
        if (type === asn1.Type.BITSTRING) {
          _checkBufferLength(bytes2, remaining, 1);
          unused = bytes2.getByte();
          remaining--;
        }
        if (unused === 0) {
          try {
            start = bytes2.length();
            var subOptions = {
              // enforce strict mode to avoid parsing ASN.1 from plain data
              strict: true,
              decodeBitStrings: true
            };
            var composed = _fromDer(bytes2, remaining, depth + 1, subOptions);
            var used = start - bytes2.length();
            remaining -= used;
            if (type == asn1.Type.BITSTRING) {
              used++;
            }
            var tc = composed.tagClass;
            if (used === length3 && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
              value2 = [composed];
            }
          } catch (ex) {
          }
        }
        if (value2 === void 0) {
          bytes2.read = savedRead;
          remaining = savedRemaining;
        }
      }
      if (value2 === void 0) {
        if (length3 === void 0) {
          if (options.strict) {
            throw new Error("Non-constructed ASN.1 object of indefinite length.");
          }
          length3 = remaining;
        }
        if (type === asn1.Type.BMPSTRING) {
          value2 = "";
          for (; length3 > 0; length3 -= 2) {
            _checkBufferLength(bytes2, remaining, 2);
            value2 += String.fromCharCode(bytes2.getInt16());
            remaining -= 2;
          }
        } else {
          value2 = bytes2.getBytes(length3);
          remaining -= length3;
        }
      }
      var asn1Options = bitStringContents === void 0 ? null : {
        bitStringContents
      };
      return asn1.create(tagClass, type, constructed, value2, asn1Options);
    }
    asn1.toDer = function(obj) {
      var bytes2 = forge9.util.createBuffer();
      var b1 = obj.tagClass | obj.type;
      var value2 = forge9.util.createBuffer();
      var useBitStringContents = false;
      if ("bitStringContents" in obj) {
        useBitStringContents = true;
        if (obj.original) {
          useBitStringContents = asn1.equals(obj, obj.original);
        }
      }
      if (useBitStringContents) {
        value2.putBytes(obj.bitStringContents);
      } else if (obj.composed) {
        if (obj.constructed) {
          b1 |= 32;
        } else {
          value2.putByte(0);
        }
        for (var i2 = 0; i2 < obj.value.length; ++i2) {
          if (obj.value[i2] !== void 0) {
            value2.putBuffer(asn1.toDer(obj.value[i2]));
          }
        }
      } else {
        if (obj.type === asn1.Type.BMPSTRING) {
          for (var i2 = 0; i2 < obj.value.length; ++i2) {
            value2.putInt16(obj.value.charCodeAt(i2));
          }
        } else {
          if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer
          (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
          obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
            value2.putBytes(obj.value.substr(1));
          } else {
            value2.putBytes(obj.value);
          }
        }
      }
      bytes2.putByte(b1);
      if (value2.length() <= 127) {
        bytes2.putByte(value2.length() & 127);
      } else {
        var len = value2.length();
        var lenBytes = "";
        do {
          lenBytes += String.fromCharCode(len & 255);
          len = len >>> 8;
        } while (len > 0);
        bytes2.putByte(lenBytes.length | 128);
        for (var i2 = lenBytes.length - 1; i2 >= 0; --i2) {
          bytes2.putByte(lenBytes.charCodeAt(i2));
        }
      }
      bytes2.putBuffer(value2);
      return bytes2;
    };
    asn1.oidToDer = function(oid) {
      var values = oid.split(".");
      var bytes2 = forge9.util.createBuffer();
      bytes2.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
      var last2, valueBytes, value2, b;
      for (var i2 = 2; i2 < values.length; ++i2) {
        last2 = true;
        valueBytes = [];
        value2 = parseInt(values[i2], 10);
        do {
          b = value2 & 127;
          value2 = value2 >>> 7;
          if (!last2) {
            b |= 128;
          }
          valueBytes.push(b);
          last2 = false;
        } while (value2 > 0);
        for (var n = valueBytes.length - 1; n >= 0; --n) {
          bytes2.putByte(valueBytes[n]);
        }
      }
      return bytes2;
    };
    asn1.derToOid = function(bytes2) {
      var oid;
      if (typeof bytes2 === "string") {
        bytes2 = forge9.util.createBuffer(bytes2);
      }
      var b = bytes2.getByte();
      oid = Math.floor(b / 40) + "." + b % 40;
      var value2 = 0;
      while (bytes2.length() > 0) {
        b = bytes2.getByte();
        value2 = value2 << 7;
        if (b & 128) {
          value2 += b & 127;
        } else {
          oid += "." + (value2 + b);
          value2 = 0;
        }
      }
      return oid;
    };
    asn1.utcTimeToDate = function(utc) {
      var date = new Date();
      var year = parseInt(utc.substr(0, 2), 10);
      year = year >= 50 ? 1900 + year : 2e3 + year;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh = parseInt(utc.substr(6, 2), 10);
      var mm = parseInt(utc.substr(8, 2), 10);
      var ss = 0;
      if (utc.length > 11) {
        var c = utc.charAt(10);
        var end = 10;
        if (c !== "+" && c !== "-") {
          ss = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year, MM, DD);
      date.setUTCHours(hh, mm, ss, 0);
      if (end) {
        c = utc.charAt(end);
        if (c === "+" || c === "-") {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset = hhoffset * 60 + mmoffset;
          offset *= 6e4;
          if (c === "+") {
            date.setTime(+date - offset);
          } else {
            date.setTime(+date + offset);
          }
        }
      }
      return date;
    };
    asn1.generalizedTimeToDate = function(gentime) {
      var date = new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh = parseInt(gentime.substr(8, 2), 10);
      var mm = parseInt(gentime.substr(10, 2), 10);
      var ss = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === "Z") {
        isUTC = true;
      }
      var end = gentime.length - 5, c = gentime.charAt(end);
      if (c === "+" || c === "-") {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset = hhoffset * 60 + mmoffset;
        offset *= 6e4;
        if (c === "+") {
          offset *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === ".") {
        fff = parseFloat(gentime.substr(14), 10) * 1e3;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh, mm, ss, fff);
        date.setTime(+date + offset);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh, mm, ss, fff);
      }
      return date;
    };
    asn1.dateToUtcTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format2 = [];
      format2.push(("" + date.getUTCFullYear()).substr(2));
      format2.push("" + (date.getUTCMonth() + 1));
      format2.push("" + date.getUTCDate());
      format2.push("" + date.getUTCHours());
      format2.push("" + date.getUTCMinutes());
      format2.push("" + date.getUTCSeconds());
      for (var i2 = 0; i2 < format2.length; ++i2) {
        if (format2[i2].length < 2) {
          rval += "0";
        }
        rval += format2[i2];
      }
      rval += "Z";
      return rval;
    };
    asn1.dateToGeneralizedTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format2 = [];
      format2.push("" + date.getUTCFullYear());
      format2.push("" + (date.getUTCMonth() + 1));
      format2.push("" + date.getUTCDate());
      format2.push("" + date.getUTCHours());
      format2.push("" + date.getUTCMinutes());
      format2.push("" + date.getUTCSeconds());
      for (var i2 = 0; i2 < format2.length; ++i2) {
        if (format2[i2].length < 2) {
          rval += "0";
        }
        rval += format2[i2];
      }
      rval += "Z";
      return rval;
    };
    asn1.integerToDer = function(x) {
      var rval = forge9.util.createBuffer();
      if (x >= -128 && x < 128) {
        return rval.putSignedInt(x, 8);
      }
      if (x >= -32768 && x < 32768) {
        return rval.putSignedInt(x, 16);
      }
      if (x >= -8388608 && x < 8388608) {
        return rval.putSignedInt(x, 24);
      }
      if (x >= -2147483648 && x < 2147483648) {
        return rval.putSignedInt(x, 32);
      }
      var error = new Error("Integer too large; max is 32-bits.");
      error.integer = x;
      throw error;
    };
    asn1.derToInteger = function(bytes2) {
      if (typeof bytes2 === "string") {
        bytes2 = forge9.util.createBuffer(bytes2);
      }
      var n = bytes2.length() * 8;
      if (n > 32) {
        throw new Error("Integer too large; max is 32-bits.");
      }
      return bytes2.getSignedInt(n);
    };
    asn1.validate = function(obj, v, capture, errors2) {
      var rval = false;
      if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
        if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
          rval = true;
          if (v.value && forge9.util.isArray(v.value)) {
            var j = 0;
            for (var i2 = 0; rval && i2 < v.value.length; ++i2) {
              rval = v.value[i2].optional || false;
              if (obj.value[j]) {
                rval = asn1.validate(obj.value[j], v.value[i2], capture, errors2);
                if (rval) {
                  ++j;
                } else if (v.value[i2].optional) {
                  rval = true;
                }
              }
              if (!rval && errors2) {
                errors2.push(
                  "[" + v.name + '] Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"'
                );
              }
            }
          }
          if (rval && capture) {
            if (v.capture) {
              capture[v.capture] = obj.value;
            }
            if (v.captureAsn1) {
              capture[v.captureAsn1] = obj;
            }
            if (v.captureBitStringContents && "bitStringContents" in obj) {
              capture[v.captureBitStringContents] = obj.bitStringContents;
            }
            if (v.captureBitStringValue && "bitStringContents" in obj) {
              if (obj.bitStringContents.length < 2) {
                capture[v.captureBitStringValue] = "";
              } else {
                var unused = obj.bitStringContents.charCodeAt(0);
                if (unused !== 0) {
                  throw new Error(
                    "captureBitStringValue only supported for zero unused bits"
                  );
                }
                capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
              }
            }
          }
        } else if (errors2) {
          errors2.push(
            "[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"'
          );
        }
      } else if (errors2) {
        if (obj.tagClass !== v.tagClass) {
          errors2.push(
            "[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"'
          );
        }
        if (obj.type !== v.type) {
          errors2.push(
            "[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"'
          );
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn1.prettyPrint = function(obj, level, indentation) {
      var rval = "";
      level = level || 0;
      indentation = indentation || 2;
      if (level > 0) {
        rval += "\n";
      }
      var indent = "";
      for (var i2 = 0; i2 < level * indentation; ++i2) {
        indent += " ";
      }
      rval += indent + "Tag: ";
      switch (obj.tagClass) {
        case asn1.Class.UNIVERSAL:
          rval += "Universal:";
          break;
        case asn1.Class.APPLICATION:
          rval += "Application:";
          break;
        case asn1.Class.CONTEXT_SPECIFIC:
          rval += "Context-Specific:";
          break;
        case asn1.Class.PRIVATE:
          rval += "Private:";
          break;
      }
      if (obj.tagClass === asn1.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn1.Type.NONE:
            rval += " (None)";
            break;
          case asn1.Type.BOOLEAN:
            rval += " (Boolean)";
            break;
          case asn1.Type.INTEGER:
            rval += " (Integer)";
            break;
          case asn1.Type.BITSTRING:
            rval += " (Bit string)";
            break;
          case asn1.Type.OCTETSTRING:
            rval += " (Octet string)";
            break;
          case asn1.Type.NULL:
            rval += " (Null)";
            break;
          case asn1.Type.OID:
            rval += " (Object Identifier)";
            break;
          case asn1.Type.ODESC:
            rval += " (Object Descriptor)";
            break;
          case asn1.Type.EXTERNAL:
            rval += " (External or Instance of)";
            break;
          case asn1.Type.REAL:
            rval += " (Real)";
            break;
          case asn1.Type.ENUMERATED:
            rval += " (Enumerated)";
            break;
          case asn1.Type.EMBEDDED:
            rval += " (Embedded PDV)";
            break;
          case asn1.Type.UTF8:
            rval += " (UTF8)";
            break;
          case asn1.Type.ROID:
            rval += " (Relative Object Identifier)";
            break;
          case asn1.Type.SEQUENCE:
            rval += " (Sequence)";
            break;
          case asn1.Type.SET:
            rval += " (Set)";
            break;
          case asn1.Type.PRINTABLESTRING:
            rval += " (Printable String)";
            break;
          case asn1.Type.IA5String:
            rval += " (IA5String (ASCII))";
            break;
          case asn1.Type.UTCTIME:
            rval += " (UTC time)";
            break;
          case asn1.Type.GENERALIZEDTIME:
            rval += " (Generalized time)";
            break;
          case asn1.Type.BMPSTRING:
            rval += " (BMP String)";
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += "\n";
      rval += indent + "Constructed: " + obj.constructed + "\n";
      if (obj.composed) {
        var subvalues = 0;
        var sub = "";
        for (var i2 = 0; i2 < obj.value.length; ++i2) {
          if (obj.value[i2] !== void 0) {
            subvalues += 1;
            sub += asn1.prettyPrint(obj.value[i2], level + 1, indentation);
            if (i2 + 1 < obj.value.length) {
              sub += ",";
            }
          }
        }
        rval += indent + "Sub values: " + subvalues + sub;
      } else {
        rval += indent + "Value: ";
        if (obj.type === asn1.Type.OID) {
          var oid = asn1.derToOid(obj.value);
          rval += oid;
          if (forge9.pki && forge9.pki.oids) {
            if (oid in forge9.pki.oids) {
              rval += " (" + forge9.pki.oids[oid] + ") ";
            }
          }
        }
        if (obj.type === asn1.Type.INTEGER) {
          try {
            rval += asn1.derToInteger(obj.value);
          } catch (ex) {
            rval += "0x" + forge9.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn1.Type.BITSTRING) {
          if (obj.value.length > 1) {
            rval += "0x" + forge9.util.bytesToHex(obj.value.slice(1));
          } else {
            rval += "(none)";
          }
          if (obj.value.length > 0) {
            var unused = obj.value.charCodeAt(0);
            if (unused == 1) {
              rval += " (1 unused bit shown)";
            } else if (unused > 1) {
              rval += " (" + unused + " unused bits shown)";
            }
          }
        } else if (obj.type === asn1.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += "(" + obj.value + ") ";
          }
          rval += "0x" + forge9.util.bytesToHex(obj.value);
        } else if (obj.type === asn1.Type.UTF8) {
          try {
            rval += forge9.util.decodeUtf8(obj.value);
          } catch (e) {
            if (e.message === "URI malformed") {
              rval += "0x" + forge9.util.bytesToHex(obj.value) + " (malformed UTF8)";
            } else {
              throw e;
            }
          }
        } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += "0x" + forge9.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += "[null]";
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
  }
});
var require_cipher = __commonJS({
  "node_modules/node-forge/lib/cipher.js"(exports2, module2) {
    var forge9 = require_forge();
    require_util();
    module2.exports = forge9.cipher = forge9.cipher || {};
    forge9.cipher.algorithms = forge9.cipher.algorithms || {};
    forge9.cipher.createCipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge9.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge9.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: false
      });
    };
    forge9.cipher.createDecipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge9.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge9.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: true
      });
    };
    forge9.cipher.registerAlgorithm = function(name9, algorithm) {
      name9 = name9.toUpperCase();
      forge9.cipher.algorithms[name9] = algorithm;
    };
    forge9.cipher.getAlgorithm = function(name9) {
      name9 = name9.toUpperCase();
      if (name9 in forge9.cipher.algorithms) {
        return forge9.cipher.algorithms[name9];
      }
      return null;
    };
    var BlockCipher = forge9.cipher.BlockCipher = function(options) {
      this.algorithm = options.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options.decrypt;
      this.algorithm.initialize(options);
    };
    BlockCipher.prototype.start = function(options) {
      options = options || {};
      var opts = {};
      for (var key in options) {
        opts[key] = options[key];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge9.util.createBuffer();
      this.output = options.output || forge9.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
      }
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad) {
      if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
        this.mode.pad = function(input) {
          return pad(this.blockSize, input, false);
        };
        this.mode.unpad = function(output) {
          return pad(this.blockSize, output, true);
        };
      }
      var options = {};
      options.decrypt = this._decrypt;
      options.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options)) {
          return false;
        }
      }
      return true;
    };
  }
});
var require_cipherModes = __commonJS({
  "node_modules/node-forge/lib/cipherModes.js"(exports2, module2) {
    var forge9 = require_forge();
    require_util();
    forge9.cipher = forge9.cipher || {};
    var modes = module2.exports = forge9.cipher.modes = forge9.cipher.modes || {};
    modes.ecb = function(options) {
      options = options || {};
      this.name = "ECB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options) {
    };
    modes.ecb.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
    };
    modes.ecb.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.ecb.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cbc = function(options) {
      options = options || {};
      this.name = "CBC";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options) {
      if (options.iv === null) {
        if (!this._prev) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = this._prev.slice(0);
      } else if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      } else {
        this._iv = transformIV(options.iv, this.blockSize);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = this._prev[i2] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._prev[i2] ^ this._outBlock[i2]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.cbc.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cfb = function(options) {
      options = options || {};
      this.name = "CFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge9.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = input.getInt32() ^ this._outBlock[i2];
          output.putInt32(this._inBlock[i2]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialBlock[i2] = input.getInt32() ^ this._outBlock[i2];
        this._partialOutput.putInt32(this._partialBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._partialBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = input.getInt32();
          output.putInt32(this._inBlock[i2] ^ this._outBlock[i2]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialBlock[i2] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i2] ^ this._outBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._partialBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb = function(options) {
      options = options || {};
      this.name = "OFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge9.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(input.getInt32() ^ this._outBlock[i2]);
          this._inBlock[i2] = this._outBlock[i2];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._outBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options) {
      options = options || {};
      this.name = "CTR";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge9.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options) {
      options = options || {};
      this.name = "GCM";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge9.util.createBuffer();
      this._partialBytes = 0;
      this._R = 3774873600;
    };
    modes.gcm.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      var iv = forge9.util.createBuffer(options.iv);
      this._cipherLength = 0;
      var additionalData;
      if ("additionalData" in options) {
        additionalData = forge9.util.createBuffer(options.additionalData);
      } else {
        additionalData = forge9.util.createBuffer();
      }
      if ("tagLength" in options) {
        this._tagLength = options.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options.decrypt) {
        this._tag = forge9.util.createBuffer(options.tag).getBytes();
        if (this._tag.length !== this._tagLength / 8) {
          throw new Error("Authentication tag does not match tag length.");
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv.length();
      if (ivLength === 12) {
        this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv.length() > 0) {
          this._j0 = this.ghash(
            this._hashSubkey,
            this._j0,
            [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]
          );
        }
        this._j0 = this.ghash(
          this._hashSubkey,
          this._j0,
          [0, 0].concat(from64To32(ivLength * 8))
        );
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge9.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32()
        ]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(this._outBlock[i2] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
        if (partialBytes <= 0 || finish) {
          if (finish) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i2 = 0; i2 < this._ints; ++i2) {
            this._outBlock[i2] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          input.read -= this.blockSize;
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2] ^ this._hashBlock[i2]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output, options) {
      var rval = true;
      if (options.decrypt && options.overflow) {
        output.truncate(this.blockSize - options.overflow);
      }
      this.tag = forge9.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag = [];
      this.cipher.encrypt(this._j0, tag);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this.tag.putInt32(this._s[i2] ^ tag[i2]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x, y) {
      var z_i = [0, 0, 0, 0];
      var v_i = y.slice(0);
      for (var i2 = 0; i2 < 128; ++i2) {
        var x_i = x[i2 / 32 | 0] & 1 << 31 - i2 % 32;
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x, out) {
      var lsb = x[3] & 1;
      for (var i2 = 3; i2 > 0; --i2) {
        out[i2] = x[i2] >>> 1 | (x[i2 - 1] & 1) << 31;
      }
      out[0] = x[0] >>> 1;
      if (lsb) {
        out[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x) {
      var z = [0, 0, 0, 0];
      for (var i2 = 0; i2 < 32; ++i2) {
        var idx = i2 / 8 | 0;
        var x_i = x[idx] >>> (7 - i2 % 8) * 4 & 15;
        var ah = this._m[i2][x_i];
        z[0] ^= ah[0];
        z[1] ^= ah[1];
        z[2] ^= ah[2];
        z[3] ^= ah[3];
      }
      return z;
    };
    modes.gcm.prototype.ghash = function(h, y, x) {
      y[0] ^= x[0];
      y[1] ^= x[1];
      y[2] ^= x[2];
      y[3] ^= x[3];
      return this.tableMultiply(y);
    };
    modes.gcm.prototype.generateHashTable = function(h, bits2) {
      var multiplier = 8 / bits2;
      var perInt = 4 * multiplier;
      var size = 16 * multiplier;
      var m = new Array(size);
      for (var i2 = 0; i2 < size; ++i2) {
        var tmp = [0, 0, 0, 0];
        var idx = i2 / perInt | 0;
        var shft = (perInt - 1 - i2 % perInt) * bits2;
        tmp[idx] = 1 << bits2 - 1 << shft;
        m[i2] = this.generateSubHashTable(this.multiply(tmp, h), bits2);
      }
      return m;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits2) {
      var size = 1 << bits2;
      var half = size >>> 1;
      var m = new Array(size);
      m[half] = mid.slice(0);
      var i2 = half >>> 1;
      while (i2 > 0) {
        this.pow(m[2 * i2], m[i2] = []);
        i2 >>= 1;
      }
      i2 = 2;
      while (i2 < half) {
        for (var j = 1; j < i2; ++j) {
          var m_i = m[i2];
          var m_j = m[j];
          m[i2 + j] = [
            m_i[0] ^ m_j[0],
            m_i[1] ^ m_j[1],
            m_i[2] ^ m_j[2],
            m_i[3] ^ m_j[3]
          ];
        }
        i2 *= 2;
      }
      m[0] = [0, 0, 0, 0];
      for (i2 = half + 1; i2 < size; ++i2) {
        var c = m[i2 ^ half];
        m[i2] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
      }
      return m;
    };
    function transformIV(iv, blockSize) {
      if (typeof iv === "string") {
        iv = forge9.util.createBuffer(iv);
      }
      if (forge9.util.isArray(iv) && iv.length > 4) {
        var tmp = iv;
        iv = forge9.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          iv.putByte(tmp[i2]);
        }
      }
      if (iv.length() < blockSize) {
        throw new Error(
          "Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes."
        );
      }
      if (!forge9.util.isArray(iv)) {
        var ints = [];
        var blocks = blockSize / 4;
        for (var i2 = 0; i2 < blocks; ++i2) {
          ints.push(iv.getInt32());
        }
        iv = ints;
      }
      return iv;
    }
    function inc32(block) {
      block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
    }
    function from64To32(num) {
      return [num / 4294967296 | 0, num & 4294967295];
    }
  }
});
var require_aes = __commonJS({
  "node_modules/node-forge/lib/aes.js"(exports2, module2) {
    var forge9 = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge9.aes = forge9.aes || {};
    forge9.aes.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge9.aes.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge9.aes.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge9.aes.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge9.aes.Algorithm = function(name9, mode) {
      if (!init) {
        initialize();
      }
      var self2 = this;
      self2.name = name9;
      self2.mode = new mode({
        blockSize: 16,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge9.aes.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = options.key;
      var tmp;
      if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
        key = forge9.util.createBuffer(key);
      } else if (forge9.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
        tmp = key;
        key = forge9.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          key.putByte(tmp[i2]);
        }
      }
      if (!forge9.util.isArray(key)) {
        tmp = key;
        key = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i2 = 0; i2 < len; ++i2) {
            key.push(tmp.getInt32());
          }
        }
      }
      if (!forge9.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
        throw new Error("Invalid key parameter.");
      }
      var mode = this.mode.name;
      var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
      this._w = _expandKey(key, options.decrypt && !encryptOp);
      this._init = true;
    };
    forge9.aes._expandKey = function(key, decrypt2) {
      if (!init) {
        initialize();
      }
      return _expandKey(key, decrypt2);
    };
    forge9.aes._updateBlock = _updateBlock;
    registerAlgorithm("AES-ECB", forge9.cipher.modes.ecb);
    registerAlgorithm("AES-CBC", forge9.cipher.modes.cbc);
    registerAlgorithm("AES-CFB", forge9.cipher.modes.cfb);
    registerAlgorithm("AES-OFB", forge9.cipher.modes.ofb);
    registerAlgorithm("AES-CTR", forge9.cipher.modes.ctr);
    registerAlgorithm("AES-GCM", forge9.cipher.modes.gcm);
    function registerAlgorithm(name9, mode) {
      var factory = function() {
        return new forge9.aes.Algorithm(name9, mode);
      };
      forge9.cipher.registerAlgorithm(name9, factory);
    }
    var init = false;
    var Nb = 4;
    var sbox;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize() {
      init = true;
      rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var xtime = new Array(256);
      for (var i2 = 0; i2 < 128; ++i2) {
        xtime[i2] = i2 << 1;
        xtime[i2 + 128] = i2 + 128 << 1 ^ 283;
      }
      sbox = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i2 = 0; i2 < 4; ++i2) {
        mix[i2] = new Array(256);
        imix[i2] = new Array(256);
      }
      var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
      for (var i2 = 0; i2 < 256; ++i2) {
        sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
        sx = sx >> 8 ^ sx & 255 ^ 99;
        sbox[e] = sx;
        isbox[sx] = e;
        sx2 = xtime[sx];
        e2 = xtime[e];
        e4 = xtime[e2];
        e8 = xtime[e4];
        me = sx2 << 24 ^ // 2
        sx << 16 ^ // 1
        sx << 8 ^ // 1
        (sx ^ sx2);
        ime = (e2 ^ e4 ^ e8) << 24 ^ // E (14)
        (e ^ e8) << 16 ^ // 9
        (e ^ e4 ^ e8) << 8 ^ // D (13)
        (e ^ e2 ^ e8);
        for (var n = 0; n < 4; ++n) {
          mix[n][e] = me;
          imix[n][sx] = ime;
          me = me << 24 | me >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e === 0) {
          e = ei = 1;
        } else {
          e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
          ei ^= xtime[xtime[ei]];
        }
      }
    }
    function _expandKey(key, decrypt2) {
      var w = key.slice(0);
      var temp, iNk = 1;
      var Nk = w.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb * Nr1;
      for (var i2 = Nk; i2 < end; ++i2) {
        temp = w[i2 - 1];
        if (i2 % Nk === 0) {
          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
          iNk++;
        } else if (Nk > 6 && i2 % Nk === 4) {
          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
        }
        w[i2] = w[i2 - Nk] ^ temp;
      }
      if (decrypt2) {
        var tmp;
        var m0 = imix[0];
        var m1 = imix[1];
        var m2 = imix[2];
        var m3 = imix[3];
        var wnew = w.slice(0);
        end = w.length;
        for (var i2 = 0, wi = end - Nb; i2 < end; i2 += Nb, wi -= Nb) {
          if (i2 === 0 || i2 === end - Nb) {
            wnew[i2] = w[wi];
            wnew[i2 + 1] = w[wi + 3];
            wnew[i2 + 2] = w[wi + 2];
            wnew[i2 + 3] = w[wi + 1];
          } else {
            for (var n = 0; n < Nb; ++n) {
              tmp = w[wi + n];
              wnew[i2 + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
            }
          }
        }
        w = wnew;
      }
      return w;
    }
    function _updateBlock(w, input, output, decrypt2) {
      var Nr = w.length / 4 - 1;
      var m0, m1, m2, m3, sub;
      if (decrypt2) {
        m0 = imix[0];
        m1 = imix[1];
        m2 = imix[2];
        m3 = imix[3];
        sub = isbox;
      } else {
        m0 = mix[0];
        m1 = mix[1];
        m2 = mix[2];
        m3 = mix[3];
        sub = sbox;
      }
      var a, b, c, d, a2, b2, c2;
      a = input[0] ^ w[0];
      b = input[decrypt2 ? 3 : 1] ^ w[1];
      c = input[2] ^ w[2];
      d = input[decrypt2 ? 1 : 3] ^ w[3];
      var i2 = 3;
      for (var round = 1; round < Nr; ++round) {
        a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i2];
        b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i2];
        c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i2];
        d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i2];
        a = a2;
        b = b2;
        c = c2;
      }
      output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i2];
      output[decrypt2 ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i2];
      output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i2];
      output[decrypt2 ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i2];
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "AES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge9.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge9.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge9.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});
var require_des = __commonJS({
  "node_modules/node-forge/lib/des.js"(exports2, module2) {
    var forge9 = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge9.des = forge9.des || {};
    forge9.des.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge9.des.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge9.des.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge9.des.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge9.des.Algorithm = function(name9, mode) {
      var self2 = this;
      self2.name = name9;
      self2.mode = new mode({
        blockSize: 8,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge9.des.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = forge9.util.createBuffer(options.key);
      if (this.name.indexOf("3DES") === 0) {
        if (key.length() !== 24) {
          throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
        }
      }
      this._keys = _createKeys(key);
      this._init = true;
    };
    registerAlgorithm("DES-ECB", forge9.cipher.modes.ecb);
    registerAlgorithm("DES-CBC", forge9.cipher.modes.cbc);
    registerAlgorithm("DES-CFB", forge9.cipher.modes.cfb);
    registerAlgorithm("DES-OFB", forge9.cipher.modes.ofb);
    registerAlgorithm("DES-CTR", forge9.cipher.modes.ctr);
    registerAlgorithm("3DES-ECB", forge9.cipher.modes.ecb);
    registerAlgorithm("3DES-CBC", forge9.cipher.modes.cbc);
    registerAlgorithm("3DES-CFB", forge9.cipher.modes.cfb);
    registerAlgorithm("3DES-OFB", forge9.cipher.modes.ofb);
    registerAlgorithm("3DES-CTR", forge9.cipher.modes.ctr);
    function registerAlgorithm(name9, mode) {
      var factory = function() {
        return new forge9.des.Algorithm(name9, mode);
      };
      forge9.cipher.registerAlgorithm(name9, factory);
    }
    var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
    var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
    var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
    var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
    var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
    var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
    var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
    var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
    function _createKeys(key) {
      var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
      var iterations = key.length() > 8 ? 3 : 1;
      var keys = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n = 0, tmp;
      for (var j = 0; j < iterations; j++) {
        var left = key.getInt32();
        var right = key.getInt32();
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 2 ^ right) & 858993459;
        right ^= tmp;
        left ^= tmp << 2;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = left << 8 | right >>> 20 & 240;
        left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
        right = tmp;
        for (var i2 = 0; i2 < shifts.length; ++i2) {
          if (shifts[i2]) {
            left = left << 2 | left >>> 26;
            right = right << 2 | right >>> 26;
          } else {
            left = left << 1 | left >>> 27;
            right = right << 1 | right >>> 27;
          }
          left &= -15;
          right &= -15;
          var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
          var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
          tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
          keys[n++] = lefttmp ^ tmp;
          keys[n++] = righttmp ^ tmp << 16;
        }
      }
      return keys;
    }
    function _updateBlock(keys, input, output, decrypt2) {
      var iterations = keys.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt2 ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = decrypt2 ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
      }
      var tmp;
      var left = input[0];
      var right = input[1];
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      left = left << 1 | left >>> 31;
      right = right << 1 | right >>> 31;
      for (var j = 0; j < iterations; j += 3) {
        var endloop = looping[j + 1];
        var loopinc = looping[j + 2];
        for (var i2 = looping[j]; i2 != endloop; i2 += loopinc) {
          var right1 = right ^ keys[i2];
          var right2 = (right >>> 4 | right << 28) ^ keys[i2 + 1];
          tmp = left;
          left = right;
          right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
        }
        tmp = left;
        left = right;
        right = tmp;
      }
      left = left >>> 1 | left << 31;
      right = right >>> 1 | right << 31;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      output[0] = left;
      output[1] = right;
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "DES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge9.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge9.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge9.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});
var require_md = __commonJS({
  "node_modules/node-forge/lib/md.js"(exports2, module2) {
    var forge9 = require_forge();
    module2.exports = forge9.md = forge9.md || {};
    forge9.md.algorithms = forge9.md.algorithms || {};
  }
});
var require_hmac = __commonJS({
  "node_modules/node-forge/lib/hmac.js"(exports2, module2) {
    var forge9 = require_forge();
    require_md();
    require_util();
    var hmac = module2.exports = forge9.hmac = forge9.hmac || {};
    hmac.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md, key) {
        if (md !== null) {
          if (typeof md === "string") {
            md = md.toLowerCase();
            if (md in forge9.md.algorithms) {
              _md = forge9.md.algorithms[md].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md + '"');
            }
          } else {
            _md = md;
          }
        }
        if (key === null) {
          key = _key;
        } else {
          if (typeof key === "string") {
            key = forge9.util.createBuffer(key);
          } else if (forge9.util.isArray(key)) {
            var tmp = key;
            key = forge9.util.createBuffer();
            for (var i2 = 0; i2 < tmp.length; ++i2) {
              key.putByte(tmp[i2]);
            }
          }
          var keylen = key.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key.bytes());
            key = _md.digest();
          }
          _ipadding = forge9.util.createBuffer();
          _opadding = forge9.util.createBuffer();
          keylen = key.length();
          for (var i2 = 0; i2 < keylen; ++i2) {
            var tmp = key.at(i2);
            _ipadding.putByte(54 ^ tmp);
            _opadding.putByte(92 ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i2 = 0; i2 < tmp; ++i2) {
              _ipadding.putByte(54);
              _opadding.putByte(92);
            }
          }
          _key = key;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes2) {
        _md.update(bytes2);
      };
      ctx.getMac = function() {
        var inner = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
  }
});
var require_pbkdf2 = __commonJS({
  "node_modules/node-forge/lib/pbkdf2.js"(exports2, module2) {
    var forge9 = require_forge();
    require_hmac();
    require_md();
    require_util();
    var pkcs5 = forge9.pkcs5 = forge9.pkcs5 || {};
    var crypto4;
    if (forge9.util.isNodejs && !forge9.options.usePureJavaScript) {
      crypto4 = require_crypto();
    }
    module2.exports = forge9.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md, callback) {
      if (typeof md === "function") {
        callback = md;
        md = null;
      }
      if (forge9.util.isNodejs && !forge9.options.usePureJavaScript && crypto4.pbkdf2 && (md === null || typeof md !== "object") && (crypto4.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
        if (typeof md !== "string") {
          md = "sha1";
        }
        p = Buffer.from(p, "binary");
        s = Buffer.from(s, "binary");
        if (!callback) {
          if (crypto4.pbkdf2Sync.length === 4) {
            return crypto4.pbkdf2Sync(p, s, c, dkLen).toString("binary");
          }
          return crypto4.pbkdf2Sync(p, s, c, dkLen, md).toString("binary");
        }
        if (crypto4.pbkdf2Sync.length === 4) {
          return crypto4.pbkdf2(p, s, c, dkLen, function(err3, key) {
            if (err3) {
              return callback(err3);
            }
            callback(null, key.toString("binary"));
          });
        }
        return crypto4.pbkdf2(p, s, c, dkLen, md, function(err3, key) {
          if (err3) {
            return callback(err3);
          }
          callback(null, key.toString("binary"));
        });
      }
      if (typeof md === "undefined" || md === null) {
        md = "sha1";
      }
      if (typeof md === "string") {
        if (!(md in forge9.md.algorithms)) {
          throw new Error("Unknown hash algorithm: " + md);
        }
        md = forge9.md[md].create();
      }
      var hLen = md.digestLength;
      if (dkLen > 4294967295 * hLen) {
        var err2 = new Error("Derived key is too long.");
        if (callback) {
          return callback(err2);
        }
        throw err2;
      }
      var len = Math.ceil(dkLen / hLen);
      var r = dkLen - (len - 1) * hLen;
      var prf = forge9.hmac.create();
      prf.start(md, p);
      var dk = "";
      var xor2, u_c, u_c1;
      if (!callback) {
        for (var i2 = 1; i2 <= len; ++i2) {
          prf.start(null, null);
          prf.update(s);
          prf.update(forge9.util.int32ToBytes(i2));
          xor2 = u_c1 = prf.digest().getBytes();
          for (var j = 2; j <= c; ++j) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor2 = forge9.util.xorBytes(xor2, u_c, hLen);
            u_c1 = u_c;
          }
          dk += i2 < len ? xor2 : xor2.substr(0, r);
        }
        return dk;
      }
      var i2 = 1, j;
      function outer() {
        if (i2 > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s);
        prf.update(forge9.util.int32ToBytes(i2));
        xor2 = u_c1 = prf.digest().getBytes();
        j = 2;
        inner();
      }
      function inner() {
        if (j <= c) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor2 = forge9.util.xorBytes(xor2, u_c, hLen);
          u_c1 = u_c;
          ++j;
          return forge9.util.setImmediate(inner);
        }
        dk += i2 < len ? xor2 : xor2.substr(0, r);
        ++i2;
        outer();
      }
      outer();
    };
  }
});
var require_pem = __commonJS({
  "node_modules/node-forge/lib/pem.js"(exports2, module2) {
    var forge9 = require_forge();
    require_util();
    var pem = module2.exports = forge9.pem = forge9.pem || {};
    pem.encode = function(msg, options) {
      options = options || {};
      var rval = "-----BEGIN " + msg.type + "-----\r\n";
      var header;
      if (msg.procType) {
        header = {
          name: "Proc-Type",
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = { name: "Content-Domain", values: [msg.contentDomain] };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i2 = 0; i2 < msg.headers.length; ++i2) {
          rval += foldHeader(msg.headers[i2]);
        }
      }
      if (msg.procType) {
        rval += "\r\n";
      }
      rval += forge9.util.encode64(msg.body, options.maxline || 64) + "\r\n";
      rval += "-----END " + msg.type + "-----\r\n";
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match;
      while (true) {
        match = rMessage.exec(str);
        if (!match) {
          break;
        }
        var type = match[1];
        if (type === "NEW CERTIFICATE REQUEST") {
          type = "CERTIFICATE REQUEST";
        }
        var msg = {
          type,
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge9.util.decode64(match[3])
        };
        rval.push(msg);
        if (!match[2]) {
          continue;
        }
        var lines = match[2].split(rCRLF);
        var li = 0;
        while (match && li < lines.length) {
          var line = lines[li].replace(/\s+$/, "");
          for (var nl = li + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) {
              break;
            }
            line += next;
            li = nl;
          }
          match = line.match(rHeader);
          if (match) {
            var header = { name: match[1], values: [] };
            var values = match[2].split(",");
            for (var vi = 0; vi < values.length; ++vi) {
              header.values.push(ltrim(values[vi]));
            }
            if (!msg.procType) {
              if (header.name !== "Proc-Type") {
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              }
              msg.procType = { version: values[0], type: values[1] };
            } else if (!msg.contentDomain && header.name === "Content-Domain") {
              msg.contentDomain = values[0] || "";
            } else if (!msg.dekInfo && header.name === "DEK-Info") {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              }
              msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
            } else {
              msg.headers.push(header);
            }
          }
          ++li;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error("Invalid PEM formatted message.");
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ": ";
      var values = [];
      var insertSpace = function(match, $1) {
        return " " + $1;
      };
      for (var i2 = 0; i2 < header.values.length; ++i2) {
        values.push(header.values[i2].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values.join(",") + "\r\n";
      var length3 = 0;
      var candidate = -1;
      for (var i2 = 0; i2 < rval.length; ++i2, ++length3) {
        if (length3 > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ",") {
            ++candidate;
            rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
          }
          length3 = i2 - candidate - 1;
          candidate = -1;
          ++i2;
        } else if (rval[i2] === " " || rval[i2] === "	" || rval[i2] === ",") {
          candidate = i2;
        }
      }
      return rval;
    }
    function ltrim(str) {
      return str.replace(/^\s+/, "");
    }
  }
});
var require_sha256 = __commonJS({
  "node_modules/node-forge/lib/sha256.js"(exports2, module2) {
    var forge9 = require_forge();
    require_md();
    require_util();
    var sha2562 = module2.exports = forge9.sha256 = forge9.sha256 || {};
    forge9.md.sha256 = forge9.md.algorithms.sha256 = sha2562;
    sha2562.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge9.util.createBuffer();
      var _w = new Array(64);
      var md = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md.fullMessageLength.push(0);
        }
        _input = forge9.util.createBuffer();
        _state = {
          h0: 1779033703,
          h1: 3144134277,
          h2: 1013904242,
          h3: 2773480762,
          h4: 1359893119,
          h5: 2600822924,
          h6: 528734635,
          h7: 1541459225
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge9.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
          md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge9.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits2 = md.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
          next = md.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits2 += carry;
          finalBlock.putInt32(bits2 >>> 0);
          bits2 = next >>> 0;
        }
        finalBlock.putInt32(bits2);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update(s2, _w, finalBlock);
        var rval = forge9.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        rval.putInt32(s2.h5);
        rval.putInt32(s2.h6);
        rval.putInt32(s2.h7);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge9.util.fillString(String.fromCharCode(0), 64);
      _k = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      _initialized = true;
    }
    function _update(s, w, bytes2) {
      var t1, t2, s0, s1, ch, maj, i2, a, b, c, d, e, f, g, h;
      var len = bytes2.length();
      while (len >= 64) {
        for (i2 = 0; i2 < 16; ++i2) {
          w[i2] = bytes2.getInt32();
        }
        for (; i2 < 64; ++i2) {
          t1 = w[i2 - 2];
          t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          t2 = w[i2 - 15];
          t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
          w[i2] = t1 + w[i2 - 7] + t2 + w[i2 - 16] | 0;
        }
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        f = s.h5;
        g = s.h6;
        h = s.h7;
        for (i2 = 0; i2 < 64; ++i2) {
          s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
          ch = g ^ e & (f ^ g);
          s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
          maj = a & b | c & (a ^ b);
          t1 = h + s1 + ch + _k[i2] + w[i2];
          t2 = s0 + maj;
          h = g;
          g = f;
          f = e;
          e = d + t1 >>> 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 >>> 0;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        s.h4 = s.h4 + e | 0;
        s.h5 = s.h5 + f | 0;
        s.h6 = s.h6 + g | 0;
        s.h7 = s.h7 + h | 0;
        len -= 64;
      }
    }
  }
});
var require_prng = __commonJS({
  "node_modules/node-forge/lib/prng.js"(exports2, module2) {
    var forge9 = require_forge();
    require_util();
    var _crypto = null;
    if (forge9.util.isNodejs && !forge9.options.usePureJavaScript && !process.versions["node-webkit"]) {
      _crypto = require_crypto();
    }
    var prng = module2.exports = forge9.prng = forge9.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin,
        key: null,
        seed: null,
        time: null,
        // number of reseeds so far
        reseeds: 0,
        // amount of data generated so far
        generated: 0,
        // no initial key bytes
        keyBytes: ""
      };
      var md = plugin.md;
      var pools = new Array(32);
      for (var i2 = 0; i2 < 32; ++i2) {
        pools[i2] = md.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count, callback) {
        if (!callback) {
          return ctx.generateSync(count);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b = forge9.util.createBuffer();
        ctx.key = null;
        generate();
        function generate(err2) {
          if (err2) {
            return callback(err2);
          }
          if (b.length() >= count) {
            return callback(null, b.getBytes(count));
          }
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge9.util.nextTick(function() {
              _reseed(generate);
            });
          }
          var bytes2 = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes2.length;
          b.putBytes(bytes2);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge9.util.setImmediate(generate);
        }
      };
      ctx.generateSync = function(count) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b = forge9.util.createBuffer();
        while (b.length() < count) {
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes2 = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes2.length;
          b.putBytes(bytes2);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b.getBytes(count);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.seedFile(needed, function(err2, bytes2) {
          if (err2) {
            return callback(err2);
          }
          ctx.collect(bytes2);
          _seed();
          callback();
        });
      }
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      function _seed() {
        ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
        var md2 = ctx.plugin.md.create();
        md2.update(ctx.keyBytes);
        var _2powK = 1;
        for (var k = 0; k < 32; ++k) {
          if (ctx.reseeds % _2powK === 0) {
            md2.update(ctx.pools[k].digest().getBytes());
            ctx.pools[k].start();
          }
          _2powK = _2powK << 1;
        }
        ctx.keyBytes = md2.digest().getBytes();
        md2.start();
        md2.update(ctx.keyBytes);
        var seedBytes = md2.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.generated = 0;
      }
      function defaultSeedFile(needed) {
        var getRandomValues = null;
        var globalScope = forge9.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto2.getRandomValues(arr);
          };
        }
        var b = forge9.util.createBuffer();
        if (getRandomValues) {
          while (b.length() < needed) {
            var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count));
            try {
              getRandomValues(entropy);
              for (var i3 = 0; i3 < entropy.length; ++i3) {
                b.putInt32(entropy[i3]);
              }
            } catch (e) {
              if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
                throw e;
              }
            }
          }
        }
        if (b.length() < needed) {
          var hi, lo, next;
          var seed2 = Math.floor(Math.random() * 65536);
          while (b.length() < needed) {
            lo = 16807 * (seed2 & 65535);
            hi = 16807 * (seed2 >> 16);
            lo += (hi & 32767) << 16;
            lo += hi >> 15;
            lo = (lo & 2147483647) + (lo >> 31);
            seed2 = lo & 4294967295;
            for (var i3 = 0; i3 < 3; ++i3) {
              next = seed2 >>> (i3 << 3);
              next ^= Math.floor(Math.random() * 256);
              b.putByte(next & 255);
            }
          }
        }
        return b.getBytes(needed);
      }
      if (_crypto) {
        ctx.seedFile = function(needed, callback) {
          _crypto.randomBytes(needed, function(err2, bytes2) {
            if (err2) {
              return callback(err2);
            }
            callback(null, bytes2.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e) {
            callback(e);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes2) {
        var count = bytes2.length;
        for (var i3 = 0; i3 < count; ++i3) {
          ctx.pools[ctx.pool].update(bytes2.substr(i3, 1));
          ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i3, n) {
        var bytes2 = "";
        for (var x = 0; x < n; x += 8) {
          bytes2 += String.fromCharCode(i3 >> x & 255);
        }
        ctx.collect(bytes2);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener2(e) {
              var data = e.data;
              if (data.forge && data.forge.prng) {
                self.removeEventListener("message", listener2);
                callback(data.forge.prng.err, data.forge.prng.bytes);
              }
            }
            self.addEventListener("message", listener2);
            self.postMessage({ forge: { prng: { needed } } });
          };
        } else {
          var listener = function(e) {
            var data = e.data;
            if (data.forge && data.forge.prng) {
              ctx.seedFile(data.forge.prng.needed, function(err2, bytes2) {
                worker.postMessage({ forge: { prng: { err: err2, bytes: bytes2 } } });
              });
            }
          };
          worker.addEventListener("message", listener);
        }
      };
      return ctx;
    };
  }
});
var require_random = __commonJS({
  "node_modules/node-forge/lib/random.js"(exports2, module2) {
    var forge9 = require_forge();
    require_aes();
    require_sha256();
    require_prng();
    require_util();
    (function() {
      if (forge9.random && forge9.random.getBytes) {
        module2.exports = forge9.random;
        return;
      }
      (function(jQuery2) {
        var prng_aes = {};
        var _prng_aes_output = new Array(4);
        var _prng_aes_buffer = forge9.util.createBuffer();
        prng_aes.formatKey = function(key2) {
          var tmp = forge9.util.createBuffer(key2);
          key2 = new Array(4);
          key2[0] = tmp.getInt32();
          key2[1] = tmp.getInt32();
          key2[2] = tmp.getInt32();
          key2[3] = tmp.getInt32();
          return forge9.aes._expandKey(key2, false);
        };
        prng_aes.formatSeed = function(seed2) {
          var tmp = forge9.util.createBuffer(seed2);
          seed2 = new Array(4);
          seed2[0] = tmp.getInt32();
          seed2[1] = tmp.getInt32();
          seed2[2] = tmp.getInt32();
          seed2[3] = tmp.getInt32();
          return seed2;
        };
        prng_aes.cipher = function(key2, seed2) {
          forge9.aes._updateBlock(key2, seed2, _prng_aes_output, false);
          _prng_aes_buffer.putInt32(_prng_aes_output[0]);
          _prng_aes_buffer.putInt32(_prng_aes_output[1]);
          _prng_aes_buffer.putInt32(_prng_aes_output[2]);
          _prng_aes_buffer.putInt32(_prng_aes_output[3]);
          return _prng_aes_buffer.getBytes();
        };
        prng_aes.increment = function(seed2) {
          ++seed2[3];
          return seed2;
        };
        prng_aes.md = forge9.md.sha256;
        function spawnPrng() {
          var ctx = forge9.prng.create(prng_aes);
          ctx.getBytes = function(count, callback) {
            return ctx.generate(count, callback);
          };
          ctx.getBytesSync = function(count) {
            return ctx.generate(count);
          };
          return ctx;
        }
        var _ctx = spawnPrng();
        var getRandomValues = null;
        var globalScope = forge9.util.globalScope;
        var _crypto = globalScope.crypto || globalScope.msCrypto;
        if (_crypto && _crypto.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto.getRandomValues(arr);
          };
        }
        if (forge9.options.usePureJavaScript || !forge9.util.isNodejs && !getRandomValues) {
          _ctx.collectInt(+new Date(), 32);
          if (typeof navigator !== "undefined") {
            var _navBytes = "";
            for (var key in navigator) {
              try {
                if (typeof navigator[key] == "string") {
                  _navBytes += navigator[key];
                }
              } catch (e) {
              }
            }
            _ctx.collect(_navBytes);
            _navBytes = null;
          }
          if (jQuery2) {
            jQuery2().mousemove(function(e) {
              _ctx.collectInt(e.clientX, 16);
              _ctx.collectInt(e.clientY, 16);
            });
            jQuery2().keypress(function(e) {
              _ctx.collectInt(e.charCode, 8);
            });
          }
        }
        if (!forge9.random) {
          forge9.random = _ctx;
        } else {
          for (var key in _ctx) {
            forge9.random[key] = _ctx[key];
          }
        }
        forge9.random.createInstance = spawnPrng;
        module2.exports = forge9.random;
      })(typeof jQuery !== "undefined" ? jQuery : null);
    })();
  }
});
var require_rc2 = __commonJS({
  "node_modules/node-forge/lib/rc2.js"(exports2, module2) {
    var forge9 = require_forge();
    require_util();
    var piTable = [
      217,
      120,
      249,
      196,
      25,
      221,
      181,
      237,
      40,
      233,
      253,
      121,
      74,
      160,
      216,
      157,
      198,
      126,
      55,
      131,
      43,
      118,
      83,
      142,
      98,
      76,
      100,
      136,
      68,
      139,
      251,
      162,
      23,
      154,
      89,
      245,
      135,
      179,
      79,
      19,
      97,
      69,
      109,
      141,
      9,
      129,
      125,
      50,
      189,
      143,
      64,
      235,
      134,
      183,
      123,
      11,
      240,
      149,
      33,
      34,
      92,
      107,
      78,
      130,
      84,
      214,
      101,
      147,
      206,
      96,
      178,
      28,
      115,
      86,
      192,
      20,
      167,
      140,
      241,
      220,
      18,
      117,
      202,
      31,
      59,
      190,
      228,
      209,
      66,
      61,
      212,
      48,
      163,
      60,
      182,
      38,
      111,
      191,
      14,
      218,
      70,
      105,
      7,
      87,
      39,
      242,
      29,
      155,
      188,
      148,
      67,
      3,
      248,
      17,
      199,
      246,
      144,
      239,
      62,
      231,
      6,
      195,
      213,
      47,
      200,
      102,
      30,
      215,
      8,
      232,
      234,
      222,
      128,
      82,
      238,
      247,
      132,
      170,
      114,
      172,
      53,
      77,
      106,
      42,
      150,
      26,
      210,
      113,
      90,
      21,
      73,
      116,
      75,
      159,
      208,
      94,
      4,
      24,
      164,
      236,
      194,
      224,
      65,
      110,
      15,
      81,
      203,
      204,
      36,
      145,
      175,
      80,
      161,
      244,
      112,
      57,
      153,
      124,
      58,
      133,
      35,
      184,
      180,
      122,
      252,
      2,
      54,
      91,
      37,
      85,
      151,
      49,
      45,
      93,
      250,
      152,
      227,
      138,
      146,
      174,
      5,
      223,
      41,
      16,
      103,
      108,
      186,
      201,
      211,
      0,
      230,
      207,
      225,
      158,
      168,
      44,
      99,
      22,
      1,
      63,
      88,
      226,
      137,
      169,
      13,
      56,
      52,
      27,
      171,
      51,
      255,
      176,
      187,
      72,
      12,
      95,
      185,
      177,
      205,
      46,
      197,
      243,
      219,
      71,
      229,
      165,
      156,
      119,
      10,
      166,
      32,
      104,
      254,
      127,
      193,
      173
    ];
    var s = [1, 2, 3, 5];
    var rol = function(word2, bits2) {
      return word2 << bits2 & 65535 | (word2 & 65535) >> 16 - bits2;
    };
    var ror = function(word2, bits2) {
      return (word2 & 65535) >> bits2 | word2 << 16 - bits2 & 65535;
    };
    module2.exports = forge9.rc2 = forge9.rc2 || {};
    forge9.rc2.expandKey = function(key, effKeyBits) {
      if (typeof key === "string") {
        key = forge9.util.createBuffer(key);
      }
      effKeyBits = effKeyBits || 128;
      var L = key;
      var T = key.length();
      var T1 = effKeyBits;
      var T8 = Math.ceil(T1 / 8);
      var TM = 255 >> (T1 & 7);
      var i2;
      for (i2 = T; i2 < 128; i2++) {
        L.putByte(piTable[L.at(i2 - 1) + L.at(i2 - T) & 255]);
      }
      L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
      for (i2 = 127 - T8; i2 >= 0; i2--) {
        L.setAt(i2, piTable[L.at(i2 + 1) ^ L.at(i2 + T8)]);
      }
      return L;
    };
    var createCipher = function(key, bits2, encrypt2) {
      var _finish = false, _input = null, _output = null, _iv = null;
      var mixRound, mashRound;
      var i2, j, K2 = [];
      key = forge9.rc2.expandKey(key, bits2);
      for (i2 = 0; i2 < 64; i2++) {
        K2.push(key.getInt16Le());
      }
      if (encrypt2) {
        mixRound = function(R) {
          for (i2 = 0; i2 < 4; i2++) {
            R[i2] += K2[j] + (R[(i2 + 3) % 4] & R[(i2 + 2) % 4]) + (~R[(i2 + 3) % 4] & R[(i2 + 1) % 4]);
            R[i2] = rol(R[i2], s[i2]);
            j++;
          }
        };
        mashRound = function(R) {
          for (i2 = 0; i2 < 4; i2++) {
            R[i2] += K2[R[(i2 + 3) % 4] & 63];
          }
        };
      } else {
        mixRound = function(R) {
          for (i2 = 3; i2 >= 0; i2--) {
            R[i2] = ror(R[i2], s[i2]);
            R[i2] -= K2[j] + (R[(i2 + 3) % 4] & R[(i2 + 2) % 4]) + (~R[(i2 + 3) % 4] & R[(i2 + 1) % 4]);
            j--;
          }
        };
        mashRound = function(R) {
          for (i2 = 3; i2 >= 0; i2--) {
            R[i2] -= K2[R[(i2 + 3) % 4] & 63];
          }
        };
      }
      var runPlan = function(plan) {
        var R = [];
        for (i2 = 0; i2 < 4; i2++) {
          var val = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt2) {
              val ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val);
            }
          }
          R.push(val & 65535);
        }
        j = encrypt2 ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
            plan[ptr][1](R);
          }
        }
        for (i2 = 0; i2 < 4; i2++) {
          if (_iv !== null) {
            if (encrypt2) {
              _iv.putInt16Le(R[i2]);
            } else {
              R[i2] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R[i2]);
        }
      };
      var cipher = null;
      cipher = {
        /**
         * Starts or restarts the encryption or decryption process, whichever
         * was previously configured.
         *
         * To use the cipher in CBC mode, iv may be given either as a string
         * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
         *
         * @param iv the initialization vector to use, null for ECB mode.
         * @param output the output the buffer to write to, null to create one.
         */
        start: function(iv, output) {
          if (iv) {
            if (typeof iv === "string") {
              iv = forge9.util.createBuffer(iv);
            }
          }
          _finish = false;
          _input = forge9.util.createBuffer();
          _output = output || new forge9.util.createBuffer();
          _iv = iv;
          cipher.output = _output;
        },
        /**
         * Updates the next block.
         *
         * @param input the buffer to read from.
         */
        update: function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([
              [5, mixRound],
              [1, mashRound],
              [6, mixRound],
              [1, mashRound],
              [5, mixRound]
            ]);
          }
        },
        /**
         * Finishes encrypting or decrypting.
         *
         * @param pad a padding function to use, null for PKCS#7 padding,
         *           signature(blockSize, buffer, decrypt).
         *
         * @return true if successful, false on error.
         */
        finish: function(pad) {
          var rval = true;
          if (encrypt2) {
            if (pad) {
              rval = pad(8, _input, !encrypt2);
            } else {
              var padding = _input.length() === 8 ? 8 : 8 - _input.length();
              _input.fillWithByte(padding, padding);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt2) {
            rval = _input.length() === 0;
            if (rval) {
              if (pad) {
                rval = pad(8, _output, !encrypt2);
              } else {
                var len = _output.length();
                var count = _output.at(len - 1);
                if (count > len) {
                  rval = false;
                } else {
                  _output.truncate(count);
                }
              }
            }
          }
          return rval;
        }
      };
      return cipher;
    };
    forge9.rc2.startEncrypting = function(key, iv, output) {
      var cipher = forge9.rc2.createEncryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge9.rc2.createEncryptionCipher = function(key, bits2) {
      return createCipher(key, bits2, true);
    };
    forge9.rc2.startDecrypting = function(key, iv, output) {
      var cipher = forge9.rc2.createDecryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge9.rc2.createDecryptionCipher = function(key, bits2) {
      return createCipher(key, bits2, false);
    };
  }
});
var require_jsbn = __commonJS({
  "node_modules/node-forge/lib/jsbn.js"(exports2, module2) {
    var forge9 = require_forge();
    module2.exports = forge9.jsbn = forge9.jsbn || {};
    var dbits;
    function BigInteger(a, b, c) {
      this.data = [];
      if (a != null)
        if ("number" == typeof a)
          this.fromNumber(a, b, c);
        else if (b == null && "string" != typeof a)
          this.fromString(a, 256);
        else
          this.fromString(a, b);
    }
    forge9.jsbn.BigInteger = BigInteger;
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i2, x, w, j, c, n) {
      while (--n >= 0) {
        var v = x * this.data[i2++] + w.data[j] + c;
        c = Math.floor(v / 67108864);
        w.data[j++] = v & 67108863;
      }
      return c;
    }
    function am2(i2, x, w, j, c, n) {
      var xl = x & 32767, xh = x >> 15;
      while (--n >= 0) {
        var l = this.data[i2] & 32767;
        var h = this.data[i2++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w.data[j++] = l & 1073741823;
      }
      return c;
    }
    function am3(i2, x, w, j, c, n) {
      var xl = x & 16383, xh = x >> 14;
      while (--n >= 0) {
        var l = this.data[i2] & 16383;
        var h = this.data[i2++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 16383) << 14) + w.data[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w.data[j++] = l & 268435455;
      }
      return c;
    }
    if (typeof navigator === "undefined") {
      BigInteger.prototype.am = am3;
      dbits = 28;
    } else if (navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr;
    var vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv)
      BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s, i2) {
      var c = BI_RC[s.charCodeAt(i2)];
      return c == null ? -1 : c;
    }
    function bnpCopyTo(r) {
      for (var i2 = this.t - 1; i2 >= 0; --i2)
        r.data[i2] = this.data[i2];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0)
        this.data[0] = x;
      else if (x < -1)
        this.data[0] = x + this.DV;
      else
        this.t = 0;
    }
    function nbv(i2) {
      var r = nbi();
      r.fromInt(i2);
      return r;
    }
    function bnpFromString(s, b) {
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 256)
        k = 8;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else {
        this.fromRadix(s, b);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i2 = s.length, mi = false, sh = 0;
      while (--i2 >= 0) {
        var x = k == 8 ? s[i2] & 255 : intAt(s, i2);
        if (x < 0) {
          if (s.charAt(i2) == "-")
            mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this.data[this.t++] = x;
        else if (sh + k > this.DB) {
          this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
          this.data[this.t++] = x >> this.DB - sh;
        } else
          this.data[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB)
          sh -= this.DB;
      }
      if (k == 8 && (s[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0)
          this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c)
        --this.t;
    }
    function bnToString(b) {
      if (this.s < 0)
        return "-" + this.negate().toString(b);
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else
        return this.toRadix(b);
      var km = (1 << k) - 1, d, m = false, r = "", i2 = this.t;
      var p = this.DB - i2 * this.DB % k;
      if (i2-- > 0) {
        if (p < this.DB && (d = this.data[i2] >> p) > 0) {
          m = true;
          r = int2char(d);
        }
        while (i2 >= 0) {
          if (p < k) {
            d = (this.data[i2] & (1 << p) - 1) << k - p;
            d |= this.data[--i2] >> (p += this.DB - k);
          } else {
            d = this.data[i2] >> (p -= k) & km;
            if (p <= 0) {
              p += this.DB;
              --i2;
            }
          }
          if (d > 0)
            m = true;
          if (m)
            r += int2char(d);
        }
      }
      return m ? r : "0";
    }
    function bnNegate() {
      var r = nbi();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r = this.s - a.s;
      if (r != 0)
        return r;
      var i2 = this.t;
      r = i2 - a.t;
      if (r != 0)
        return this.s < 0 ? -r : r;
      while (--i2 >= 0)
        if ((r = this.data[i2] - a.data[i2]) != 0)
          return r;
      return 0;
    }
    function nbits(x) {
      var r = 1, t;
      if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
      }
      if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
      }
      if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
      }
      if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
      }
      if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
      }
      return r;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n, r) {
      var i2;
      for (i2 = this.t - 1; i2 >= 0; --i2)
        r.data[i2 + n] = this.data[i2];
      for (i2 = n - 1; i2 >= 0; --i2)
        r.data[i2] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    function bnpDRShiftTo(n, r) {
      for (var i2 = n; i2 < this.t; ++i2)
        r.data[i2 - n] = this.data[i2];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    function bnpLShiftTo(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i2;
      for (i2 = this.t - 1; i2 >= 0; --i2) {
        r.data[i2 + ds + 1] = this.data[i2] >> cbs | c;
        c = (this.data[i2] & bm) << bs;
      }
      for (i2 = ds - 1; i2 >= 0; --i2)
        r.data[i2] = 0;
      r.data[ds] = c;
      r.t = this.t + ds + 1;
      r.s = this.s;
      r.clamp();
    }
    function bnpRShiftTo(n, r) {
      r.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r.data[0] = this.data[ds] >> bs;
      for (var i2 = ds + 1; i2 < this.t; ++i2) {
        r.data[i2 - ds - 1] |= (this.data[i2] & bm) << cbs;
        r.data[i2 - ds] = this.data[i2] >> bs;
      }
      if (bs > 0)
        r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds;
      r.clamp();
    }
    function bnpSubTo(a, r) {
      var i2 = 0, c = 0, m = Math.min(a.t, this.t);
      while (i2 < m) {
        c += this.data[i2] - a.data[i2];
        r.data[i2++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i2 < this.t) {
          c += this.data[i2];
          r.data[i2++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i2 < a.t) {
          c -= a.data[i2];
          r.data[i2++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c < -1)
        r.data[i2++] = this.DV + c;
      else if (c > 0)
        r.data[i2++] = c;
      r.t = i2;
      r.clamp();
    }
    function bnpMultiplyTo(a, r) {
      var x = this.abs(), y = a.abs();
      var i2 = x.t;
      r.t = i2 + y.t;
      while (--i2 >= 0)
        r.data[i2] = 0;
      for (i2 = 0; i2 < y.t; ++i2)
        r.data[i2 + x.t] = x.am(0, y.data[i2], r, i2, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnpSquareTo(r) {
      var x = this.abs();
      var i2 = r.t = 2 * x.t;
      while (--i2 >= 0)
        r.data[i2] = 0;
      for (i2 = 0; i2 < x.t - 1; ++i2) {
        var c = x.am(i2, x.data[i2], r, 2 * i2, 0, 1);
        if ((r.data[i2 + x.t] += x.am(i2 + 1, 2 * x.data[i2], r, 2 * i2 + 1, c, x.t - i2 - 1)) >= x.DV) {
          r.data[i2 + x.t] -= x.DV;
          r.data[i2 + x.t + 1] = 1;
        }
      }
      if (r.t > 0)
        r.data[r.t - 1] += x.am(i2, x.data[i2], r, 2 * i2, 0, 1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo(m, q, r) {
      var pm = m.abs();
      if (pm.t <= 0)
        return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q != null)
          q.fromInt(0);
        if (r != null)
          this.copyTo(r);
        return;
      }
      if (r == null)
        r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB - nbits(pm.data[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y);
        pt.copyTo(r);
      }
      var ys = y.t;
      var y0 = y.data[ys - 1];
      if (y0 == 0)
        return;
      var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
      var i2 = r.t, j = i2 - ys, t = q == null ? nbi() : q;
      y.dlShiftTo(j, t);
      if (r.compareTo(t) >= 0) {
        r.data[r.t++] = 1;
        r.subTo(t, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t);
      t.subTo(y, y);
      while (y.t < ys)
        y.data[y.t++] = 0;
      while (--j >= 0) {
        var qd = r.data[--i2] == y0 ? this.DM : Math.floor(r.data[i2] * d1 + (r.data[i2 - 1] + e) * d2);
        if ((r.data[i2] += y.am(0, qd, r, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t);
          r.subTo(t, r);
          while (r.data[i2] < --qd)
            r.subTo(t, r);
        }
      }
      if (q != null) {
        r.drShiftTo(ys, q);
        if (ts != ms)
          BigInteger.ZERO.subTo(q, q);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0)
        r.rShiftTo(nsh, r);
      if (ts < 0)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        a.subTo(r, r);
      return r;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0)
        return x.mod(this.m);
      else
        return x;
    }
    function cRevert(x) {
      return x;
    }
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x = this.data[0];
      if ((x & 1) == 0)
        return 0;
      var y = x & 3;
      y = y * (2 - (x & 15) * y) & 15;
      y = y * (2 - (x & 255) * y) & 255;
      y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
      y = y * (2 - x * y % this.DV) % this.DV;
      return y > 0 ? this.DV - y : -y;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m.DB - 15) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        this.m.subTo(r, r);
      return r;
    }
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    function montReduce(x) {
      while (x.t <= this.mt2)
        x.data[x.t++] = 0;
      for (var i2 = 0; i2 < this.m.t; ++i2) {
        var j = x.data[i2] & 32767;
        var u0 = j * this.mpl + ((j * this.mph + (x.data[i2] >> 15) * this.mpl & this.um) << 15) & x.DM;
        j = i2 + this.m.t;
        x.data[j] += this.m.am(0, u0, x, i2, 0, this.m.t);
        while (x.data[j] >= x.DV) {
          x.data[j] -= x.DV;
          x.data[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function montMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
    }
    function bnpExp(e, z) {
      if (e > 4294967295 || e < 1)
        return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z.convert(this), i2 = nbits(e) - 1;
      g.copyTo(r);
      while (--i2 >= 0) {
        z.sqrTo(r, r2);
        if ((e & 1 << i2) > 0)
          z.mulTo(r2, g, r);
        else {
          var t = r;
          r = r2;
          r2 = t;
        }
      }
      return z.revert(r);
    }
    function bnModPowInt(e, m) {
      var z;
      if (e < 256 || m.isEven())
        z = new Classic(m);
      else
        z = new Montgomery(m);
      return this.exp(e, z);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r = nbi();
      this.copyTo(r);
      return r;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this.data[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this.data[0];
      else if (this.t == 0)
        return 0;
      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
    }
    function bnpChunkSize(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b) {
      if (b == null)
        b = 10;
      if (this.signum() == 0 || b < 2 || b > 36)
        return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d = nbv(a), y = nbi(), z = nbi(), r = "";
      this.divRemTo(d, y, z);
      while (y.signum() > 0) {
        r = (a + z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z);
      }
      return z.intValue().toString(b) + r;
    }
    function bnpFromRadix(s, b) {
      this.fromInt(0);
      if (b == null)
        b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
      for (var i2 = 0; i2 < s.length; ++i2) {
        var x = intAt(s, i2);
        if (x < 0) {
          if (s.charAt(i2) == "-" && this.signum() == 0)
            mi = true;
          continue;
        }
        w = b * w + x;
        if (++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w, 0);
          j = 0;
          w = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
      }
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a, b, c) {
      if ("number" == typeof b) {
        if (a < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a)
              this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = new Array(), t = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t > 0)
          x[0] &= (1 << t) - 1;
        else
          x[0] = 0;
        this.fromString(x, 256);
      }
    }
    function bnToByteArray() {
      var i2 = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB - i2 * this.DB % 8, d, k = 0;
      if (i2-- > 0) {
        if (p < this.DB && (d = this.data[i2] >> p) != (this.s & this.DM) >> p)
          r[k++] = d | this.s << this.DB - p;
        while (i2 >= 0) {
          if (p < 8) {
            d = (this.data[i2] & (1 << p) - 1) << 8 - p;
            d |= this.data[--i2] >> (p += this.DB - 8);
          } else {
            d = this.data[i2] >> (p -= 8) & 255;
            if (p <= 0) {
              p += this.DB;
              --i2;
            }
          }
          if ((d & 128) != 0)
            d |= -256;
          if (k == 0 && (this.s & 128) != (d & 128))
            ++k;
          if (k > 0 || d != this.s)
            r[k++] = d;
        }
      }
      return r;
    }
    function bnEquals(a) {
      return this.compareTo(a) == 0;
    }
    function bnMin(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    function bnMax(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    function bnpBitwiseTo(a, op, r) {
      var i2, f, m = Math.min(a.t, this.t);
      for (i2 = 0; i2 < m; ++i2)
        r.data[i2] = op(this.data[i2], a.data[i2]);
      if (a.t < this.t) {
        f = a.s & this.DM;
        for (i2 = m; i2 < this.t; ++i2)
          r.data[i2] = op(this.data[i2], f);
        r.t = this.t;
      } else {
        f = this.s & this.DM;
        for (i2 = m; i2 < a.t; ++i2)
          r.data[i2] = op(f, a.data[i2]);
        r.t = a.t;
      }
      r.s = op(this.s, a.s);
      r.clamp();
    }
    function op_and(x, y) {
      return x & y;
    }
    function bnAnd(a) {
      var r = nbi();
      this.bitwiseTo(a, op_and, r);
      return r;
    }
    function op_or(x, y) {
      return x | y;
    }
    function bnOr(a) {
      var r = nbi();
      this.bitwiseTo(a, op_or, r);
      return r;
    }
    function op_xor(x, y) {
      return x ^ y;
    }
    function bnXor(a) {
      var r = nbi();
      this.bitwiseTo(a, op_xor, r);
      return r;
    }
    function op_andnot(x, y) {
      return x & ~y;
    }
    function bnAndNot(a) {
      var r = nbi();
      this.bitwiseTo(a, op_andnot, r);
      return r;
    }
    function bnNot() {
      var r = nbi();
      for (var i2 = 0; i2 < this.t; ++i2)
        r.data[i2] = this.DM & ~this.data[i2];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    function bnShiftLeft(n) {
      var r = nbi();
      if (n < 0)
        this.rShiftTo(-n, r);
      else
        this.lShiftTo(n, r);
      return r;
    }
    function bnShiftRight(n) {
      var r = nbi();
      if (n < 0)
        this.lShiftTo(-n, r);
      else
        this.rShiftTo(n, r);
      return r;
    }
    function lbit(x) {
      if (x == 0)
        return -1;
      var r = 0;
      if ((x & 65535) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 255) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 15) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0)
        ++r;
      return r;
    }
    function bnGetLowestSetBit() {
      for (var i2 = 0; i2 < this.t; ++i2)
        if (this.data[i2] != 0)
          return i2 * this.DB + lbit(this.data[i2]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    function bnBitCount() {
      var r = 0, x = this.s & this.DM;
      for (var i2 = 0; i2 < this.t; ++i2)
        r += cbit(this.data[i2] ^ x);
      return r;
    }
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t)
        return this.s != 0;
      return (this.data[j] & 1 << n % this.DB) != 0;
    }
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a, r) {
      var i2 = 0, c = 0, m = Math.min(a.t, this.t);
      while (i2 < m) {
        c += this.data[i2] + a.data[i2];
        r.data[i2++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i2 < this.t) {
          c += this.data[i2];
          r.data[i2++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i2 < a.t) {
          c += a.data[i2];
          r.data[i2++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c > 0)
        r.data[i2++] = c;
      else if (c < -1)
        r.data[i2++] = this.DV + c;
      r.t = i2;
      r.clamp();
    }
    function bnAdd(a) {
      var r = nbi();
      this.addTo(a, r);
      return r;
    }
    function bnSubtract(a) {
      var r = nbi();
      this.subTo(a, r);
      return r;
    }
    function bnMultiply(a) {
      var r = nbi();
      this.multiplyTo(a, r);
      return r;
    }
    function bnDivide(a) {
      var r = nbi();
      this.divRemTo(a, r, null);
      return r;
    }
    function bnRemainder(a) {
      var r = nbi();
      this.divRemTo(a, null, r);
      return r;
    }
    function bnDivideAndRemainder(a) {
      var q = nbi(), r = nbi();
      this.divRemTo(a, q, r);
      return new Array(q, r);
    }
    function bnpDMultiply(n) {
      this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w) {
      if (n == 0)
        return;
      while (this.t <= w)
        this.data[this.t++] = 0;
      this.data[w] += n;
      while (this.data[w] >= this.DV) {
        this.data[w] -= this.DV;
        if (++w >= this.t)
          this.data[this.t++] = 0;
        ++this.data[w];
      }
    }
    function NullExp() {
    }
    function nNop(x) {
      return x;
    }
    function nMulTo(x, y, r) {
      x.multiplyTo(y, r);
    }
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp());
    }
    function bnpMultiplyLowerTo(a, n, r) {
      var i2 = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i2;
      while (i2 > 0)
        r.data[--i2] = 0;
      var j;
      for (j = r.t - this.t; i2 < j; ++i2)
        r.data[i2 + this.t] = this.am(0, a.data[i2], r, i2, 0, this.t);
      for (j = Math.min(a.t, n); i2 < j; ++i2)
        this.am(0, a.data[i2], r, i2, 0, n - i2);
      r.clamp();
    }
    function bnpMultiplyUpperTo(a, n, r) {
      --n;
      var i2 = r.t = this.t + a.t - n;
      r.s = 0;
      while (--i2 >= 0)
        r.data[i2] = 0;
      for (i2 = Math.max(n - this.t, 0); i2 < a.t; ++i2)
        r.data[this.t + i2 - n] = this.am(n - i2, a.data[i2], r, 0, 0, this.t + i2 - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    function Barrett(m) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t)
        return x.mod(this.m);
      else if (x.compareTo(this.m) < 0)
        return x;
      else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    function barrettRevert(x) {
      return x;
    }
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0)
        x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function barrettMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i2 = e.bitLength(), k, r = nbv(1), z;
      if (i2 <= 0)
        return r;
      else if (i2 < 18)
        k = 1;
      else if (i2 < 48)
        k = 3;
      else if (i2 < 144)
        k = 4;
      else if (i2 < 768)
        k = 5;
      else
        k = 6;
      if (i2 < 8)
        z = new Classic(m);
      else if (m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);
      var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
      g[1] = z.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
      i2 = nbits(e.data[j]) - 1;
      while (j >= 0) {
        if (i2 >= k1)
          w = e.data[j] >> i2 - k1 & km;
        else {
          w = (e.data[j] & (1 << i2 + 1) - 1) << k1 - i2;
          if (j > 0)
            w |= e.data[j - 1] >> this.DB + i2 - k1;
        }
        n = k;
        while ((w & 1) == 0) {
          w >>= 1;
          --n;
        }
        if ((i2 -= n) < 0) {
          i2 += this.DB;
          --j;
        }
        if (is1) {
          g[w].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z.sqrTo(r, r2);
            z.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0)
            z.sqrTo(r, r2);
          else {
            t = r;
            r = r2;
            r2 = t;
          }
          z.mulTo(r2, g[w], r);
        }
        while (j >= 0 && (e.data[j] & 1 << i2) == 0) {
          z.sqrTo(r, r2);
          t = r;
          r = r2;
          r2 = t;
          if (--i2 < 0) {
            i2 = this.DB - 1;
            --j;
          }
        }
      }
      return z.revert(r);
    }
    function bnGCD(a) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y = a.s < 0 ? a.negate() : a.clone();
      if (x.compareTo(y) < 0) {
        var t = x;
        x = y;
        y = t;
      }
      var i2 = x.getLowestSetBit(), g = y.getLowestSetBit();
      if (g < 0)
        return x;
      if (i2 < g)
        g = i2;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i2 = x.getLowestSetBit()) > 0)
          x.rShiftTo(i2, x);
        if ((i2 = y.getLowestSetBit()) > 0)
          y.rShiftTo(i2, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0)
        y.lShiftTo(g, y);
      return y;
    }
    function bnpModInt(n) {
      if (n <= 0)
        return 0;
      var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d == 0)
          r = this.data[0] % n;
        else
          for (var i2 = this.t - 1; i2 >= 0; --i2)
            r = (d * r + this.data[i2]) % n;
      return r;
    }
    function bnModInverse(m) {
      var ac = m.isEven();
      if (this.isEven() && ac || m.signum() == 0)
        return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven())
            b.subTo(m, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven())
            d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac)
            a.subTo(c, a);
          b.subTo(d, b);
        } else {
          v.subTo(u, v);
          if (ac)
            c.subTo(a, c);
          d.subTo(b, d);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0)
        return BigInteger.ZERO;
      if (d.compareTo(m) >= 0)
        return d.subtract(m);
      if (d.signum() < 0)
        d.addTo(m, d);
      else
        return d;
      if (d.signum() < 0)
        return d.add(m);
      else
        return d;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t) {
      var i2, x = this.abs();
      if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i2 = 0; i2 < lowprimes.length; ++i2)
          if (x.data[0] == lowprimes[i2])
            return true;
        return false;
      }
      if (x.isEven())
        return false;
      i2 = 1;
      while (i2 < lowprimes.length) {
        var m = lowprimes[i2], j = i2 + 1;
        while (j < lowprimes.length && m < lplim)
          m *= lowprimes[j++];
        m = x.modInt(m);
        while (i2 < j)
          if (m % lowprimes[i2++] == 0)
            return false;
      }
      return x.millerRabin(t);
    }
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0)
        return false;
      var r = n1.shiftRight(k);
      var prng = bnGetPrng();
      var a;
      for (var i2 = 0; i2 < t; ++i2) {
        do {
          a = new BigInteger(this.bitLength(), prng);
        } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) == 0)
              return false;
          }
          if (y.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    function bnGetPrng() {
      return {
        // x is an array to fill with bytes
        nextBytes: function(x) {
          for (var i2 = 0; i2 < x.length; ++i2) {
            x[i2] = Math.floor(Math.random() * 256);
          }
        }
      };
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
  }
});
var require_sha1 = __commonJS({
  "node_modules/node-forge/lib/sha1.js"(exports2, module2) {
    var forge9 = require_forge();
    require_md();
    require_util();
    var sha1 = module2.exports = forge9.sha1 = forge9.sha1 || {};
    forge9.md.sha1 = forge9.md.algorithms.sha1 = sha1;
    sha1.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge9.util.createBuffer();
      var _w = new Array(80);
      var md = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md.fullMessageLength.push(0);
        }
        _input = forge9.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878,
          h4: 3285377520
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge9.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
          md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge9.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits2 = md.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
          next = md.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits2 += carry;
          finalBlock.putInt32(bits2 >>> 0);
          bits2 = next >>> 0;
        }
        finalBlock.putInt32(bits2);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update(s2, _w, finalBlock);
        var rval = forge9.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge9.util.fillString(String.fromCharCode(0), 64);
      _initialized = true;
    }
    function _update(s, w, bytes2) {
      var t, a, b, c, d, e, f, i2;
      var len = bytes2.length();
      while (len >= 64) {
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        for (i2 = 0; i2 < 16; ++i2) {
          t = bytes2.getInt32();
          w[i2] = t;
          f = d ^ b & (c ^ d);
          t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i2 < 20; ++i2) {
          t = w[i2 - 3] ^ w[i2 - 8] ^ w[i2 - 14] ^ w[i2 - 16];
          t = t << 1 | t >>> 31;
          w[i2] = t;
          f = d ^ b & (c ^ d);
          t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i2 < 32; ++i2) {
          t = w[i2 - 3] ^ w[i2 - 8] ^ w[i2 - 14] ^ w[i2 - 16];
          t = t << 1 | t >>> 31;
          w[i2] = t;
          f = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i2 < 40; ++i2) {
          t = w[i2 - 6] ^ w[i2 - 16] ^ w[i2 - 28] ^ w[i2 - 32];
          t = t << 2 | t >>> 30;
          w[i2] = t;
          f = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i2 < 60; ++i2) {
          t = w[i2 - 6] ^ w[i2 - 16] ^ w[i2 - 28] ^ w[i2 - 32];
          t = t << 2 | t >>> 30;
          w[i2] = t;
          f = b & c | d & (b ^ c);
          t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i2 < 80; ++i2) {
          t = w[i2 - 6] ^ w[i2 - 16] ^ w[i2 - 28] ^ w[i2 - 32];
          t = t << 2 | t >>> 30;
          w[i2] = t;
          f = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        s.h4 = s.h4 + e | 0;
        len -= 64;
      }
    }
  }
});
var require_pkcs1 = __commonJS({
  "node_modules/node-forge/lib/pkcs1.js"(exports2, module2) {
    var forge9 = require_forge();
    require_util();
    require_random();
    require_sha1();
    var pkcs1 = module2.exports = forge9.pkcs1 = forge9.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key, message2, options) {
      var label;
      var seed2;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        seed2 = arguments[3] || void 0;
        md = arguments[4] || void 0;
      } else if (options) {
        label = options.label || void 0;
        seed2 = options.seed || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      if (!md) {
        md = forge9.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md.digestLength - 2;
      if (message2.length > maxLength) {
        var error = new Error("RSAES-OAEP input message length is too long.");
        error.length = message2.length;
        error.maxLength = maxLength;
        throw error;
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest();
      var PS = "";
      var PS_length = maxLength - message2.length;
      for (var i2 = 0; i2 < PS_length; i2++) {
        PS += "\0";
      }
      var DB = lHash.getBytes() + PS + "" + message2;
      if (!seed2) {
        seed2 = forge9.random.getBytes(md.digestLength);
      } else if (seed2.length !== md.digestLength) {
        var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
        error.seedLength = seed2.length;
        error.digestLength = md.digestLength;
        throw error;
      }
      var dbMask = rsa_mgf1(seed2, keyLength - md.digestLength - 1, mgf1Md);
      var maskedDB = forge9.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var maskedSeed = forge9.util.xorBytes(seed2, seedMask, seed2.length);
      return "\0" + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key, em, options) {
      var label;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        md = arguments[3] || void 0;
      } else if (options) {
        label = options.label || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      if (em.length !== keyLength) {
        var error = new Error("RSAES-OAEP encoded message length is invalid.");
        error.length = em.length;
        error.expectedLength = keyLength;
        throw error;
      }
      if (md === void 0) {
        md = forge9.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      if (keyLength < 2 * md.digestLength + 2) {
        throw new Error("RSAES-OAEP key is too short for the hash function.");
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest().getBytes();
      var y = em.charAt(0);
      var maskedSeed = em.substring(1, md.digestLength + 1);
      var maskedDB = em.substring(1 + md.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var seed2 = forge9.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed2, keyLength - md.digestLength - 1, mgf1Md);
      var db = forge9.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db.substring(0, md.digestLength);
      var error = y !== "\0";
      for (var i2 = 0; i2 < md.digestLength; ++i2) {
        error |= lHash.charAt(i2) !== lHashPrime.charAt(i2);
      }
      var in_ps = 1;
      var index2 = md.digestLength;
      for (var j = md.digestLength; j < db.length; j++) {
        var code8 = db.charCodeAt(j);
        var is_0 = code8 & 1 ^ 1;
        var error_mask = in_ps ? 65534 : 0;
        error |= code8 & error_mask;
        in_ps = in_ps & is_0;
        index2 += in_ps;
      }
      if (error || db.charCodeAt(index2) !== 1) {
        throw new Error("Invalid RSAES-OAEP padding.");
      }
      return db.substring(index2 + 1);
    };
    function rsa_mgf1(seed2, maskLength, hash3) {
      if (!hash3) {
        hash3 = forge9.md.sha1.create();
      }
      var t = "";
      var count = Math.ceil(maskLength / hash3.digestLength);
      for (var i2 = 0; i2 < count; ++i2) {
        var c = String.fromCharCode(
          i2 >> 24 & 255,
          i2 >> 16 & 255,
          i2 >> 8 & 255,
          i2 & 255
        );
        hash3.start();
        hash3.update(seed2 + c);
        t += hash3.digest().getBytes();
      }
      return t.substring(0, maskLength);
    }
  }
});
var require_prime = __commonJS({
  "node_modules/node-forge/lib/prime.js"(exports2, module2) {
    var forge9 = require_forge();
    require_util();
    require_jsbn();
    require_random();
    (function() {
      if (forge9.prime) {
        module2.exports = forge9.prime;
        return;
      }
      var prime = module2.exports = forge9.prime = forge9.prime || {};
      var BigInteger = forge9.jsbn.BigInteger;
      var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var op_or = function(x, y) {
        return x | y;
      };
      prime.generateProbablePrime = function(bits2, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        var algorithm = options.algorithm || "PRIMEINC";
        if (typeof algorithm === "string") {
          algorithm = { name: algorithm };
        }
        algorithm.options = algorithm.options || {};
        var prng = options.prng || forge9.random;
        var rng = {
          // x is an array to fill with bytes
          nextBytes: function(x) {
            var b = prng.getBytesSync(x.length);
            for (var i2 = 0; i2 < x.length; ++i2) {
              x[i2] = b.charCodeAt(i2);
            }
          }
        };
        if (algorithm.name === "PRIMEINC") {
          return primeincFindPrime(bits2, rng, algorithm.options, callback);
        }
        throw new Error("Invalid prime generation algorithm: " + algorithm.name);
      };
      function primeincFindPrime(bits2, rng, options, callback) {
        if ("workers" in options) {
          return primeincFindPrimeWithWorkers(bits2, rng, options, callback);
        }
        return primeincFindPrimeWithoutWorkers(bits2, rng, options, callback);
      }
      function primeincFindPrimeWithoutWorkers(bits2, rng, options, callback) {
        var num = generateRandom(bits2, rng);
        var deltaIdx = 0;
        var mrTests = getMillerRabinTests(num.bitLength());
        if ("millerRabinTests" in options) {
          mrTests = options.millerRabinTests;
        }
        var maxBlockTime = 10;
        if ("maxBlockTime" in options) {
          maxBlockTime = options.maxBlockTime;
        }
        _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback);
      }
      function _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback) {
        var start = +new Date();
        do {
          if (num.bitLength() > bits2) {
            num = generateRandom(bits2, rng);
          }
          if (num.isProbablePrime(mrTests)) {
            return callback(null, num);
          }
          num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        } while (maxBlockTime < 0 || +new Date() - start < maxBlockTime);
        forge9.util.setImmediate(function() {
          _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback);
        });
      }
      function primeincFindPrimeWithWorkers(bits2, rng, options, callback) {
        if (typeof Worker === "undefined") {
          return primeincFindPrimeWithoutWorkers(bits2, rng, options, callback);
        }
        var num = generateRandom(bits2, rng);
        var numWorkers = options.workers;
        var workLoad = options.workLoad || 100;
        var range = workLoad * 30 / 8;
        var workerScript = options.workerScript || "forge/prime.worker.js";
        if (numWorkers === -1) {
          return forge9.util.estimateCores(function(err2, cores) {
            if (err2) {
              cores = 2;
            }
            numWorkers = cores - 1;
            generate();
          });
        }
        generate();
        function generate() {
          numWorkers = Math.max(1, numWorkers);
          var workers = [];
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2] = new Worker(workerScript);
          }
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2].addEventListener("message", workerMessage);
          }
          var found = false;
          function workerMessage(e) {
            if (found) {
              return;
            }
            var data = e.data;
            if (data.found) {
              for (var i3 = 0; i3 < workers.length; ++i3) {
                workers[i3].terminate();
              }
              found = true;
              return callback(null, new BigInteger(data.prime, 16));
            }
            if (num.bitLength() > bits2) {
              num = generateRandom(bits2, rng);
            }
            var hex = num.toString(16);
            e.target.postMessage({
              hex,
              workLoad
            });
            num.dAddOffset(range, 0);
          }
        }
      }
      function generateRandom(bits2, rng) {
        var num = new BigInteger(bits2, rng);
        var bits1 = bits2 - 1;
        if (!num.testBit(bits1)) {
          num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
        }
        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
        return num;
      }
      function getMillerRabinTests(bits2) {
        if (bits2 <= 100)
          return 27;
        if (bits2 <= 150)
          return 18;
        if (bits2 <= 200)
          return 15;
        if (bits2 <= 250)
          return 12;
        if (bits2 <= 300)
          return 9;
        if (bits2 <= 350)
          return 8;
        if (bits2 <= 400)
          return 7;
        if (bits2 <= 500)
          return 6;
        if (bits2 <= 600)
          return 5;
        if (bits2 <= 800)
          return 4;
        if (bits2 <= 1250)
          return 3;
        return 2;
      }
    })();
  }
});
var require_rsa = __commonJS({
  "node_modules/node-forge/lib/rsa.js"(exports2, module2) {
    var forge9 = require_forge();
    require_asn1();
    require_jsbn();
    require_oids();
    require_pkcs1();
    require_prime();
    require_random();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge9.jsbn.BigInteger;
    }
    var BigInteger;
    var _crypto = forge9.util.isNodejs ? require_crypto() : null;
    var asn1 = forge9.asn1;
    var util2 = forge9.util;
    forge9.pki = forge9.pki || {};
    module2.exports = forge9.pki.rsa = forge9.rsa = forge9.rsa || {};
    var pki2 = forge9.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    var rsaPrivateKeyValidator = {
      // RSAPrivateKey
      name: "RSAPrivateKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "RSAPrivateKey.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // modulus (n)
        name: "RSAPrivateKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPublicExponent"
      }, {
        // privateExponent (d)
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrivateExponent"
      }, {
        // prime1 (p)
        name: "RSAPrivateKey.prime1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime1"
      }, {
        // prime2 (q)
        name: "RSAPrivateKey.prime2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime2"
      }, {
        // exponent1 (d mod (p-1))
        name: "RSAPrivateKey.exponent1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent1"
      }, {
        // exponent2 (d mod (q-1))
        name: "RSAPrivateKey.exponent2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent2"
      }, {
        // coefficient ((inverse of q) mod p)
        name: "RSAPrivateKey.coefficient",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyCoefficient"
      }]
    };
    var rsaPublicKeyValidator = {
      // RSAPublicKey
      name: "RSAPublicKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // modulus (n)
        name: "RSAPublicKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPublicKey.exponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyExponent"
      }]
    };
    var publicKeyValidator = forge9.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      }, {
        // subjectPublicKey
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        value: [{
          // RSAPublicKey
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    };
    var digestInfoValidator = {
      name: "DigestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "DigestInfo.DigestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "algorithmIdentifier"
        }, {
          // NULL paramters
          name: "DigestInfo.DigestAlgorithm.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.NULL,
          // captured only to check existence for md2 and md5
          capture: "parameters",
          optional: true,
          constructed: false
        }]
      }, {
        // digest
        name: "DigestInfo.digest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "digest"
      }]
    };
    var emsaPkcs1v15encode = function(md) {
      var oid;
      if (md.algorithm in pki2.oids) {
        oid = pki2.oids[md.algorithm];
      } else {
        var error = new Error("Unknown message digest algorithm.");
        error.algorithm = md.algorithm;
        throw error;
      }
      var oidBytes = asn1.oidToDer(oid).getBytes();
      var digestInfo = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var digestAlgorithm = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        oidBytes
      ));
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.NULL,
        false,
        ""
      ));
      var digest2 = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        md.digest().getBytes()
      );
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest2);
      return asn1.toDer(digestInfo).getBytes();
    };
    var _modPow = function(x, key, pub) {
      if (pub) {
        return x.modPow(key.e, key.n);
      }
      if (!key.p || !key.q) {
        return x.modPow(key.d, key.n);
      }
      if (!key.dP) {
        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
      }
      if (!key.dQ) {
        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
      }
      if (!key.qInv) {
        key.qInv = key.q.modInverse(key.p);
      }
      var r;
      do {
        r = new BigInteger(
          forge9.util.bytesToHex(forge9.random.getBytes(key.n.bitLength() / 8)),
          16
        );
      } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
      x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
      var xp = x.mod(key.p).modPow(key.dP, key.p);
      var xq = x.mod(key.q).modPow(key.dQ, key.q);
      while (xp.compareTo(xq) < 0) {
        xp = xp.add(key.p);
      }
      var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
      y = y.multiply(r.modInverse(key.n)).mod(key.n);
      return y;
    };
    pki2.rsa.encrypt = function(m, key, bt) {
      var pub = bt;
      var eb;
      var k = Math.ceil(key.n.bitLength() / 8);
      if (bt !== false && bt !== true) {
        pub = bt === 2;
        eb = _encodePkcs1_v1_5(m, key, bt);
      } else {
        eb = forge9.util.createBuffer();
        eb.putBytes(m);
      }
      var x = new BigInteger(eb.toHex(), 16);
      var y = _modPow(x, key, pub);
      var yhex = y.toString(16);
      var ed = forge9.util.createBuffer();
      var zeros = k - Math.ceil(yhex.length / 2);
      while (zeros > 0) {
        ed.putByte(0);
        --zeros;
      }
      ed.putBytes(forge9.util.hexToBytes(yhex));
      return ed.getBytes();
    };
    pki2.rsa.decrypt = function(ed, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      if (ed.length !== k) {
        var error = new Error("Encrypted message length is invalid.");
        error.length = ed.length;
        error.expected = k;
        throw error;
      }
      var y = new BigInteger(forge9.util.createBuffer(ed).toHex(), 16);
      if (y.compareTo(key.n) >= 0) {
        throw new Error("Encrypted message is invalid.");
      }
      var x = _modPow(y, key, pub);
      var xhex = x.toString(16);
      var eb = forge9.util.createBuffer();
      var zeros = k - Math.ceil(xhex.length / 2);
      while (zeros > 0) {
        eb.putByte(0);
        --zeros;
      }
      eb.putBytes(forge9.util.hexToBytes(xhex));
      if (ml !== false) {
        return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
      }
      return eb.getBytes();
    };
    pki2.rsa.createKeyPairGenerationState = function(bits2, e, options) {
      if (typeof bits2 === "string") {
        bits2 = parseInt(bits2, 10);
      }
      bits2 = bits2 || 2048;
      options = options || {};
      var prng = options.prng || forge9.random;
      var rng = {
        // x is an array to fill with bytes
        nextBytes: function(x) {
          var b = prng.getBytesSync(x.length);
          for (var i2 = 0; i2 < x.length; ++i2) {
            x[i2] = b.charCodeAt(i2);
          }
        }
      };
      var algorithm = options.algorithm || "PRIMEINC";
      var rval;
      if (algorithm === "PRIMEINC") {
        rval = {
          algorithm,
          state: 0,
          bits: bits2,
          rng,
          eInt: e || 65537,
          e: new BigInteger(null),
          p: null,
          q: null,
          qBits: bits2 >> 1,
          pBits: bits2 - (bits2 >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error("Invalid key generation algorithm: " + algorithm);
      }
      return rval;
    };
    pki2.rsa.stepKeyPairGenerationState = function(state, n) {
      if (!("algorithm" in state)) {
        state.algorithm = "PRIMEINC";
      }
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or = function(x, y) {
        return x | y;
      };
      var t1 = +new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n <= 0 || total < n)) {
        if (state.state === 0) {
          var bits2 = state.p === null ? state.pBits : state.qBits;
          var bits1 = bits2 - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger(bits2, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(
                BigInteger.ONE.shiftLeft(bits1),
                op_or,
                state.num
              );
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits2) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(
              _getMillerRabinTests(state.num.bitLength())
            )) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki2.rsa.setPrivateKey(
              state.n,
              state.e,
              d,
              state.p,
              state.q,
              d.mod(state.p1),
              d.mod(state.q1),
              state.q.modInverse(state.p)
            ),
            publicKey: pki2.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +new Date();
        total += t2 - t1;
        t1 = t2;
      }
      return state.keys !== null;
    };
    pki2.rsa.generateKeyPair = function(bits2, e, options, callback) {
      if (arguments.length === 1) {
        if (typeof bits2 === "object") {
          options = bits2;
          bits2 = void 0;
        } else if (typeof bits2 === "function") {
          callback = bits2;
          bits2 = void 0;
        }
      } else if (arguments.length === 2) {
        if (typeof bits2 === "number") {
          if (typeof e === "function") {
            callback = e;
            e = void 0;
          } else if (typeof e !== "number") {
            options = e;
            e = void 0;
          }
        } else {
          options = bits2;
          callback = e;
          bits2 = void 0;
          e = void 0;
        }
      } else if (arguments.length === 3) {
        if (typeof e === "number") {
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
        } else {
          callback = options;
          options = e;
          e = void 0;
        }
      }
      options = options || {};
      if (bits2 === void 0) {
        bits2 = options.bits || 2048;
      }
      if (e === void 0) {
        e = options.e || 65537;
      }
      if (!forge9.options.usePureJavaScript && !options.prng && bits2 >= 256 && bits2 <= 16384 && (e === 65537 || e === 3)) {
        if (callback) {
          if (_detectNodeCrypto("generateKeyPair")) {
            return _crypto.generateKeyPair("rsa", {
              modulusLength: bits2,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            }, function(err2, pub, priv) {
              if (err2) {
                return callback(err2);
              }
              callback(null, {
                privateKey: pki2.privateKeyFromPem(priv),
                publicKey: pki2.publicKeyFromPem(pub)
              });
            });
          }
          if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
            return util2.globalScope.crypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits2,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]).then(function(pair2) {
              return util2.globalScope.crypto.subtle.exportKey(
                "pkcs8",
                pair2.privateKey
              );
            }).then(void 0, function(err2) {
              callback(err2);
            }).then(function(pkcs8) {
              if (pkcs8) {
                var privateKey = pki2.privateKeyFromAsn1(
                  asn1.fromDer(forge9.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki2.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              }
            });
          }
          if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
            var genOp = util2.globalScope.msCrypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits2,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]);
            genOp.oncomplete = function(e2) {
              var pair2 = e2.target.result;
              var exportOp = util2.globalScope.msCrypto.subtle.exportKey(
                "pkcs8",
                pair2.privateKey
              );
              exportOp.oncomplete = function(e3) {
                var pkcs8 = e3.target.result;
                var privateKey = pki2.privateKeyFromAsn1(
                  asn1.fromDer(forge9.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki2.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              };
              exportOp.onerror = function(err2) {
                callback(err2);
              };
            };
            genOp.onerror = function(err2) {
              callback(err2);
            };
            return;
          }
        } else {
          if (_detectNodeCrypto("generateKeyPairSync")) {
            var keypair = _crypto.generateKeyPairSync("rsa", {
              modulusLength: bits2,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            });
            return {
              privateKey: pki2.privateKeyFromPem(keypair.privateKey),
              publicKey: pki2.publicKeyFromPem(keypair.publicKey)
            };
          }
        }
      }
      var state = pki2.rsa.createKeyPairGenerationState(bits2, e, options);
      if (!callback) {
        pki2.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options, callback);
    };
    pki2.setRsaPublicKey = pki2.rsa.setPublicKey = function(n, e) {
      var key = {
        n,
        e
      };
      key.encrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = {
            encode: function(m, key2, pub) {
              return _encodePkcs1_v1_5(m, key2, 2).getBytes();
            }
          };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            encode: function(m, key2) {
              return forge9.pkcs1.encode_rsa_oaep(key2, m, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { encode: function(e3) {
            return e3;
          } };
        } else if (typeof scheme === "string") {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e2 = scheme.encode(data, key, true);
        return pki2.rsa.encrypt(e2, key, true);
      };
      key.verify = function(digest2, signature, scheme, options) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSASSA-PKCS1-V1_5";
        }
        if (options === void 0) {
          options = {
            _parseAllDigestBytes: true
          };
        }
        if (!("_parseAllDigestBytes" in options)) {
          options._parseAllDigestBytes = true;
        }
        if (scheme === "RSASSA-PKCS1-V1_5") {
          scheme = {
            verify: function(digest3, d2) {
              d2 = _decodePkcs1_v1_5(d2, key, true);
              var obj = asn1.fromDer(d2, {
                parseAllBytes: options._parseAllDigestBytes
              });
              var capture = {};
              var errors2 = [];
              if (!asn1.validate(obj, digestInfoValidator, capture, errors2)) {
                var error = new Error(
                  "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
                );
                error.errors = errors2;
                throw error;
              }
              var oid = asn1.derToOid(capture.algorithmIdentifier);
              if (!(oid === forge9.oids.md2 || oid === forge9.oids.md5 || oid === forge9.oids.sha1 || oid === forge9.oids.sha224 || oid === forge9.oids.sha256 || oid === forge9.oids.sha384 || oid === forge9.oids.sha512 || oid === forge9.oids["sha512-224"] || oid === forge9.oids["sha512-256"])) {
                var error = new Error(
                  "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
                );
                error.oid = oid;
                throw error;
              }
              if (oid === forge9.oids.md2 || oid === forge9.oids.md5) {
                if (!("parameters" in capture)) {
                  throw new Error(
                    "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters."
                  );
                }
              }
              return digest3 === capture.digest;
            }
          };
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = {
            verify: function(digest3, d2) {
              d2 = _decodePkcs1_v1_5(d2, key, true);
              return digest3 === d2;
            }
          };
        }
        var d = pki2.rsa.decrypt(signature, key, true, false);
        return scheme.verify(digest2, d, key.n.bitLength());
      };
      return key;
    };
    pki2.setRsaPrivateKey = pki2.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
      var key = {
        n,
        e,
        d,
        p,
        q,
        dP,
        dQ,
        qInv
      };
      key.decrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        var d2 = pki2.rsa.decrypt(data, key, false, false);
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = { decode: _decodePkcs1_v1_5 };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            decode: function(d32, key2) {
              return forge9.pkcs1.decode_rsa_oaep(key2, d32, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { decode: function(d32) {
            return d32;
          } };
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d2, key, false);
      };
      key.sign = function(md, scheme) {
        var bt = false;
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        }
        if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
          scheme = { encode: emsaPkcs1v15encode };
          bt = 1;
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = { encode: function() {
            return md;
          } };
          bt = 1;
        }
        var d2 = scheme.encode(md, key.n.bitLength());
        return pki2.rsa.encrypt(d2, key, bt);
      };
      return key;
    };
    pki2.wrapRsaPrivateKey = function(rsaKey) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (0)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        // privateKeyAlgorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki2.oids.rsaEncryption).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // PrivateKey
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          asn1.toDer(rsaKey).getBytes()
        )
      ]);
    };
    pki2.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors2 = [];
      if (asn1.validate(obj, privateKeyValidator, capture, errors2)) {
        obj = asn1.fromDer(forge9.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors2 = [];
      if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors2)) {
        var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
        error.errors = errors2;
        throw error;
      }
      var n, e, d, p, q, dP, dQ, qInv;
      n = forge9.util.createBuffer(capture.privateKeyModulus).toHex();
      e = forge9.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d = forge9.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p = forge9.util.createBuffer(capture.privateKeyPrime1).toHex();
      q = forge9.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge9.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge9.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge9.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki2.setRsaPrivateKey(
        new BigInteger(n, 16),
        new BigInteger(e, 16),
        new BigInteger(d, 16),
        new BigInteger(p, 16),
        new BigInteger(q, 16),
        new BigInteger(dP, 16),
        new BigInteger(dQ, 16),
        new BigInteger(qInv, 16)
      );
    };
    pki2.privateKeyToAsn1 = pki2.privateKeyToRSAPrivateKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (0 = only 2 primes, 1 multiple primes)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        // modulus (n)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        ),
        // privateExponent (d)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.d)
        ),
        // privateKeyPrime1 (p)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.p)
        ),
        // privateKeyPrime2 (q)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.q)
        ),
        // privateKeyExponent1 (dP)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dP)
        ),
        // privateKeyExponent2 (dQ)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dQ)
        ),
        // coefficient (qInv)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.qInv)
        )
      ]);
    };
    pki2.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors2 = [];
      if (asn1.validate(obj, publicKeyValidator, capture, errors2)) {
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki2.oids.rsaEncryption) {
          var error = new Error("Cannot read public key. Unknown OID.");
          error.oid = oid;
          throw error;
        }
        obj = capture.rsaPublicKey;
      }
      errors2 = [];
      if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors2)) {
        var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
        error.errors = errors2;
        throw error;
      }
      var n = forge9.util.createBuffer(capture.publicKeyModulus).toHex();
      var e = forge9.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki2.setRsaPublicKey(
        new BigInteger(n, 16),
        new BigInteger(e, 16)
      );
    };
    pki2.publicKeyToAsn1 = pki2.publicKeyToSubjectPublicKeyInfo = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki2.oids.rsaEncryption).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // subjectPublicKey
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
          pki2.publicKeyToRSAPublicKey(key)
        ])
      ]);
    };
    pki2.publicKeyToRSAPublicKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // modulus (n)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        )
      ]);
    };
    function _encodePkcs1_v1_5(m, key, bt) {
      var eb = forge9.util.createBuffer();
      var k = Math.ceil(key.n.bitLength() / 8);
      if (m.length > k - 11) {
        var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
        error.length = m.length;
        error.max = k - 11;
        throw error;
      }
      eb.putByte(0);
      eb.putByte(bt);
      var padNum = k - 3 - m.length;
      var padByte;
      if (bt === 0 || bt === 1) {
        padByte = bt === 0 ? 0 : 255;
        for (var i2 = 0; i2 < padNum; ++i2) {
          eb.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes = forge9.random.getBytes(padNum);
          for (var i2 = 0; i2 < padNum; ++i2) {
            padByte = padBytes.charCodeAt(i2);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb.putByte(0);
      eb.putBytes(m);
      return eb;
    }
    function _decodePkcs1_v1_5(em, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      var eb = forge9.util.createBuffer(em);
      var first2 = eb.getByte();
      var bt = eb.getByte();
      if (first2 !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
        throw new Error("Encryption block is invalid.");
      }
      var padNum = 0;
      if (bt === 0) {
        padNum = k - 3 - ml;
        for (var i2 = 0; i2 < padNum; ++i2) {
          if (eb.getByte() !== 0) {
            throw new Error("Encryption block is invalid.");
          }
        }
      } else if (bt === 1) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() !== 255) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      } else if (bt === 2) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() === 0) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      }
      var zero2 = eb.getByte();
      if (zero2 !== 0 || padNum !== k - 3 - eb.length()) {
        throw new Error("Encryption block is invalid.");
      }
      return eb.getBytes();
    }
    function _generateKeyPair(state, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var opts = {
        algorithm: {
          name: options.algorithm || "PRIMEINC",
          options: {
            workers: options.workers || 2,
            workLoad: options.workLoad || 100,
            workerScript: options.workerScript
          }
        }
      };
      if ("prng" in options) {
        opts.prng = options.prng;
      }
      generate();
      function generate() {
        getPrime(state.pBits, function(err2, num) {
          if (err2) {
            return callback(err2);
          }
          state.p = num;
          if (state.q !== null) {
            return finish(err2, state.q);
          }
          getPrime(state.qBits, finish);
        });
      }
      function getPrime(bits2, callback2) {
        forge9.prime.generateProbablePrime(bits2, opts, callback2);
      }
      function finish(err2, num) {
        if (err2) {
          return callback(err2);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = null;
          generate();
          return;
        }
        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = state.q = null;
          generate();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        var d = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki2.rsa.setPrivateKey(
            state.n,
            state.e,
            d,
            state.p,
            state.q,
            d.mod(state.p1),
            d.mod(state.q1),
            state.q.modInverse(state.p)
          ),
          publicKey: pki2.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
    }
    function _bnToBytes(b) {
      var hex = b.toString(16);
      if (hex[0] >= "8") {
        hex = "00" + hex;
      }
      var bytes2 = forge9.util.hexToBytes(hex);
      if (bytes2.length > 1 && // leading 0x00 for positive integer
      (bytes2.charCodeAt(0) === 0 && (bytes2.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
      bytes2.charCodeAt(0) === 255 && (bytes2.charCodeAt(1) & 128) === 128)) {
        return bytes2.substr(1);
      }
      return bytes2;
    }
    function _getMillerRabinTests(bits2) {
      if (bits2 <= 100)
        return 27;
      if (bits2 <= 150)
        return 18;
      if (bits2 <= 200)
        return 15;
      if (bits2 <= 250)
        return 12;
      if (bits2 <= 300)
        return 9;
      if (bits2 <= 350)
        return 8;
      if (bits2 <= 400)
        return 7;
      if (bits2 <= 500)
        return 6;
      if (bits2 <= 600)
        return 5;
      if (bits2 <= 800)
        return 4;
      if (bits2 <= 1250)
        return 3;
      return 2;
    }
    function _detectNodeCrypto(fn) {
      return forge9.util.isNodejs && typeof _crypto[fn] === "function";
    }
    function _detectSubtleCrypto(fn) {
      return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.crypto === "object" && typeof util2.globalScope.crypto.subtle === "object" && typeof util2.globalScope.crypto.subtle[fn] === "function";
    }
    function _detectSubtleMsCrypto(fn) {
      return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.msCrypto === "object" && typeof util2.globalScope.msCrypto.subtle === "object" && typeof util2.globalScope.msCrypto.subtle[fn] === "function";
    }
    function _intToUint8Array(x) {
      var bytes2 = forge9.util.hexToBytes(x.toString(16));
      var buffer2 = new Uint8Array(bytes2.length);
      for (var i2 = 0; i2 < bytes2.length; ++i2) {
        buffer2[i2] = bytes2.charCodeAt(i2);
      }
      return buffer2;
    }
  }
});
var require_pbe = __commonJS({
  "node_modules/node-forge/lib/pbe.js"(exports2, module2) {
    var forge9 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_oids();
    require_pbkdf2();
    require_pem();
    require_random();
    require_rc2();
    require_rsa();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge9.jsbn.BigInteger;
    }
    var BigInteger;
    var asn1 = forge9.asn1;
    var pki2 = forge9.pki = forge9.pki || {};
    module2.exports = pki2.pbe = forge9.pbe = forge9.pbe || {};
    var oids = pki2.oids;
    var encryptedPrivateKeyValidator = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encryptionOid"
        }, {
          name: "AlgorithmIdentifier.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "encryptionParams"
        }]
      }, {
        // encryptedData
        name: "EncryptedPrivateKeyInfo.encryptedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encryptedData"
      }]
    };
    var PBES2AlgorithmsValidator = {
      name: "PBES2Algorithms",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "kdfOid"
        }, {
          name: "PBES2Algorithms.params",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.params.salt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "kdfSalt"
          }, {
            name: "PBES2Algorithms.params.iterationCount",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "kdfIterationCount"
          }, {
            name: "PBES2Algorithms.params.keyLength",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "keyLength"
          }, {
            // prf
            name: "PBES2Algorithms.params.prf",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "PBES2Algorithms.params.prf.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "prfOid"
            }]
          }]
        }]
      }, {
        name: "PBES2Algorithms.encryptionScheme",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.encryptionScheme.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encOid"
        }, {
          name: "PBES2Algorithms.encryptionScheme.iv",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "encIv"
        }]
      }]
    };
    var pkcs12PbeParamsValidator = {
      name: "pkcs-12PbeParams",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "pkcs-12PbeParams.salt",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "salt"
      }, {
        name: "pkcs-12PbeParams.iterations",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "iterations"
      }]
    };
    pki2.encryptPrivateKeyInfo = function(obj, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || "aes128";
      options.prfAlgorithm = options.prfAlgorithm || "sha1";
      var salt = forge9.random.getBytesSync(options.saltSize);
      var count = options.count;
      var countBytes = asn1.integerToDer(count);
      var dkLen;
      var encryptionAlgorithm;
      var encryptedData;
      if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
        var ivLen, encOid, cipherFn;
        switch (options.algorithm) {
          case "aes128":
            dkLen = 16;
            ivLen = 16;
            encOid = oids["aes128-CBC"];
            cipherFn = forge9.aes.createEncryptionCipher;
            break;
          case "aes192":
            dkLen = 24;
            ivLen = 16;
            encOid = oids["aes192-CBC"];
            cipherFn = forge9.aes.createEncryptionCipher;
            break;
          case "aes256":
            dkLen = 32;
            ivLen = 16;
            encOid = oids["aes256-CBC"];
            cipherFn = forge9.aes.createEncryptionCipher;
            break;
          case "des":
            dkLen = 8;
            ivLen = 8;
            encOid = oids["desCBC"];
            cipherFn = forge9.des.createEncryptionCipher;
            break;
          default:
            var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error.algorithm = options.algorithm;
            throw error;
        }
        var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
        var md = prfAlgorithmToMessageDigest(prfAlgorithm);
        var dk = forge9.pkcs5.pbkdf2(password, salt, count, dkLen, md);
        var iv = forge9.random.getBytesSync(ivLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // keyDerivationFunc
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()
                ),
                // PBKDF2-params
                params
              ]),
              // encryptionScheme
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(encOid).getBytes()
                ),
                // iv
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  iv
                )
              ])
            ])
          ]
        );
      } else if (options.algorithm === "3des") {
        dkLen = 24;
        var saltBytes = new forge9.util.ByteBuffer(salt);
        var dk = pki2.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
        var iv = pki2.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
        var cipher = forge9.des.createEncryptionCipher(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
            ),
            // pkcs-12PbeParams
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // salt
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
              // iteration count
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                countBytes.getBytes()
              )
            ])
          ]
        );
      } else {
        var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error.algorithm = options.algorithm;
        throw error;
      }
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // encryptionAlgorithm
        encryptionAlgorithm,
        // encryptedData
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          encryptedData
        )
      ]);
      return rval;
    };
    pki2.decryptPrivateKeyInfo = function(obj, password) {
      var rval = null;
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors2)) {
        var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors2;
        throw error;
      }
      var oid = asn1.derToOid(capture.encryptionOid);
      var cipher = pki2.pbe.getCipher(oid, capture.encryptionParams, password);
      var encrypted = forge9.util.createBuffer(capture.encryptedData);
      cipher.update(encrypted);
      if (cipher.finish()) {
        rval = asn1.fromDer(cipher.output);
      }
      return rval;
    };
    pki2.encryptedPrivateKeyToPem = function(epki, maxline) {
      var msg = {
        type: "ENCRYPTED PRIVATE KEY",
        body: asn1.toDer(epki).getBytes()
      };
      return forge9.pem.encode(msg, { maxline });
    };
    pki2.encryptedPrivateKeyFromPem = function(pem) {
      var msg = forge9.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY") {
        var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
      }
      return asn1.fromDer(msg.body);
    };
    pki2.encryptRsaPrivateKey = function(rsaKey, password, options) {
      options = options || {};
      if (!options.legacy) {
        var rval = pki2.wrapRsaPrivateKey(pki2.privateKeyToAsn1(rsaKey));
        rval = pki2.encryptPrivateKeyInfo(rval, password, options);
        return pki2.encryptedPrivateKeyToPem(rval);
      }
      var algorithm;
      var iv;
      var dkLen;
      var cipherFn;
      switch (options.algorithm) {
        case "aes128":
          algorithm = "AES-128-CBC";
          dkLen = 16;
          iv = forge9.random.getBytesSync(16);
          cipherFn = forge9.aes.createEncryptionCipher;
          break;
        case "aes192":
          algorithm = "AES-192-CBC";
          dkLen = 24;
          iv = forge9.random.getBytesSync(16);
          cipherFn = forge9.aes.createEncryptionCipher;
          break;
        case "aes256":
          algorithm = "AES-256-CBC";
          dkLen = 32;
          iv = forge9.random.getBytesSync(16);
          cipherFn = forge9.aes.createEncryptionCipher;
          break;
        case "3des":
          algorithm = "DES-EDE3-CBC";
          dkLen = 24;
          iv = forge9.random.getBytesSync(8);
          cipherFn = forge9.des.createEncryptionCipher;
          break;
        case "des":
          algorithm = "DES-CBC";
          dkLen = 8;
          iv = forge9.random.getBytesSync(8);
          cipherFn = forge9.des.createEncryptionCipher;
          break;
        default:
          var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
          error.algorithm = options.algorithm;
          throw error;
      }
      var dk = forge9.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(pki2.privateKeyToAsn1(rsaKey)));
      cipher.finish();
      var msg = {
        type: "RSA PRIVATE KEY",
        procType: {
          version: "4",
          type: "ENCRYPTED"
        },
        dekInfo: {
          algorithm,
          parameters: forge9.util.bytesToHex(iv).toUpperCase()
        },
        body: cipher.output.getBytes()
      };
      return forge9.pem.encode(msg);
    };
    pki2.decryptRsaPrivateKey = function(pem, password) {
      var rval = null;
      var msg = forge9.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        error.headerType = error;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        var dkLen;
        var cipherFn;
        switch (msg.dekInfo.algorithm) {
          case "DES-CBC":
            dkLen = 8;
            cipherFn = forge9.des.createDecryptionCipher;
            break;
          case "DES-EDE3-CBC":
            dkLen = 24;
            cipherFn = forge9.des.createDecryptionCipher;
            break;
          case "AES-128-CBC":
            dkLen = 16;
            cipherFn = forge9.aes.createDecryptionCipher;
            break;
          case "AES-192-CBC":
            dkLen = 24;
            cipherFn = forge9.aes.createDecryptionCipher;
            break;
          case "AES-256-CBC":
            dkLen = 32;
            cipherFn = forge9.aes.createDecryptionCipher;
            break;
          case "RC2-40-CBC":
            dkLen = 5;
            cipherFn = function(key) {
              return forge9.rc2.createDecryptionCipher(key, 40);
            };
            break;
          case "RC2-64-CBC":
            dkLen = 8;
            cipherFn = function(key) {
              return forge9.rc2.createDecryptionCipher(key, 64);
            };
            break;
          case "RC2-128-CBC":
            dkLen = 16;
            cipherFn = function(key) {
              return forge9.rc2.createDecryptionCipher(key, 128);
            };
            break;
          default:
            var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
            error.algorithm = msg.dekInfo.algorithm;
            throw error;
        }
        var iv = forge9.util.hexToBytes(msg.dekInfo.parameters);
        var dk = forge9.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(forge9.util.createBuffer(msg.body));
        if (cipher.finish()) {
          rval = cipher.output.getBytes();
        } else {
          return rval;
        }
      } else {
        rval = msg.body;
      }
      if (msg.type === "ENCRYPTED PRIVATE KEY") {
        rval = pki2.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
      } else {
        rval = asn1.fromDer(rval);
      }
      if (rval !== null) {
        rval = pki2.privateKeyFromAsn1(rval);
      }
      return rval;
    };
    pki2.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
      var j, l;
      if (typeof md === "undefined" || md === null) {
        if (!("sha1" in forge9.md)) {
          throw new Error('"sha1" hash algorithm unavailable.');
        }
        md = forge9.md.sha1.create();
      }
      var u = md.digestLength;
      var v = md.blockLength;
      var result = new forge9.util.ByteBuffer();
      var passBuf = new forge9.util.ByteBuffer();
      if (password !== null && password !== void 0) {
        for (l = 0; l < password.length; l++) {
          passBuf.putInt16(password.charCodeAt(l));
        }
        passBuf.putInt16(0);
      }
      var p = passBuf.length();
      var s = salt.length();
      var D = new forge9.util.ByteBuffer();
      D.fillWithByte(id, v);
      var Slen = v * Math.ceil(s / v);
      var S = new forge9.util.ByteBuffer();
      for (l = 0; l < Slen; l++) {
        S.putByte(salt.at(l % s));
      }
      var Plen = v * Math.ceil(p / v);
      var P = new forge9.util.ByteBuffer();
      for (l = 0; l < Plen; l++) {
        P.putByte(passBuf.at(l % p));
      }
      var I = S;
      I.putBuffer(P);
      var c = Math.ceil(n / u);
      for (var i2 = 1; i2 <= c; i2++) {
        var buf2 = new forge9.util.ByteBuffer();
        buf2.putBytes(D.bytes());
        buf2.putBytes(I.bytes());
        for (var round = 0; round < iter; round++) {
          md.start();
          md.update(buf2.getBytes());
          buf2 = md.digest();
        }
        var B = new forge9.util.ByteBuffer();
        for (l = 0; l < v; l++) {
          B.putByte(buf2.at(l % u));
        }
        var k = Math.ceil(s / v) + Math.ceil(p / v);
        var Inew = new forge9.util.ByteBuffer();
        for (j = 0; j < k; j++) {
          var chunk = new forge9.util.ByteBuffer(I.getBytes(v));
          var x = 511;
          for (l = B.length() - 1; l >= 0; l--) {
            x = x >> 8;
            x += B.at(l) + chunk.at(l);
            chunk.setAt(l, x & 255);
          }
          Inew.putBuffer(chunk);
        }
        I = Inew;
        result.putBuffer(buf2);
      }
      result.truncate(result.length() - n);
      return result;
    };
    pki2.pbe.getCipher = function(oid, params, password) {
      switch (oid) {
        case pki2.oids["pkcs5PBES2"]:
          return pki2.pbe.getCipherForPBES2(oid, params, password);
        case pki2.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        case pki2.oids["pbewithSHAAnd40BitRC2-CBC"]:
          return pki2.pbe.getCipherForPKCS12PBE(oid, params, password);
        default:
          var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
          error.oid = oid;
          error.supportedOids = [
            "pkcs5PBES2",
            "pbeWithSHAAnd3-KeyTripleDES-CBC",
            "pbewithSHAAnd40BitRC2-CBC"
          ];
          throw error;
      }
    };
    pki2.pbe.getCipherForPBES2 = function(oid, params, password) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors2)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors2;
        throw error;
      }
      oid = asn1.derToOid(capture.kdfOid);
      if (oid !== pki2.oids["pkcs5PBKDF2"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
        error.oid = oid;
        error.supportedOids = ["pkcs5PBKDF2"];
        throw error;
      }
      oid = asn1.derToOid(capture.encOid);
      if (oid !== pki2.oids["aes128-CBC"] && oid !== pki2.oids["aes192-CBC"] && oid !== pki2.oids["aes256-CBC"] && oid !== pki2.oids["des-EDE3-CBC"] && oid !== pki2.oids["desCBC"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
        error.oid = oid;
        error.supportedOids = [
          "aes128-CBC",
          "aes192-CBC",
          "aes256-CBC",
          "des-EDE3-CBC",
          "desCBC"
        ];
        throw error;
      }
      var salt = capture.kdfSalt;
      var count = forge9.util.createBuffer(capture.kdfIterationCount);
      count = count.getInt(count.length() << 3);
      var dkLen;
      var cipherFn;
      switch (pki2.oids[oid]) {
        case "aes128-CBC":
          dkLen = 16;
          cipherFn = forge9.aes.createDecryptionCipher;
          break;
        case "aes192-CBC":
          dkLen = 24;
          cipherFn = forge9.aes.createDecryptionCipher;
          break;
        case "aes256-CBC":
          dkLen = 32;
          cipherFn = forge9.aes.createDecryptionCipher;
          break;
        case "des-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge9.des.createDecryptionCipher;
          break;
        case "desCBC":
          dkLen = 8;
          cipherFn = forge9.des.createDecryptionCipher;
          break;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var dk = forge9.pkcs5.pbkdf2(password, salt, count, dkLen, md);
      var iv = capture.encIv;
      var cipher = cipherFn(dk);
      cipher.start(iv);
      return cipher;
    };
    pki2.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors2)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors2;
        throw error;
      }
      var salt = forge9.util.createBuffer(capture.salt);
      var count = forge9.util.createBuffer(capture.iterations);
      count = count.getInt(count.length() << 3);
      var dkLen, dIvLen, cipherFn;
      switch (oid) {
        case pki2.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          dkLen = 24;
          dIvLen = 8;
          cipherFn = forge9.des.startDecrypting;
          break;
        case pki2.oids["pbewithSHAAnd40BitRC2-CBC"]:
          dkLen = 5;
          dIvLen = 8;
          cipherFn = function(key2, iv2) {
            var cipher = forge9.rc2.createDecryptionCipher(key2, 40);
            cipher.start(iv2, null);
            return cipher;
          };
          break;
        default:
          var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
          error.oid = oid;
          throw error;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var key = pki2.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
      md.start();
      var iv = pki2.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
      return cipherFn(key, iv);
    };
    pki2.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
      if (typeof md === "undefined" || md === null) {
        if (!("md5" in forge9.md)) {
          throw new Error('"md5" hash algorithm unavailable.');
        }
        md = forge9.md.md5.create();
      }
      if (salt === null) {
        salt = "";
      }
      var digests = [hash3(md, password + salt)];
      for (var length3 = 16, i2 = 1; length3 < dkLen; ++i2, length3 += 16) {
        digests.push(hash3(md, digests[i2 - 1] + password + salt));
      }
      return digests.join("").substr(0, dkLen);
    };
    function hash3(md, bytes2) {
      return md.start().update(bytes2).digest().getBytes();
    }
    function prfOidToMessageDigest(prfOid) {
      var prfAlgorithm;
      if (!prfOid) {
        prfAlgorithm = "hmacWithSHA1";
      } else {
        prfAlgorithm = pki2.oids[asn1.derToOid(prfOid)];
        if (!prfAlgorithm) {
          var error = new Error("Unsupported PRF OID.");
          error.oid = prfOid;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
        }
      }
      return prfAlgorithmToMessageDigest(prfAlgorithm);
    }
    function prfAlgorithmToMessageDigest(prfAlgorithm) {
      var factory = forge9.md;
      switch (prfAlgorithm) {
        case "hmacWithSHA224":
          factory = forge9.md.sha512;
        case "hmacWithSHA1":
        case "hmacWithSHA256":
        case "hmacWithSHA384":
        case "hmacWithSHA512":
          prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
          break;
        default:
          var error = new Error("Unsupported PRF algorithm.");
          error.algorithm = prfAlgorithm;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
      }
      if (!factory || !(prfAlgorithm in factory)) {
        throw new Error("Unknown hash algorithm: " + prfAlgorithm);
      }
      return factory[prfAlgorithm].create();
    }
    function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
      var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // salt
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          salt
        ),
        // iteration count
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          countBytes.getBytes()
        )
      ]);
      if (prfAlgorithm !== "hmacWithSHA1") {
        params.value.push(
          // key length
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge9.util.hexToBytes(dkLen.toString(16))
          ),
          // AlgorithmIdentifier
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // algorithm
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki2.oids[prfAlgorithm]).getBytes()
            ),
            // parameters (null)
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ])
        );
      }
      return params;
    }
  }
});
var require_sha512$1 = __commonJS({
  "node_modules/node-forge/lib/sha512.js"(exports2, module2) {
    var forge9 = require_forge();
    require_md();
    require_util();
    var sha5122 = module2.exports = forge9.sha512 = forge9.sha512 || {};
    forge9.md.sha512 = forge9.md.algorithms.sha512 = sha5122;
    var sha384 = forge9.sha384 = forge9.sha512.sha384 = forge9.sha512.sha384 || {};
    sha384.create = function() {
      return sha5122.create("SHA-384");
    };
    forge9.md.sha384 = forge9.md.algorithms.sha384 = sha384;
    forge9.sha512.sha256 = forge9.sha512.sha256 || {
      create: function() {
        return sha5122.create("SHA-512/256");
      }
    };
    forge9.md["sha512/256"] = forge9.md.algorithms["sha512/256"] = forge9.sha512.sha256;
    forge9.sha512.sha224 = forge9.sha512.sha224 || {
      create: function() {
        return sha5122.create("SHA-512/224");
      }
    };
    forge9.md["sha512/224"] = forge9.md.algorithms["sha512/224"] = forge9.sha512.sha224;
    sha5122.create = function(algorithm) {
      if (!_initialized) {
        _init();
      }
      if (typeof algorithm === "undefined") {
        algorithm = "SHA-512";
      }
      if (!(algorithm in _states)) {
        throw new Error("Invalid SHA-512 algorithm: " + algorithm);
      }
      var _state = _states[algorithm];
      var _h = null;
      var _input = forge9.util.createBuffer();
      var _w = new Array(80);
      for (var wi = 0; wi < 80; ++wi) {
        _w[wi] = new Array(2);
      }
      var digestLength = 64;
      switch (algorithm) {
        case "SHA-384":
          digestLength = 48;
          break;
        case "SHA-512/256":
          digestLength = 32;
          break;
        case "SHA-512/224":
          digestLength = 28;
          break;
      }
      var md = {
        // SHA-512 => sha512
        algorithm: algorithm.replace("-", "").toLowerCase(),
        blockLength: 128,
        digestLength,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 16
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength128 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md.fullMessageLength.push(0);
        }
        _input = forge9.util.createBuffer();
        _h = new Array(_state.length);
        for (var i2 = 0; i2 < _state.length; ++i2) {
          _h[i2] = _state[i2].slice(0);
        }
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge9.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
          md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_h, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge9.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits2 = md.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
          next = md.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits2 += carry;
          finalBlock.putInt32(bits2 >>> 0);
          bits2 = next >>> 0;
        }
        finalBlock.putInt32(bits2);
        var h = new Array(_h.length);
        for (var i2 = 0; i2 < _h.length; ++i2) {
          h[i2] = _h[i2].slice(0);
        }
        _update(h, _w, finalBlock);
        var rval = forge9.util.createBuffer();
        var hlen;
        if (algorithm === "SHA-512") {
          hlen = h.length;
        } else if (algorithm === "SHA-384") {
          hlen = h.length - 2;
        } else {
          hlen = h.length - 4;
        }
        for (var i2 = 0; i2 < hlen; ++i2) {
          rval.putInt32(h[i2][0]);
          if (i2 !== hlen - 1 || algorithm !== "SHA-512/224") {
            rval.putInt32(h[i2][1]);
          }
        }
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    var _states = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge9.util.fillString(String.fromCharCode(0), 128);
      _k = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591]
      ];
      _states = {};
      _states["SHA-512"] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209]
      ];
      _states["SHA-384"] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428]
      ];
      _states["SHA-512/256"] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882]
      ];
      _states["SHA-512/224"] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561]
      ];
      _initialized = true;
    }
    function _update(s, w, bytes2) {
      var t1_hi, t1_lo;
      var t2_hi, t2_lo;
      var s0_hi, s0_lo;
      var s1_hi, s1_lo;
      var ch_hi, ch_lo;
      var maj_hi, maj_lo;
      var a_hi, a_lo;
      var b_hi, b_lo;
      var c_hi, c_lo;
      var d_hi, d_lo;
      var e_hi, e_lo;
      var f_hi, f_lo;
      var g_hi, g_lo;
      var h_hi, h_lo;
      var i2, hi, lo, w2, w7, w15, w16;
      var len = bytes2.length();
      while (len >= 128) {
        for (i2 = 0; i2 < 16; ++i2) {
          w[i2][0] = bytes2.getInt32() >>> 0;
          w[i2][1] = bytes2.getInt32() >>> 0;
        }
        for (; i2 < 80; ++i2) {
          w2 = w[i2 - 2];
          hi = w2[0];
          lo = w2[1];
          t1_hi = ((hi >>> 19 | lo << 13) ^ // ROTR 19
          (lo >>> 29 | hi << 3) ^ // ROTR 61/(swap + ROTR 29)
          hi >>> 6) >>> 0;
          t1_lo = ((hi << 13 | lo >>> 19) ^ // ROTR 19
          (lo << 3 | hi >>> 29) ^ // ROTR 61/(swap + ROTR 29)
          (hi << 26 | lo >>> 6)) >>> 0;
          w15 = w[i2 - 15];
          hi = w15[0];
          lo = w15[1];
          t2_hi = ((hi >>> 1 | lo << 31) ^ // ROTR 1
          (hi >>> 8 | lo << 24) ^ // ROTR 8
          hi >>> 7) >>> 0;
          t2_lo = ((hi << 31 | lo >>> 1) ^ // ROTR 1
          (hi << 24 | lo >>> 8) ^ // ROTR 8
          (hi << 25 | lo >>> 7)) >>> 0;
          w7 = w[i2 - 7];
          w16 = w[i2 - 16];
          lo = t1_lo + w7[1] + t2_lo + w16[1];
          w[i2][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
          w[i2][1] = lo >>> 0;
        }
        a_hi = s[0][0];
        a_lo = s[0][1];
        b_hi = s[1][0];
        b_lo = s[1][1];
        c_hi = s[2][0];
        c_lo = s[2][1];
        d_hi = s[3][0];
        d_lo = s[3][1];
        e_hi = s[4][0];
        e_lo = s[4][1];
        f_hi = s[5][0];
        f_lo = s[5][1];
        g_hi = s[6][0];
        g_lo = s[6][1];
        h_hi = s[7][0];
        h_lo = s[7][1];
        for (i2 = 0; i2 < 80; ++i2) {
          s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14
          (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18
          (e_lo >>> 9 | e_hi << 23)) >>> 0;
          s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14
          (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18
          (e_lo << 23 | e_hi >>> 9)) >>> 0;
          ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
          ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
          s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28
          (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo >>> 7 | a_hi << 25)) >>> 0;
          s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28
          (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo << 25 | a_hi >>> 7)) >>> 0;
          maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
          maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
          lo = h_lo + s1_lo + ch_lo + _k[i2][1] + w[i2][1];
          t1_hi = h_hi + s1_hi + ch_hi + _k[i2][0] + w[i2][0] + (lo / 4294967296 >>> 0) >>> 0;
          t1_lo = lo >>> 0;
          lo = s0_lo + maj_lo;
          t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
          t2_lo = lo >>> 0;
          h_hi = g_hi;
          h_lo = g_lo;
          g_hi = f_hi;
          g_lo = f_lo;
          f_hi = e_hi;
          f_lo = e_lo;
          lo = d_lo + t1_lo;
          e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
          e_lo = lo >>> 0;
          d_hi = c_hi;
          d_lo = c_lo;
          c_hi = b_hi;
          c_lo = b_lo;
          b_hi = a_hi;
          b_lo = a_lo;
          lo = t1_lo + t2_lo;
          a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
          a_lo = lo >>> 0;
        }
        lo = s[0][1] + a_lo;
        s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[0][1] = lo >>> 0;
        lo = s[1][1] + b_lo;
        s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[1][1] = lo >>> 0;
        lo = s[2][1] + c_lo;
        s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[2][1] = lo >>> 0;
        lo = s[3][1] + d_lo;
        s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[3][1] = lo >>> 0;
        lo = s[4][1] + e_lo;
        s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[4][1] = lo >>> 0;
        lo = s[5][1] + f_lo;
        s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[5][1] = lo >>> 0;
        lo = s[6][1] + g_lo;
        s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[6][1] = lo >>> 0;
        lo = s[7][1] + h_lo;
        s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[7][1] = lo >>> 0;
        len -= 128;
      }
    }
  }
});
var require_is_domain_name = __commonJS({
  "node_modules/is-domain-name/index.js"(exports2, module2) {
    var domainNameRegex = /^(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9])?\.){0,126}(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9]))\.?$/i;
    module2.exports = function isDomainName(domainName, rootDot) {
      if (rootDot == null)
        rootDot = false;
      if (domainName.length < 2)
        return false;
      if (domainName.length > 255)
        return false;
      var lastChar = domainName[domainName.length - 1];
      if (rootDot) {
        if (lastChar !== ".")
          return false;
      } else {
        if (lastChar === ".")
          return false;
      }
      return domainNameRegex.test(domainName);
    };
  }
});
var require_murmurHash3js = __commonJS({
  "node_modules/murmurhash3js-revisited/lib/murmurHash3js.js"(exports2, module2) {
    (function(root2, undefined2) {
      var library = {
        "version": "3.0.0",
        "x86": {},
        "x64": {},
        "inputValidation": true
      };
      function _validBytes(bytes2) {
        if (!Array.isArray(bytes2) && !ArrayBuffer.isView(bytes2)) {
          return false;
        }
        for (var i2 = 0; i2 < bytes2.length; i2++) {
          if (!Number.isInteger(bytes2[i2]) || bytes2[i2] < 0 || bytes2[i2] > 255) {
            return false;
          }
        }
        return true;
      }
      function _x86Multiply(m, n) {
        return (m & 65535) * n + (((m >>> 16) * n & 65535) << 16);
      }
      function _x86Rotl(m, n) {
        return m << n | m >>> 32 - n;
      }
      function _x86Fmix(h) {
        h ^= h >>> 16;
        h = _x86Multiply(h, 2246822507);
        h ^= h >>> 13;
        h = _x86Multiply(h, 3266489909);
        h ^= h >>> 16;
        return h;
      }
      function _x64Add(m, n) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m[3] + n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m[2] + n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m[1] + n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m[0] + n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Multiply(m, n) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m[3] * n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m[2] * n[3];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[2] += m[3] * n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m[1] * n[3];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m[2] * n[2];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m[3] * n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m[0] * n[3] + m[1] * n[2] + m[2] * n[1] + m[3] * n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Rotl(m, n) {
        n %= 64;
        if (n === 32) {
          return [m[1], m[0]];
        } else if (n < 32) {
          return [m[0] << n | m[1] >>> 32 - n, m[1] << n | m[0] >>> 32 - n];
        } else {
          n -= 32;
          return [m[1] << n | m[0] >>> 32 - n, m[0] << n | m[1] >>> 32 - n];
        }
      }
      function _x64LeftShift(m, n) {
        n %= 64;
        if (n === 0) {
          return m;
        } else if (n < 32) {
          return [m[0] << n | m[1] >>> 32 - n, m[1] << n];
        } else {
          return [m[1] << n - 32, 0];
        }
      }
      function _x64Xor(m, n) {
        return [m[0] ^ n[0], m[1] ^ n[1]];
      }
      function _x64Fmix(h) {
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [4283543511, 3981806797]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [3301882366, 444984403]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        return h;
      }
      library.x86.hash32 = function(bytes2, seed2) {
        if (library.inputValidation && !_validBytes(bytes2)) {
          return undefined2;
        }
        seed2 = seed2 || 0;
        var remainder = bytes2.length % 4;
        var blocks = bytes2.length - remainder;
        var h1 = seed2;
        var k1 = 0;
        var c1 = 3432918353;
        var c2 = 461845907;
        for (var i2 = 0; i2 < blocks; i2 = i2 + 4) {
          k1 = bytes2[i2] | bytes2[i2 + 1] << 8 | bytes2[i2 + 2] << 16 | bytes2[i2 + 3] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 13);
          h1 = _x86Multiply(h1, 5) + 3864292196;
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= bytes2[i2 + 2] << 16;
          case 2:
            k1 ^= bytes2[i2 + 1] << 8;
          case 1:
            k1 ^= bytes2[i2];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes2.length;
        h1 = _x86Fmix(h1);
        return h1 >>> 0;
      };
      library.x86.hash128 = function(bytes2, seed2) {
        if (library.inputValidation && !_validBytes(bytes2)) {
          return undefined2;
        }
        seed2 = seed2 || 0;
        var remainder = bytes2.length % 16;
        var blocks = bytes2.length - remainder;
        var h1 = seed2;
        var h2 = seed2;
        var h3 = seed2;
        var h4 = seed2;
        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;
        var c1 = 597399067;
        var c2 = 2869860233;
        var c3 = 951274213;
        var c4 = 2716044179;
        for (var i2 = 0; i2 < blocks; i2 = i2 + 16) {
          k1 = bytes2[i2] | bytes2[i2 + 1] << 8 | bytes2[i2 + 2] << 16 | bytes2[i2 + 3] << 24;
          k2 = bytes2[i2 + 4] | bytes2[i2 + 5] << 8 | bytes2[i2 + 6] << 16 | bytes2[i2 + 7] << 24;
          k3 = bytes2[i2 + 8] | bytes2[i2 + 9] << 8 | bytes2[i2 + 10] << 16 | bytes2[i2 + 11] << 24;
          k4 = bytes2[i2 + 12] | bytes2[i2 + 13] << 8 | bytes2[i2 + 14] << 16 | bytes2[i2 + 15] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 19);
          h1 += h2;
          h1 = _x86Multiply(h1, 5) + 1444728091;
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
          h2 = _x86Rotl(h2, 17);
          h2 += h3;
          h2 = _x86Multiply(h2, 5) + 197830471;
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
          h3 = _x86Rotl(h3, 15);
          h3 += h4;
          h3 = _x86Multiply(h3, 5) + 2530024501;
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
          h4 = _x86Rotl(h4, 13);
          h4 += h1;
          h4 = _x86Multiply(h4, 5) + 850148119;
        }
        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;
        switch (remainder) {
          case 15:
            k4 ^= bytes2[i2 + 14] << 16;
          case 14:
            k4 ^= bytes2[i2 + 13] << 8;
          case 13:
            k4 ^= bytes2[i2 + 12];
            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;
          case 12:
            k3 ^= bytes2[i2 + 11] << 24;
          case 11:
            k3 ^= bytes2[i2 + 10] << 16;
          case 10:
            k3 ^= bytes2[i2 + 9] << 8;
          case 9:
            k3 ^= bytes2[i2 + 8];
            k3 = _x86Multiply(k3, c3);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h3 ^= k3;
          case 8:
            k2 ^= bytes2[i2 + 7] << 24;
          case 7:
            k2 ^= bytes2[i2 + 6] << 16;
          case 6:
            k2 ^= bytes2[i2 + 5] << 8;
          case 5:
            k2 ^= bytes2[i2 + 4];
            k2 = _x86Multiply(k2, c2);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c3);
            h2 ^= k2;
          case 4:
            k1 ^= bytes2[i2 + 3] << 24;
          case 3:
            k1 ^= bytes2[i2 + 2] << 16;
          case 2:
            k1 ^= bytes2[i2 + 1] << 8;
          case 1:
            k1 ^= bytes2[i2];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes2.length;
        h2 ^= bytes2.length;
        h3 ^= bytes2.length;
        h4 ^= bytes2.length;
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        h1 = _x86Fmix(h1);
        h2 = _x86Fmix(h2);
        h3 = _x86Fmix(h3);
        h4 = _x86Fmix(h4);
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
      };
      library.x64.hash128 = function(bytes2, seed2) {
        if (library.inputValidation && !_validBytes(bytes2)) {
          return undefined2;
        }
        seed2 = seed2 || 0;
        var remainder = bytes2.length % 16;
        var blocks = bytes2.length - remainder;
        var h1 = [0, seed2];
        var h2 = [0, seed2];
        var k1 = [0, 0];
        var k2 = [0, 0];
        var c1 = [2277735313, 289559509];
        var c2 = [1291169091, 658871167];
        for (var i2 = 0; i2 < blocks; i2 = i2 + 16) {
          k1 = [bytes2[i2 + 4] | bytes2[i2 + 5] << 8 | bytes2[i2 + 6] << 16 | bytes2[i2 + 7] << 24, bytes2[i2] | bytes2[i2 + 1] << 8 | bytes2[i2 + 2] << 16 | bytes2[i2 + 3] << 24];
          k2 = [bytes2[i2 + 12] | bytes2[i2 + 13] << 8 | bytes2[i2 + 14] << 16 | bytes2[i2 + 15] << 24, bytes2[i2 + 8] | bytes2[i2 + 9] << 8 | bytes2[i2 + 10] << 16 | bytes2[i2 + 11] << 24];
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
          h1 = _x64Rotl(h1, 27);
          h1 = _x64Add(h1, h2);
          h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
          h2 = _x64Rotl(h2, 31);
          h2 = _x64Add(h2, h1);
          h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
        }
        k1 = [0, 0];
        k2 = [0, 0];
        switch (remainder) {
          case 15:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 14]], 48));
          case 14:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 13]], 40));
          case 13:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 12]], 32));
          case 12:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 11]], 24));
          case 11:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 10]], 16));
          case 10:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 9]], 8));
          case 9:
            k2 = _x64Xor(k2, [0, bytes2[i2 + 8]]);
            k2 = _x64Multiply(k2, c2);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h2 = _x64Xor(h2, k2);
          case 8:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 7]], 56));
          case 7:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 6]], 48));
          case 6:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 5]], 40));
          case 5:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 4]], 32));
          case 4:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 3]], 24));
          case 3:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 2]], 16));
          case 2:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 1]], 8));
          case 1:
            k1 = _x64Xor(k1, [0, bytes2[i2]]);
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c2);
            h1 = _x64Xor(h1, k1);
        }
        h1 = _x64Xor(h1, [0, bytes2.length]);
        h2 = _x64Xor(h2, [0, bytes2.length]);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        h1 = _x64Fmix(h1);
        h2 = _x64Fmix(h2);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
      };
      if (typeof exports2 !== "undefined") {
        if (typeof module2 !== "undefined" && module2.exports) {
          exports2 = module2.exports = library;
        }
        exports2.murmurHash3 = library;
      } else if (typeof define === "function" && define.amd) {
        define([], function() {
          return library;
        });
      } else {
        library._murmurHash3 = root2.murmurHash3;
        library.noConflict = function() {
          root2.murmurHash3 = library._murmurHash3;
          library._murmurHash3 = undefined2;
          library.noConflict = undefined2;
          return library;
        };
        root2.murmurHash3 = library;
      }
    })(exports2);
  }
});
var require_murmurhash3js_revisited = __commonJS({
  "node_modules/murmurhash3js-revisited/index.js"(exports2, module2) {
    module2.exports = require_murmurHash3js();
  }
});
var require_rabin = __commonJS({
  "node_modules/rabin-wasm/src/rabin.js"(exports2, module2) {
    var Rabin = class {
      /**
       * Creates an instance of Rabin.
       * @param { import("./../dist/rabin-wasm") } asModule
       * @param {number} [bits=12]
       * @param {number} [min=8 * 1024]
       * @param {number} [max=32 * 1024]
       * @param {number} polynomial
       * @memberof Rabin
       */
      constructor(asModule, bits2 = 12, min = 8 * 1024, max = 32 * 1024, windowSize = 64, polynomial) {
        this.bits = bits2;
        this.min = min;
        this.max = max;
        this.asModule = asModule;
        this.rabin = new asModule.Rabin(bits2, min, max, windowSize, polynomial);
        this.polynomial = polynomial;
      }
      /**
       * Fingerprints the buffer
       *
       * @param {Uint8Array} buf
       * @returns {Array<number>}
       * @memberof Rabin
       */
      fingerprint(buf2) {
        const {
          __retain,
          __release,
          __allocArray,
          __getInt32Array,
          Int32Array_ID,
          Uint8Array_ID
        } = this.asModule;
        const lengths = new Int32Array(Math.ceil(buf2.length / this.min));
        const lengthsPtr = __retain(__allocArray(Int32Array_ID, lengths));
        const pointer = __retain(__allocArray(Uint8Array_ID, buf2));
        const out = this.rabin.fingerprint(pointer, lengthsPtr);
        const processed = __getInt32Array(out);
        __release(pointer);
        __release(lengthsPtr);
        const end = processed.indexOf(0);
        return end >= 0 ? processed.subarray(0, end) : processed;
      }
    };
    module2.exports = Rabin;
  }
});
var require_loader = __commonJS({
  "node_modules/@assemblyscript/loader/index.js"(exports2) {
    var ID_OFFSET = -8;
    var SIZE_OFFSET = -4;
    var ARRAYBUFFER_ID = 0;
    var STRING_ID = 1;
    var ARRAYBUFFERVIEW = 1 << 0;
    var ARRAY = 1 << 1;
    var VAL_ALIGN_OFFSET = 5;
    var VAL_SIGNED = 1 << 10;
    var VAL_FLOAT = 1 << 11;
    var VAL_MANAGED = 1 << 13;
    var ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;
    var ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;
    var ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;
    var ARRAYBUFFERVIEW_SIZE = 12;
    var ARRAY_LENGTH_OFFSET = 12;
    var ARRAY_SIZE = 16;
    var BIGINT = typeof BigUint64Array !== "undefined";
    var THIS = Symbol();
    var CHUNKSIZE = 1024;
    function getStringImpl(buffer2, ptr) {
      const U32 = new Uint32Array(buffer2);
      const U16 = new Uint16Array(buffer2);
      var length3 = U32[ptr + SIZE_OFFSET >>> 2] >>> 1;
      var offset = ptr >>> 1;
      if (length3 <= CHUNKSIZE)
        return String.fromCharCode.apply(String, U16.subarray(offset, offset + length3));
      const parts2 = [];
      do {
        const last2 = U16[offset + CHUNKSIZE - 1];
        const size = last2 >= 55296 && last2 < 56320 ? CHUNKSIZE - 1 : CHUNKSIZE;
        parts2.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));
        length3 -= size;
      } while (length3 > CHUNKSIZE);
      return parts2.join("") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length3));
    }
    function preInstantiate(imports) {
      const baseModule = {};
      function getString(memory, ptr) {
        if (!memory)
          return "<yet unknown>";
        return getStringImpl(memory.buffer, ptr);
      }
      const env = imports.env = imports.env || {};
      env.abort = env.abort || function abort(mesg, file, line, colm) {
        const memory = baseModule.memory || env.memory;
        throw Error("abort: " + getString(memory, mesg) + " at " + getString(memory, file) + ":" + line + ":" + colm);
      };
      env.trace = env.trace || function trace(mesg, n) {
        const memory = baseModule.memory || env.memory;
        console.log("trace: " + getString(memory, mesg) + (n ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + n).join(", "));
      };
      imports.Math = imports.Math || Math;
      imports.Date = imports.Date || Date;
      return baseModule;
    }
    function postInstantiate(baseModule, instance) {
      const rawExports = instance.exports;
      const memory = rawExports.memory;
      const table2 = rawExports.table;
      const alloc3 = rawExports["__alloc"];
      const retain = rawExports["__retain"];
      const rttiBase = rawExports["__rtti_base"] || ~0;
      function getInfo(id) {
        const U32 = new Uint32Array(memory.buffer);
        const count = U32[rttiBase >>> 2];
        if ((id >>>= 0) >= count)
          throw Error("invalid id: " + id);
        return U32[(rttiBase + 4 >>> 2) + id * 2];
      }
      function getBase(id) {
        const U32 = new Uint32Array(memory.buffer);
        const count = U32[rttiBase >>> 2];
        if ((id >>>= 0) >= count)
          throw Error("invalid id: " + id);
        return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];
      }
      function getValueAlign(info) {
        return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31);
      }
      function __allocString(str) {
        const length3 = str.length;
        const ptr = alloc3(length3 << 1, STRING_ID);
        const U16 = new Uint16Array(memory.buffer);
        for (var i2 = 0, p = ptr >>> 1; i2 < length3; ++i2)
          U16[p + i2] = str.charCodeAt(i2);
        return ptr;
      }
      baseModule.__allocString = __allocString;
      function __getString(ptr) {
        const buffer2 = memory.buffer;
        const id = new Uint32Array(buffer2)[ptr + ID_OFFSET >>> 2];
        if (id !== STRING_ID)
          throw Error("not a string: " + ptr);
        return getStringImpl(buffer2, ptr);
      }
      baseModule.__getString = __getString;
      function getView(alignLog2, signed, float) {
        const buffer2 = memory.buffer;
        if (float) {
          switch (alignLog2) {
            case 2:
              return new Float32Array(buffer2);
            case 3:
              return new Float64Array(buffer2);
          }
        } else {
          switch (alignLog2) {
            case 0:
              return new (signed ? Int8Array : Uint8Array)(buffer2);
            case 1:
              return new (signed ? Int16Array : Uint16Array)(buffer2);
            case 2:
              return new (signed ? Int32Array : Uint32Array)(buffer2);
            case 3:
              return new (signed ? BigInt64Array : BigUint64Array)(buffer2);
          }
        }
        throw Error("unsupported align: " + alignLog2);
      }
      function __allocArray(id, values) {
        const info = getInfo(id);
        if (!(info & (ARRAYBUFFERVIEW | ARRAY)))
          throw Error("not an array: " + id + " @ " + info);
        const align = getValueAlign(info);
        const length3 = values.length;
        const buf2 = alloc3(length3 << align, ARRAYBUFFER_ID);
        const arr = alloc3(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);
        const U32 = new Uint32Array(memory.buffer);
        U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf2);
        U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf2;
        U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length3 << align;
        if (info & ARRAY)
          U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length3;
        const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);
        if (info & VAL_MANAGED) {
          for (let i2 = 0; i2 < length3; ++i2)
            view[(buf2 >>> align) + i2] = retain(values[i2]);
        } else {
          view.set(values, buf2 >>> align);
        }
        return arr;
      }
      baseModule.__allocArray = __allocArray;
      function __getArrayView(arr) {
        const U32 = new Uint32Array(memory.buffer);
        const id = U32[arr + ID_OFFSET >>> 2];
        const info = getInfo(id);
        if (!(info & ARRAYBUFFERVIEW))
          throw Error("not an array: " + id);
        const align = getValueAlign(info);
        var buf2 = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
        const length3 = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf2 + SIZE_OFFSET >>> 2] >>> align;
        return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf2 >>>= align, buf2 + length3);
      }
      baseModule.__getArrayView = __getArrayView;
      function __getArray(arr) {
        const input = __getArrayView(arr);
        const len = input.length;
        const out = new Array(len);
        for (let i2 = 0; i2 < len; i2++)
          out[i2] = input[i2];
        return out;
      }
      baseModule.__getArray = __getArray;
      function __getArrayBuffer(ptr) {
        const buffer2 = memory.buffer;
        const length3 = new Uint32Array(buffer2)[ptr + SIZE_OFFSET >>> 2];
        return buffer2.slice(ptr, ptr + length3);
      }
      baseModule.__getArrayBuffer = __getArrayBuffer;
      function getTypedArray(Type2, alignLog2, ptr) {
        return new Type2(getTypedArrayView(Type2, alignLog2, ptr));
      }
      function getTypedArrayView(Type2, alignLog2, ptr) {
        const buffer2 = memory.buffer;
        const U32 = new Uint32Array(buffer2);
        const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
        return new Type2(buffer2, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);
      }
      baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);
      baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);
      baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);
      baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);
      baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);
      baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);
      baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);
      baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);
      baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);
      baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);
      baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);
      baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);
      baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);
      baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);
      if (BIGINT) {
        baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);
        baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);
        baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);
        baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);
      }
      baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);
      baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);
      baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);
      baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);
      function __instanceof(ptr, baseId) {
        const U32 = new Uint32Array(memory.buffer);
        var id = U32[ptr + ID_OFFSET >>> 2];
        if (id <= U32[rttiBase >>> 2]) {
          do
            if (id == baseId)
              return true;
          while (id = getBase(id));
        }
        return false;
      }
      baseModule.__instanceof = __instanceof;
      baseModule.memory = baseModule.memory || memory;
      baseModule.table = baseModule.table || table2;
      return demangle(rawExports, baseModule);
    }
    function isResponse(o) {
      return typeof Response !== "undefined" && o instanceof Response;
    }
    async function instantiate(source, imports) {
      if (isResponse(source = await source))
        return instantiateStreaming(source, imports);
      return postInstantiate(
        preInstantiate(imports || (imports = {})),
        await WebAssembly.instantiate(
          source instanceof WebAssembly.Module ? source : await WebAssembly.compile(source),
          imports
        )
      );
    }
    exports2.instantiate = instantiate;
    function instantiateSync(source, imports) {
      return postInstantiate(
        preInstantiate(imports || (imports = {})),
        new WebAssembly.Instance(
          source instanceof WebAssembly.Module ? source : new WebAssembly.Module(source),
          imports
        )
      );
    }
    exports2.instantiateSync = instantiateSync;
    async function instantiateStreaming(source, imports) {
      if (!WebAssembly.instantiateStreaming) {
        return instantiate(
          isResponse(source = await source) ? source.arrayBuffer() : source,
          imports
        );
      }
      return postInstantiate(
        preInstantiate(imports || (imports = {})),
        (await WebAssembly.instantiateStreaming(source, imports)).instance
      );
    }
    exports2.instantiateStreaming = instantiateStreaming;
    function demangle(exports3, baseModule) {
      var module3 = baseModule ? Object.create(baseModule) : {};
      var setArgumentsLength = exports3["__argumentsLength"] ? function(length3) {
        exports3["__argumentsLength"].value = length3;
      } : exports3["__setArgumentsLength"] || exports3["__setargc"] || function() {
      };
      for (let internalName in exports3) {
        if (!Object.prototype.hasOwnProperty.call(exports3, internalName))
          continue;
        const elem = exports3[internalName];
        let parts2 = internalName.split(".");
        let curr = module3;
        while (parts2.length > 1) {
          let part = parts2.shift();
          if (!Object.prototype.hasOwnProperty.call(curr, part))
            curr[part] = {};
          curr = curr[part];
        }
        let name9 = parts2[0];
        let hash3 = name9.indexOf("#");
        if (hash3 >= 0) {
          let className = name9.substring(0, hash3);
          let classElem = curr[className];
          if (typeof classElem === "undefined" || !classElem.prototype) {
            let ctor = function(...args) {
              return ctor.wrap(ctor.prototype.constructor(0, ...args));
            };
            ctor.prototype = {
              valueOf: function valueOf() {
                return this[THIS];
              }
            };
            ctor.wrap = function(thisValue) {
              return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });
            };
            if (classElem)
              Object.getOwnPropertyNames(classElem).forEach(
                (name10) => Object.defineProperty(ctor, name10, Object.getOwnPropertyDescriptor(classElem, name10))
              );
            curr[className] = ctor;
          }
          name9 = name9.substring(hash3 + 1);
          curr = curr[className].prototype;
          if (/^(get|set):/.test(name9)) {
            if (!Object.prototype.hasOwnProperty.call(curr, name9 = name9.substring(4))) {
              let getter = exports3[internalName.replace("set:", "get:")];
              let setter = exports3[internalName.replace("get:", "set:")];
              Object.defineProperty(curr, name9, {
                get: function() {
                  return getter(this[THIS]);
                },
                set: function(value2) {
                  setter(this[THIS], value2);
                },
                enumerable: true
              });
            }
          } else {
            if (name9 === "constructor") {
              (curr[name9] = (...args) => {
                setArgumentsLength(args.length);
                return elem(...args);
              }).original = elem;
            } else {
              (curr[name9] = function(...args) {
                setArgumentsLength(args.length);
                return elem(this[THIS], ...args);
              }).original = elem;
            }
          }
        } else {
          if (/^(get|set):/.test(name9)) {
            if (!Object.prototype.hasOwnProperty.call(curr, name9 = name9.substring(4))) {
              Object.defineProperty(curr, name9, {
                get: exports3[internalName.replace("set:", "get:")],
                set: exports3[internalName.replace("get:", "set:")],
                enumerable: true
              });
            }
          } else if (typeof elem === "function" && elem !== setArgumentsLength) {
            (curr[name9] = (...args) => {
              setArgumentsLength(args.length);
              return elem(...args);
            }).original = elem;
          } else {
            curr[name9] = elem;
          }
        }
      }
      return module3;
    }
    exports2.demangle = demangle;
  }
});
var require_rabin_wasm = __commonJS({
  "node_modules/rabin-wasm/dist/rabin-wasm.js"(exports2, module2) {
    var { instantiate } = require_loader();
    loadWebAssembly.supported = typeof WebAssembly !== "undefined";
    function loadWebAssembly(imp = {}) {
      if (!loadWebAssembly.supported)
        return null;
      var wasm = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 78, 14, 96, 2, 127, 126, 0, 96, 1, 127, 1, 126, 96, 2, 127, 127, 0, 96, 1, 127, 1, 127, 96, 1, 127, 0, 96, 2, 127, 127, 1, 127, 96, 3, 127, 127, 127, 1, 127, 96, 0, 0, 96, 3, 127, 127, 127, 0, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 0, 96, 5, 127, 127, 127, 127, 127, 1, 127, 96, 1, 126, 1, 127, 96, 2, 126, 126, 1, 126, 2, 13, 1, 3, 101, 110, 118, 5, 97, 98, 111, 114, 116, 0, 10, 3, 54, 53, 2, 2, 8, 9, 3, 5, 2, 8, 6, 5, 3, 4, 2, 6, 9, 12, 13, 2, 5, 11, 3, 2, 3, 2, 3, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 7, 7, 4, 4, 5, 3, 1, 0, 1, 6, 47, 9, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 3, 11, 127, 0, 65, 4, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 240, 2, 11, 127, 0, 65, 6, 11, 7, 240, 5, 41, 6, 109, 101, 109, 111, 114, 121, 2, 0, 7, 95, 95, 97, 108, 108, 111, 99, 0, 10, 8, 95, 95, 114, 101, 116, 97, 105, 110, 0, 11, 9, 95, 95, 114, 101, 108, 101, 97, 115, 101, 0, 12, 9, 95, 95, 99, 111, 108, 108, 101, 99, 116, 0, 51, 11, 95, 95, 114, 116, 116, 105, 95, 98, 97, 115, 101, 3, 7, 13, 73, 110, 116, 51, 50, 65, 114, 114, 97, 121, 95, 73, 68, 3, 2, 13, 85, 105, 110, 116, 56, 65, 114, 114, 97, 121, 95, 73, 68, 3, 3, 6, 100, 101, 103, 114, 101, 101, 0, 16, 3, 109, 111, 100, 0, 17, 5, 82, 97, 98, 105, 110, 3, 8, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 21, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 22, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 23, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 24, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 112, 111, 115, 0, 25, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 112, 111, 115, 0, 26, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 111, 117, 110, 116, 0, 27, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 111, 117, 110, 116, 0, 28, 13, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 115, 0, 29, 13, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 115, 0, 30, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 115, 116, 97, 114, 116, 0, 31, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 115, 116, 97, 114, 116, 0, 32, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 33, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 34, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 35, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 36, 22, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 37, 22, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 38, 31, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 39, 31, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 40, 20, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 41, 20, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 42, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 43, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 44, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 45, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 46, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 115, 107, 0, 47, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 115, 107, 0, 48, 17, 82, 97, 98, 105, 110, 35, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 0, 20, 17, 82, 97, 98, 105, 110, 35, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 49, 8, 1, 50, 10, 165, 31, 53, 199, 1, 1, 4, 127, 32, 1, 40, 2, 0, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 3, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 3, 65, 7, 107, 11, 33, 3, 32, 1, 40, 2, 20, 33, 2, 32, 1, 40, 2, 16, 34, 5, 4, 64, 32, 5, 32, 2, 54, 2, 20, 11, 32, 2, 4, 64, 32, 2, 32, 5, 54, 2, 16, 11, 32, 1, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 70, 4, 64, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 2, 54, 2, 96, 32, 2, 69, 4, 64, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 65, 127, 115, 113, 34, 1, 54, 2, 4, 32, 1, 69, 4, 64, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 65, 127, 115, 113, 54, 2, 0, 11, 11, 11, 11, 226, 2, 1, 6, 127, 32, 1, 40, 2, 0, 33, 3, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 34, 5, 65, 1, 113, 4, 64, 32, 3, 65, 124, 113, 65, 16, 106, 32, 5, 65, 124, 113, 106, 34, 2, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 4, 16, 1, 32, 1, 32, 2, 32, 3, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 33, 5, 11, 11, 32, 3, 65, 2, 113, 4, 64, 32, 1, 65, 4, 107, 40, 2, 0, 34, 2, 40, 2, 0, 34, 6, 65, 124, 113, 65, 16, 106, 32, 3, 65, 124, 113, 106, 34, 7, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 2, 16, 1, 32, 2, 32, 7, 32, 6, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 2, 33, 1, 11, 11, 32, 4, 32, 5, 65, 2, 114, 54, 2, 0, 32, 4, 65, 4, 107, 32, 1, 54, 2, 0, 32, 0, 32, 3, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 2, 65, 7, 107, 11, 34, 3, 65, 4, 116, 32, 4, 106, 65, 2, 116, 106, 40, 2, 96, 33, 2, 32, 1, 65, 0, 54, 2, 16, 32, 1, 32, 2, 54, 2, 20, 32, 2, 4, 64, 32, 2, 32, 1, 54, 2, 16, 11, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 1, 54, 2, 96, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 114, 54, 2, 0, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 114, 54, 2, 4, 11, 119, 1, 1, 127, 32, 2, 2, 127, 32, 0, 40, 2, 160, 12, 34, 2, 4, 64, 32, 2, 32, 1, 65, 16, 107, 70, 4, 64, 32, 2, 40, 2, 0, 33, 3, 32, 1, 65, 16, 107, 33, 1, 11, 11, 32, 1, 11, 107, 34, 2, 65, 48, 73, 4, 64, 15, 11, 32, 1, 32, 3, 65, 2, 113, 32, 2, 65, 32, 107, 65, 1, 114, 114, 54, 2, 0, 32, 1, 65, 0, 54, 2, 16, 32, 1, 65, 0, 54, 2, 20, 32, 1, 32, 2, 106, 65, 16, 107, 34, 2, 65, 2, 54, 2, 0, 32, 0, 32, 2, 54, 2, 160, 12, 32, 0, 32, 1, 16, 2, 11, 155, 1, 1, 3, 127, 35, 0, 34, 0, 69, 4, 64, 65, 1, 63, 0, 34, 0, 74, 4, 127, 65, 1, 32, 0, 107, 64, 0, 65, 0, 72, 5, 65, 0, 11, 4, 64, 0, 11, 65, 176, 3, 34, 0, 65, 0, 54, 2, 0, 65, 208, 15, 65, 0, 54, 2, 0, 3, 64, 32, 1, 65, 23, 73, 4, 64, 32, 1, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 4, 65, 0, 33, 2, 3, 64, 32, 2, 65, 16, 73, 4, 64, 32, 1, 65, 4, 116, 32, 2, 106, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 96, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 65, 176, 3, 65, 224, 15, 63, 0, 65, 16, 116, 16, 3, 65, 176, 3, 36, 0, 11, 32, 0, 11, 45, 0, 32, 0, 65, 240, 255, 255, 255, 3, 79, 4, 64, 65, 32, 65, 224, 0, 65, 201, 3, 65, 29, 16, 0, 0, 11, 32, 0, 65, 15, 106, 65, 112, 113, 34, 0, 65, 16, 32, 0, 65, 16, 75, 27, 11, 169, 1, 1, 1, 127, 32, 0, 32, 1, 65, 128, 2, 73, 4, 127, 32, 1, 65, 4, 118, 33, 1, 65, 0, 5, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 64, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 106, 65, 1, 107, 33, 1, 11, 32, 1, 65, 31, 32, 1, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 1, 32, 2, 65, 7, 107, 11, 34, 2, 65, 2, 116, 106, 40, 2, 4, 65, 127, 32, 1, 116, 113, 34, 1, 4, 127, 32, 0, 32, 1, 104, 32, 2, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 32, 0, 40, 2, 0, 65, 127, 32, 2, 65, 1, 106, 116, 113, 34, 1, 4, 127, 32, 0, 32, 0, 32, 1, 104, 34, 0, 65, 2, 116, 106, 40, 2, 4, 104, 32, 0, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 65, 0, 11, 11, 11, 111, 1, 1, 127, 63, 0, 34, 2, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 127, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 65, 1, 107, 106, 5, 32, 1, 11, 65, 16, 32, 0, 40, 2, 160, 12, 32, 2, 65, 16, 116, 65, 16, 107, 71, 116, 106, 65, 255, 255, 3, 106, 65, 128, 128, 124, 113, 65, 16, 118, 34, 1, 32, 2, 32, 1, 74, 27, 64, 0, 65, 0, 72, 4, 64, 32, 1, 64, 0, 65, 0, 72, 4, 64, 0, 11, 11, 32, 0, 32, 2, 65, 16, 116, 63, 0, 65, 16, 116, 16, 3, 11, 113, 1, 2, 127, 32, 1, 40, 2, 0, 34, 3, 65, 124, 113, 32, 2, 107, 34, 4, 65, 32, 79, 4, 64, 32, 1, 32, 2, 32, 3, 65, 2, 113, 114, 54, 2, 0, 32, 2, 32, 1, 65, 16, 106, 106, 34, 1, 32, 4, 65, 16, 107, 65, 1, 114, 54, 2, 0, 32, 0, 32, 1, 16, 2, 5, 32, 1, 32, 3, 65, 126, 113, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 40, 2, 0, 65, 125, 113, 54, 2, 0, 11, 11, 91, 1, 2, 127, 32, 0, 32, 1, 16, 5, 34, 4, 16, 6, 34, 3, 69, 4, 64, 65, 1, 36, 1, 65, 0, 36, 1, 32, 0, 32, 4, 16, 6, 34, 3, 69, 4, 64, 32, 0, 32, 4, 16, 7, 32, 0, 32, 4, 16, 6, 33, 3, 11, 11, 32, 3, 65, 0, 54, 2, 4, 32, 3, 32, 2, 54, 2, 8, 32, 3, 32, 1, 54, 2, 12, 32, 0, 32, 3, 16, 1, 32, 0, 32, 3, 32, 4, 16, 8, 32, 3, 11, 13, 0, 16, 4, 32, 0, 32, 1, 16, 9, 65, 16, 106, 11, 33, 1, 1, 127, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 18, 0, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 140, 3, 1, 1, 127, 2, 64, 32, 1, 69, 13, 0, 32, 0, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 1, 107, 65, 0, 58, 0, 0, 32, 1, 65, 2, 77, 13, 0, 32, 0, 65, 1, 106, 65, 0, 58, 0, 0, 32, 0, 65, 2, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 34, 2, 65, 2, 107, 65, 0, 58, 0, 0, 32, 2, 65, 3, 107, 65, 0, 58, 0, 0, 32, 1, 65, 6, 77, 13, 0, 32, 0, 65, 3, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 4, 107, 65, 0, 58, 0, 0, 32, 1, 65, 8, 77, 13, 0, 32, 1, 65, 0, 32, 0, 107, 65, 3, 113, 34, 1, 107, 33, 2, 32, 0, 32, 1, 106, 34, 0, 65, 0, 54, 2, 0, 32, 0, 32, 2, 65, 124, 113, 34, 1, 106, 65, 4, 107, 65, 0, 54, 2, 0, 32, 1, 65, 8, 77, 13, 0, 32, 0, 65, 4, 106, 65, 0, 54, 2, 0, 32, 0, 65, 8, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 12, 107, 65, 0, 54, 2, 0, 32, 2, 65, 8, 107, 65, 0, 54, 2, 0, 32, 1, 65, 24, 77, 13, 0, 32, 0, 65, 12, 106, 65, 0, 54, 2, 0, 32, 0, 65, 16, 106, 65, 0, 54, 2, 0, 32, 0, 65, 20, 106, 65, 0, 54, 2, 0, 32, 0, 65, 24, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 28, 107, 65, 0, 54, 2, 0, 32, 2, 65, 24, 107, 65, 0, 54, 2, 0, 32, 2, 65, 20, 107, 65, 0, 54, 2, 0, 32, 2, 65, 16, 107, 65, 0, 54, 2, 0, 32, 0, 32, 0, 65, 4, 113, 65, 24, 106, 34, 2, 106, 33, 0, 32, 1, 32, 2, 107, 33, 1, 3, 64, 32, 1, 65, 32, 79, 4, 64, 32, 0, 66, 0, 55, 3, 0, 32, 0, 65, 8, 106, 66, 0, 55, 3, 0, 32, 0, 65, 16, 106, 66, 0, 55, 3, 0, 32, 0, 65, 24, 106, 66, 0, 55, 3, 0, 32, 1, 65, 32, 107, 33, 1, 32, 0, 65, 32, 106, 33, 0, 12, 1, 11, 11, 11, 11, 178, 1, 1, 3, 127, 32, 1, 65, 240, 255, 255, 255, 3, 32, 2, 118, 75, 4, 64, 65, 144, 1, 65, 192, 1, 65, 23, 65, 56, 16, 0, 0, 11, 32, 1, 32, 2, 116, 34, 3, 65, 0, 16, 10, 34, 2, 32, 3, 16, 13, 32, 0, 69, 4, 64, 65, 12, 65, 2, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 2, 34, 1, 32, 0, 40, 2, 0, 34, 4, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 4, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 32, 0, 32, 2, 54, 2, 4, 32, 0, 32, 3, 54, 2, 8, 32, 0, 11, 46, 1, 2, 127, 65, 12, 65, 5, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 65, 128, 2, 65, 3, 16, 14, 11, 9, 0, 65, 63, 32, 0, 121, 167, 107, 11, 49, 1, 2, 127, 65, 63, 32, 1, 121, 167, 107, 33, 2, 3, 64, 65, 63, 32, 0, 121, 167, 107, 32, 2, 107, 34, 3, 65, 0, 78, 4, 64, 32, 0, 32, 1, 32, 3, 172, 134, 133, 33, 0, 12, 1, 11, 11, 32, 0, 11, 40, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 163, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 65, 0, 58, 0, 0, 11, 38, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 152, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 45, 0, 0, 11, 254, 5, 2, 1, 127, 4, 126, 32, 0, 69, 4, 64, 65, 232, 0, 65, 6, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 32, 0, 66, 0, 55, 3, 40, 32, 0, 66, 0, 55, 3, 48, 32, 0, 66, 0, 55, 3, 56, 32, 0, 66, 0, 55, 3, 64, 32, 0, 66, 0, 55, 3, 72, 32, 0, 66, 0, 55, 3, 80, 32, 0, 66, 0, 55, 3, 88, 32, 0, 66, 0, 55, 3, 96, 32, 0, 32, 2, 173, 55, 3, 80, 32, 0, 32, 3, 173, 55, 3, 88, 65, 12, 65, 4, 16, 10, 34, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 32, 4, 65, 0, 16, 14, 33, 2, 32, 0, 40, 2, 0, 16, 12, 32, 0, 32, 2, 54, 2, 0, 32, 0, 32, 4, 54, 2, 4, 32, 0, 66, 1, 32, 1, 173, 134, 66, 1, 125, 55, 3, 96, 32, 0, 66, 243, 130, 183, 218, 216, 230, 232, 30, 55, 3, 72, 35, 4, 69, 4, 64, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 32, 2, 65, 255, 1, 113, 173, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 65, 0, 33, 4, 3, 64, 32, 4, 32, 0, 40, 2, 4, 65, 1, 107, 72, 4, 64, 32, 6, 66, 8, 134, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 4, 65, 1, 106, 33, 4, 12, 1, 11, 11, 35, 6, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 63, 32, 0, 41, 3, 72, 121, 167, 107, 172, 33, 7, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 35, 5, 33, 1, 32, 2, 172, 32, 7, 134, 34, 8, 33, 6, 65, 63, 32, 0, 41, 3, 72, 34, 9, 121, 167, 107, 33, 3, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 3, 107, 34, 4, 65, 0, 78, 4, 64, 32, 6, 32, 9, 32, 4, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 1, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 32, 8, 132, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 1, 36, 4, 11, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 65, 0, 33, 2, 3, 64, 32, 2, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 2, 16, 18, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 6, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 6, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 0, 11, 38, 1, 1, 127, 32, 0, 40, 2, 0, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 55, 1, 2, 127, 32, 1, 32, 0, 40, 2, 0, 34, 2, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 11, 7, 0, 32, 0, 40, 2, 4, 11, 9, 0, 32, 0, 32, 1, 54, 2, 4, 11, 7, 0, 32, 0, 40, 2, 8, 11, 9, 0, 32, 0, 32, 1, 54, 2, 8, 11, 7, 0, 32, 0, 41, 3, 16, 11, 9, 0, 32, 0, 32, 1, 55, 3, 16, 11, 7, 0, 32, 0, 41, 3, 24, 11, 9, 0, 32, 0, 32, 1, 55, 3, 24, 11, 7, 0, 32, 0, 41, 3, 32, 11, 9, 0, 32, 0, 32, 1, 55, 3, 32, 11, 7, 0, 32, 0, 41, 3, 40, 11, 9, 0, 32, 0, 32, 1, 55, 3, 40, 11, 7, 0, 32, 0, 41, 3, 48, 11, 9, 0, 32, 0, 32, 1, 55, 3, 48, 11, 7, 0, 32, 0, 41, 3, 56, 11, 9, 0, 32, 0, 32, 1, 55, 3, 56, 11, 7, 0, 32, 0, 41, 3, 64, 11, 9, 0, 32, 0, 32, 1, 55, 3, 64, 11, 7, 0, 32, 0, 41, 3, 72, 11, 9, 0, 32, 0, 32, 1, 55, 3, 72, 11, 7, 0, 32, 0, 41, 3, 80, 11, 9, 0, 32, 0, 32, 1, 55, 3, 80, 11, 7, 0, 32, 0, 41, 3, 88, 11, 9, 0, 32, 0, 32, 1, 55, 3, 88, 11, 7, 0, 32, 0, 41, 3, 96, 11, 9, 0, 32, 0, 32, 1, 55, 3, 96, 11, 172, 4, 2, 5, 127, 1, 126, 32, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 4, 32, 4, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 33, 4, 65, 0, 33, 2, 32, 1, 40, 2, 8, 33, 5, 32, 1, 40, 2, 4, 33, 6, 3, 64, 2, 127, 65, 0, 33, 3, 3, 64, 32, 3, 32, 5, 72, 4, 64, 32, 3, 32, 6, 106, 45, 0, 0, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 7, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 32, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 7, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 1, 173, 32, 8, 66, 8, 134, 132, 133, 55, 3, 40, 32, 0, 32, 0, 41, 3, 16, 66, 1, 124, 55, 3, 16, 32, 0, 32, 0, 41, 3, 24, 66, 1, 124, 55, 3, 24, 32, 0, 41, 3, 16, 32, 0, 41, 3, 80, 90, 4, 127, 32, 0, 41, 3, 40, 32, 0, 41, 3, 96, 131, 80, 5, 65, 0, 11, 4, 127, 65, 1, 5, 32, 0, 41, 3, 16, 32, 0, 41, 3, 88, 90, 11, 4, 64, 32, 0, 32, 0, 41, 3, 32, 55, 3, 48, 32, 0, 32, 0, 41, 3, 16, 55, 3, 56, 32, 0, 32, 0, 41, 3, 40, 55, 3, 64, 65, 0, 33, 1, 3, 64, 32, 1, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 1, 16, 18, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 8, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 3, 65, 1, 106, 12, 3, 11, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 34, 1, 65, 0, 78, 4, 64, 32, 5, 32, 1, 107, 33, 5, 32, 1, 32, 6, 106, 33, 6, 32, 2, 34, 1, 65, 1, 106, 33, 2, 32, 4, 40, 2, 4, 32, 1, 65, 2, 116, 106, 32, 0, 41, 3, 56, 62, 2, 0, 12, 1, 11, 11, 32, 4, 11, 10, 0, 16, 15, 36, 5, 16, 15, 36, 6, 11, 3, 0, 1, 11, 73, 1, 2, 127, 32, 0, 40, 2, 4, 34, 1, 65, 255, 255, 255, 255, 0, 113, 34, 2, 65, 1, 70, 4, 64, 32, 0, 65, 16, 106, 16, 53, 32, 0, 32, 0, 40, 2, 0, 65, 1, 114, 54, 2, 0, 35, 0, 32, 0, 16, 2, 5, 32, 0, 32, 2, 65, 1, 107, 32, 1, 65, 128, 128, 128, 128, 127, 113, 114, 54, 2, 4, 11, 11, 58, 0, 2, 64, 2, 64, 2, 64, 32, 0, 65, 8, 107, 40, 2, 0, 14, 7, 0, 0, 1, 1, 1, 1, 1, 2, 11, 15, 11, 32, 0, 40, 2, 0, 34, 0, 4, 64, 32, 0, 65, 172, 3, 79, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 15, 11, 0, 11, 11, 137, 3, 7, 0, 65, 16, 11, 55, 40, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 40, 0, 0, 0, 97, 0, 108, 0, 108, 0, 111, 0, 99, 0, 97, 0, 116, 0, 105, 0, 111, 0, 110, 0, 32, 0, 116, 0, 111, 0, 111, 0, 32, 0, 108, 0, 97, 0, 114, 0, 103, 0, 101, 0, 65, 208, 0, 11, 45, 30, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 30, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 114, 0, 116, 0, 47, 0, 116, 0, 108, 0, 115, 0, 102, 0, 46, 0, 116, 0, 115, 0, 65, 128, 1, 11, 43, 28, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 73, 0, 110, 0, 118, 0, 97, 0, 108, 0, 105, 0, 100, 0, 32, 0, 108, 0, 101, 0, 110, 0, 103, 0, 116, 0, 104, 0, 65, 176, 1, 11, 53, 38, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 38, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 98, 0, 117, 0, 102, 0, 102, 0, 101, 0, 114, 0, 46, 0, 116, 0, 115, 0, 65, 240, 1, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 73, 0, 110, 0, 100, 0, 101, 0, 120, 0, 32, 0, 111, 0, 117, 0, 116, 0, 32, 0, 111, 0, 102, 0, 32, 0, 114, 0, 97, 0, 110, 0, 103, 0, 101, 0, 65, 176, 2, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 116, 0, 121, 0, 112, 0, 101, 0, 100, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 46, 0, 116, 0, 115, 0, 65, 240, 2, 11, 53, 7, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 145, 4, 0, 0, 2, 0, 0, 0, 49, 0, 0, 0, 2, 0, 0, 0, 17, 1, 0, 0, 2, 0, 0, 0, 16, 0, 34, 16, 115, 111, 117, 114, 99, 101, 77, 97, 112, 112, 105, 110, 103, 85, 82, 76, 16, 46, 47, 114, 97, 98, 105, 110, 46, 119, 97, 115, 109, 46, 109, 97, 112]);
      return instantiate(new Response(new Blob([wasm], { type: "application/wasm" })), imp);
    }
    module2.exports = loadWebAssembly;
  }
});
var require_src2 = __commonJS({
  "node_modules/rabin-wasm/src/index.js"(exports2, module2) {
    var Rabin = require_rabin();
    var getRabin = require_rabin_wasm();
    var create10 = async (avg, min, max, windowSize, polynomial) => {
      const compiled = await getRabin();
      return new Rabin(compiled, avg, min, max, windowSize, polynomial);
    };
    module2.exports = {
      Rabin,
      create: create10
    };
  }
});
var require_sparse_array = __commonJS({
  "node_modules/sparse-array/index.js"(exports2, module2) {
    var BITS_PER_BYTE = 7;
    module2.exports = class SparseArray {
      constructor() {
        this._bitArrays = [];
        this._data = [];
        this._length = 0;
        this._changedLength = false;
        this._changedData = false;
      }
      set(index2, value2) {
        let pos = this._internalPositionFor(index2, false);
        if (value2 === void 0) {
          if (pos !== -1) {
            this._unsetInternalPos(pos);
            this._unsetBit(index2);
            this._changedLength = true;
            this._changedData = true;
          }
        } else {
          let needsSort = false;
          if (pos === -1) {
            pos = this._data.length;
            this._setBit(index2);
            this._changedData = true;
          } else {
            needsSort = true;
          }
          this._setInternalPos(pos, index2, value2, needsSort);
          this._changedLength = true;
        }
      }
      unset(index2) {
        this.set(index2, void 0);
      }
      get(index2) {
        this._sortData();
        const pos = this._internalPositionFor(index2, true);
        if (pos === -1) {
          return void 0;
        }
        return this._data[pos][1];
      }
      push(value2) {
        this.set(this.length, value2);
        return this.length;
      }
      get length() {
        this._sortData();
        if (this._changedLength) {
          const last2 = this._data[this._data.length - 1];
          this._length = last2 ? last2[0] + 1 : 0;
          this._changedLength = false;
        }
        return this._length;
      }
      forEach(iterator) {
        let i2 = 0;
        while (i2 < this.length) {
          iterator(this.get(i2), i2, this);
          i2++;
        }
      }
      map(iterator) {
        let i2 = 0;
        let mapped = new Array(this.length);
        while (i2 < this.length) {
          mapped[i2] = iterator(this.get(i2), i2, this);
          i2++;
        }
        return mapped;
      }
      reduce(reducer, initialValue) {
        let i2 = 0;
        let acc = initialValue;
        while (i2 < this.length) {
          const value2 = this.get(i2);
          acc = reducer(acc, value2, i2);
          i2++;
        }
        return acc;
      }
      find(finder) {
        let i2 = 0, found, last2;
        while (i2 < this.length && !found) {
          last2 = this.get(i2);
          found = finder(last2);
          i2++;
        }
        return found ? last2 : void 0;
      }
      _internalPositionFor(index2, noCreate) {
        const bytePos = this._bytePosFor(index2, noCreate);
        if (bytePos >= this._bitArrays.length) {
          return -1;
        }
        const byte = this._bitArrays[bytePos];
        const bitPos = index2 - bytePos * BITS_PER_BYTE;
        const exists2 = (byte & 1 << bitPos) > 0;
        if (!exists2) {
          return -1;
        }
        const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
        const mask = ~(4294967295 << bitPos + 1);
        const bytePopCount = popCount(byte & mask);
        const arrayPos = previousPopCount + bytePopCount - 1;
        return arrayPos;
      }
      _bytePosFor(index2, noCreate) {
        const bytePos = Math.floor(index2 / BITS_PER_BYTE);
        const targetLength = bytePos + 1;
        while (!noCreate && this._bitArrays.length < targetLength) {
          this._bitArrays.push(0);
        }
        return bytePos;
      }
      _setBit(index2) {
        const bytePos = this._bytePosFor(index2, false);
        this._bitArrays[bytePos] |= 1 << index2 - bytePos * BITS_PER_BYTE;
      }
      _unsetBit(index2) {
        const bytePos = this._bytePosFor(index2, false);
        this._bitArrays[bytePos] &= ~(1 << index2 - bytePos * BITS_PER_BYTE);
      }
      _setInternalPos(pos, index2, value2, needsSort) {
        const data = this._data;
        const elem = [index2, value2];
        if (needsSort) {
          this._sortData();
          data[pos] = elem;
        } else {
          if (data.length) {
            if (data[data.length - 1][0] >= index2) {
              data.push(elem);
            } else if (data[0][0] <= index2) {
              data.unshift(elem);
            } else {
              const randomIndex = Math.round(data.length / 2);
              this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));
            }
          } else {
            this._data.push(elem);
          }
          this._changedData = true;
          this._changedLength = true;
        }
      }
      _unsetInternalPos(pos) {
        this._data.splice(pos, 1);
      }
      _sortData() {
        if (this._changedData) {
          this._data.sort(sortInternal);
        }
        this._changedData = false;
      }
      bitField() {
        const bytes2 = [];
        let pendingBitsForResultingByte = 8;
        let pendingBitsForNewByte = 0;
        let resultingByte = 0;
        let newByte;
        const pending = this._bitArrays.slice();
        while (pending.length || pendingBitsForNewByte) {
          if (pendingBitsForNewByte === 0) {
            newByte = pending.shift();
            pendingBitsForNewByte = 7;
          }
          const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
          const mask = ~(255 << usingBits);
          const masked = newByte & mask;
          resultingByte |= masked << 8 - pendingBitsForResultingByte;
          newByte = newByte >>> usingBits;
          pendingBitsForNewByte -= usingBits;
          pendingBitsForResultingByte -= usingBits;
          if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
            bytes2.push(resultingByte);
            resultingByte = 0;
            pendingBitsForResultingByte = 8;
          }
        }
        for (var i2 = bytes2.length - 1; i2 > 0; i2--) {
          const value2 = bytes2[i2];
          if (value2 === 0) {
            bytes2.pop();
          } else {
            break;
          }
        }
        return bytes2;
      }
      compactArray() {
        this._sortData();
        return this._data.map(valueOnly);
      }
    };
    function popCountReduce(count, byte) {
      return count + popCount(byte);
    }
    function popCount(_v) {
      let v = _v;
      v = v - (v >> 1 & 1431655765);
      v = (v & 858993459) + (v >> 2 & 858993459);
      return (v + (v >> 4) & 252645135) * 16843009 >> 24;
    }
    function sortInternal(a, b) {
      return a[0] - b[0];
    }
    function valueOnly(elem) {
      return elem[1];
    }
  }
});
var require_index_browser = __commonJS({
  "node_modules/iso-constants/index.browser.js"(exports2, module2) {
    module2.exports = {
      "RTLD_LAZY": 1,
      "RTLD_NOW": 2,
      "RTLD_GLOBAL": 256,
      "RTLD_LOCAL": 0,
      "RTLD_DEEPBIND": 8,
      "E2BIG": 7,
      "EACCES": 13,
      "EADDRINUSE": 98,
      "EADDRNOTAVAIL": 99,
      "EAFNOSUPPORT": 97,
      "EAGAIN": 11,
      "EALREADY": 114,
      "EBADF": 9,
      "EBADMSG": 74,
      "EBUSY": 16,
      "ECANCELED": 125,
      "ECHILD": 10,
      "ECONNABORTED": 103,
      "ECONNREFUSED": 111,
      "ECONNRESET": 104,
      "EDEADLK": 35,
      "EDESTADDRREQ": 89,
      "EDOM": 33,
      "EDQUOT": 122,
      "EEXIST": 17,
      "EFAULT": 14,
      "EFBIG": 27,
      "EHOSTUNREACH": 113,
      "EIDRM": 43,
      "EILSEQ": 84,
      "EINPROGRESS": 115,
      "EINTR": 4,
      "EINVAL": 22,
      "EIO": 5,
      "EISCONN": 106,
      "EISDIR": 21,
      "ELOOP": 40,
      "EMFILE": 24,
      "EMLINK": 31,
      "EMSGSIZE": 90,
      "EMULTIHOP": 72,
      "ENAMETOOLONG": 36,
      "ENETDOWN": 100,
      "ENETRESET": 102,
      "ENETUNREACH": 101,
      "ENFILE": 23,
      "ENOBUFS": 105,
      "ENODATA": 61,
      "ENODEV": 19,
      "ENOENT": 2,
      "ENOEXEC": 8,
      "ENOLCK": 37,
      "ENOLINK": 67,
      "ENOMEM": 12,
      "ENOMSG": 42,
      "ENOPROTOOPT": 92,
      "ENOSPC": 28,
      "ENOSR": 63,
      "ENOSTR": 60,
      "ENOSYS": 38,
      "ENOTCONN": 107,
      "ENOTDIR": 20,
      "ENOTEMPTY": 39,
      "ENOTSOCK": 88,
      "ENOTSUP": 95,
      "ENOTTY": 25,
      "ENXIO": 6,
      "EOPNOTSUPP": 95,
      "EOVERFLOW": 75,
      "EPERM": 1,
      "EPIPE": 32,
      "EPROTO": 71,
      "EPROTONOSUPPORT": 93,
      "EPROTOTYPE": 91,
      "ERANGE": 34,
      "EROFS": 30,
      "ESPIPE": 29,
      "ESRCH": 3,
      "ESTALE": 116,
      "ETIME": 62,
      "ETIMEDOUT": 110,
      "ETXTBSY": 26,
      "EWOULDBLOCK": 11,
      "EXDEV": 18,
      "PRIORITY_LOW": 19,
      "PRIORITY_BELOW_NORMAL": 10,
      "PRIORITY_NORMAL": 0,
      "PRIORITY_ABOVE_NORMAL": -7,
      "PRIORITY_HIGH": -14,
      "PRIORITY_HIGHEST": -20,
      "SIGHUP": 1,
      "SIGINT": 2,
      "SIGQUIT": 3,
      "SIGILL": 4,
      "SIGTRAP": 5,
      "SIGABRT": 6,
      "SIGIOT": 6,
      "SIGBUS": 7,
      "SIGFPE": 8,
      "SIGKILL": 9,
      "SIGUSR1": 10,
      "SIGSEGV": 11,
      "SIGUSR2": 12,
      "SIGPIPE": 13,
      "SIGALRM": 14,
      "SIGTERM": 15,
      "SIGCHLD": 17,
      "SIGSTKFLT": 16,
      "SIGCONT": 18,
      "SIGSTOP": 19,
      "SIGTSTP": 20,
      "SIGTTIN": 21,
      "SIGTTOU": 22,
      "SIGURG": 23,
      "SIGXCPU": 24,
      "SIGXFSZ": 25,
      "SIGVTALRM": 26,
      "SIGPROF": 27,
      "SIGWINCH": 28,
      "SIGIO": 29,
      "SIGPOLL": 29,
      "SIGPWR": 30,
      "SIGSYS": 31,
      "UV_FS_SYMLINK_DIR": 1,
      "UV_FS_SYMLINK_JUNCTION": 2,
      "O_RDONLY": 0,
      "O_WRONLY": 1,
      "O_RDWR": 2,
      "UV_DIRENT_UNKNOWN": 0,
      "UV_DIRENT_FILE": 1,
      "UV_DIRENT_DIR": 2,
      "UV_DIRENT_LINK": 3,
      "UV_DIRENT_FIFO": 4,
      "UV_DIRENT_SOCKET": 5,
      "UV_DIRENT_CHAR": 6,
      "UV_DIRENT_BLOCK": 7,
      "S_IFMT": 61440,
      "S_IFREG": 32768,
      "S_IFDIR": 16384,
      "S_IFCHR": 8192,
      "S_IFBLK": 24576,
      "S_IFIFO": 4096,
      "S_IFLNK": 40960,
      "S_IFSOCK": 49152,
      "O_CREAT": 64,
      "O_EXCL": 128,
      "UV_FS_O_FILEMAP": 0,
      "O_NOCTTY": 256,
      "O_TRUNC": 512,
      "O_APPEND": 1024,
      "O_DIRECTORY": 65536,
      "O_NOATIME": 262144,
      "O_NOFOLLOW": 131072,
      "O_SYNC": 1052672,
      "O_DSYNC": 4096,
      "O_DIRECT": 16384,
      "O_NONBLOCK": 2048,
      "S_IRWXU": 448,
      "S_IRUSR": 256,
      "S_IWUSR": 128,
      "S_IXUSR": 64,
      "S_IRWXG": 56,
      "S_IRGRP": 32,
      "S_IWGRP": 16,
      "S_IXGRP": 8,
      "S_IRWXO": 7,
      "S_IROTH": 4,
      "S_IWOTH": 2,
      "S_IXOTH": 1,
      "F_OK": 0,
      "R_OK": 4,
      "W_OK": 2,
      "X_OK": 1,
      "UV_FS_COPYFILE_EXCL": 1,
      "COPYFILE_EXCL": 1,
      "UV_FS_COPYFILE_FICLONE": 2,
      "COPYFILE_FICLONE": 2,
      "UV_FS_COPYFILE_FICLONE_FORCE": 4,
      "COPYFILE_FICLONE_FORCE": 4,
      "OPENSSL_VERSION_NUMBER": 805306480,
      "SSL_OP_ALL": 2147485776,
      "SSL_OP_ALLOW_NO_DHE_KEX": 1024,
      "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION": 262144,
      "SSL_OP_CIPHER_SERVER_PREFERENCE": 4194304,
      "SSL_OP_CISCO_ANYCONNECT": 32768,
      "SSL_OP_COOKIE_EXCHANGE": 8192,
      "SSL_OP_CRYPTOPRO_TLSEXT_BUG": 2147483648,
      "SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS": 2048,
      "SSL_OP_EPHEMERAL_RSA": 0,
      "SSL_OP_LEGACY_SERVER_CONNECT": 4,
      "SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER": 0,
      "SSL_OP_MICROSOFT_SESS_ID_BUG": 0,
      "SSL_OP_MSIE_SSLV2_RSA_PADDING": 0,
      "SSL_OP_NETSCAPE_CA_DN_BUG": 0,
      "SSL_OP_NETSCAPE_CHALLENGE_BUG": 0,
      "SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG": 0,
      "SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG": 0,
      "SSL_OP_NO_COMPRESSION": 131072,
      "SSL_OP_NO_ENCRYPT_THEN_MAC": 524288,
      "SSL_OP_NO_QUERY_MTU": 4096,
      "SSL_OP_NO_RENEGOTIATION": 1073741824,
      "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION": 65536,
      "SSL_OP_NO_SSLv2": 0,
      "SSL_OP_NO_SSLv3": 33554432,
      "SSL_OP_NO_TICKET": 16384,
      "SSL_OP_NO_TLSv1": 67108864,
      "SSL_OP_NO_TLSv1_1": 268435456,
      "SSL_OP_NO_TLSv1_2": 134217728,
      "SSL_OP_NO_TLSv1_3": 536870912,
      "SSL_OP_PKCS1_CHECK_1": 0,
      "SSL_OP_PKCS1_CHECK_2": 0,
      "SSL_OP_PRIORITIZE_CHACHA": 2097152,
      "SSL_OP_SINGLE_DH_USE": 0,
      "SSL_OP_SINGLE_ECDH_USE": 0,
      "SSL_OP_SSLEAY_080_CLIENT_DH_BUG": 0,
      "SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG": 0,
      "SSL_OP_TLS_BLOCK_PADDING_BUG": 0,
      "SSL_OP_TLS_D5_BUG": 0,
      "SSL_OP_TLS_ROLLBACK_BUG": 8388608,
      "ENGINE_METHOD_RSA": 1,
      "ENGINE_METHOD_DSA": 2,
      "ENGINE_METHOD_DH": 4,
      "ENGINE_METHOD_RAND": 8,
      "ENGINE_METHOD_EC": 2048,
      "ENGINE_METHOD_CIPHERS": 64,
      "ENGINE_METHOD_DIGESTS": 128,
      "ENGINE_METHOD_PKEY_METHS": 512,
      "ENGINE_METHOD_PKEY_ASN1_METHS": 1024,
      "ENGINE_METHOD_ALL": 65535,
      "ENGINE_METHOD_NONE": 0,
      "DH_CHECK_P_NOT_SAFE_PRIME": 2,
      "DH_CHECK_P_NOT_PRIME": 1,
      "DH_UNABLE_TO_CHECK_GENERATOR": 4,
      "DH_NOT_SUITABLE_GENERATOR": 8,
      "ALPN_ENABLED": 1,
      "RSA_PKCS1_PADDING": 1,
      "RSA_NO_PADDING": 3,
      "RSA_PKCS1_OAEP_PADDING": 4,
      "RSA_X931_PADDING": 5,
      "RSA_PKCS1_PSS_PADDING": 6,
      "RSA_PSS_SALTLEN_DIGEST": -1,
      "RSA_PSS_SALTLEN_MAX_SIGN": -2,
      "RSA_PSS_SALTLEN_AUTO": -2,
      "defaultCoreCipherList": "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
      "TLS1_VERSION": 769,
      "TLS1_1_VERSION": 770,
      "TLS1_2_VERSION": 771,
      "TLS1_3_VERSION": 772,
      "POINT_CONVERSION_COMPRESSED": 2,
      "POINT_CONVERSION_UNCOMPRESSED": 4,
      "POINT_CONVERSION_HYBRID": 6
    };
  }
});
var require_fnv1a = __commonJS({
  "node_modules/fnv1a/index.js"(exports2, module2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    hash3.BASE = 2166136261;
    function hash3(s, h = hash3.BASE) {
      const l = s.length;
      for (let i2 = 0; i2 < l; i2++) {
        h ^= s.charCodeAt(i2);
        h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
      }
      return h >>> 0;
    }
    exports2.default = hash3;
    module2.exports = hash3;
  }
});
var require_bytes = __commonJS({
  "node_modules/bytes/index.js"(exports2, module2) {
    module2.exports = bytes2;
    module2.exports.format = format2;
    module2.exports.parse = parse5;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map4 = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes2(value2, options) {
      if (typeof value2 === "string") {
        return parse5(value2);
      }
      if (typeof value2 === "number") {
        return format2(value2, options);
      }
      return null;
    }
    function format2(value2, options) {
      if (!Number.isFinite(value2)) {
        return null;
      }
      var mag = Math.abs(value2);
      var thousandsSeparator = options && options.thousandsSeparator || "";
      var unitSeparator = options && options.unitSeparator || "";
      var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
      var fixedDecimals = Boolean(options && options.fixedDecimals);
      var unit = options && options.unit || "";
      if (!unit || !map4[unit.toLowerCase()]) {
        if (mag >= map4.pb) {
          unit = "PB";
        } else if (mag >= map4.tb) {
          unit = "TB";
        } else if (mag >= map4.gb) {
          unit = "GB";
        } else if (mag >= map4.mb) {
          unit = "MB";
        } else if (mag >= map4.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value2 / map4[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.split(".").map(function(s, i2) {
          return i2 === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
        }).join(".");
      }
      return str + unitSeparator + unit;
    }
    function parse5(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      if (isNaN(floatValue)) {
        return null;
      }
      return Math.floor(map4[unit] * floatValue);
    }
  }
});
var require_level_supports = __commonJS({
  "node_modules/level-supports/index.js"(exports2) {
    exports2.supports = function supports(...manifests) {
      const manifest = manifests.reduce((acc, m) => Object.assign(acc, m), {});
      return Object.assign(manifest, {
        snapshots: manifest.snapshots || false,
        permanence: manifest.permanence || false,
        seek: manifest.seek || false,
        clear: manifest.clear || false,
        getMany: manifest.getMany || false,
        keyIterator: manifest.keyIterator || false,
        valueIterator: manifest.valueIterator || false,
        iteratorNextv: manifest.iteratorNextv || false,
        iteratorAll: manifest.iteratorAll || false,
        status: manifest.status || false,
        createIfMissing: manifest.createIfMissing || false,
        errorIfExists: manifest.errorIfExists || false,
        deferredOpen: manifest.deferredOpen || false,
        promises: manifest.promises || false,
        streams: manifest.streams || false,
        encodings: Object.assign({}, manifest.encodings),
        events: Object.assign({}, manifest.events),
        additionalMethods: Object.assign({}, manifest.additionalMethods)
      });
    };
  }
});
var require_module_error = __commonJS({
  "node_modules/module-error/index.js"(exports2, module2) {
    module2.exports = class ModuleError extends Error {
      /**
       * @param {string} message Error message
       * @param {{ code?: string, cause?: Error, expected?: boolean, transient?: boolean }} [options]
       */
      constructor(message2, options) {
        super(message2 || "");
        if (typeof options === "object" && options !== null) {
          if (options.code)
            this.code = String(options.code);
          if (options.expected)
            this.expected = true;
          if (options.transient)
            this.transient = true;
          if (options.cause)
            this.cause = options.cause;
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
    };
  }
});
var require_text_endec = __commonJS({
  "node_modules/level-transcoder/lib/text-endec.js"(exports2, module2) {
    var lazy = null;
    module2.exports = function() {
      if (lazy === null) {
        lazy = {
          textEncoder: new TextEncoder(),
          textDecoder: new TextDecoder()
        };
      }
      return lazy;
    };
  }
});
var require_encoding = __commonJS({
  "node_modules/level-transcoder/lib/encoding.js"(exports2) {
    var ModuleError = require_module_error();
    var formats = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
    var Encoding = class {
      /**
       * @param {IEncoding<TIn,TFormat,TOut>} options
       */
      constructor(options) {
        this.encode = options.encode || this.encode;
        this.decode = options.decode || this.decode;
        this.name = options.name || this.name;
        this.format = options.format || this.format;
        if (typeof this.encode !== "function") {
          throw new TypeError("The 'encode' property must be a function");
        }
        if (typeof this.decode !== "function") {
          throw new TypeError("The 'decode' property must be a function");
        }
        this.encode = this.encode.bind(this);
        this.decode = this.decode.bind(this);
        if (typeof this.name !== "string" || this.name === "") {
          throw new TypeError("The 'name' property must be a string");
        }
        if (typeof this.format !== "string" || !formats.has(this.format)) {
          throw new TypeError("The 'format' property must be one of 'buffer', 'view', 'utf8'");
        }
        if (options.createViewTranscoder) {
          this.createViewTranscoder = options.createViewTranscoder;
        }
        if (options.createBufferTranscoder) {
          this.createBufferTranscoder = options.createBufferTranscoder;
        }
        if (options.createUTF8Transcoder) {
          this.createUTF8Transcoder = options.createUTF8Transcoder;
        }
      }
      get commonName() {
        return (
          /** @type {string} */
          this.name.split("+")[0]
        );
      }
      /** @return {BufferFormat<TIn,TOut>} */
      createBufferTranscoder() {
        throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'buffer'`, {
          code: "LEVEL_ENCODING_NOT_SUPPORTED"
        });
      }
      /** @return {ViewFormat<TIn,TOut>} */
      createViewTranscoder() {
        throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'view'`, {
          code: "LEVEL_ENCODING_NOT_SUPPORTED"
        });
      }
      /** @return {UTF8Format<TIn,TOut>} */
      createUTF8Transcoder() {
        throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'utf8'`, {
          code: "LEVEL_ENCODING_NOT_SUPPORTED"
        });
      }
    };
    exports2.Encoding = Encoding;
  }
});
var require_formats = __commonJS({
  "node_modules/level-transcoder/lib/formats.js"(exports2) {
    var { Buffer: Buffer2 } = require_buffer() || {};
    var { Encoding } = require_encoding();
    var textEndec = require_text_endec();
    var BufferFormat = class extends Encoding {
      /**
       * @param {Omit<IEncoding<TIn, Buffer, TOut>, 'format'>} options
       */
      constructor(options) {
        super({ ...options, format: "buffer" });
      }
      /** @override */
      createViewTranscoder() {
        return new ViewFormat({
          encode: this.encode,
          // Buffer is a view (UInt8Array)
          decode: (data) => this.decode(
            Buffer2.from(data.buffer, data.byteOffset, data.byteLength)
          ),
          name: `${this.name}+view`
        });
      }
      /** @override */
      createBufferTranscoder() {
        return this;
      }
    };
    var ViewFormat = class extends Encoding {
      /**
       * @param {Omit<IEncoding<TIn, Uint8Array, TOut>, 'format'>} options
       */
      constructor(options) {
        super({ ...options, format: "view" });
      }
      /** @override */
      createBufferTranscoder() {
        return new BufferFormat({
          encode: (data) => {
            const view = this.encode(data);
            return Buffer2.from(view.buffer, view.byteOffset, view.byteLength);
          },
          decode: this.decode,
          // Buffer is a view (UInt8Array)
          name: `${this.name}+buffer`
        });
      }
      /** @override */
      createViewTranscoder() {
        return this;
      }
    };
    var UTF8Format = class extends Encoding {
      /**
       * @param {Omit<IEncoding<TIn, string, TOut>, 'format'>} options
       */
      constructor(options) {
        super({ ...options, format: "utf8" });
      }
      /** @override */
      createBufferTranscoder() {
        return new BufferFormat({
          encode: (data) => Buffer2.from(this.encode(data), "utf8"),
          decode: (data) => this.decode(data.toString("utf8")),
          name: `${this.name}+buffer`
        });
      }
      /** @override */
      createViewTranscoder() {
        const { textEncoder: textEncoder5, textDecoder: textDecoder4 } = textEndec();
        return new ViewFormat({
          encode: (data) => textEncoder5.encode(this.encode(data)),
          decode: (data) => this.decode(textDecoder4.decode(data)),
          name: `${this.name}+view`
        });
      }
      /** @override */
      createUTF8Transcoder() {
        return this;
      }
    };
    exports2.BufferFormat = BufferFormat;
    exports2.ViewFormat = ViewFormat;
    exports2.UTF8Format = UTF8Format;
  }
});
var require_encodings = __commonJS({
  "node_modules/level-transcoder/lib/encodings.js"(exports2) {
    var { Buffer: Buffer2 } = require_buffer() || { Buffer: { isBuffer: () => false } };
    var { textEncoder: textEncoder5, textDecoder: textDecoder4 } = require_text_endec()();
    var { BufferFormat, ViewFormat, UTF8Format } = require_formats();
    var identity3 = (v) => v;
    exports2.utf8 = new UTF8Format({
      encode: function(data) {
        return Buffer2.isBuffer(data) ? data.toString("utf8") : ArrayBuffer.isView(data) ? textDecoder4.decode(data) : String(data);
      },
      decode: identity3,
      name: "utf8",
      createViewTranscoder() {
        return new ViewFormat({
          encode: function(data) {
            return ArrayBuffer.isView(data) ? data : textEncoder5.encode(data);
          },
          decode: function(data) {
            return textDecoder4.decode(data);
          },
          name: `${this.name}+view`
        });
      },
      createBufferTranscoder() {
        return new BufferFormat({
          encode: function(data) {
            return Buffer2.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer2.from(data.buffer, data.byteOffset, data.byteLength) : Buffer2.from(String(data), "utf8");
          },
          decode: function(data) {
            return data.toString("utf8");
          },
          name: `${this.name}+buffer`
        });
      }
    });
    exports2.json = new UTF8Format({
      encode: JSON.stringify,
      decode: JSON.parse,
      name: "json"
    });
    exports2.buffer = new BufferFormat({
      encode: function(data) {
        return Buffer2.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer2.from(data.buffer, data.byteOffset, data.byteLength) : Buffer2.from(String(data), "utf8");
      },
      decode: identity3,
      name: "buffer",
      createViewTranscoder() {
        return new ViewFormat({
          encode: function(data) {
            return ArrayBuffer.isView(data) ? data : Buffer2.from(String(data), "utf8");
          },
          decode: function(data) {
            return Buffer2.from(data.buffer, data.byteOffset, data.byteLength);
          },
          name: `${this.name}+view`
        });
      }
    });
    exports2.view = new ViewFormat({
      encode: function(data) {
        return ArrayBuffer.isView(data) ? data : textEncoder5.encode(data);
      },
      decode: identity3,
      name: "view",
      createBufferTranscoder() {
        return new BufferFormat({
          encode: function(data) {
            return Buffer2.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer2.from(data.buffer, data.byteOffset, data.byteLength) : Buffer2.from(String(data), "utf8");
          },
          decode: identity3,
          name: `${this.name}+buffer`
        });
      }
    });
    exports2.hex = new BufferFormat({
      encode: function(data) {
        return Buffer2.isBuffer(data) ? data : Buffer2.from(String(data), "hex");
      },
      decode: function(buffer2) {
        return buffer2.toString("hex");
      },
      name: "hex"
    });
    exports2.base64 = new BufferFormat({
      encode: function(data) {
        return Buffer2.isBuffer(data) ? data : Buffer2.from(String(data), "base64");
      },
      decode: function(buffer2) {
        return buffer2.toString("base64");
      },
      name: "base64"
    });
  }
});
var require_level_transcoder = __commonJS({
  "node_modules/level-transcoder/index.js"(exports2) {
    var ModuleError = require_module_error();
    var encodings = require_encodings();
    var { Encoding } = require_encoding();
    var { BufferFormat, ViewFormat, UTF8Format } = require_formats();
    var kFormats = Symbol("formats");
    var kEncodings = Symbol("encodings");
    var validFormats = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
    var Transcoder = class {
      /**
       * @param {Array<'buffer'|'view'|'utf8'>} formats
       */
      constructor(formats) {
        if (!Array.isArray(formats)) {
          throw new TypeError("The first argument 'formats' must be an array");
        } else if (!formats.every((f) => validFormats.has(f))) {
          throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
        }
        this[kEncodings] = /* @__PURE__ */ new Map();
        this[kFormats] = new Set(formats);
        for (const k in encodings) {
          try {
            this.encoding(k);
          } catch (err2) {
            if (err2.code !== "LEVEL_ENCODING_NOT_SUPPORTED")
              throw err2;
          }
        }
      }
      /**
       * @returns {Array<Encoding<any,T,any>>}
       */
      encodings() {
        return Array.from(new Set(this[kEncodings].values()));
      }
      /**
       * @param {string|MixedEncoding<any, any, any>} encoding
       * @returns {Encoding<any, T, any>}
       */
      encoding(encoding) {
        let resolved = this[kEncodings].get(encoding);
        if (resolved === void 0) {
          if (typeof encoding === "string" && encoding !== "") {
            resolved = lookup3[encoding];
            if (!resolved) {
              throw new ModuleError(`Encoding '${encoding}' is not found`, {
                code: "LEVEL_ENCODING_NOT_FOUND"
              });
            }
          } else if (typeof encoding !== "object" || encoding === null) {
            throw new TypeError("First argument 'encoding' must be a string or object");
          } else {
            resolved = from3(encoding);
          }
          const { name: name9, format: format2 } = resolved;
          if (!this[kFormats].has(format2)) {
            if (this[kFormats].has("view")) {
              resolved = resolved.createViewTranscoder();
            } else if (this[kFormats].has("buffer")) {
              resolved = resolved.createBufferTranscoder();
            } else if (this[kFormats].has("utf8")) {
              resolved = resolved.createUTF8Transcoder();
            } else {
              throw new ModuleError(`Encoding '${name9}' cannot be transcoded`, {
                code: "LEVEL_ENCODING_NOT_SUPPORTED"
              });
            }
          }
          for (const k of [encoding, name9, resolved.name, resolved.commonName]) {
            this[kEncodings].set(k, resolved);
          }
        }
        return resolved;
      }
    };
    exports2.Transcoder = Transcoder;
    function from3(options) {
      if (options instanceof Encoding) {
        return options;
      }
      const maybeType = "type" in options && typeof options.type === "string" ? options.type : void 0;
      const name9 = options.name || maybeType || `anonymous-${anonymousCount++}`;
      switch (detectFormat(options)) {
        case "view":
          return new ViewFormat({ ...options, name: name9 });
        case "utf8":
          return new UTF8Format({ ...options, name: name9 });
        case "buffer":
          return new BufferFormat({ ...options, name: name9 });
        default: {
          throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
        }
      }
    }
    function detectFormat(options) {
      if ("format" in options && options.format !== void 0) {
        return options.format;
      } else if ("buffer" in options && typeof options.buffer === "boolean") {
        return options.buffer ? "buffer" : "utf8";
      } else if ("code" in options && Number.isInteger(options.code)) {
        return "view";
      } else {
        return "buffer";
      }
    }
    var aliases = {
      binary: encodings.buffer,
      "utf-8": encodings.utf8
    };
    var lookup3 = {
      ...encodings,
      ...aliases
    };
    var anonymousCount = 0;
  }
});
var require_events = __commonJS({
  "node_modules/events/events.js"(exports2, module2) {
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value2) {
      return value2 !== value2;
    };
    function EventEmitter6() {
      EventEmitter6.init.call(this);
    }
    module2.exports = EventEmitter6;
    module2.exports.once = once;
    EventEmitter6.EventEmitter = EventEmitter6;
    EventEmitter6.prototype._events = void 0;
    EventEmitter6.prototype._eventsCount = 0;
    EventEmitter6.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter6, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter6.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter6.prototype.setMaxListeners = function setMaxListeners12(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter6.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter6.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter6.prototype.emit = function emit(type) {
      var args = [];
      for (var i2 = 1; i2 < arguments.length; i2++)
        args.push(arguments[i2]);
      var doError = type === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err2 = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err2.context = er;
        throw err2;
      }
      var handler = events2[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i2 = 0; i2 < len; ++i2)
          ReflectApply(listeners[i2], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events2 = target._events;
        }
        existing = events2[type];
      }
      if (existing === void 0) {
        existing = events2[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter6.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter6.prototype.on = EventEmitter6.prototype.addListener;
    EventEmitter6.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter6.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter6.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter6.prototype.removeListener = function removeListener(type, listener) {
      var list, events2, position, i2, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0)
        return this;
      list = events2[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type];
          if (events2.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i2 = list.length - 1; i2 >= 0; i2--) {
          if (list[i2] === listener || list[i2].listener === listener) {
            originalListener = list[i2].listener;
            position = i2;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events2[type] = list[0];
        if (events2.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter6.prototype.off = EventEmitter6.prototype.removeListener;
    EventEmitter6.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events2, i2;
      events2 = this._events;
      if (events2 === void 0)
        return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events2[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events2);
        var key;
        for (i2 = 0; i2 < keys.length; ++i2) {
          key = keys[i2];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events2[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i2 = listeners.length - 1; i2 >= 0; i2--) {
          this.removeListener(type, listeners[i2]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap3) {
      var events2 = target._events;
      if (events2 === void 0)
        return [];
      var evlistener = events2[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap3 ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap3 ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter6.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter6.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter6.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter6.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter6.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i2 = 0; i2 < n; ++i2)
        copy[i2] = arr[i2];
      return copy;
    }
    function spliceOne(list, index2) {
      for (; index2 + 1 < list.length; index2++)
        list[index2] = list[index2 + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i2 = 0; i2 < ret.length; ++i2) {
        ret[i2] = arr[i2].listener || arr[i2];
      }
      return ret;
    }
    function once(emitter, name9) {
      return new Promise(function(resolve7, reject) {
        function errorListener(err2) {
          emitter.removeListener(name9, resolver);
          reject(err2);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve7([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name9, resolver, { once: true });
        if (name9 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name9, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name9, listener);
        } else {
          emitter.on(name9, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name9, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name9, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});
var require_next_tick_browser = __commonJS({
  "node_modules/catering/next-tick-browser.js"(exports2, module2) {
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn);
  }
});
var require_catering = __commonJS({
  "node_modules/catering/index.js"(exports2) {
    var nextTick2 = require_next_tick_browser();
    exports2.fromCallback = function(callback, symbol7) {
      if (callback === void 0) {
        var promise = new Promise(function(resolve7, reject) {
          callback = function(err2, res) {
            if (err2)
              reject(err2);
            else
              resolve7(res);
          };
        });
        callback[symbol7 !== void 0 ? symbol7 : "promise"] = promise;
      } else if (typeof callback !== "function") {
        throw new TypeError("Callback must be a function");
      }
      return callback;
    };
    exports2.fromPromise = function(promise, callback) {
      if (callback === void 0)
        return promise;
      promise.then(function(res) {
        nextTick2(() => callback(null, res));
      }).catch(function(err2) {
        nextTick2(() => callback(err2));
      });
    };
  }
});
var require_common2 = __commonJS({
  "node_modules/abstract-level/lib/common.js"(exports2) {
    exports2.getCallback = function(options, callback) {
      return typeof options === "function" ? options : callback;
    };
    exports2.getOptions = function(options, def2) {
      if (typeof options === "object" && options !== null) {
        return options;
      }
      if (def2 !== void 0) {
        return def2;
      }
      return {};
    };
  }
});
var require_abstract_iterator = __commonJS({
  "node_modules/abstract-level/abstract-iterator.js"(exports2) {
    var { fromCallback } = require_catering();
    var ModuleError = require_module_error();
    var { getOptions, getCallback } = require_common2();
    var kPromise = Symbol("promise");
    var kCallback = Symbol("callback");
    var kWorking = Symbol("working");
    var kHandleOne = Symbol("handleOne");
    var kHandleMany = Symbol("handleMany");
    var kAutoClose = Symbol("autoClose");
    var kFinishWork = Symbol("finishWork");
    var kReturnMany = Symbol("returnMany");
    var kClosing = Symbol("closing");
    var kHandleClose = Symbol("handleClose");
    var kClosed = Symbol("closed");
    var kCloseCallbacks = Symbol("closeCallbacks");
    var kKeyEncoding = Symbol("keyEncoding");
    var kValueEncoding = Symbol("valueEncoding");
    var kAbortOnClose = Symbol("abortOnClose");
    var kLegacy = Symbol("legacy");
    var kKeys = Symbol("keys");
    var kValues = Symbol("values");
    var kLimit = Symbol("limit");
    var kCount = Symbol("count");
    var emptyOptions = Object.freeze({});
    var noop5 = () => {
    };
    var warnedEnd = false;
    var CommonIterator = class {
      constructor(db, options, legacy) {
        if (typeof db !== "object" || db === null) {
          const hint = db === null ? "null" : typeof db;
          throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`);
        }
        if (typeof options !== "object" || options === null) {
          throw new TypeError("The second argument must be an options object");
        }
        this[kClosed] = false;
        this[kCloseCallbacks] = [];
        this[kWorking] = false;
        this[kClosing] = false;
        this[kAutoClose] = false;
        this[kCallback] = null;
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
        this[kHandleClose] = this[kHandleClose].bind(this);
        this[kKeyEncoding] = options[kKeyEncoding];
        this[kValueEncoding] = options[kValueEncoding];
        this[kLegacy] = legacy;
        this[kLimit] = Number.isInteger(options.limit) && options.limit >= 0 ? options.limit : Infinity;
        this[kCount] = 0;
        this[kAbortOnClose] = !!options.abortOnClose;
        this.db = db;
        this.db.attachResource(this);
        this.nextTick = db.nextTick;
      }
      get count() {
        return this[kCount];
      }
      get limit() {
        return this[kLimit];
      }
      next(callback) {
        let promise;
        if (callback === void 0) {
          promise = new Promise((resolve7, reject) => {
            callback = (err2, key, value2) => {
              if (err2)
                reject(err2);
              else if (!this[kLegacy])
                resolve7(key);
              else if (key === void 0 && value2 === void 0)
                resolve7();
              else
                resolve7([key, value2]);
            };
          });
        } else if (typeof callback !== "function") {
          throw new TypeError("Callback must be a function");
        }
        if (this[kClosing]) {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call next() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        } else if (this[kWorking]) {
          this.nextTick(callback, new ModuleError("Iterator is busy: cannot call next() until previous call has completed", {
            code: "LEVEL_ITERATOR_BUSY"
          }));
        } else {
          this[kWorking] = true;
          this[kCallback] = callback;
          if (this[kCount] >= this[kLimit])
            this.nextTick(this[kHandleOne], null);
          else
            this._next(this[kHandleOne]);
        }
        return promise;
      }
      _next(callback) {
        this.nextTick(callback);
      }
      nextv(size, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, emptyOptions);
        if (!Number.isInteger(size)) {
          this.nextTick(callback, new TypeError("The first argument 'size' must be an integer"));
          return callback[kPromise];
        }
        if (this[kClosing]) {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call nextv() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        } else if (this[kWorking]) {
          this.nextTick(callback, new ModuleError("Iterator is busy: cannot call nextv() until previous call has completed", {
            code: "LEVEL_ITERATOR_BUSY"
          }));
        } else {
          if (size < 1)
            size = 1;
          if (this[kLimit] < Infinity)
            size = Math.min(size, this[kLimit] - this[kCount]);
          this[kWorking] = true;
          this[kCallback] = callback;
          if (size <= 0)
            this.nextTick(this[kHandleMany], null, []);
          else
            this._nextv(size, options, this[kHandleMany]);
        }
        return callback[kPromise];
      }
      _nextv(size, options, callback) {
        const acc = [];
        const onnext = (err2, key, value2) => {
          if (err2) {
            return callback(err2);
          } else if (this[kLegacy] ? key === void 0 && value2 === void 0 : key === void 0) {
            return callback(null, acc);
          }
          acc.push(this[kLegacy] ? [key, value2] : key);
          if (acc.length === size) {
            callback(null, acc);
          } else {
            this._next(onnext);
          }
        };
        this._next(onnext);
      }
      all(options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, emptyOptions);
        if (this[kClosing]) {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call all() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        } else if (this[kWorking]) {
          this.nextTick(callback, new ModuleError("Iterator is busy: cannot call all() until previous call has completed", {
            code: "LEVEL_ITERATOR_BUSY"
          }));
        } else {
          this[kWorking] = true;
          this[kCallback] = callback;
          this[kAutoClose] = true;
          if (this[kCount] >= this[kLimit])
            this.nextTick(this[kHandleMany], null, []);
          else
            this._all(options, this[kHandleMany]);
        }
        return callback[kPromise];
      }
      _all(options, callback) {
        let count = this[kCount];
        const acc = [];
        const nextv = () => {
          const size = this[kLimit] < Infinity ? Math.min(1e3, this[kLimit] - count) : 1e3;
          if (size <= 0) {
            this.nextTick(callback, null, acc);
          } else {
            this._nextv(size, emptyOptions, onnextv);
          }
        };
        const onnextv = (err2, items) => {
          if (err2) {
            callback(err2);
          } else if (items.length === 0) {
            callback(null, acc);
          } else {
            acc.push.apply(acc, items);
            count += items.length;
            nextv();
          }
        };
        nextv();
      }
      [kFinishWork]() {
        const cb = this[kCallback];
        if (this[kAbortOnClose] && cb === null)
          return noop5;
        this[kWorking] = false;
        this[kCallback] = null;
        if (this[kClosing])
          this._close(this[kHandleClose]);
        return cb;
      }
      [kReturnMany](cb, err2, items) {
        if (this[kAutoClose]) {
          this.close(cb.bind(null, err2, items));
        } else {
          cb(err2, items);
        }
      }
      seek(target, options) {
        options = getOptions(options, emptyOptions);
        if (this[kClosing])
          ;
        else if (this[kWorking]) {
          throw new ModuleError("Iterator is busy: cannot call seek() until next() has completed", {
            code: "LEVEL_ITERATOR_BUSY"
          });
        } else {
          const keyEncoding = this.db.keyEncoding(options.keyEncoding || this[kKeyEncoding]);
          const keyFormat = keyEncoding.format;
          if (options.keyEncoding !== keyFormat) {
            options = { ...options, keyEncoding: keyFormat };
          }
          const mapped = this.db.prefixKey(keyEncoding.encode(target), keyFormat);
          this._seek(mapped, options);
        }
      }
      _seek(target, options) {
        throw new ModuleError("Iterator does not support seek()", {
          code: "LEVEL_NOT_SUPPORTED"
        });
      }
      close(callback) {
        callback = fromCallback(callback, kPromise);
        if (this[kClosed]) {
          this.nextTick(callback);
        } else if (this[kClosing]) {
          this[kCloseCallbacks].push(callback);
        } else {
          this[kClosing] = true;
          this[kCloseCallbacks].push(callback);
          if (!this[kWorking]) {
            this._close(this[kHandleClose]);
          } else if (this[kAbortOnClose]) {
            const cb = this[kFinishWork]();
            cb(new ModuleError("Aborted on iterator close()", {
              code: "LEVEL_ITERATOR_NOT_OPEN"
            }));
          }
        }
        return callback[kPromise];
      }
      _close(callback) {
        this.nextTick(callback);
      }
      [kHandleClose]() {
        this[kClosed] = true;
        this.db.detachResource(this);
        const callbacks = this[kCloseCallbacks];
        this[kCloseCallbacks] = [];
        for (const cb of callbacks) {
          cb();
        }
      }
      async *[Symbol.asyncIterator]() {
        try {
          let item;
          while ((item = await this.next()) !== void 0) {
            yield item;
          }
        } finally {
          if (!this[kClosed])
            await this.close();
        }
      }
    };
    var AbstractIterator = class extends CommonIterator {
      constructor(db, options) {
        super(db, options, true);
        this[kKeys] = options.keys !== false;
        this[kValues] = options.values !== false;
      }
      [kHandleOne](err2, key, value2) {
        const cb = this[kFinishWork]();
        if (err2)
          return cb(err2);
        try {
          key = this[kKeys] && key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
          value2 = this[kValues] && value2 !== void 0 ? this[kValueEncoding].decode(value2) : void 0;
        } catch (err3) {
          return cb(new IteratorDecodeError("entry", err3));
        }
        if (!(key === void 0 && value2 === void 0)) {
          this[kCount]++;
        }
        cb(null, key, value2);
      }
      [kHandleMany](err2, entries) {
        const cb = this[kFinishWork]();
        if (err2)
          return this[kReturnMany](cb, err2);
        try {
          for (const entry of entries) {
            const key = entry[0];
            const value2 = entry[1];
            entry[0] = this[kKeys] && key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
            entry[1] = this[kValues] && value2 !== void 0 ? this[kValueEncoding].decode(value2) : void 0;
          }
        } catch (err3) {
          return this[kReturnMany](cb, new IteratorDecodeError("entries", err3));
        }
        this[kCount] += entries.length;
        this[kReturnMany](cb, null, entries);
      }
      end(callback) {
        if (!warnedEnd && typeof console !== "undefined") {
          warnedEnd = true;
          console.warn(new ModuleError(
            "The iterator.end() method was renamed to close() and end() is an alias that will be removed in a future version",
            { code: "LEVEL_LEGACY" }
          ));
        }
        return this.close(callback);
      }
    };
    var AbstractKeyIterator = class extends CommonIterator {
      constructor(db, options) {
        super(db, options, false);
      }
      [kHandleOne](err2, key) {
        const cb = this[kFinishWork]();
        if (err2)
          return cb(err2);
        try {
          key = key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
        } catch (err3) {
          return cb(new IteratorDecodeError("key", err3));
        }
        if (key !== void 0)
          this[kCount]++;
        cb(null, key);
      }
      [kHandleMany](err2, keys) {
        const cb = this[kFinishWork]();
        if (err2)
          return this[kReturnMany](cb, err2);
        try {
          for (let i2 = 0; i2 < keys.length; i2++) {
            const key = keys[i2];
            keys[i2] = key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
          }
        } catch (err3) {
          return this[kReturnMany](cb, new IteratorDecodeError("keys", err3));
        }
        this[kCount] += keys.length;
        this[kReturnMany](cb, null, keys);
      }
    };
    var AbstractValueIterator = class extends CommonIterator {
      constructor(db, options) {
        super(db, options, false);
      }
      [kHandleOne](err2, value2) {
        const cb = this[kFinishWork]();
        if (err2)
          return cb(err2);
        try {
          value2 = value2 !== void 0 ? this[kValueEncoding].decode(value2) : void 0;
        } catch (err3) {
          return cb(new IteratorDecodeError("value", err3));
        }
        if (value2 !== void 0)
          this[kCount]++;
        cb(null, value2);
      }
      [kHandleMany](err2, values) {
        const cb = this[kFinishWork]();
        if (err2)
          return this[kReturnMany](cb, err2);
        try {
          for (let i2 = 0; i2 < values.length; i2++) {
            const value2 = values[i2];
            values[i2] = value2 !== void 0 ? this[kValueEncoding].decode(value2) : void 0;
          }
        } catch (err3) {
          return this[kReturnMany](cb, new IteratorDecodeError("values", err3));
        }
        this[kCount] += values.length;
        this[kReturnMany](cb, null, values);
      }
    };
    var IteratorDecodeError = class extends ModuleError {
      constructor(subject, cause) {
        super(`Iterator could not decode ${subject}`, {
          code: "LEVEL_DECODE_ERROR",
          cause
        });
      }
    };
    for (const k of ["_ended property", "_nexting property", "_end method"]) {
      Object.defineProperty(AbstractIterator.prototype, k.split(" ")[0], {
        get() {
          throw new ModuleError(`The ${k} has been removed`, { code: "LEVEL_LEGACY" });
        },
        set() {
          throw new ModuleError(`The ${k} has been removed`, { code: "LEVEL_LEGACY" });
        }
      });
    }
    AbstractIterator.keyEncoding = kKeyEncoding;
    AbstractIterator.valueEncoding = kValueEncoding;
    exports2.AbstractIterator = AbstractIterator;
    exports2.AbstractKeyIterator = AbstractKeyIterator;
    exports2.AbstractValueIterator = AbstractValueIterator;
  }
});
var require_default_kv_iterator = __commonJS({
  "node_modules/abstract-level/lib/default-kv-iterator.js"(exports2) {
    var { AbstractKeyIterator, AbstractValueIterator } = require_abstract_iterator();
    var kIterator = Symbol("iterator");
    var kCallback = Symbol("callback");
    var kHandleOne = Symbol("handleOne");
    var kHandleMany = Symbol("handleMany");
    var DefaultKeyIterator = class extends AbstractKeyIterator {
      constructor(db, options) {
        super(db, options);
        this[kIterator] = db.iterator({ ...options, keys: true, values: false });
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
      }
    };
    var DefaultValueIterator = class extends AbstractValueIterator {
      constructor(db, options) {
        super(db, options);
        this[kIterator] = db.iterator({ ...options, keys: false, values: true });
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
      }
    };
    for (const Iterator of [DefaultKeyIterator, DefaultValueIterator]) {
      const keys = Iterator === DefaultKeyIterator;
      const mapEntry = keys ? (entry) => entry[0] : (entry) => entry[1];
      Iterator.prototype._next = function(callback) {
        this[kCallback] = callback;
        this[kIterator].next(this[kHandleOne]);
      };
      Iterator.prototype[kHandleOne] = function(err2, key, value2) {
        const callback = this[kCallback];
        if (err2)
          callback(err2);
        else
          callback(null, keys ? key : value2);
      };
      Iterator.prototype._nextv = function(size, options, callback) {
        this[kCallback] = callback;
        this[kIterator].nextv(size, options, this[kHandleMany]);
      };
      Iterator.prototype._all = function(options, callback) {
        this[kCallback] = callback;
        this[kIterator].all(options, this[kHandleMany]);
      };
      Iterator.prototype[kHandleMany] = function(err2, entries) {
        const callback = this[kCallback];
        if (err2)
          callback(err2);
        else
          callback(null, entries.map(mapEntry));
      };
      Iterator.prototype._seek = function(target, options) {
        this[kIterator].seek(target, options);
      };
      Iterator.prototype._close = function(callback) {
        this[kIterator].close(callback);
      };
    }
    exports2.DefaultKeyIterator = DefaultKeyIterator;
    exports2.DefaultValueIterator = DefaultValueIterator;
  }
});
var require_deferred_iterator = __commonJS({
  "node_modules/abstract-level/lib/deferred-iterator.js"(exports2) {
    var { AbstractIterator, AbstractKeyIterator, AbstractValueIterator } = require_abstract_iterator();
    var ModuleError = require_module_error();
    var kNut = Symbol("nut");
    var kUndefer = Symbol("undefer");
    var kFactory = Symbol("factory");
    var DeferredIterator = class extends AbstractIterator {
      constructor(db, options) {
        super(db, options);
        this[kNut] = null;
        this[kFactory] = () => db.iterator(options);
        this.db.defer(() => this[kUndefer]());
      }
    };
    var DeferredKeyIterator = class extends AbstractKeyIterator {
      constructor(db, options) {
        super(db, options);
        this[kNut] = null;
        this[kFactory] = () => db.keys(options);
        this.db.defer(() => this[kUndefer]());
      }
    };
    var DeferredValueIterator = class extends AbstractValueIterator {
      constructor(db, options) {
        super(db, options);
        this[kNut] = null;
        this[kFactory] = () => db.values(options);
        this.db.defer(() => this[kUndefer]());
      }
    };
    for (const Iterator of [DeferredIterator, DeferredKeyIterator, DeferredValueIterator]) {
      Iterator.prototype[kUndefer] = function() {
        if (this.db.status === "open") {
          this[kNut] = this[kFactory]();
        }
      };
      Iterator.prototype._next = function(callback) {
        if (this[kNut] !== null) {
          this[kNut].next(callback);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._next(callback));
        } else {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call next() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        }
      };
      Iterator.prototype._nextv = function(size, options, callback) {
        if (this[kNut] !== null) {
          this[kNut].nextv(size, options, callback);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._nextv(size, options, callback));
        } else {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call nextv() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        }
      };
      Iterator.prototype._all = function(options, callback) {
        if (this[kNut] !== null) {
          this[kNut].all(callback);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._all(options, callback));
        } else {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call all() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        }
      };
      Iterator.prototype._seek = function(target, options) {
        if (this[kNut] !== null) {
          this[kNut]._seek(target, options);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._seek(target, options));
        }
      };
      Iterator.prototype._close = function(callback) {
        if (this[kNut] !== null) {
          this[kNut].close(callback);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._close(callback));
        } else {
          this.nextTick(callback);
        }
      };
    }
    exports2.DeferredIterator = DeferredIterator;
    exports2.DeferredKeyIterator = DeferredKeyIterator;
    exports2.DeferredValueIterator = DeferredValueIterator;
  }
});
var require_abstract_chained_batch = __commonJS({
  "node_modules/abstract-level/abstract-chained-batch.js"(exports2) {
    var { fromCallback } = require_catering();
    var ModuleError = require_module_error();
    var { getCallback, getOptions } = require_common2();
    var kPromise = Symbol("promise");
    var kStatus = Symbol("status");
    var kOperations = Symbol("operations");
    var kFinishClose = Symbol("finishClose");
    var kCloseCallbacks = Symbol("closeCallbacks");
    var AbstractChainedBatch = class {
      constructor(db) {
        if (typeof db !== "object" || db === null) {
          const hint = db === null ? "null" : typeof db;
          throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`);
        }
        this[kOperations] = [];
        this[kCloseCallbacks] = [];
        this[kStatus] = "open";
        this[kFinishClose] = this[kFinishClose].bind(this);
        this.db = db;
        this.db.attachResource(this);
        this.nextTick = db.nextTick;
      }
      get length() {
        return this[kOperations].length;
      }
      put(key, value2, options) {
        if (this[kStatus] !== "open") {
          throw new ModuleError("Batch is not open: cannot call put() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          });
        }
        const err2 = this.db._checkKey(key) || this.db._checkValue(value2);
        if (err2)
          throw err2;
        const db = options && options.sublevel != null ? options.sublevel : this.db;
        const original = options;
        const keyEncoding = db.keyEncoding(options && options.keyEncoding);
        const valueEncoding = db.valueEncoding(options && options.valueEncoding);
        const keyFormat = keyEncoding.format;
        options = { ...options, keyEncoding: keyFormat, valueEncoding: valueEncoding.format };
        if (db !== this.db) {
          options.sublevel = null;
        }
        const mappedKey = db.prefixKey(keyEncoding.encode(key), keyFormat);
        const mappedValue = valueEncoding.encode(value2);
        this._put(mappedKey, mappedValue, options);
        this[kOperations].push({ ...original, type: "put", key, value: value2 });
        return this;
      }
      _put(key, value2, options) {
      }
      del(key, options) {
        if (this[kStatus] !== "open") {
          throw new ModuleError("Batch is not open: cannot call del() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          });
        }
        const err2 = this.db._checkKey(key);
        if (err2)
          throw err2;
        const db = options && options.sublevel != null ? options.sublevel : this.db;
        const original = options;
        const keyEncoding = db.keyEncoding(options && options.keyEncoding);
        const keyFormat = keyEncoding.format;
        options = { ...options, keyEncoding: keyFormat };
        if (db !== this.db) {
          options.sublevel = null;
        }
        this._del(db.prefixKey(keyEncoding.encode(key), keyFormat), options);
        this[kOperations].push({ ...original, type: "del", key });
        return this;
      }
      _del(key, options) {
      }
      clear() {
        if (this[kStatus] !== "open") {
          throw new ModuleError("Batch is not open: cannot call clear() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          });
        }
        this._clear();
        this[kOperations] = [];
        return this;
      }
      _clear() {
      }
      write(options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options);
        if (this[kStatus] !== "open") {
          this.nextTick(callback, new ModuleError("Batch is not open: cannot call write() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          }));
        } else if (this.length === 0) {
          this.close(callback);
        } else {
          this[kStatus] = "writing";
          this._write(options, (err2) => {
            this[kStatus] = "closing";
            this[kCloseCallbacks].push(() => callback(err2));
            if (!err2)
              this.db.emit("batch", this[kOperations]);
            this._close(this[kFinishClose]);
          });
        }
        return callback[kPromise];
      }
      _write(options, callback) {
      }
      close(callback) {
        callback = fromCallback(callback, kPromise);
        if (this[kStatus] === "closing") {
          this[kCloseCallbacks].push(callback);
        } else if (this[kStatus] === "closed") {
          this.nextTick(callback);
        } else {
          this[kCloseCallbacks].push(callback);
          if (this[kStatus] !== "writing") {
            this[kStatus] = "closing";
            this._close(this[kFinishClose]);
          }
        }
        return callback[kPromise];
      }
      _close(callback) {
        this.nextTick(callback);
      }
      [kFinishClose]() {
        this[kStatus] = "closed";
        this.db.detachResource(this);
        const callbacks = this[kCloseCallbacks];
        this[kCloseCallbacks] = [];
        for (const cb of callbacks) {
          cb();
        }
      }
    };
    exports2.AbstractChainedBatch = AbstractChainedBatch;
  }
});
var require_default_chained_batch = __commonJS({
  "node_modules/abstract-level/lib/default-chained-batch.js"(exports2) {
    var { AbstractChainedBatch } = require_abstract_chained_batch();
    var ModuleError = require_module_error();
    var kEncoded = Symbol("encoded");
    var DefaultChainedBatch = class extends AbstractChainedBatch {
      constructor(db) {
        super(db);
        this[kEncoded] = [];
      }
      _put(key, value2, options) {
        this[kEncoded].push({ ...options, type: "put", key, value: value2 });
      }
      _del(key, options) {
        this[kEncoded].push({ ...options, type: "del", key });
      }
      _clear() {
        this[kEncoded] = [];
      }
      // Assumes this[kEncoded] cannot change after write()
      _write(options, callback) {
        if (this.db.status === "opening") {
          this.db.defer(() => this._write(options, callback));
        } else if (this.db.status === "open") {
          if (this[kEncoded].length === 0)
            this.nextTick(callback);
          else
            this.db._batch(this[kEncoded], options, callback);
        } else {
          this.nextTick(callback, new ModuleError("Batch is not open: cannot call write() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          }));
        }
      }
    };
    exports2.DefaultChainedBatch = DefaultChainedBatch;
  }
});
var require_range_options = __commonJS({
  "node_modules/abstract-level/lib/range-options.js"(exports2, module2) {
    var ModuleError = require_module_error();
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var rangeOptions = /* @__PURE__ */ new Set(["lt", "lte", "gt", "gte"]);
    module2.exports = function(options, keyEncoding) {
      const result = {};
      for (const k in options) {
        if (!hasOwnProperty2.call(options, k))
          continue;
        if (k === "keyEncoding" || k === "valueEncoding")
          continue;
        if (k === "start" || k === "end") {
          throw new ModuleError(`The legacy range option '${k}' has been removed`, {
            code: "LEVEL_LEGACY"
          });
        } else if (k === "encoding") {
          throw new ModuleError("The levelup-style 'encoding' alias has been removed, use 'valueEncoding' instead", {
            code: "LEVEL_LEGACY"
          });
        }
        if (rangeOptions.has(k)) {
          result[k] = keyEncoding.encode(options[k]);
        } else {
          result[k] = options[k];
        }
      }
      result.reverse = !!result.reverse;
      result.limit = Number.isInteger(result.limit) && result.limit >= 0 ? result.limit : -1;
      return result;
    };
  }
});
var require_queue_microtask = __commonJS({
  "node_modules/queue-microtask/index.js"(exports2, module2) {
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : globalThis) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err2) => setTimeout(() => {
      throw err2;
    }, 0));
  }
});
var require_next_tick_browser2 = __commonJS({
  "node_modules/abstract-level/lib/next-tick-browser.js"(exports2, module2) {
    var queueMicrotask2 = require_queue_microtask();
    module2.exports = function(fn, ...args) {
      if (args.length === 0) {
        queueMicrotask2(fn);
      } else {
        queueMicrotask2(() => fn(...args));
      }
    };
  }
});
var require_abstract_sublevel_iterator = __commonJS({
  "node_modules/abstract-level/lib/abstract-sublevel-iterator.js"(exports2) {
    var { AbstractIterator, AbstractKeyIterator, AbstractValueIterator } = require_abstract_iterator();
    var kUnfix = Symbol("unfix");
    var kIterator = Symbol("iterator");
    var kHandleOne = Symbol("handleOne");
    var kHandleMany = Symbol("handleMany");
    var kCallback = Symbol("callback");
    var AbstractSublevelIterator = class extends AbstractIterator {
      constructor(db, options, iterator, unfix) {
        super(db, options);
        this[kIterator] = iterator;
        this[kUnfix] = unfix;
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
        this[kCallback] = null;
      }
      [kHandleOne](err2, key, value2) {
        const callback = this[kCallback];
        if (err2)
          return callback(err2);
        if (key !== void 0)
          key = this[kUnfix](key);
        callback(err2, key, value2);
      }
      [kHandleMany](err2, entries) {
        const callback = this[kCallback];
        if (err2)
          return callback(err2);
        for (const entry of entries) {
          const key = entry[0];
          if (key !== void 0)
            entry[0] = this[kUnfix](key);
        }
        callback(err2, entries);
      }
    };
    var AbstractSublevelKeyIterator = class extends AbstractKeyIterator {
      constructor(db, options, iterator, unfix) {
        super(db, options);
        this[kIterator] = iterator;
        this[kUnfix] = unfix;
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
        this[kCallback] = null;
      }
      [kHandleOne](err2, key) {
        const callback = this[kCallback];
        if (err2)
          return callback(err2);
        if (key !== void 0)
          key = this[kUnfix](key);
        callback(err2, key);
      }
      [kHandleMany](err2, keys) {
        const callback = this[kCallback];
        if (err2)
          return callback(err2);
        for (let i2 = 0; i2 < keys.length; i2++) {
          const key = keys[i2];
          if (key !== void 0)
            keys[i2] = this[kUnfix](key);
        }
        callback(err2, keys);
      }
    };
    var AbstractSublevelValueIterator = class extends AbstractValueIterator {
      constructor(db, options, iterator) {
        super(db, options);
        this[kIterator] = iterator;
      }
    };
    for (const Iterator of [AbstractSublevelIterator, AbstractSublevelKeyIterator]) {
      Iterator.prototype._next = function(callback) {
        this[kCallback] = callback;
        this[kIterator].next(this[kHandleOne]);
      };
      Iterator.prototype._nextv = function(size, options, callback) {
        this[kCallback] = callback;
        this[kIterator].nextv(size, options, this[kHandleMany]);
      };
      Iterator.prototype._all = function(options, callback) {
        this[kCallback] = callback;
        this[kIterator].all(options, this[kHandleMany]);
      };
    }
    for (const Iterator of [AbstractSublevelValueIterator]) {
      Iterator.prototype._next = function(callback) {
        this[kIterator].next(callback);
      };
      Iterator.prototype._nextv = function(size, options, callback) {
        this[kIterator].nextv(size, options, callback);
      };
      Iterator.prototype._all = function(options, callback) {
        this[kIterator].all(options, callback);
      };
    }
    for (const Iterator of [AbstractSublevelIterator, AbstractSublevelKeyIterator, AbstractSublevelValueIterator]) {
      Iterator.prototype._seek = function(target, options) {
        this[kIterator].seek(target, options);
      };
      Iterator.prototype._close = function(callback) {
        this[kIterator].close(callback);
      };
    }
    exports2.AbstractSublevelIterator = AbstractSublevelIterator;
    exports2.AbstractSublevelKeyIterator = AbstractSublevelKeyIterator;
    exports2.AbstractSublevelValueIterator = AbstractSublevelValueIterator;
  }
});
var require_abstract_sublevel = __commonJS({
  "node_modules/abstract-level/lib/abstract-sublevel.js"(exports2, module2) {
    var ModuleError = require_module_error();
    var { Buffer: Buffer2 } = require_buffer() || {};
    var {
      AbstractSublevelIterator,
      AbstractSublevelKeyIterator,
      AbstractSublevelValueIterator
    } = require_abstract_sublevel_iterator();
    var kPrefix = Symbol("prefix");
    var kUpperBound = Symbol("upperBound");
    var kPrefixRange = Symbol("prefixRange");
    var kParent = Symbol("parent");
    var kUnfix = Symbol("unfix");
    var textEncoder5 = new TextEncoder();
    var defaults2 = { separator: "!" };
    module2.exports = function({ AbstractLevel }) {
      class AbstractSublevel extends AbstractLevel {
        static defaults(options) {
          if (typeof options === "string") {
            throw new ModuleError("The subleveldown string shorthand for { separator } has been removed", {
              code: "LEVEL_LEGACY"
            });
          } else if (options && options.open) {
            throw new ModuleError("The subleveldown open option has been removed", {
              code: "LEVEL_LEGACY"
            });
          }
          if (options == null) {
            return defaults2;
          } else if (!options.separator) {
            return { ...options, separator: "!" };
          } else {
            return options;
          }
        }
        // TODO: add autoClose option, which if true, does parent.attachResource(this)
        constructor(db, name9, options) {
          const { separator, manifest, ...forward } = AbstractSublevel.defaults(options);
          name9 = trim2(name9, separator);
          const reserved = separator.charCodeAt(0) + 1;
          const parent2 = db[kParent] || db;
          if (!textEncoder5.encode(name9).every((x) => x > reserved && x < 127)) {
            throw new ModuleError(`Prefix must use bytes > ${reserved} < ${127}`, {
              code: "LEVEL_INVALID_PREFIX"
            });
          }
          super(mergeManifests(parent2, manifest), forward);
          const prefix = (db.prefix || "") + separator + name9 + separator;
          const upperBound = prefix.slice(0, -1) + String.fromCharCode(reserved);
          this[kParent] = parent2;
          this[kPrefix] = new MultiFormat(prefix);
          this[kUpperBound] = new MultiFormat(upperBound);
          this[kUnfix] = new Unfixer();
          this.nextTick = parent2.nextTick;
        }
        prefixKey(key, keyFormat) {
          if (keyFormat === "utf8") {
            return this[kPrefix].utf8 + key;
          } else if (key.byteLength === 0) {
            return this[kPrefix][keyFormat];
          } else if (keyFormat === "view") {
            const view = this[kPrefix].view;
            const result = new Uint8Array(view.byteLength + key.byteLength);
            result.set(view, 0);
            result.set(key, view.byteLength);
            return result;
          } else {
            const buffer2 = this[kPrefix].buffer;
            return Buffer2.concat([buffer2, key], buffer2.byteLength + key.byteLength);
          }
        }
        // Not exposed for now.
        [kPrefixRange](range, keyFormat) {
          if (range.gte !== void 0) {
            range.gte = this.prefixKey(range.gte, keyFormat);
          } else if (range.gt !== void 0) {
            range.gt = this.prefixKey(range.gt, keyFormat);
          } else {
            range.gte = this[kPrefix][keyFormat];
          }
          if (range.lte !== void 0) {
            range.lte = this.prefixKey(range.lte, keyFormat);
          } else if (range.lt !== void 0) {
            range.lt = this.prefixKey(range.lt, keyFormat);
          } else {
            range.lte = this[kUpperBound][keyFormat];
          }
        }
        get prefix() {
          return this[kPrefix].utf8;
        }
        get db() {
          return this[kParent];
        }
        _open(options, callback) {
          this[kParent].open({ passive: true }, callback);
        }
        _put(key, value2, options, callback) {
          this[kParent].put(key, value2, options, callback);
        }
        _get(key, options, callback) {
          this[kParent].get(key, options, callback);
        }
        _getMany(keys, options, callback) {
          this[kParent].getMany(keys, options, callback);
        }
        _del(key, options, callback) {
          this[kParent].del(key, options, callback);
        }
        _batch(operations, options, callback) {
          this[kParent].batch(operations, options, callback);
        }
        _clear(options, callback) {
          this[kPrefixRange](options, options.keyEncoding);
          this[kParent].clear(options, callback);
        }
        _iterator(options) {
          this[kPrefixRange](options, options.keyEncoding);
          const iterator = this[kParent].iterator(options);
          const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);
          return new AbstractSublevelIterator(this, options, iterator, unfix);
        }
        _keys(options) {
          this[kPrefixRange](options, options.keyEncoding);
          const iterator = this[kParent].keys(options);
          const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);
          return new AbstractSublevelKeyIterator(this, options, iterator, unfix);
        }
        _values(options) {
          this[kPrefixRange](options, options.keyEncoding);
          const iterator = this[kParent].values(options);
          return new AbstractSublevelValueIterator(this, options, iterator);
        }
      }
      return { AbstractSublevel };
    };
    var mergeManifests = function(parent2, manifest) {
      return {
        // Inherit manifest of parent db
        ...parent2.supports,
        // Disable unsupported features
        createIfMissing: false,
        errorIfExists: false,
        // Unset additional events because we're not forwarding them
        events: {},
        // Unset additional methods (like approximateSize) which we can't support here unless
        // the AbstractSublevel class is overridden by an implementation of `abstract-level`.
        additionalMethods: {},
        // Inherit manifest of custom AbstractSublevel subclass. Such a class is not
        // allowed to override encodings.
        ...manifest,
        encodings: {
          utf8: supportsEncoding(parent2, "utf8"),
          buffer: supportsEncoding(parent2, "buffer"),
          view: supportsEncoding(parent2, "view")
        }
      };
    };
    var supportsEncoding = function(parent2, encoding) {
      return parent2.supports.encodings[encoding] ? parent2.keyEncoding(encoding).name === encoding : false;
    };
    var MultiFormat = class {
      constructor(key) {
        this.utf8 = key;
        this.view = textEncoder5.encode(key);
        this.buffer = Buffer2 ? Buffer2.from(this.view.buffer, 0, this.view.byteLength) : {};
      }
    };
    var Unfixer = class {
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
      }
      get(prefixLength, keyFormat) {
        let unfix = this.cache.get(keyFormat);
        if (unfix === void 0) {
          if (keyFormat === "view") {
            unfix = function(prefixLength2, key) {
              return key.subarray(prefixLength2);
            }.bind(null, prefixLength);
          } else {
            unfix = function(prefixLength2, key) {
              return key.slice(prefixLength2);
            }.bind(null, prefixLength);
          }
          this.cache.set(keyFormat, unfix);
        }
        return unfix;
      }
    };
    var trim2 = function(str, char) {
      let start = 0;
      let end = str.length;
      while (start < end && str[start] === char)
        start++;
      while (end > start && str[end - 1] === char)
        end--;
      return str.slice(start, end);
    };
  }
});
var require_abstract_level = __commonJS({
  "node_modules/abstract-level/abstract-level.js"(exports2) {
    var { supports } = require_level_supports();
    var { Transcoder } = require_level_transcoder();
    var { EventEmitter: EventEmitter6 } = require_events();
    var { fromCallback } = require_catering();
    var ModuleError = require_module_error();
    var { AbstractIterator } = require_abstract_iterator();
    var { DefaultKeyIterator, DefaultValueIterator } = require_default_kv_iterator();
    var { DeferredIterator, DeferredKeyIterator, DeferredValueIterator } = require_deferred_iterator();
    var { DefaultChainedBatch } = require_default_chained_batch();
    var { getCallback, getOptions } = require_common2();
    var rangeOptions = require_range_options();
    var kPromise = Symbol("promise");
    var kLanded = Symbol("landed");
    var kResources = Symbol("resources");
    var kCloseResources = Symbol("closeResources");
    var kOperations = Symbol("operations");
    var kUndefer = Symbol("undefer");
    var kDeferOpen = Symbol("deferOpen");
    var kOptions = Symbol("options");
    var kStatus = Symbol("status");
    var kDefaultOptions = Symbol("defaultOptions");
    var kTranscoder = Symbol("transcoder");
    var kKeyEncoding = Symbol("keyEncoding");
    var kValueEncoding = Symbol("valueEncoding");
    var noop5 = () => {
    };
    var AbstractLevel = class extends EventEmitter6 {
      constructor(manifest, options) {
        super();
        if (typeof manifest !== "object" || manifest === null) {
          throw new TypeError("The first argument 'manifest' must be an object");
        }
        options = getOptions(options);
        const { keyEncoding, valueEncoding, passive, ...forward } = options;
        this[kResources] = /* @__PURE__ */ new Set();
        this[kOperations] = [];
        this[kDeferOpen] = true;
        this[kOptions] = forward;
        this[kStatus] = "opening";
        this.supports = supports(manifest, {
          status: true,
          promises: true,
          clear: true,
          getMany: true,
          deferredOpen: true,
          // TODO (next major): add seek
          snapshots: manifest.snapshots !== false,
          permanence: manifest.permanence !== false,
          // TODO: remove from level-supports because it's always supported
          keyIterator: true,
          valueIterator: true,
          iteratorNextv: true,
          iteratorAll: true,
          encodings: manifest.encodings || {},
          events: Object.assign({}, manifest.events, {
            opening: true,
            open: true,
            closing: true,
            closed: true,
            put: true,
            del: true,
            batch: true,
            clear: true
          })
        });
        this[kTranscoder] = new Transcoder(formats(this));
        this[kKeyEncoding] = this[kTranscoder].encoding(keyEncoding || "utf8");
        this[kValueEncoding] = this[kTranscoder].encoding(valueEncoding || "utf8");
        for (const encoding of this[kTranscoder].encodings()) {
          if (!this.supports.encodings[encoding.commonName]) {
            this.supports.encodings[encoding.commonName] = true;
          }
        }
        this[kDefaultOptions] = {
          empty: Object.freeze({}),
          entry: Object.freeze({
            keyEncoding: this[kKeyEncoding].commonName,
            valueEncoding: this[kValueEncoding].commonName
          }),
          key: Object.freeze({
            keyEncoding: this[kKeyEncoding].commonName
          })
        };
        this.nextTick(() => {
          if (this[kDeferOpen]) {
            this.open({ passive: false }, noop5);
          }
        });
      }
      get status() {
        return this[kStatus];
      }
      keyEncoding(encoding) {
        return this[kTranscoder].encoding(encoding != null ? encoding : this[kKeyEncoding]);
      }
      valueEncoding(encoding) {
        return this[kTranscoder].encoding(encoding != null ? encoding : this[kValueEncoding]);
      }
      open(options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = { ...this[kOptions], ...getOptions(options) };
        options.createIfMissing = options.createIfMissing !== false;
        options.errorIfExists = !!options.errorIfExists;
        const maybeOpened = (err2) => {
          if (this[kStatus] === "closing" || this[kStatus] === "opening") {
            this.once(kLanded, err2 ? () => maybeOpened(err2) : maybeOpened);
          } else if (this[kStatus] !== "open") {
            callback(new ModuleError("Database is not open", {
              code: "LEVEL_DATABASE_NOT_OPEN",
              cause: err2
            }));
          } else {
            callback();
          }
        };
        if (options.passive) {
          if (this[kStatus] === "opening") {
            this.once(kLanded, maybeOpened);
          } else {
            this.nextTick(maybeOpened);
          }
        } else if (this[kStatus] === "closed" || this[kDeferOpen]) {
          this[kDeferOpen] = false;
          this[kStatus] = "opening";
          this.emit("opening");
          this._open(options, (err2) => {
            if (err2) {
              this[kStatus] = "closed";
              this[kCloseResources](() => {
                this.emit(kLanded);
                maybeOpened(err2);
              });
              this[kUndefer]();
              return;
            }
            this[kStatus] = "open";
            this[kUndefer]();
            this.emit(kLanded);
            if (this[kStatus] === "open")
              this.emit("open");
            if (this[kStatus] === "open")
              this.emit("ready");
            maybeOpened();
          });
        } else if (this[kStatus] === "open") {
          this.nextTick(maybeOpened);
        } else {
          this.once(kLanded, () => this.open(options, callback));
        }
        return callback[kPromise];
      }
      _open(options, callback) {
        this.nextTick(callback);
      }
      close(callback) {
        callback = fromCallback(callback, kPromise);
        const maybeClosed = (err2) => {
          if (this[kStatus] === "opening" || this[kStatus] === "closing") {
            this.once(kLanded, err2 ? maybeClosed(err2) : maybeClosed);
          } else if (this[kStatus] !== "closed") {
            callback(new ModuleError("Database is not closed", {
              code: "LEVEL_DATABASE_NOT_CLOSED",
              cause: err2
            }));
          } else {
            callback();
          }
        };
        if (this[kStatus] === "open") {
          this[kStatus] = "closing";
          this.emit("closing");
          const cancel = (err2) => {
            this[kStatus] = "open";
            this[kUndefer]();
            this.emit(kLanded);
            maybeClosed(err2);
          };
          this[kCloseResources](() => {
            this._close((err2) => {
              if (err2)
                return cancel(err2);
              this[kStatus] = "closed";
              this[kUndefer]();
              this.emit(kLanded);
              if (this[kStatus] === "closed")
                this.emit("closed");
              maybeClosed();
            });
          });
        } else if (this[kStatus] === "closed") {
          this.nextTick(maybeClosed);
        } else {
          this.once(kLanded, () => this.close(callback));
        }
        return callback[kPromise];
      }
      [kCloseResources](callback) {
        if (this[kResources].size === 0) {
          return this.nextTick(callback);
        }
        let pending = this[kResources].size;
        let sync = true;
        const next = () => {
          if (--pending === 0) {
            if (sync)
              this.nextTick(callback);
            else
              callback();
          }
        };
        for (const resource of this[kResources]) {
          resource.close(next);
        }
        sync = false;
        this[kResources].clear();
      }
      _close(callback) {
        this.nextTick(callback);
      }
      get(key, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].entry);
        if (this[kStatus] === "opening") {
          this.defer(() => this.get(key, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        const err2 = this._checkKey(key);
        if (err2) {
          this.nextTick(callback, err2);
          return callback[kPromise];
        }
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        const valueEncoding = this.valueEncoding(options.valueEncoding);
        const keyFormat = keyEncoding.format;
        const valueFormat = valueEncoding.format;
        if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
          options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
        }
        this._get(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err3, value2) => {
          if (err3) {
            if (err3.code === "LEVEL_NOT_FOUND" || err3.notFound || /NotFound/i.test(err3)) {
              if (!err3.code)
                err3.code = "LEVEL_NOT_FOUND";
              if (!err3.notFound)
                err3.notFound = true;
              if (!err3.status)
                err3.status = 404;
            }
            return callback(err3);
          }
          try {
            value2 = valueEncoding.decode(value2);
          } catch (err4) {
            return callback(new ModuleError("Could not decode value", {
              code: "LEVEL_DECODE_ERROR",
              cause: err4
            }));
          }
          callback(null, value2);
        });
        return callback[kPromise];
      }
      _get(key, options, callback) {
        this.nextTick(callback, new Error("NotFound"));
      }
      getMany(keys, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].entry);
        if (this[kStatus] === "opening") {
          this.defer(() => this.getMany(keys, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        if (!Array.isArray(keys)) {
          this.nextTick(callback, new TypeError("The first argument 'keys' must be an array"));
          return callback[kPromise];
        }
        if (keys.length === 0) {
          this.nextTick(callback, null, []);
          return callback[kPromise];
        }
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        const valueEncoding = this.valueEncoding(options.valueEncoding);
        const keyFormat = keyEncoding.format;
        const valueFormat = valueEncoding.format;
        if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
          options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
        }
        const mappedKeys = new Array(keys.length);
        for (let i2 = 0; i2 < keys.length; i2++) {
          const key = keys[i2];
          const err2 = this._checkKey(key);
          if (err2) {
            this.nextTick(callback, err2);
            return callback[kPromise];
          }
          mappedKeys[i2] = this.prefixKey(keyEncoding.encode(key), keyFormat);
        }
        this._getMany(mappedKeys, options, (err2, values) => {
          if (err2)
            return callback(err2);
          try {
            for (let i2 = 0; i2 < values.length; i2++) {
              if (values[i2] !== void 0) {
                values[i2] = valueEncoding.decode(values[i2]);
              }
            }
          } catch (err3) {
            return callback(new ModuleError(`Could not decode one or more of ${values.length} value(s)`, {
              code: "LEVEL_DECODE_ERROR",
              cause: err3
            }));
          }
          callback(null, values);
        });
        return callback[kPromise];
      }
      _getMany(keys, options, callback) {
        this.nextTick(callback, null, new Array(keys.length).fill(void 0));
      }
      put(key, value2, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].entry);
        if (this[kStatus] === "opening") {
          this.defer(() => this.put(key, value2, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        const err2 = this._checkKey(key) || this._checkValue(value2);
        if (err2) {
          this.nextTick(callback, err2);
          return callback[kPromise];
        }
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        const valueEncoding = this.valueEncoding(options.valueEncoding);
        const keyFormat = keyEncoding.format;
        const valueFormat = valueEncoding.format;
        if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
          options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
        }
        const mappedKey = this.prefixKey(keyEncoding.encode(key), keyFormat);
        const mappedValue = valueEncoding.encode(value2);
        this._put(mappedKey, mappedValue, options, (err3) => {
          if (err3)
            return callback(err3);
          this.emit("put", key, value2);
          callback();
        });
        return callback[kPromise];
      }
      _put(key, value2, options, callback) {
        this.nextTick(callback);
      }
      del(key, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].key);
        if (this[kStatus] === "opening") {
          this.defer(() => this.del(key, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        const err2 = this._checkKey(key);
        if (err2) {
          this.nextTick(callback, err2);
          return callback[kPromise];
        }
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        const keyFormat = keyEncoding.format;
        if (options.keyEncoding !== keyFormat) {
          options = Object.assign({}, options, { keyEncoding: keyFormat });
        }
        this._del(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err3) => {
          if (err3)
            return callback(err3);
          this.emit("del", key);
          callback();
        });
        return callback[kPromise];
      }
      _del(key, options, callback) {
        this.nextTick(callback);
      }
      batch(operations, options, callback) {
        if (!arguments.length) {
          if (this[kStatus] === "opening")
            return new DefaultChainedBatch(this);
          if (this[kStatus] !== "open") {
            throw new ModuleError("Database is not open", {
              code: "LEVEL_DATABASE_NOT_OPEN"
            });
          }
          return this._chainedBatch();
        }
        if (typeof operations === "function")
          callback = operations;
        else
          callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].empty);
        if (this[kStatus] === "opening") {
          this.defer(() => this.batch(operations, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        if (!Array.isArray(operations)) {
          this.nextTick(callback, new TypeError("The first argument 'operations' must be an array"));
          return callback[kPromise];
        }
        if (operations.length === 0) {
          this.nextTick(callback);
          return callback[kPromise];
        }
        const mapped = new Array(operations.length);
        const { keyEncoding: ke, valueEncoding: ve, ...forward } = options;
        for (let i2 = 0; i2 < operations.length; i2++) {
          if (typeof operations[i2] !== "object" || operations[i2] === null) {
            this.nextTick(callback, new TypeError("A batch operation must be an object"));
            return callback[kPromise];
          }
          const op = Object.assign({}, operations[i2]);
          if (op.type !== "put" && op.type !== "del") {
            this.nextTick(callback, new TypeError("A batch operation must have a type property that is 'put' or 'del'"));
            return callback[kPromise];
          }
          const err2 = this._checkKey(op.key);
          if (err2) {
            this.nextTick(callback, err2);
            return callback[kPromise];
          }
          const db = op.sublevel != null ? op.sublevel : this;
          const keyEncoding = db.keyEncoding(op.keyEncoding || ke);
          const keyFormat = keyEncoding.format;
          op.key = db.prefixKey(keyEncoding.encode(op.key), keyFormat);
          op.keyEncoding = keyFormat;
          if (op.type === "put") {
            const valueErr = this._checkValue(op.value);
            if (valueErr) {
              this.nextTick(callback, valueErr);
              return callback[kPromise];
            }
            const valueEncoding = db.valueEncoding(op.valueEncoding || ve);
            op.value = valueEncoding.encode(op.value);
            op.valueEncoding = valueEncoding.format;
          }
          if (db !== this) {
            op.sublevel = null;
          }
          mapped[i2] = op;
        }
        this._batch(mapped, forward, (err2) => {
          if (err2)
            return callback(err2);
          this.emit("batch", operations);
          callback();
        });
        return callback[kPromise];
      }
      _batch(operations, options, callback) {
        this.nextTick(callback);
      }
      sublevel(name9, options) {
        return this._sublevel(name9, AbstractSublevel.defaults(options));
      }
      _sublevel(name9, options) {
        return new AbstractSublevel(this, name9, options);
      }
      prefixKey(key, keyFormat) {
        return key;
      }
      clear(options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].empty);
        if (this[kStatus] === "opening") {
          this.defer(() => this.clear(options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        const original = options;
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        options = rangeOptions(options, keyEncoding);
        options.keyEncoding = keyEncoding.format;
        if (options.limit === 0) {
          this.nextTick(callback);
        } else {
          this._clear(options, (err2) => {
            if (err2)
              return callback(err2);
            this.emit("clear", original);
            callback();
          });
        }
        return callback[kPromise];
      }
      _clear(options, callback) {
        this.nextTick(callback);
      }
      iterator(options) {
        const keyEncoding = this.keyEncoding(options && options.keyEncoding);
        const valueEncoding = this.valueEncoding(options && options.valueEncoding);
        options = rangeOptions(options, keyEncoding);
        options.keys = options.keys !== false;
        options.values = options.values !== false;
        options[AbstractIterator.keyEncoding] = keyEncoding;
        options[AbstractIterator.valueEncoding] = valueEncoding;
        options.keyEncoding = keyEncoding.format;
        options.valueEncoding = valueEncoding.format;
        if (this[kStatus] === "opening") {
          return new DeferredIterator(this, options);
        } else if (this[kStatus] !== "open") {
          throw new ModuleError("Database is not open", {
            code: "LEVEL_DATABASE_NOT_OPEN"
          });
        }
        return this._iterator(options);
      }
      _iterator(options) {
        return new AbstractIterator(this, options);
      }
      keys(options) {
        const keyEncoding = this.keyEncoding(options && options.keyEncoding);
        const valueEncoding = this.valueEncoding(options && options.valueEncoding);
        options = rangeOptions(options, keyEncoding);
        options[AbstractIterator.keyEncoding] = keyEncoding;
        options[AbstractIterator.valueEncoding] = valueEncoding;
        options.keyEncoding = keyEncoding.format;
        options.valueEncoding = valueEncoding.format;
        if (this[kStatus] === "opening") {
          return new DeferredKeyIterator(this, options);
        } else if (this[kStatus] !== "open") {
          throw new ModuleError("Database is not open", {
            code: "LEVEL_DATABASE_NOT_OPEN"
          });
        }
        return this._keys(options);
      }
      _keys(options) {
        return new DefaultKeyIterator(this, options);
      }
      values(options) {
        const keyEncoding = this.keyEncoding(options && options.keyEncoding);
        const valueEncoding = this.valueEncoding(options && options.valueEncoding);
        options = rangeOptions(options, keyEncoding);
        options[AbstractIterator.keyEncoding] = keyEncoding;
        options[AbstractIterator.valueEncoding] = valueEncoding;
        options.keyEncoding = keyEncoding.format;
        options.valueEncoding = valueEncoding.format;
        if (this[kStatus] === "opening") {
          return new DeferredValueIterator(this, options);
        } else if (this[kStatus] !== "open") {
          throw new ModuleError("Database is not open", {
            code: "LEVEL_DATABASE_NOT_OPEN"
          });
        }
        return this._values(options);
      }
      _values(options) {
        return new DefaultValueIterator(this, options);
      }
      defer(fn) {
        if (typeof fn !== "function") {
          throw new TypeError("The first argument must be a function");
        }
        this[kOperations].push(fn);
      }
      [kUndefer]() {
        if (this[kOperations].length === 0) {
          return;
        }
        const operations = this[kOperations];
        this[kOperations] = [];
        for (const op of operations) {
          op();
        }
      }
      // TODO: docs and types
      attachResource(resource) {
        if (typeof resource !== "object" || resource === null || typeof resource.close !== "function") {
          throw new TypeError("The first argument must be a resource object");
        }
        this[kResources].add(resource);
      }
      // TODO: docs and types
      detachResource(resource) {
        this[kResources].delete(resource);
      }
      _chainedBatch() {
        return new DefaultChainedBatch(this);
      }
      _checkKey(key) {
        if (key === null || key === void 0) {
          return new ModuleError("Key cannot be null or undefined", {
            code: "LEVEL_INVALID_KEY"
          });
        }
      }
      _checkValue(value2) {
        if (value2 === null || value2 === void 0) {
          return new ModuleError("Value cannot be null or undefined", {
            code: "LEVEL_INVALID_VALUE"
          });
        }
      }
    };
    AbstractLevel.prototype.nextTick = require_next_tick_browser2();
    var { AbstractSublevel } = require_abstract_sublevel()({ AbstractLevel });
    exports2.AbstractLevel = AbstractLevel;
    exports2.AbstractSublevel = AbstractSublevel;
    var maybeError = function(db, callback) {
      if (db[kStatus] !== "open") {
        db.nextTick(callback, new ModuleError("Database is not open", {
          code: "LEVEL_DATABASE_NOT_OPEN"
        }));
        return true;
      }
      return false;
    };
    var formats = function(db) {
      return Object.keys(db.supports.encodings).filter((k) => !!db.supports.encodings[k]);
    };
  }
});
var require_abstract_level2 = __commonJS({
  "node_modules/abstract-level/index.js"(exports2) {
    exports2.AbstractLevel = require_abstract_level().AbstractLevel;
    exports2.AbstractSublevel = require_abstract_level().AbstractSublevel;
    exports2.AbstractIterator = require_abstract_iterator().AbstractIterator;
    exports2.AbstractKeyIterator = require_abstract_iterator().AbstractKeyIterator;
    exports2.AbstractValueIterator = require_abstract_iterator().AbstractValueIterator;
    exports2.AbstractChainedBatch = require_abstract_chained_batch().AbstractChainedBatch;
  }
});
var require_run_parallel_limit = __commonJS({
  "node_modules/run-parallel-limit/index.js"(exports2, module2) {
    module2.exports = runParallelLimit;
    var queueMicrotask2 = require_queue_microtask();
    function runParallelLimit(tasks, limit, cb) {
      if (typeof limit !== "number")
        throw new Error("second argument must be a Number");
      let results, len, pending, keys, isErrored;
      let isSync = true;
      let next;
      if (Array.isArray(tasks)) {
        results = [];
        pending = len = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = len = keys.length;
      }
      function done(err2) {
        function end() {
          if (cb)
            cb(err2, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i2, err2, result) {
        results[i2] = result;
        if (err2)
          isErrored = true;
        if (--pending === 0 || err2) {
          done(err2);
        } else if (!isErrored && next < len) {
          let key;
          if (keys) {
            key = keys[next];
            next += 1;
            tasks[key](function(err3, result2) {
              each(key, err3, result2);
            });
          } else {
            key = next;
            next += 1;
            tasks[key](function(err3, result2) {
              each(key, err3, result2);
            });
          }
        }
      }
      next = limit;
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.some(function(key, i2) {
          tasks[key](function(err2, result) {
            each(key, err2, result);
          });
          if (i2 === limit - 1)
            return true;
          return false;
        });
      } else {
        tasks.some(function(task, i2) {
          task(function(err2, result) {
            each(i2, err2, result);
          });
          if (i2 === limit - 1)
            return true;
          return false;
        });
      }
      isSync = false;
    }
  }
});
var require_key_range = __commonJS({
  "node_modules/browser-level/util/key-range.js"(exports2, module2) {
    module2.exports = function createKeyRange(options) {
      const lower = options.gte !== void 0 ? options.gte : options.gt !== void 0 ? options.gt : void 0;
      const upper = options.lte !== void 0 ? options.lte : options.lt !== void 0 ? options.lt : void 0;
      const lowerExclusive = options.gte === void 0;
      const upperExclusive = options.lte === void 0;
      if (lower !== void 0 && upper !== void 0) {
        return IDBKeyRange.bound(lower, upper, lowerExclusive, upperExclusive);
      } else if (lower !== void 0) {
        return IDBKeyRange.lowerBound(lower, lowerExclusive);
      } else if (upper !== void 0) {
        return IDBKeyRange.upperBound(upper, upperExclusive);
      } else {
        return null;
      }
    };
  }
});
var require_deserialize = __commonJS({
  "node_modules/browser-level/util/deserialize.js"(exports2, module2) {
    var textEncoder5 = new TextEncoder();
    module2.exports = function(data) {
      if (data instanceof Uint8Array) {
        return data;
      } else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
      } else {
        return textEncoder5.encode(data);
      }
    };
  }
});
var require_iterator = __commonJS({
  "node_modules/browser-level/iterator.js"(exports2) {
    var { AbstractIterator } = require_abstract_level2();
    var createKeyRange = require_key_range();
    var deserialize = require_deserialize();
    var kCache = Symbol("cache");
    var kFinished = Symbol("finished");
    var kOptions = Symbol("options");
    var kCurrentOptions = Symbol("currentOptions");
    var kPosition = Symbol("position");
    var kLocation = Symbol("location");
    var kFirst = Symbol("first");
    var emptyOptions = {};
    var Iterator = class extends AbstractIterator {
      constructor(db, location2, options) {
        super(db, options);
        this[kCache] = [];
        this[kFinished] = this.limit === 0;
        this[kOptions] = options;
        this[kCurrentOptions] = { ...options };
        this[kPosition] = void 0;
        this[kLocation] = location2;
        this[kFirst] = true;
      }
      // Note: if called by _all() then size can be Infinity. This is an internal
      // detail; by design AbstractIterator.nextv() does not support Infinity.
      _nextv(size, options, callback) {
        this[kFirst] = false;
        if (this[kFinished]) {
          return this.nextTick(callback, null, []);
        } else if (this[kCache].length > 0) {
          size = Math.min(size, this[kCache].length);
          return this.nextTick(callback, null, this[kCache].splice(0, size));
        }
        if (this[kPosition] !== void 0) {
          if (this[kOptions].reverse) {
            this[kCurrentOptions].lt = this[kPosition];
            this[kCurrentOptions].lte = void 0;
          } else {
            this[kCurrentOptions].gt = this[kPosition];
            this[kCurrentOptions].gte = void 0;
          }
        }
        let keyRange;
        try {
          keyRange = createKeyRange(this[kCurrentOptions]);
        } catch (_) {
          this[kFinished] = true;
          return this.nextTick(callback, null, []);
        }
        const transaction = this.db.db.transaction([this[kLocation]], "readonly");
        const store = transaction.objectStore(this[kLocation]);
        const entries = [];
        if (!this[kOptions].reverse) {
          let keys;
          let values;
          const complete = () => {
            if (keys === void 0 || values === void 0)
              return;
            const length3 = Math.max(keys.length, values.length);
            if (length3 === 0 || size === Infinity) {
              this[kFinished] = true;
            } else {
              this[kPosition] = keys[length3 - 1];
            }
            entries.length = length3;
            for (let i2 = 0; i2 < length3; i2++) {
              const key = keys[i2];
              const value2 = values[i2];
              entries[i2] = [
                this[kOptions].keys && key !== void 0 ? deserialize(key) : void 0,
                this[kOptions].values && value2 !== void 0 ? deserialize(value2) : void 0
              ];
            }
            maybeCommit(transaction);
          };
          if (this[kOptions].keys || size < Infinity) {
            store.getAllKeys(keyRange, size < Infinity ? size : void 0).onsuccess = (ev) => {
              keys = ev.target.result;
              complete();
            };
          } else {
            keys = [];
            this.nextTick(complete);
          }
          if (this[kOptions].values) {
            store.getAll(keyRange, size < Infinity ? size : void 0).onsuccess = (ev) => {
              values = ev.target.result;
              complete();
            };
          } else {
            values = [];
            this.nextTick(complete);
          }
        } else {
          const method = !this[kOptions].values && store.openKeyCursor ? "openKeyCursor" : "openCursor";
          store[method](keyRange, "prev").onsuccess = (ev) => {
            const cursor = ev.target.result;
            if (cursor) {
              const { key, value: value2 } = cursor;
              this[kPosition] = key;
              entries.push([
                this[kOptions].keys && key !== void 0 ? deserialize(key) : void 0,
                this[kOptions].values && value2 !== void 0 ? deserialize(value2) : void 0
              ]);
              if (entries.length < size) {
                cursor.continue();
              } else {
                maybeCommit(transaction);
              }
            } else {
              this[kFinished] = true;
            }
          };
        }
        transaction.onabort = () => {
          callback(transaction.error || new Error("aborted by user"));
          callback = null;
        };
        transaction.oncomplete = () => {
          callback(null, entries);
          callback = null;
        };
      }
      _next(callback) {
        if (this[kCache].length > 0) {
          const [key, value2] = this[kCache].shift();
          this.nextTick(callback, null, key, value2);
        } else if (this[kFinished]) {
          this.nextTick(callback);
        } else {
          let size = Math.min(100, this.limit - this.count);
          if (this[kFirst]) {
            this[kFirst] = false;
            size = 1;
          }
          this._nextv(size, emptyOptions, (err2, entries) => {
            if (err2)
              return callback(err2);
            this[kCache] = entries;
            this._next(callback);
          });
        }
      }
      _all(options, callback) {
        this[kFirst] = false;
        const cache4 = this[kCache].splice(0, this[kCache].length);
        const size = this.limit - this.count - cache4.length;
        if (size <= 0) {
          return this.nextTick(callback, null, cache4);
        }
        this._nextv(size, emptyOptions, (err2, entries) => {
          if (err2)
            return callback(err2);
          if (cache4.length > 0)
            entries = cache4.concat(entries);
          callback(null, entries);
        });
      }
      _seek(target, options) {
        this[kFirst] = true;
        this[kCache] = [];
        this[kFinished] = false;
        this[kPosition] = void 0;
        this[kCurrentOptions] = { ...this[kOptions] };
        let keyRange;
        try {
          keyRange = createKeyRange(this[kOptions]);
        } catch (_) {
          this[kFinished] = true;
          return;
        }
        if (keyRange !== null && !keyRange.includes(target)) {
          this[kFinished] = true;
        } else if (this[kOptions].reverse) {
          this[kCurrentOptions].lte = target;
        } else {
          this[kCurrentOptions].gte = target;
        }
      }
    };
    exports2.Iterator = Iterator;
    function maybeCommit(transaction) {
      if (typeof transaction.commit === "function") {
        transaction.commit();
      }
    }
  }
});
var require_clear = __commonJS({
  "node_modules/browser-level/util/clear.js"(exports2, module2) {
    module2.exports = function clear(db, location2, keyRange, options, callback) {
      if (options.limit === 0)
        return db.nextTick(callback);
      const transaction = db.db.transaction([location2], "readwrite");
      const store = transaction.objectStore(location2);
      let count = 0;
      transaction.oncomplete = function() {
        callback();
      };
      transaction.onabort = function() {
        callback(transaction.error || new Error("aborted by user"));
      };
      const method = store.openKeyCursor ? "openKeyCursor" : "openCursor";
      const direction = options.reverse ? "prev" : "next";
      store[method](keyRange, direction).onsuccess = function(ev) {
        const cursor = ev.target.result;
        if (cursor) {
          store.delete(cursor.key).onsuccess = function() {
            if (options.limit <= 0 || ++count < options.limit) {
              cursor.continue();
            }
          };
        }
      };
    };
  }
});
var require_browser_level = __commonJS({
  "node_modules/browser-level/index.js"(exports2) {
    var { AbstractLevel } = require_abstract_level2();
    var ModuleError = require_module_error();
    var parallel2 = require_run_parallel_limit();
    var { fromCallback } = require_catering();
    var { Iterator } = require_iterator();
    var deserialize = require_deserialize();
    var clear = require_clear();
    var createKeyRange = require_key_range();
    var DEFAULT_PREFIX = "level-js-";
    var kIDB = Symbol("idb");
    var kNamePrefix = Symbol("namePrefix");
    var kLocation = Symbol("location");
    var kVersion = Symbol("version");
    var kStore = Symbol("store");
    var kOnComplete = Symbol("onComplete");
    var kPromise = Symbol("promise");
    var BrowserLevel = class extends AbstractLevel {
      constructor(location2, options, _) {
        if (typeof options === "function" || typeof _ === "function") {
          throw new ModuleError("The levelup-style callback argument has been removed", {
            code: "LEVEL_LEGACY"
          });
        }
        const { prefix, version: version3, ...forward } = options || {};
        super({
          encodings: { view: true },
          snapshots: false,
          createIfMissing: false,
          errorIfExists: false,
          seek: true
        }, forward);
        if (typeof location2 !== "string") {
          throw new Error("constructor requires a location string argument");
        }
        this[kLocation] = location2;
        this[kNamePrefix] = prefix == null ? DEFAULT_PREFIX : prefix;
        this[kVersion] = parseInt(version3 || 1, 10);
        this[kIDB] = null;
      }
      get location() {
        return this[kLocation];
      }
      get namePrefix() {
        return this[kNamePrefix];
      }
      get version() {
        return this[kVersion];
      }
      // Exposed for backwards compat and unit tests
      get db() {
        return this[kIDB];
      }
      get type() {
        return "browser-level";
      }
      _open(options, callback) {
        const req = indexedDB.open(this[kNamePrefix] + this[kLocation], this[kVersion]);
        req.onerror = function() {
          callback(req.error || new Error("unknown error"));
        };
        req.onsuccess = () => {
          this[kIDB] = req.result;
          callback();
        };
        req.onupgradeneeded = (ev) => {
          const db = ev.target.result;
          if (!db.objectStoreNames.contains(this[kLocation])) {
            db.createObjectStore(this[kLocation]);
          }
        };
      }
      [kStore](mode) {
        const transaction = this[kIDB].transaction([this[kLocation]], mode);
        return transaction.objectStore(this[kLocation]);
      }
      [kOnComplete](request2, callback) {
        const transaction = request2.transaction;
        transaction.onabort = function() {
          callback(transaction.error || new Error("aborted by user"));
        };
        transaction.oncomplete = function() {
          callback(null, request2.result);
        };
      }
      _get(key, options, callback) {
        const store = this[kStore]("readonly");
        let req;
        try {
          req = store.get(key);
        } catch (err2) {
          return this.nextTick(callback, err2);
        }
        this[kOnComplete](req, function(err2, value2) {
          if (err2)
            return callback(err2);
          if (value2 === void 0) {
            return callback(new ModuleError("Entry not found", {
              code: "LEVEL_NOT_FOUND"
            }));
          }
          callback(null, deserialize(value2));
        });
      }
      _getMany(keys, options, callback) {
        const store = this[kStore]("readonly");
        const tasks = keys.map((key) => (next) => {
          let request2;
          try {
            request2 = store.get(key);
          } catch (err2) {
            return next(err2);
          }
          request2.onsuccess = () => {
            const value2 = request2.result;
            next(null, value2 === void 0 ? value2 : deserialize(value2));
          };
          request2.onerror = (ev) => {
            ev.stopPropagation();
            next(request2.error);
          };
        });
        parallel2(tasks, 16, callback);
      }
      _del(key, options, callback) {
        const store = this[kStore]("readwrite");
        let req;
        try {
          req = store.delete(key);
        } catch (err2) {
          return this.nextTick(callback, err2);
        }
        this[kOnComplete](req, callback);
      }
      _put(key, value2, options, callback) {
        const store = this[kStore]("readwrite");
        let req;
        try {
          req = store.put(value2, key);
        } catch (err2) {
          return this.nextTick(callback, err2);
        }
        this[kOnComplete](req, callback);
      }
      // TODO: implement key and value iterators
      _iterator(options) {
        return new Iterator(this, this[kLocation], options);
      }
      _batch(operations, options, callback) {
        const store = this[kStore]("readwrite");
        const transaction = store.transaction;
        let index2 = 0;
        let error;
        transaction.onabort = function() {
          callback(error || transaction.error || new Error("aborted by user"));
        };
        transaction.oncomplete = function() {
          callback();
        };
        function loop() {
          const op = operations[index2++];
          const key = op.key;
          let req;
          try {
            req = op.type === "del" ? store.delete(key) : store.put(op.value, key);
          } catch (err2) {
            error = err2;
            transaction.abort();
            return;
          }
          if (index2 < operations.length) {
            req.onsuccess = loop;
          } else if (typeof transaction.commit === "function") {
            transaction.commit();
          }
        }
        loop();
      }
      _clear(options, callback) {
        let keyRange;
        let req;
        try {
          keyRange = createKeyRange(options);
        } catch (e) {
          return this.nextTick(callback);
        }
        if (options.limit >= 0) {
          return clear(this, this[kLocation], keyRange, options, callback);
        }
        try {
          const store = this[kStore]("readwrite");
          req = keyRange ? store.delete(keyRange) : store.clear();
        } catch (err2) {
          return this.nextTick(callback, err2);
        }
        this[kOnComplete](req, callback);
      }
      _close(callback) {
        this[kIDB].close();
        this.nextTick(callback);
      }
    };
    BrowserLevel.destroy = function(location2, prefix, callback) {
      if (typeof prefix === "function") {
        callback = prefix;
        prefix = DEFAULT_PREFIX;
      }
      callback = fromCallback(callback, kPromise);
      const request2 = indexedDB.deleteDatabase(prefix + location2);
      request2.onsuccess = function() {
        callback();
      };
      request2.onerror = function(err2) {
        callback(err2);
      };
      return callback[kPromise];
    };
    exports2.BrowserLevel = BrowserLevel;
  }
});
var require_browser3 = __commonJS({
  "node_modules/level/browser.js"(exports2) {
    exports2.Level = require_browser_level().BrowserLevel;
  }
});
var require_longbits2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    module2.exports = LongBits2;
    var util2 = require_minimal3();
    function LongBits2(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero2 = LongBits2.zero = new LongBits2(0, 0);
    zero2.toNumber = function() {
      return 0;
    };
    zero2.zzEncode = zero2.zzDecode = function() {
      return this;
    };
    zero2.length = function() {
      return 1;
    };
    var zeroHash = LongBits2.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits2.fromNumber = function fromNumber(value2) {
      if (value2 === 0)
        return zero2;
      var sign4 = value2 < 0;
      if (sign4)
        value2 = -value2;
      var lo = value2 >>> 0, hi = (value2 - lo) / 4294967296 >>> 0;
      if (sign4) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits2(lo, hi);
    };
    LongBits2.from = function from3(value2) {
      if (typeof value2 === "number")
        return LongBits2.fromNumber(value2);
      if (util2.isString(value2)) {
        if (util2.Long)
          value2 = util2.Long.fromString(value2);
        else
          return LongBits2.fromNumber(parseInt(value2, 10));
      }
      return value2.low || value2.high ? new LongBits2(value2.low >>> 0, value2.high >>> 0) : zero2;
    };
    LongBits2.prototype.toNumber = function toNumber(unsigned2) {
      if (!unsigned2 && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits2.prototype.toLong = function toLong(unsigned2) {
      return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned2)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned2) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits2.fromHash = function fromHash(hash3) {
      if (hash3 === zeroHash)
        return zero2;
      return new LongBits2(
        (charCodeAt.call(hash3, 0) | charCodeAt.call(hash3, 1) << 8 | charCodeAt.call(hash3, 2) << 16 | charCodeAt.call(hash3, 3) << 24) >>> 0,
        (charCodeAt.call(hash3, 4) | charCodeAt.call(hash3, 5) << 8 | charCodeAt.call(hash3, 6) << 16 | charCodeAt.call(hash3, 7) << 24) >>> 0
      );
    };
    LongBits2.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits2.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits2.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits2.prototype.length = function length3() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});
var require_minimal3 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/util/minimal.js"(exports2) {
    var util2 = exports2;
    util2.asPromise = require_aspromise();
    util2.base64 = require_base64();
    util2.EventEmitter = require_eventemitter();
    util2.float = require_float();
    util2.inquire = require_inquire();
    util2.utf8 = require_utf8();
    util2.pool = require_pool();
    util2.LongBits = require_longbits2();
    util2.isNode = Boolean(typeof globalThis !== "undefined" && globalThis && globalThis.process && globalThis.process.versions && globalThis.process.versions.node);
    util2.global = util2.isNode && globalThis || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util2.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util2.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util2.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value2) {
      return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2;
    };
    util2.isString = function isString2(value2) {
      return typeof value2 === "string" || value2 instanceof String;
    };
    util2.isObject = function isObject2(value2) {
      return value2 && typeof value2 === "object";
    };
    util2.isset = /**
    * Checks if a property on a message is considered to be present.
    * @param {Object} obj Plain object or message instance
    * @param {string} prop Property name
    * @returns {boolean} `true` if considered to be present, otherwise `false`
    */
    util2.isSet = function isSet(obj, prop) {
      var value2 = obj[prop];
      if (value2 != null && obj.hasOwnProperty(prop))
        return typeof value2 !== "object" || (Array.isArray(value2) ? value2.length : Object.keys(value2).length) > 0;
      return false;
    };
    util2.Buffer = function() {
      try {
        var Buffer2 = util2.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util2._Buffer_from = null;
    util2._Buffer_allocUnsafe = null;
    util2.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util2.Long = /* istanbul ignore next */
    util2.global.dcodeIO && /* istanbul ignore next */
    util2.global.dcodeIO.Long || /* istanbul ignore next */
    util2.global.Long || util2.inquire("long");
    util2.key2Re = /^true|false|0|1$/;
    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util2.longToHash = function longToHash(value2) {
      return value2 ? util2.LongBits.from(value2).toHash() : util2.LongBits.zeroHash;
    };
    util2.longFromHash = function longFromHash(hash3, unsigned2) {
      var bits2 = util2.LongBits.fromHash(hash3);
      if (util2.Long)
        return util2.Long.fromBits(bits2.lo, bits2.hi, unsigned2);
      return bits2.toNumber(Boolean(unsigned2));
    };
    function merge3(dst, src2, ifNotSet) {
      for (var keys = Object.keys(src2), i2 = 0; i2 < keys.length; ++i2)
        if (dst[keys[i2]] === void 0 || !ifNotSet)
          dst[keys[i2]] = src2[keys[i2]];
      return dst;
    }
    util2.merge = merge3;
    util2.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name9) {
      function CustomError(message2, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message2, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message2;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge3(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name9;
      } });
      CustomError.prototype.toString = function toString7() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util2.newError = newError;
    util2.ProtocolError = newError("ProtocolError");
    util2.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        fieldMap[fieldNames[i2]] = 1;
      return function() {
        for (var keys = Object.keys(this), i3 = keys.length - 1; i3 > -1; --i3)
          if (fieldMap[keys[i3]] === 1 && this[keys[i3]] !== void 0 && this[keys[i3]] !== null)
            return keys[i3];
      };
    };
    util2.oneOfSetter = function setOneOf(fieldNames) {
      return function(name9) {
        for (var i2 = 0; i2 < fieldNames.length; ++i2)
          if (fieldNames[i2] !== name9)
            delete this[fieldNames[i2]];
      };
    };
    util2.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util2._configure = function() {
      var Buffer2 = util2.Buffer;
      if (!Buffer2) {
        util2._Buffer_from = util2._Buffer_allocUnsafe = null;
        return;
      }
      util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value2, encoding) {
        return new Buffer2(value2, encoding);
      };
      util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});
var require_writer2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/writer.js"(exports2, module2) {
    module2.exports = Writer;
    var util2 = require_minimal3();
    var BufferWriter;
    var LongBits2 = util2.LongBits;
    var base642 = util2.base64;
    var utf8 = util2.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop5() {
    }
    function State(writer2) {
      this.head = writer2.head;
      this.tail = writer2.tail;
      this.len = writer2.len;
      this.next = writer2.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop5, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create10 = function create11() {
      return util2.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create10();
    Writer.alloc = function alloc3(size) {
      return new util2.Array(size);
    };
    if (util2.Array !== Array)
      Writer.alloc = util2.pool(Writer.alloc, util2.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf2, pos) {
      buf2[pos] = val & 255;
    }
    function writeVarint32(val, buf2, pos) {
      while (val > 127) {
        buf2[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf2[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value2) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value2 = value2 >>> 0) < 128 ? 1 : value2 < 16384 ? 2 : value2 < 2097152 ? 3 : value2 < 268435456 ? 4 : 5,
        value2
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value2) {
      return value2 < 0 ? this._push(writeVarint64, 10, LongBits2.fromNumber(value2)) : this.uint32(value2);
    };
    Writer.prototype.sint32 = function write_sint32(value2) {
      return this.uint32((value2 << 1 ^ value2 >> 31) >>> 0);
    };
    function writeVarint64(val, buf2, pos) {
      while (val.hi) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf2[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value2) {
      var bits2 = LongBits2.from(value2);
      return this._push(writeVarint64, bits2.length(), bits2);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value2) {
      var bits2 = LongBits2.from(value2).zzEncode();
      return this._push(writeVarint64, bits2.length(), bits2);
    };
    Writer.prototype.bool = function write_bool(value2) {
      return this._push(writeByte, 1, value2 ? 1 : 0);
    };
    function writeFixed32(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value2) {
      return this._push(writeFixed32, 4, value2 >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value2) {
      var bits2 = LongBits2.from(value2);
      return this._push(writeFixed32, 4, bits2.lo)._push(writeFixed32, 4, bits2.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value2) {
      return this._push(util2.float.writeFloatLE, 4, value2);
    };
    Writer.prototype.double = function write_double(value2) {
      return this._push(util2.float.writeDoubleLE, 8, value2);
    };
    var writeBytes = util2.Array.prototype.set ? function writeBytes_set(val, buf2, pos) {
      buf2.set(val, pos);
    } : function writeBytes_for(val, buf2, pos) {
      for (var i2 = 0; i2 < val.length; ++i2)
        buf2[pos + i2] = val[i2];
    };
    Writer.prototype.bytes = function write_bytes(value2) {
      var len = value2.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util2.isString(value2)) {
        var buf2 = Writer.alloc(len = base642.length(value2));
        base642.decode(value2, buf2, 0);
        value2 = buf2;
      }
      return this.uint32(len)._push(writeBytes, len, value2);
    };
    Writer.prototype.string = function write_string(value2) {
      var len = utf8.length(value2);
      return len ? this.uint32(len)._push(utf8.write, len, value2) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop5, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop5, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf2 = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf2, pos);
        pos += head.len;
        head = head.next;
      }
      return buf2;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create10();
      BufferWriter._configure();
    };
  }
});
var require_writer_buffer2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    module2.exports = BufferWriter;
    var Writer = require_writer2();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util2 = require_minimal3();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util2._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util2.Buffer && util2.Buffer.prototype instanceof Uint8Array && util2.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf2, pos) {
        buf2.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf2, pos) {
        if (val.copy)
          val.copy(buf2, pos, 0, val.length);
        else
          for (var i2 = 0; i2 < val.length; )
            buf2[pos++] = val[i2++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value2) {
      if (util2.isString(value2))
        value2 = util2._Buffer_from(value2, "base64");
      var len = value2.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value2);
      return this;
    };
    function writeStringBuffer(val, buf2, pos) {
      if (val.length < 40)
        util2.utf8.write(val, buf2, pos);
      else if (buf2.utf8Write)
        buf2.utf8Write(val, pos);
      else
        buf2.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value2) {
      var len = util2.Buffer.byteLength(value2);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value2);
      return this;
    };
    BufferWriter._configure();
  }
});
var require_reader2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/reader.js"(exports2, module2) {
    module2.exports = Reader;
    var util2 = require_minimal3();
    var BufferReader;
    var LongBits2 = util2.LongBits;
    var utf8 = util2.utf8;
    function indexOutOfRange(reader3, writeLength) {
      return RangeError("index out of range: " + reader3.pos + " + " + (writeLength || 1) + " > " + reader3.len);
    }
    function Reader(buffer2) {
      this.buf = buffer2;
      this.pos = 0;
      this.len = buffer2.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
      if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    } : function create_array2(buffer2) {
      if (Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    };
    var create10 = function create11() {
      return util2.Buffer ? function create_buffer_setup(buffer2) {
        return (Reader.create = function create_buffer(buffer3) {
          return util2.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
        })(buffer2);
      } : create_array;
    };
    Reader.create = create10();
    Reader.prototype._slice = util2.Array.prototype.subarray || /* istanbul ignore next */
    util2.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value2 = 4294967295;
      return function read_uint32() {
        value2 = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        value2 = (value2 | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        value2 = (value2 | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        value2 = (value2 | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        value2 = (value2 | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value2;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value2;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value2 = this.uint32();
      return value2 >>> 1 ^ -(value2 & 1) | 0;
    };
    function readLongVarint() {
      var bits2 = new LongBits2(0, 0);
      var i2 = 0;
      if (this.len - this.pos > 4) {
        for (; i2 < 4; ++i2) {
          bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits2;
        }
        bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits2;
        i2 = 0;
      } else {
        for (; i2 < 3; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits2;
        }
        bits2.lo = (bits2.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
        return bits2;
      }
      if (this.len - this.pos > 4) {
        for (; i2 < 5; ++i2) {
          bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits2;
        }
      } else {
        for (; i2 < 5; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits2;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf2, end) {
      return (buf2[end - 4] | buf2[end - 3] << 8 | buf2[end - 2] << 16 | buf2[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits2(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value2 = util2.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value2;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value2 = util2.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value2;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length3 = this.uint32(), start = this.pos, end = this.pos + length3;
      if (end > this.len)
        throw indexOutOfRange(this, length3);
      this.pos += length3;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes2 = this.bytes();
      return utf8.read(bytes2, 0, bytes2.length);
    };
    Reader.prototype.skip = function skip(length3) {
      if (typeof length3 === "number") {
        if (this.pos + length3 > this.len)
          throw indexOutOfRange(this, length3);
        this.pos += length3;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create10();
      BufferReader._configure();
      var fn = util2.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util2.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});
var require_reader_buffer2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    module2.exports = BufferReader;
    var Reader = require_reader2();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util2 = require_minimal3();
    function BufferReader(buffer2) {
      Reader.call(this, buffer2);
    }
    BufferReader._configure = function() {
      if (util2.Buffer)
        BufferReader.prototype._slice = util2.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});
var require_service2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    module2.exports = Service2;
    var util2 = require_minimal3();
    (Service2.prototype = Object.create(util2.EventEmitter.prototype)).constructor = Service2;
    function Service2(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util2.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service2.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request2, callback) {
      if (!request2)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util2.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request2);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request2).finish(),
          function rpcCallback(err2, response) {
            if (err2) {
              self2.emit("error", err2, method);
              return callback(err2);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err3) {
                self2.emit("error", err3, method);
                return callback(err3);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err2) {
        self2.emit("error", err2, method);
        setTimeout(function() {
          callback(err2);
        }, 0);
        return void 0;
      }
    };
    Service2.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});
var require_rpc2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/rpc.js"(exports2) {
    var rpc = exports2;
    rpc.Service = require_service2();
  }
});
var require_roots2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/roots.js"(exports2, module2) {
    module2.exports = {};
  }
});
var require_index_minimal2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/index-minimal.js"(exports2) {
    var protobuf2 = exports2;
    protobuf2.build = "minimal";
    protobuf2.Writer = require_writer2();
    protobuf2.BufferWriter = require_writer_buffer2();
    protobuf2.Reader = require_reader2();
    protobuf2.BufferReader = require_reader_buffer2();
    protobuf2.util = require_minimal3();
    protobuf2.rpc = require_rpc2();
    protobuf2.roots = require_roots2();
    protobuf2.configure = configure3;
    function configure3() {
      protobuf2.util._configure();
      protobuf2.Writer._configure(protobuf2.BufferWriter);
      protobuf2.Reader._configure(protobuf2.BufferReader);
    }
    configure3();
  }
});
var require_minimal4 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/minimal.js"(exports2, module2) {
    module2.exports = require_index_minimal2();
  }
});
var require_rpc3 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/rpc.cjs"(exports2, module2) {
    (function(global2, factory) {
      if (typeof define === "function" && define.amd)
        define(["protobufjs/minimal"], factory);
      else if (typeof __require === "function" && typeof module2 === "object" && module2 && module2.exports)
        module2.exports = factory(require_minimal4());
    })(exports2, function($protobuf10) {
      var $Reader9 = $protobuf10.Reader, $Writer9 = $protobuf10.Writer, $util9 = $protobuf10.util;
      var $root9 = $protobuf10.roots["default"] || ($protobuf10.roots["default"] = {});
      $root9.RPC = function() {
        function RPC3(p) {
          this.subscriptions = [];
          this.messages = [];
          if (p) {
            for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
              if (p[ks[i2]] != null)
                this[ks[i2]] = p[ks[i2]];
          }
        }
        RPC3.prototype.subscriptions = $util9.emptyArray;
        RPC3.prototype.messages = $util9.emptyArray;
        RPC3.prototype.control = null;
        var $oneOfFields;
        Object.defineProperty(RPC3.prototype, "_control", {
          get: $util9.oneOfGetter($oneOfFields = ["control"]),
          set: $util9.oneOfSetter($oneOfFields)
        });
        RPC3.encode = function encode21(m, w) {
          if (!w)
            w = $Writer9.create();
          if (m.subscriptions != null && m.subscriptions.length) {
            for (var i2 = 0; i2 < m.subscriptions.length; ++i2)
              $root9.RPC.SubOpts.encode(m.subscriptions[i2], w.uint32(10).fork()).ldelim();
          }
          if (m.messages != null && m.messages.length) {
            for (var i2 = 0; i2 < m.messages.length; ++i2)
              $root9.RPC.Message.encode(m.messages[i2], w.uint32(18).fork()).ldelim();
          }
          if (m.control != null && Object.hasOwnProperty.call(m, "control"))
            $root9.RPC.ControlMessage.encode(m.control, w.uint32(26).fork()).ldelim();
          return w;
        };
        RPC3.decode = function decode17(r, l) {
          if (!(r instanceof $Reader9))
            r = $Reader9.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root9.RPC();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                if (!(m.subscriptions && m.subscriptions.length))
                  m.subscriptions = [];
                m.subscriptions.push($root9.RPC.SubOpts.decode(r, r.uint32()));
                break;
              case 2:
                if (!(m.messages && m.messages.length))
                  m.messages = [];
                m.messages.push($root9.RPC.Message.decode(r, r.uint32()));
                break;
              case 3:
                m.control = $root9.RPC.ControlMessage.decode(r, r.uint32());
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        RPC3.fromObject = function fromObject(d) {
          if (d instanceof $root9.RPC)
            return d;
          var m = new $root9.RPC();
          if (d.subscriptions) {
            if (!Array.isArray(d.subscriptions))
              throw TypeError(".RPC.subscriptions: array expected");
            m.subscriptions = [];
            for (var i2 = 0; i2 < d.subscriptions.length; ++i2) {
              if (typeof d.subscriptions[i2] !== "object")
                throw TypeError(".RPC.subscriptions: object expected");
              m.subscriptions[i2] = $root9.RPC.SubOpts.fromObject(d.subscriptions[i2]);
            }
          }
          if (d.messages) {
            if (!Array.isArray(d.messages))
              throw TypeError(".RPC.messages: array expected");
            m.messages = [];
            for (var i2 = 0; i2 < d.messages.length; ++i2) {
              if (typeof d.messages[i2] !== "object")
                throw TypeError(".RPC.messages: object expected");
              m.messages[i2] = $root9.RPC.Message.fromObject(d.messages[i2]);
            }
          }
          if (d.control != null) {
            if (typeof d.control !== "object")
              throw TypeError(".RPC.control: object expected");
            m.control = $root9.RPC.ControlMessage.fromObject(d.control);
          }
          return m;
        };
        RPC3.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.subscriptions = [];
            d.messages = [];
          }
          if (m.subscriptions && m.subscriptions.length) {
            d.subscriptions = [];
            for (var j = 0; j < m.subscriptions.length; ++j) {
              d.subscriptions[j] = $root9.RPC.SubOpts.toObject(m.subscriptions[j], o);
            }
          }
          if (m.messages && m.messages.length) {
            d.messages = [];
            for (var j = 0; j < m.messages.length; ++j) {
              d.messages[j] = $root9.RPC.Message.toObject(m.messages[j], o);
            }
          }
          if (m.control != null && m.hasOwnProperty("control")) {
            d.control = $root9.RPC.ControlMessage.toObject(m.control, o);
            if (o.oneofs)
              d._control = "control";
          }
          return d;
        };
        RPC3.prototype.toJSON = function toJSON2() {
          return this.constructor.toObject(this, $protobuf10.util.toJSONOptions);
        };
        RPC3.SubOpts = function() {
          function SubOpts(p) {
            if (p) {
              for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
                if (p[ks[i2]] != null)
                  this[ks[i2]] = p[ks[i2]];
            }
          }
          SubOpts.prototype.subscribe = null;
          SubOpts.prototype.topic = null;
          var $oneOfFields2;
          Object.defineProperty(SubOpts.prototype, "_subscribe", {
            get: $util9.oneOfGetter($oneOfFields2 = ["subscribe"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(SubOpts.prototype, "_topic", {
            get: $util9.oneOfGetter($oneOfFields2 = ["topic"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          SubOpts.encode = function encode21(m, w) {
            if (!w)
              w = $Writer9.create();
            if (m.subscribe != null && Object.hasOwnProperty.call(m, "subscribe"))
              w.uint32(8).bool(m.subscribe);
            if (m.topic != null && Object.hasOwnProperty.call(m, "topic"))
              w.uint32(18).string(m.topic);
            return w;
          };
          SubOpts.decode = function decode17(r, l) {
            if (!(r instanceof $Reader9))
              r = $Reader9.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root9.RPC.SubOpts();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.subscribe = r.bool();
                  break;
                case 2:
                  m.topic = r.string();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          SubOpts.fromObject = function fromObject(d) {
            if (d instanceof $root9.RPC.SubOpts)
              return d;
            var m = new $root9.RPC.SubOpts();
            if (d.subscribe != null) {
              m.subscribe = Boolean(d.subscribe);
            }
            if (d.topic != null) {
              m.topic = String(d.topic);
            }
            return m;
          };
          SubOpts.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.subscribe != null && m.hasOwnProperty("subscribe")) {
              d.subscribe = m.subscribe;
              if (o.oneofs)
                d._subscribe = "subscribe";
            }
            if (m.topic != null && m.hasOwnProperty("topic")) {
              d.topic = m.topic;
              if (o.oneofs)
                d._topic = "topic";
            }
            return d;
          };
          SubOpts.prototype.toJSON = function toJSON2() {
            return this.constructor.toObject(this, $protobuf10.util.toJSONOptions);
          };
          return SubOpts;
        }();
        RPC3.Message = function() {
          function Message4(p) {
            if (p) {
              for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
                if (p[ks[i2]] != null)
                  this[ks[i2]] = p[ks[i2]];
            }
          }
          Message4.prototype.from = null;
          Message4.prototype.data = null;
          Message4.prototype.seqno = null;
          Message4.prototype.topic = "";
          Message4.prototype.signature = null;
          Message4.prototype.key = null;
          var $oneOfFields2;
          Object.defineProperty(Message4.prototype, "_from", {
            get: $util9.oneOfGetter($oneOfFields2 = ["from"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message4.prototype, "_data", {
            get: $util9.oneOfGetter($oneOfFields2 = ["data"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message4.prototype, "_seqno", {
            get: $util9.oneOfGetter($oneOfFields2 = ["seqno"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message4.prototype, "_signature", {
            get: $util9.oneOfGetter($oneOfFields2 = ["signature"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message4.prototype, "_key", {
            get: $util9.oneOfGetter($oneOfFields2 = ["key"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          Message4.encode = function encode21(m, w) {
            if (!w)
              w = $Writer9.create();
            if (m.from != null && Object.hasOwnProperty.call(m, "from"))
              w.uint32(10).bytes(m.from);
            if (m.data != null && Object.hasOwnProperty.call(m, "data"))
              w.uint32(18).bytes(m.data);
            if (m.seqno != null && Object.hasOwnProperty.call(m, "seqno"))
              w.uint32(26).bytes(m.seqno);
            w.uint32(34).string(m.topic);
            if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
              w.uint32(42).bytes(m.signature);
            if (m.key != null && Object.hasOwnProperty.call(m, "key"))
              w.uint32(50).bytes(m.key);
            return w;
          };
          Message4.decode = function decode17(r, l) {
            if (!(r instanceof $Reader9))
              r = $Reader9.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root9.RPC.Message();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.from = r.bytes();
                  break;
                case 2:
                  m.data = r.bytes();
                  break;
                case 3:
                  m.seqno = r.bytes();
                  break;
                case 4:
                  m.topic = r.string();
                  break;
                case 5:
                  m.signature = r.bytes();
                  break;
                case 6:
                  m.key = r.bytes();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            if (!m.hasOwnProperty("topic"))
              throw $util9.ProtocolError("missing required 'topic'", { instance: m });
            return m;
          };
          Message4.fromObject = function fromObject(d) {
            if (d instanceof $root9.RPC.Message)
              return d;
            var m = new $root9.RPC.Message();
            if (d.from != null) {
              if (typeof d.from === "string")
                $util9.base64.decode(d.from, m.from = $util9.newBuffer($util9.base64.length(d.from)), 0);
              else if (d.from.length)
                m.from = d.from;
            }
            if (d.data != null) {
              if (typeof d.data === "string")
                $util9.base64.decode(d.data, m.data = $util9.newBuffer($util9.base64.length(d.data)), 0);
              else if (d.data.length)
                m.data = d.data;
            }
            if (d.seqno != null) {
              if (typeof d.seqno === "string")
                $util9.base64.decode(d.seqno, m.seqno = $util9.newBuffer($util9.base64.length(d.seqno)), 0);
              else if (d.seqno.length)
                m.seqno = d.seqno;
            }
            if (d.topic != null) {
              m.topic = String(d.topic);
            }
            if (d.signature != null) {
              if (typeof d.signature === "string")
                $util9.base64.decode(d.signature, m.signature = $util9.newBuffer($util9.base64.length(d.signature)), 0);
              else if (d.signature.length)
                m.signature = d.signature;
            }
            if (d.key != null) {
              if (typeof d.key === "string")
                $util9.base64.decode(d.key, m.key = $util9.newBuffer($util9.base64.length(d.key)), 0);
              else if (d.key.length)
                m.key = d.key;
            }
            return m;
          };
          Message4.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.defaults) {
              d.topic = "";
            }
            if (m.from != null && m.hasOwnProperty("from")) {
              d.from = o.bytes === String ? $util9.base64.encode(m.from, 0, m.from.length) : o.bytes === Array ? Array.prototype.slice.call(m.from) : m.from;
              if (o.oneofs)
                d._from = "from";
            }
            if (m.data != null && m.hasOwnProperty("data")) {
              d.data = o.bytes === String ? $util9.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
              if (o.oneofs)
                d._data = "data";
            }
            if (m.seqno != null && m.hasOwnProperty("seqno")) {
              d.seqno = o.bytes === String ? $util9.base64.encode(m.seqno, 0, m.seqno.length) : o.bytes === Array ? Array.prototype.slice.call(m.seqno) : m.seqno;
              if (o.oneofs)
                d._seqno = "seqno";
            }
            if (m.topic != null && m.hasOwnProperty("topic")) {
              d.topic = m.topic;
            }
            if (m.signature != null && m.hasOwnProperty("signature")) {
              d.signature = o.bytes === String ? $util9.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
              if (o.oneofs)
                d._signature = "signature";
            }
            if (m.key != null && m.hasOwnProperty("key")) {
              d.key = o.bytes === String ? $util9.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
              if (o.oneofs)
                d._key = "key";
            }
            return d;
          };
          Message4.prototype.toJSON = function toJSON2() {
            return this.constructor.toObject(this, $protobuf10.util.toJSONOptions);
          };
          return Message4;
        }();
        RPC3.ControlMessage = function() {
          function ControlMessage(p) {
            this.ihave = [];
            this.iwant = [];
            this.graft = [];
            this.prune = [];
            if (p) {
              for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
                if (p[ks[i2]] != null)
                  this[ks[i2]] = p[ks[i2]];
            }
          }
          ControlMessage.prototype.ihave = $util9.emptyArray;
          ControlMessage.prototype.iwant = $util9.emptyArray;
          ControlMessage.prototype.graft = $util9.emptyArray;
          ControlMessage.prototype.prune = $util9.emptyArray;
          ControlMessage.encode = function encode21(m, w) {
            if (!w)
              w = $Writer9.create();
            if (m.ihave != null && m.ihave.length) {
              for (var i2 = 0; i2 < m.ihave.length; ++i2)
                $root9.RPC.ControlIHave.encode(m.ihave[i2], w.uint32(10).fork()).ldelim();
            }
            if (m.iwant != null && m.iwant.length) {
              for (var i2 = 0; i2 < m.iwant.length; ++i2)
                $root9.RPC.ControlIWant.encode(m.iwant[i2], w.uint32(18).fork()).ldelim();
            }
            if (m.graft != null && m.graft.length) {
              for (var i2 = 0; i2 < m.graft.length; ++i2)
                $root9.RPC.ControlGraft.encode(m.graft[i2], w.uint32(26).fork()).ldelim();
            }
            if (m.prune != null && m.prune.length) {
              for (var i2 = 0; i2 < m.prune.length; ++i2)
                $root9.RPC.ControlPrune.encode(m.prune[i2], w.uint32(34).fork()).ldelim();
            }
            return w;
          };
          ControlMessage.decode = function decode17(r, l) {
            if (!(r instanceof $Reader9))
              r = $Reader9.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root9.RPC.ControlMessage();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  if (!(m.ihave && m.ihave.length))
                    m.ihave = [];
                  m.ihave.push($root9.RPC.ControlIHave.decode(r, r.uint32()));
                  break;
                case 2:
                  if (!(m.iwant && m.iwant.length))
                    m.iwant = [];
                  m.iwant.push($root9.RPC.ControlIWant.decode(r, r.uint32()));
                  break;
                case 3:
                  if (!(m.graft && m.graft.length))
                    m.graft = [];
                  m.graft.push($root9.RPC.ControlGraft.decode(r, r.uint32()));
                  break;
                case 4:
                  if (!(m.prune && m.prune.length))
                    m.prune = [];
                  m.prune.push($root9.RPC.ControlPrune.decode(r, r.uint32()));
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlMessage.fromObject = function fromObject(d) {
            if (d instanceof $root9.RPC.ControlMessage)
              return d;
            var m = new $root9.RPC.ControlMessage();
            if (d.ihave) {
              if (!Array.isArray(d.ihave))
                throw TypeError(".RPC.ControlMessage.ihave: array expected");
              m.ihave = [];
              for (var i2 = 0; i2 < d.ihave.length; ++i2) {
                if (typeof d.ihave[i2] !== "object")
                  throw TypeError(".RPC.ControlMessage.ihave: object expected");
                m.ihave[i2] = $root9.RPC.ControlIHave.fromObject(d.ihave[i2]);
              }
            }
            if (d.iwant) {
              if (!Array.isArray(d.iwant))
                throw TypeError(".RPC.ControlMessage.iwant: array expected");
              m.iwant = [];
              for (var i2 = 0; i2 < d.iwant.length; ++i2) {
                if (typeof d.iwant[i2] !== "object")
                  throw TypeError(".RPC.ControlMessage.iwant: object expected");
                m.iwant[i2] = $root9.RPC.ControlIWant.fromObject(d.iwant[i2]);
              }
            }
            if (d.graft) {
              if (!Array.isArray(d.graft))
                throw TypeError(".RPC.ControlMessage.graft: array expected");
              m.graft = [];
              for (var i2 = 0; i2 < d.graft.length; ++i2) {
                if (typeof d.graft[i2] !== "object")
                  throw TypeError(".RPC.ControlMessage.graft: object expected");
                m.graft[i2] = $root9.RPC.ControlGraft.fromObject(d.graft[i2]);
              }
            }
            if (d.prune) {
              if (!Array.isArray(d.prune))
                throw TypeError(".RPC.ControlMessage.prune: array expected");
              m.prune = [];
              for (var i2 = 0; i2 < d.prune.length; ++i2) {
                if (typeof d.prune[i2] !== "object")
                  throw TypeError(".RPC.ControlMessage.prune: object expected");
                m.prune[i2] = $root9.RPC.ControlPrune.fromObject(d.prune[i2]);
              }
            }
            return m;
          };
          ControlMessage.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.ihave = [];
              d.iwant = [];
              d.graft = [];
              d.prune = [];
            }
            if (m.ihave && m.ihave.length) {
              d.ihave = [];
              for (var j = 0; j < m.ihave.length; ++j) {
                d.ihave[j] = $root9.RPC.ControlIHave.toObject(m.ihave[j], o);
              }
            }
            if (m.iwant && m.iwant.length) {
              d.iwant = [];
              for (var j = 0; j < m.iwant.length; ++j) {
                d.iwant[j] = $root9.RPC.ControlIWant.toObject(m.iwant[j], o);
              }
            }
            if (m.graft && m.graft.length) {
              d.graft = [];
              for (var j = 0; j < m.graft.length; ++j) {
                d.graft[j] = $root9.RPC.ControlGraft.toObject(m.graft[j], o);
              }
            }
            if (m.prune && m.prune.length) {
              d.prune = [];
              for (var j = 0; j < m.prune.length; ++j) {
                d.prune[j] = $root9.RPC.ControlPrune.toObject(m.prune[j], o);
              }
            }
            return d;
          };
          ControlMessage.prototype.toJSON = function toJSON2() {
            return this.constructor.toObject(this, $protobuf10.util.toJSONOptions);
          };
          return ControlMessage;
        }();
        RPC3.ControlIHave = function() {
          function ControlIHave(p) {
            this.messageIDs = [];
            if (p) {
              for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
                if (p[ks[i2]] != null)
                  this[ks[i2]] = p[ks[i2]];
            }
          }
          ControlIHave.prototype.topicID = null;
          ControlIHave.prototype.messageIDs = $util9.emptyArray;
          var $oneOfFields2;
          Object.defineProperty(ControlIHave.prototype, "_topicID", {
            get: $util9.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          ControlIHave.encode = function encode21(m, w) {
            if (!w)
              w = $Writer9.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            if (m.messageIDs != null && m.messageIDs.length) {
              for (var i2 = 0; i2 < m.messageIDs.length; ++i2)
                w.uint32(18).bytes(m.messageIDs[i2]);
            }
            return w;
          };
          ControlIHave.decode = function decode17(r, l) {
            if (!(r instanceof $Reader9))
              r = $Reader9.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root9.RPC.ControlIHave();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                case 2:
                  if (!(m.messageIDs && m.messageIDs.length))
                    m.messageIDs = [];
                  m.messageIDs.push(r.bytes());
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlIHave.fromObject = function fromObject(d) {
            if (d instanceof $root9.RPC.ControlIHave)
              return d;
            var m = new $root9.RPC.ControlIHave();
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            if (d.messageIDs) {
              if (!Array.isArray(d.messageIDs))
                throw TypeError(".RPC.ControlIHave.messageIDs: array expected");
              m.messageIDs = [];
              for (var i2 = 0; i2 < d.messageIDs.length; ++i2) {
                if (typeof d.messageIDs[i2] === "string")
                  $util9.base64.decode(d.messageIDs[i2], m.messageIDs[i2] = $util9.newBuffer($util9.base64.length(d.messageIDs[i2])), 0);
                else if (d.messageIDs[i2].length)
                  m.messageIDs[i2] = d.messageIDs[i2];
              }
            }
            return m;
          };
          ControlIHave.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.messageIDs = [];
            }
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            if (m.messageIDs && m.messageIDs.length) {
              d.messageIDs = [];
              for (var j = 0; j < m.messageIDs.length; ++j) {
                d.messageIDs[j] = o.bytes === String ? $util9.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];
              }
            }
            return d;
          };
          ControlIHave.prototype.toJSON = function toJSON2() {
            return this.constructor.toObject(this, $protobuf10.util.toJSONOptions);
          };
          return ControlIHave;
        }();
        RPC3.ControlIWant = function() {
          function ControlIWant(p) {
            this.messageIDs = [];
            if (p) {
              for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
                if (p[ks[i2]] != null)
                  this[ks[i2]] = p[ks[i2]];
            }
          }
          ControlIWant.prototype.messageIDs = $util9.emptyArray;
          ControlIWant.encode = function encode21(m, w) {
            if (!w)
              w = $Writer9.create();
            if (m.messageIDs != null && m.messageIDs.length) {
              for (var i2 = 0; i2 < m.messageIDs.length; ++i2)
                w.uint32(10).bytes(m.messageIDs[i2]);
            }
            return w;
          };
          ControlIWant.decode = function decode17(r, l) {
            if (!(r instanceof $Reader9))
              r = $Reader9.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root9.RPC.ControlIWant();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  if (!(m.messageIDs && m.messageIDs.length))
                    m.messageIDs = [];
                  m.messageIDs.push(r.bytes());
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlIWant.fromObject = function fromObject(d) {
            if (d instanceof $root9.RPC.ControlIWant)
              return d;
            var m = new $root9.RPC.ControlIWant();
            if (d.messageIDs) {
              if (!Array.isArray(d.messageIDs))
                throw TypeError(".RPC.ControlIWant.messageIDs: array expected");
              m.messageIDs = [];
              for (var i2 = 0; i2 < d.messageIDs.length; ++i2) {
                if (typeof d.messageIDs[i2] === "string")
                  $util9.base64.decode(d.messageIDs[i2], m.messageIDs[i2] = $util9.newBuffer($util9.base64.length(d.messageIDs[i2])), 0);
                else if (d.messageIDs[i2].length)
                  m.messageIDs[i2] = d.messageIDs[i2];
              }
            }
            return m;
          };
          ControlIWant.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.messageIDs = [];
            }
            if (m.messageIDs && m.messageIDs.length) {
              d.messageIDs = [];
              for (var j = 0; j < m.messageIDs.length; ++j) {
                d.messageIDs[j] = o.bytes === String ? $util9.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];
              }
            }
            return d;
          };
          ControlIWant.prototype.toJSON = function toJSON2() {
            return this.constructor.toObject(this, $protobuf10.util.toJSONOptions);
          };
          return ControlIWant;
        }();
        RPC3.ControlGraft = function() {
          function ControlGraft(p) {
            if (p) {
              for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
                if (p[ks[i2]] != null)
                  this[ks[i2]] = p[ks[i2]];
            }
          }
          ControlGraft.prototype.topicID = null;
          var $oneOfFields2;
          Object.defineProperty(ControlGraft.prototype, "_topicID", {
            get: $util9.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          ControlGraft.encode = function encode21(m, w) {
            if (!w)
              w = $Writer9.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            return w;
          };
          ControlGraft.decode = function decode17(r, l) {
            if (!(r instanceof $Reader9))
              r = $Reader9.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root9.RPC.ControlGraft();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlGraft.fromObject = function fromObject(d) {
            if (d instanceof $root9.RPC.ControlGraft)
              return d;
            var m = new $root9.RPC.ControlGraft();
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            return m;
          };
          ControlGraft.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            return d;
          };
          ControlGraft.prototype.toJSON = function toJSON2() {
            return this.constructor.toObject(this, $protobuf10.util.toJSONOptions);
          };
          return ControlGraft;
        }();
        RPC3.ControlPrune = function() {
          function ControlPrune(p) {
            this.peers = [];
            if (p) {
              for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
                if (p[ks[i2]] != null)
                  this[ks[i2]] = p[ks[i2]];
            }
          }
          ControlPrune.prototype.topicID = null;
          ControlPrune.prototype.peers = $util9.emptyArray;
          ControlPrune.prototype.backoff = null;
          var $oneOfFields2;
          Object.defineProperty(ControlPrune.prototype, "_topicID", {
            get: $util9.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(ControlPrune.prototype, "_backoff", {
            get: $util9.oneOfGetter($oneOfFields2 = ["backoff"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          ControlPrune.encode = function encode21(m, w) {
            if (!w)
              w = $Writer9.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            if (m.peers != null && m.peers.length) {
              for (var i2 = 0; i2 < m.peers.length; ++i2)
                $root9.RPC.PeerInfo.encode(m.peers[i2], w.uint32(18).fork()).ldelim();
            }
            if (m.backoff != null && Object.hasOwnProperty.call(m, "backoff"))
              w.uint32(24).uint64(m.backoff);
            return w;
          };
          ControlPrune.decode = function decode17(r, l) {
            if (!(r instanceof $Reader9))
              r = $Reader9.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root9.RPC.ControlPrune();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                case 2:
                  if (!(m.peers && m.peers.length))
                    m.peers = [];
                  m.peers.push($root9.RPC.PeerInfo.decode(r, r.uint32()));
                  break;
                case 3:
                  m.backoff = r.uint64();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlPrune.fromObject = function fromObject(d) {
            if (d instanceof $root9.RPC.ControlPrune)
              return d;
            var m = new $root9.RPC.ControlPrune();
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            if (d.peers) {
              if (!Array.isArray(d.peers))
                throw TypeError(".RPC.ControlPrune.peers: array expected");
              m.peers = [];
              for (var i2 = 0; i2 < d.peers.length; ++i2) {
                if (typeof d.peers[i2] !== "object")
                  throw TypeError(".RPC.ControlPrune.peers: object expected");
                m.peers[i2] = $root9.RPC.PeerInfo.fromObject(d.peers[i2]);
              }
            }
            if (d.backoff != null) {
              if ($util9.Long)
                (m.backoff = $util9.Long.fromValue(d.backoff)).unsigned = true;
              else if (typeof d.backoff === "string")
                m.backoff = parseInt(d.backoff, 10);
              else if (typeof d.backoff === "number")
                m.backoff = d.backoff;
              else if (typeof d.backoff === "object")
                m.backoff = new $util9.LongBits(d.backoff.low >>> 0, d.backoff.high >>> 0).toNumber(true);
            }
            return m;
          };
          ControlPrune.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.peers = [];
            }
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            if (m.peers && m.peers.length) {
              d.peers = [];
              for (var j = 0; j < m.peers.length; ++j) {
                d.peers[j] = $root9.RPC.PeerInfo.toObject(m.peers[j], o);
              }
            }
            if (m.backoff != null && m.hasOwnProperty("backoff")) {
              if (typeof m.backoff === "number")
                d.backoff = o.longs === String ? String(m.backoff) : m.backoff;
              else
                d.backoff = o.longs === String ? $util9.Long.prototype.toString.call(m.backoff) : o.longs === Number ? new $util9.LongBits(m.backoff.low >>> 0, m.backoff.high >>> 0).toNumber(true) : m.backoff;
              if (o.oneofs)
                d._backoff = "backoff";
            }
            return d;
          };
          ControlPrune.prototype.toJSON = function toJSON2() {
            return this.constructor.toObject(this, $protobuf10.util.toJSONOptions);
          };
          return ControlPrune;
        }();
        RPC3.PeerInfo = function() {
          function PeerInfo(p) {
            if (p) {
              for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
                if (p[ks[i2]] != null)
                  this[ks[i2]] = p[ks[i2]];
            }
          }
          PeerInfo.prototype.peerID = null;
          PeerInfo.prototype.signedPeerRecord = null;
          var $oneOfFields2;
          Object.defineProperty(PeerInfo.prototype, "_peerID", {
            get: $util9.oneOfGetter($oneOfFields2 = ["peerID"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(PeerInfo.prototype, "_signedPeerRecord", {
            get: $util9.oneOfGetter($oneOfFields2 = ["signedPeerRecord"]),
            set: $util9.oneOfSetter($oneOfFields2)
          });
          PeerInfo.encode = function encode21(m, w) {
            if (!w)
              w = $Writer9.create();
            if (m.peerID != null && Object.hasOwnProperty.call(m, "peerID"))
              w.uint32(10).bytes(m.peerID);
            if (m.signedPeerRecord != null && Object.hasOwnProperty.call(m, "signedPeerRecord"))
              w.uint32(18).bytes(m.signedPeerRecord);
            return w;
          };
          PeerInfo.decode = function decode17(r, l) {
            if (!(r instanceof $Reader9))
              r = $Reader9.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root9.RPC.PeerInfo();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.peerID = r.bytes();
                  break;
                case 2:
                  m.signedPeerRecord = r.bytes();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          PeerInfo.fromObject = function fromObject(d) {
            if (d instanceof $root9.RPC.PeerInfo)
              return d;
            var m = new $root9.RPC.PeerInfo();
            if (d.peerID != null) {
              if (typeof d.peerID === "string")
                $util9.base64.decode(d.peerID, m.peerID = $util9.newBuffer($util9.base64.length(d.peerID)), 0);
              else if (d.peerID.length)
                m.peerID = d.peerID;
            }
            if (d.signedPeerRecord != null) {
              if (typeof d.signedPeerRecord === "string")
                $util9.base64.decode(d.signedPeerRecord, m.signedPeerRecord = $util9.newBuffer($util9.base64.length(d.signedPeerRecord)), 0);
              else if (d.signedPeerRecord.length)
                m.signedPeerRecord = d.signedPeerRecord;
            }
            return m;
          };
          PeerInfo.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.peerID != null && m.hasOwnProperty("peerID")) {
              d.peerID = o.bytes === String ? $util9.base64.encode(m.peerID, 0, m.peerID.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerID) : m.peerID;
              if (o.oneofs)
                d._peerID = "peerID";
            }
            if (m.signedPeerRecord != null && m.hasOwnProperty("signedPeerRecord")) {
              d.signedPeerRecord = o.bytes === String ? $util9.base64.encode(m.signedPeerRecord, 0, m.signedPeerRecord.length) : o.bytes === Array ? Array.prototype.slice.call(m.signedPeerRecord) : m.signedPeerRecord;
              if (o.oneofs)
                d._signedPeerRecord = "signedPeerRecord";
            }
            return d;
          };
          PeerInfo.prototype.toJSON = function toJSON2() {
            return this.constructor.toObject(this, $protobuf10.util.toJSONOptions);
          };
          return PeerInfo;
        }();
        return RPC3;
      }();
      return $root9;
    });
  }
});
var require_denque = __commonJS({
  "node_modules/denque/index.js"(exports2, module2) {
    function Denque2(array, options) {
      var options = options || {};
      this._head = 0;
      this._tail = 0;
      this._capacity = options.capacity;
      this._capacityMask = 3;
      this._list = new Array(4);
      if (Array.isArray(array)) {
        this._fromArray(array);
      }
    }
    Denque2.prototype.peekAt = function peekAt(index2) {
      var i2 = index2;
      if (i2 !== (i2 | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i2 >= len || i2 < -len)
        return void 0;
      if (i2 < 0)
        i2 += len;
      i2 = this._head + i2 & this._capacityMask;
      return this._list[i2];
    };
    Denque2.prototype.get = function get3(i2) {
      return this.peekAt(i2);
    };
    Denque2.prototype.peek = function peek() {
      if (this._head === this._tail)
        return void 0;
      return this._list[this._head];
    };
    Denque2.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque2.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque2.prototype, "length", {
      get: function length3() {
        return this.size();
      }
    });
    Denque2.prototype.size = function size() {
      if (this._head === this._tail)
        return 0;
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque2.prototype.unshift = function unshift(item) {
      if (item === void 0)
        return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head)
        this._growArray();
      if (this._capacity && this.size() > this._capacity)
        this.pop();
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque2.prototype.shift = function shift() {
      var head = this._head;
      if (head === this._tail)
        return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque2.prototype.push = function push(item) {
      if (item === void 0)
        return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque2.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head)
        return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque2.prototype.removeOne = function removeOne(index2) {
      var i2 = index2;
      if (i2 !== (i2 | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i2 >= size || i2 < -size)
        return void 0;
      if (i2 < 0)
        i2 += size;
      i2 = this._head + i2 & this._capacityMask;
      var item = this._list[i2];
      var k;
      if (index2 < size / 2) {
        for (k = index2; k > 0; k--) {
          this._list[i2] = this._list[i2 = i2 - 1 + len & this._capacityMask];
        }
        this._list[i2] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index2; k > 0; k--) {
          this._list[i2] = this._list[i2 = i2 + 1 + len & this._capacityMask];
        }
        this._list[i2] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque2.prototype.remove = function remove(index2, count) {
      var i2 = index2;
      var removed;
      var del_count = count;
      if (i2 !== (i2 | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i2 >= size || i2 < -size || count < 1)
        return void 0;
      if (i2 < 0)
        i2 += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i2);
        return removed;
      }
      if (i2 === 0 && i2 + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i2 + count > size)
        count = size - i2;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i2 + k & this._capacityMask];
      }
      i2 = this._head + i2 & this._capacityMask;
      if (index2 + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i2 = i2 + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index2 === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i2 = i2 + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i2 < size / 2) {
        this._head = this._head + index2 + count + len & this._capacityMask;
        for (k = index2; k > 0; k--) {
          this.unshift(this._list[i2 = i2 - 1 + len & this._capacityMask]);
        }
        i2 = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i2 = i2 - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index2 < 0)
          this._tail = i2;
      } else {
        this._tail = i2;
        i2 = i2 + count + len & this._capacityMask;
        for (k = size - (count + index2); k > 0; k--) {
          this.push(this._list[i2++]);
        }
        i2 = this._tail;
        while (del_count > 0) {
          this._list[i2 = i2 + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
        this._shrinkArray();
      return removed;
    };
    Denque2.prototype.splice = function splice(index2, count) {
      var i2 = index2;
      if (i2 !== (i2 | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i2 < 0)
        i2 += size;
      if (i2 > size)
        return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i2 < size / 2) {
          temp = new Array(i2);
          for (k = 0; k < i2; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i2 > 0) {
              this._head = this._head + i2 + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i2, count);
            this._head = this._head + i2 + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i2; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i2 + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i2 + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i2 != size) {
              this._tail = this._head + i2 + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i2, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i2, count);
      }
    };
    Denque2.prototype.clear = function clear() {
      this._head = 0;
      this._tail = 0;
    };
    Denque2.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque2.prototype.toArray = function toArray2() {
      return this._copyArray(false);
    };
    Denque2.prototype._fromArray = function _fromArray(array) {
      for (var i2 = 0; i2 < array.length; i2++)
        this.push(array[i2]);
    };
    Denque2.prototype._copyArray = function _copyArray(fullCopy) {
      var newArray = [];
      var list = this._list;
      var len = list.length;
      var i2;
      if (fullCopy || this._head > this._tail) {
        for (i2 = this._head; i2 < len; i2++)
          newArray.push(list[i2]);
        for (i2 = 0; i2 < this._tail; i2++)
          newArray.push(list[i2]);
      } else {
        for (i2 = this._head; i2 < this._tail; i2++)
          newArray.push(list[i2]);
      }
      return newArray;
    };
    Denque2.prototype._growArray = function _growArray() {
      if (this._head) {
        this._list = this._copyArray(true);
        this._head = 0;
      }
      this._tail = this._list.length;
      this._list.length <<= 1;
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque2.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    module2.exports = Denque2;
  }
});
var require_source = __commonJS({
  "node_modules/stream-to-it/source.js"(exports2, module2) {
    module2.exports = (readable) => {
      if (readable[Symbol.asyncIterator])
        return readable;
      if (readable.getReader) {
        return async function* () {
          const reader3 = readable.getReader();
          try {
            while (true) {
              const { done, value: value2 } = await reader3.read();
              if (done)
                return;
              yield value2;
            }
          } finally {
            reader3.releaseLock();
          }
        }();
      }
      throw new Error("unknown stream");
    };
  }
});
var require_glob_source = __commonJS({
  "browser-external:ipfs-utils/src/files/glob-source.js"(exports2, module2) {
    module2.exports = {};
  }
});
var require_url_source = __commonJS({
  "node_modules/ipfs-utils/src/files/url-source.js"(exports2, module2) {
    var HTTP6 = require_http();
    var urlSource2 = (url2, options) => {
      return {
        path: decodeURIComponent(new URL(url2).pathname.split("/").pop() || ""),
        content: readURLContent(url2, options)
      };
    };
    async function* readURLContent(url2, options) {
      const http = new HTTP6();
      const response = await http.get(url2, options);
      yield* response.iterator();
    }
    module2.exports = urlSource2;
  }
});
var require_random_browser = __commonJS({
  "node_modules/iso-random-stream/src/random.browser.js"(exports2, module2) {
    var MAX_BYTES = 65536;
    function randomBytes3(size) {
      const bytes2 = new Uint8Array(size);
      let generated = 0;
      if (size > 0) {
        if (size > MAX_BYTES) {
          while (generated < size) {
            if (generated + MAX_BYTES > size) {
              crypto.getRandomValues(
                bytes2.subarray(generated, generated + (size - generated))
              );
              generated += size - generated;
            } else {
              crypto.getRandomValues(
                bytes2.subarray(generated, generated + MAX_BYTES)
              );
              generated += MAX_BYTES;
            }
          }
        } else {
          crypto.getRandomValues(bytes2);
        }
      }
      return bytes2;
    }
    module2.exports = randomBytes3;
  }
});
var require_delay = __commonJS({
  "node_modules/delay/index.js"(exports2, module2) {
    var randomInteger = (minimum, maximum) => Math.floor(Math.random() * (maximum - minimum + 1) + minimum);
    var createAbortError = () => {
      const error = new Error("Delay aborted");
      error.name = "AbortError";
      return error;
    };
    var createDelay = ({ clearTimeout: defaultClear, setTimeout: set2, willResolve }) => (ms, { value: value2, signal } = {}) => {
      if (signal && signal.aborted) {
        return Promise.reject(createAbortError());
      }
      let timeoutId;
      let settle2;
      let rejectFn;
      const clear = defaultClear || clearTimeout;
      const signalListener = () => {
        clear(timeoutId);
        rejectFn(createAbortError());
      };
      const cleanup = () => {
        if (signal) {
          signal.removeEventListener("abort", signalListener);
        }
      };
      const delayPromise = new Promise((resolve7, reject) => {
        settle2 = () => {
          cleanup();
          if (willResolve) {
            resolve7(value2);
          } else {
            reject(value2);
          }
        };
        rejectFn = reject;
        timeoutId = (set2 || setTimeout)(settle2, ms);
      });
      if (signal) {
        signal.addEventListener("abort", signalListener, { once: true });
      }
      delayPromise.clear = () => {
        clear(timeoutId);
        timeoutId = null;
        settle2();
      };
      return delayPromise;
    };
    var createWithTimers = (clearAndSet) => {
      const delay4 = createDelay({ ...clearAndSet, willResolve: true });
      delay4.reject = createDelay({ ...clearAndSet, willResolve: false });
      delay4.range = (minimum, maximum, options) => delay4(randomInteger(minimum, maximum), options);
      return delay4;
    };
    var delay3 = createWithTimers();
    delay3.createWithTimers = createWithTimers;
    module2.exports = delay3;
    module2.exports.default = delay3;
  }
});
var require_src3 = __commonJS({
  "node_modules/set-delayed-interval/src/index.js"(exports2, module2) {
    var intervals = /* @__PURE__ */ new Map();
    var _generateId = () => `${Date.now()}:${Math.floor(Math.random() * 1e6)}`;
    async function _runPeriodically(task, interval, id) {
      while (intervals.get(id)) {
        try {
          await task();
        } catch (err2) {
          setTimeout(() => {
            throw err2;
          }, 1);
          break;
        }
        if (!intervals.get(id)) {
          break;
        }
        await new Promise((resolve7) => {
          const _timeout = setTimeout(resolve7, interval);
          intervals.set(id, _timeout);
        });
      }
    }
    function setDelayedInterval3(task, interval, delay3) {
      delay3 = delay3 || interval;
      const id = _generateId();
      const _timeout = setTimeout(() => {
        _runPeriodically(task, interval, id);
      }, delay3);
      intervals.set(id, _timeout);
      return id;
    }
    function clearDelayedInterval3(id) {
      const _timeout = intervals.get(id);
      if (_timeout) {
        clearTimeout(_timeout);
        intervals.delete(id);
      }
    }
    module2.exports = {
      setDelayedInterval: setDelayedInterval3,
      clearDelayedInterval: clearDelayedInterval3
    };
  }
});
var require_RateLimiterAbstract = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterAbstract.js"(exports2, module2) {
    module2.exports = class RateLimiterAbstract {
      /**
       *
       * @param opts Object Defaults {
       *   points: 4, // Number of points
       *   duration: 1, // Per seconds
       *   blockDuration: 0, // Block if consumed more than points in current duration for blockDuration seconds
       *   execEvenly: false, // Execute allowed actions evenly over duration
       *   execEvenlyMinDelayMs: duration * 1000 / points, // ms, works with execEvenly=true option
       *   keyPrefix: 'rlflx',
       * }
       */
      constructor(opts = {}) {
        this.points = opts.points;
        this.duration = opts.duration;
        this.blockDuration = opts.blockDuration;
        this.execEvenly = opts.execEvenly;
        this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs;
        this.keyPrefix = opts.keyPrefix;
      }
      get points() {
        return this._points;
      }
      set points(value2) {
        this._points = value2 >= 0 ? value2 : 4;
      }
      get duration() {
        return this._duration;
      }
      set duration(value2) {
        this._duration = typeof value2 === "undefined" ? 1 : value2;
      }
      get msDuration() {
        return this.duration * 1e3;
      }
      get blockDuration() {
        return this._blockDuration;
      }
      set blockDuration(value2) {
        this._blockDuration = typeof value2 === "undefined" ? 0 : value2;
      }
      get msBlockDuration() {
        return this.blockDuration * 1e3;
      }
      get execEvenly() {
        return this._execEvenly;
      }
      set execEvenly(value2) {
        this._execEvenly = typeof value2 === "undefined" ? false : Boolean(value2);
      }
      get execEvenlyMinDelayMs() {
        return this._execEvenlyMinDelayMs;
      }
      set execEvenlyMinDelayMs(value2) {
        this._execEvenlyMinDelayMs = typeof value2 === "undefined" ? Math.ceil(this.msDuration / this.points) : value2;
      }
      get keyPrefix() {
        return this._keyPrefix;
      }
      set keyPrefix(value2) {
        if (typeof value2 === "undefined") {
          value2 = "rlflx";
        }
        if (typeof value2 !== "string") {
          throw new Error("keyPrefix must be string");
        }
        this._keyPrefix = value2;
      }
      _getKeySecDuration(options = {}) {
        return options && options.customDuration >= 0 ? options.customDuration : this.duration;
      }
      getKey(key) {
        return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;
      }
      parseKey(rlKey) {
        return rlKey.substring(this.keyPrefix.length);
      }
      consume() {
        throw new Error("You have to implement the method 'consume'!");
      }
      penalty() {
        throw new Error("You have to implement the method 'penalty'!");
      }
      reward() {
        throw new Error("You have to implement the method 'reward'!");
      }
      get() {
        throw new Error("You have to implement the method 'get'!");
      }
      set() {
        throw new Error("You have to implement the method 'set'!");
      }
      block() {
        throw new Error("You have to implement the method 'block'!");
      }
      delete() {
        throw new Error("You have to implement the method 'delete'!");
      }
    };
  }
});
var require_BlockedKeys = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/BlockedKeys/BlockedKeys.js"(exports2, module2) {
    module2.exports = class BlockedKeys {
      constructor() {
        this._keys = {};
        this._addedKeysAmount = 0;
      }
      collectExpired() {
        const now = Date.now();
        Object.keys(this._keys).forEach((key) => {
          if (this._keys[key] <= now) {
            delete this._keys[key];
          }
        });
        this._addedKeysAmount = Object.keys(this._keys).length;
      }
      /**
       * Add new blocked key
       *
       * @param key String
       * @param sec Number
       */
      add(key, sec) {
        this.addMs(key, sec * 1e3);
      }
      /**
       * Add new blocked key for ms
       *
       * @param key String
       * @param ms Number
       */
      addMs(key, ms) {
        this._keys[key] = Date.now() + ms;
        this._addedKeysAmount++;
        if (this._addedKeysAmount > 999) {
          this.collectExpired();
        }
      }
      /**
       * 0 means not blocked
       *
       * @param key
       * @returns {number}
       */
      msBeforeExpire(key) {
        const expire = this._keys[key];
        if (expire && expire >= Date.now()) {
          this.collectExpired();
          const now = Date.now();
          return expire >= now ? expire - now : 0;
        }
        return 0;
      }
      /**
       * If key is not given, delete all data in memory
       * 
       * @param {string|undefined} key
       */
      delete(key) {
        if (key) {
          delete this._keys[key];
        } else {
          Object.keys(this._keys).forEach((key2) => {
            delete this._keys[key2];
          });
        }
      }
    };
  }
});
var require_BlockedKeys2 = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/BlockedKeys/index.js"(exports2, module2) {
    var BlockedKeys = require_BlockedKeys();
    module2.exports = BlockedKeys;
  }
});
var require_RateLimiterRes = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterRes.js"(exports2, module2) {
    module2.exports = class RateLimiterRes {
      constructor(remainingPoints, msBeforeNext, consumedPoints, isFirstInDuration) {
        this.remainingPoints = typeof remainingPoints === "undefined" ? 0 : remainingPoints;
        this.msBeforeNext = typeof msBeforeNext === "undefined" ? 0 : msBeforeNext;
        this.consumedPoints = typeof consumedPoints === "undefined" ? 0 : consumedPoints;
        this.isFirstInDuration = typeof isFirstInDuration === "undefined" ? false : isFirstInDuration;
      }
      get msBeforeNext() {
        return this._msBeforeNext;
      }
      set msBeforeNext(ms) {
        this._msBeforeNext = ms;
        return this;
      }
      get remainingPoints() {
        return this._remainingPoints;
      }
      set remainingPoints(p) {
        this._remainingPoints = p;
        return this;
      }
      get consumedPoints() {
        return this._consumedPoints;
      }
      set consumedPoints(p) {
        this._consumedPoints = p;
        return this;
      }
      get isFirstInDuration() {
        return this._isFirstInDuration;
      }
      set isFirstInDuration(value2) {
        this._isFirstInDuration = Boolean(value2);
      }
      _getDecoratedProperties() {
        return {
          remainingPoints: this.remainingPoints,
          msBeforeNext: this.msBeforeNext,
          consumedPoints: this.consumedPoints,
          isFirstInDuration: this.isFirstInDuration
        };
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return this._getDecoratedProperties();
      }
      toString() {
        return JSON.stringify(this._getDecoratedProperties());
      }
      toJSON() {
        return this._getDecoratedProperties();
      }
    };
  }
});
var require_RateLimiterStoreAbstract = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterStoreAbstract.js"(exports2, module2) {
    var RateLimiterAbstract = require_RateLimiterAbstract();
    var BlockedKeys = require_BlockedKeys2();
    var RateLimiterRes = require_RateLimiterRes();
    module2.exports = class RateLimiterStoreAbstract extends RateLimiterAbstract {
      /**
       *
       * @param opts Object Defaults {
       *   ... see other in RateLimiterAbstract
       *
       *   inMemoryBlockOnConsumed: 40, // Number of points when key is blocked
       *   inMemoryBlockDuration: 10, // Block duration in seconds
       *   insuranceLimiter: RateLimiterAbstract
       * }
       */
      constructor(opts = {}) {
        super(opts);
        this.inMemoryBlockOnConsumed = opts.inMemoryBlockOnConsumed || opts.inmemoryBlockOnConsumed;
        this.inMemoryBlockDuration = opts.inMemoryBlockDuration || opts.inmemoryBlockDuration;
        this.insuranceLimiter = opts.insuranceLimiter;
        this._inMemoryBlockedKeys = new BlockedKeys();
      }
      get client() {
        return this._client;
      }
      set client(value2) {
        if (typeof value2 === "undefined") {
          throw new Error("storeClient is not set");
        }
        this._client = value2;
      }
      /**
       * Have to be launched after consume
       * It blocks key and execute evenly depending on result from store
       *
       * It uses _getRateLimiterRes function to prepare RateLimiterRes from store result
       *
       * @param resolve
       * @param reject
       * @param rlKey
       * @param changedPoints
       * @param storeResult
       * @param {Object} options
       * @private
       */
      _afterConsume(resolve7, reject, rlKey, changedPoints, storeResult, options = {}) {
        const res = this._getRateLimiterRes(rlKey, changedPoints, storeResult);
        if (this.inMemoryBlockOnConsumed > 0 && !(this.inMemoryBlockDuration > 0) && res.consumedPoints >= this.inMemoryBlockOnConsumed) {
          this._inMemoryBlockedKeys.addMs(rlKey, res.msBeforeNext);
          if (res.consumedPoints > this.points) {
            return reject(res);
          } else {
            return resolve7(res);
          }
        } else if (res.consumedPoints > this.points) {
          let blockPromise = Promise.resolve();
          if (this.blockDuration > 0 && res.consumedPoints <= this.points + changedPoints) {
            res.msBeforeNext = this.msBlockDuration;
            blockPromise = this._block(rlKey, res.consumedPoints, this.msBlockDuration, options);
          }
          if (this.inMemoryBlockOnConsumed > 0 && res.consumedPoints >= this.inMemoryBlockOnConsumed) {
            this._inMemoryBlockedKeys.add(rlKey, this.inMemoryBlockDuration);
            res.msBeforeNext = this.msInMemoryBlockDuration;
          }
          blockPromise.then(() => {
            reject(res);
          }).catch((err2) => {
            reject(err2);
          });
        } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
          let delay3 = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
          if (delay3 < this.execEvenlyMinDelayMs) {
            delay3 = res.consumedPoints * this.execEvenlyMinDelayMs;
          }
          setTimeout(resolve7, delay3, res);
        } else {
          resolve7(res);
        }
      }
      _handleError(err2, funcName, resolve7, reject, key, data = false, options = {}) {
        if (!(this.insuranceLimiter instanceof RateLimiterAbstract)) {
          reject(err2);
        } else {
          this.insuranceLimiter[funcName](key, data, options).then((res) => {
            resolve7(res);
          }).catch((res) => {
            reject(res);
          });
        }
      }
      /**
       * @deprecated Use camelCase version
       * @returns {BlockedKeys}
       * @private
       */
      get _inmemoryBlockedKeys() {
        return this._inMemoryBlockedKeys;
      }
      /**
       * @deprecated Use camelCase version
       * @param rlKey
       * @returns {number}
       */
      getInmemoryBlockMsBeforeExpire(rlKey) {
        return this.getInMemoryBlockMsBeforeExpire(rlKey);
      }
      /**
       * @deprecated Use camelCase version
       * @returns {number|number}
       */
      get inmemoryBlockOnConsumed() {
        return this.inMemoryBlockOnConsumed;
      }
      /**
       * @deprecated Use camelCase version
       * @param value
       */
      set inmemoryBlockOnConsumed(value2) {
        this.inMemoryBlockOnConsumed = value2;
      }
      /**
       * @deprecated Use camelCase version
       * @returns {number|number}
       */
      get inmemoryBlockDuration() {
        return this.inMemoryBlockDuration;
      }
      /**
       * @deprecated Use camelCase version
       * @param value
       */
      set inmemoryBlockDuration(value2) {
        this.inMemoryBlockDuration = value2;
      }
      /**
       * @deprecated Use camelCase version
       * @returns {number}
       */
      get msInmemoryBlockDuration() {
        return this.inMemoryBlockDuration * 1e3;
      }
      getInMemoryBlockMsBeforeExpire(rlKey) {
        if (this.inMemoryBlockOnConsumed > 0) {
          return this._inMemoryBlockedKeys.msBeforeExpire(rlKey);
        }
        return 0;
      }
      get inMemoryBlockOnConsumed() {
        return this._inMemoryBlockOnConsumed;
      }
      set inMemoryBlockOnConsumed(value2) {
        this._inMemoryBlockOnConsumed = value2 ? parseInt(value2) : 0;
        if (this.inMemoryBlockOnConsumed > 0 && this.points > this.inMemoryBlockOnConsumed) {
          throw new Error('inMemoryBlockOnConsumed option must be greater or equal "points" option');
        }
      }
      get inMemoryBlockDuration() {
        return this._inMemoryBlockDuration;
      }
      set inMemoryBlockDuration(value2) {
        this._inMemoryBlockDuration = value2 ? parseInt(value2) : 0;
        if (this.inMemoryBlockDuration > 0 && this.inMemoryBlockOnConsumed === 0) {
          throw new Error("inMemoryBlockOnConsumed option must be set up");
        }
      }
      get msInMemoryBlockDuration() {
        return this._inMemoryBlockDuration * 1e3;
      }
      get insuranceLimiter() {
        return this._insuranceLimiter;
      }
      set insuranceLimiter(value2) {
        if (typeof value2 !== "undefined" && !(value2 instanceof RateLimiterAbstract)) {
          throw new Error("insuranceLimiter must be instance of RateLimiterAbstract");
        }
        this._insuranceLimiter = value2;
        if (this._insuranceLimiter) {
          this._insuranceLimiter.blockDuration = this.blockDuration;
          this._insuranceLimiter.execEvenly = this.execEvenly;
        }
      }
      /**
       * Block any key for secDuration seconds
       *
       * @param key
       * @param secDuration
       * @param {Object} options
       *
       * @return Promise<RateLimiterRes>
       */
      block(key, secDuration, options = {}) {
        const msDuration = secDuration * 1e3;
        return this._block(this.getKey(key), this.points + 1, msDuration, options);
      }
      /**
       * Set points by key for any duration
       *
       * @param key
       * @param points
       * @param secDuration
       * @param {Object} options
       *
       * @return Promise<RateLimiterRes>
       */
      set(key, points, secDuration, options = {}) {
        const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
        return this._block(this.getKey(key), points, msDuration, options);
      }
      /**
       *
       * @param key
       * @param pointsToConsume
       * @param {Object} options
       * @returns Promise<RateLimiterRes>
       */
      consume(key, pointsToConsume = 1, options = {}) {
        return new Promise((resolve7, reject) => {
          const rlKey = this.getKey(key);
          const inMemoryBlockMsBeforeExpire = this.getInMemoryBlockMsBeforeExpire(rlKey);
          if (inMemoryBlockMsBeforeExpire > 0) {
            return reject(new RateLimiterRes(0, inMemoryBlockMsBeforeExpire));
          }
          this._upsert(rlKey, pointsToConsume, this._getKeySecDuration(options) * 1e3, false, options).then((res) => {
            this._afterConsume(resolve7, reject, rlKey, pointsToConsume, res);
          }).catch((err2) => {
            this._handleError(err2, "consume", resolve7, reject, key, pointsToConsume, options);
          });
        });
      }
      /**
       *
       * @param key
       * @param points
       * @param {Object} options
       * @returns Promise<RateLimiterRes>
       */
      penalty(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve7, reject) => {
          this._upsert(rlKey, points, this._getKeySecDuration(options) * 1e3, false, options).then((res) => {
            resolve7(this._getRateLimiterRes(rlKey, points, res));
          }).catch((err2) => {
            this._handleError(err2, "penalty", resolve7, reject, key, points, options);
          });
        });
      }
      /**
       *
       * @param key
       * @param points
       * @param {Object} options
       * @returns Promise<RateLimiterRes>
       */
      reward(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve7, reject) => {
          this._upsert(rlKey, -points, this._getKeySecDuration(options) * 1e3, false, options).then((res) => {
            resolve7(this._getRateLimiterRes(rlKey, -points, res));
          }).catch((err2) => {
            this._handleError(err2, "reward", resolve7, reject, key, points, options);
          });
        });
      }
      /**
       *
       * @param key
       * @param {Object} options
       * @returns Promise<RateLimiterRes>|null
       */
      get(key, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve7, reject) => {
          this._get(rlKey, options).then((res) => {
            if (res === null || typeof res === "undefined") {
              resolve7(null);
            } else {
              resolve7(this._getRateLimiterRes(rlKey, 0, res));
            }
          }).catch((err2) => {
            this._handleError(err2, "get", resolve7, reject, key, options);
          });
        });
      }
      /**
       *
       * @param key
       * @param {Object} options
       * @returns Promise<boolean>
       */
      delete(key, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve7, reject) => {
          this._delete(rlKey, options).then((res) => {
            this._inMemoryBlockedKeys.delete(rlKey);
            resolve7(res);
          }).catch((err2) => {
            this._handleError(err2, "delete", resolve7, reject, key, options);
          });
        });
      }
      /**
       * Cleanup keys no-matter expired or not.
       */
      deleteInMemoryBlockedAll() {
        this._inMemoryBlockedKeys.delete();
      }
      /**
       * Get RateLimiterRes object filled depending on storeResult, which specific for exact store
       *
       * @param rlKey
       * @param changedPoints
       * @param storeResult
       * @private
       */
      _getRateLimiterRes(rlKey, changedPoints, storeResult) {
        throw new Error("You have to implement the method '_getRateLimiterRes'!");
      }
      /**
       * Block key for this.msBlockDuration milliseconds
       * Usually, it just prolongs lifetime of key
       *
       * @param rlKey
       * @param initPoints
       * @param msDuration
       * @param {Object} options
       *
       * @return Promise<any>
       */
      _block(rlKey, initPoints, msDuration, options = {}) {
        return new Promise((resolve7, reject) => {
          this._upsert(rlKey, initPoints, msDuration, true, options).then(() => {
            resolve7(new RateLimiterRes(0, msDuration > 0 ? msDuration : -1, initPoints));
          }).catch((err2) => {
            this._handleError(err2, "block", resolve7, reject, this.parseKey(rlKey), msDuration / 1e3, options);
          });
        });
      }
      /**
       * Have to be implemented in every limiter
       * Resolve with raw result from Store OR null if rlKey is not set
       * or Reject with error
       *
       * @param rlKey
       * @param {Object} options
       * @private
       *
       * @return Promise<any>
       */
      _get(rlKey, options = {}) {
        throw new Error("You have to implement the method '_get'!");
      }
      /**
       * Have to be implemented
       * Resolve with true OR false if rlKey doesn't exist
       * or Reject with error
       *
       * @param rlKey
       * @param {Object} options
       * @private
       *
       * @return Promise<any>
       */
      _delete(rlKey, options = {}) {
        throw new Error("You have to implement the method '_delete'!");
      }
      /**
       * Have to be implemented
       * Resolve with object used for {@link _getRateLimiterRes} to generate {@link RateLimiterRes}
       *
       * @param {string} rlKey
       * @param {number} points
       * @param {number} msDuration
       * @param {boolean} forceExpire
       * @param {Object} options
       * @abstract
       *
       * @return Promise<Object>
       */
      _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {
        throw new Error("You have to implement the method '_upsert'!");
      }
    };
  }
});
var require_RateLimiterRedis = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterRedis.js"(exports2, module2) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var incrTtlLuaScript = `redis.call('set', KEYS[1], 0, 'EX', ARGV[2], 'NX') local consumed = redis.call('incrby', KEYS[1], ARGV[1]) local ttl = redis.call('pttl', KEYS[1]) if ttl == -1 then   redis.call('expire', KEYS[1], ARGV[2])   ttl = 1000 * ARGV[2] end return {consumed, ttl} `;
    var RateLimiterRedis = class extends RateLimiterStoreAbstract {
      /**
       *
       * @param {Object} opts
       * Defaults {
       *   ... see other in RateLimiterStoreAbstract
       *
       *   redis: RedisClient
       *   rejectIfRedisNotReady: boolean = false - reject / invoke insuranceLimiter immediately when redis connection is not "ready"
       * }
       */
      constructor(opts) {
        super(opts);
        if (opts.redis) {
          this.client = opts.redis;
        } else {
          this.client = opts.storeClient;
        }
        this._rejectIfRedisNotReady = !!opts.rejectIfRedisNotReady;
        if (typeof this.client.defineCommand === "function") {
          this.client.defineCommand("rlflxIncr", {
            numberOfKeys: 1,
            lua: incrTtlLuaScript
          });
        }
      }
      /**
       * Prevent actual redis call if redis connection is not ready
       * Because of different connection state checks for ioredis and node-redis, only this clients would be actually checked.
       * For any other clients all the requests would be passed directly to redis client
       * @return {boolean}
       * @private
       */
      _isRedisReady() {
        if (!this._rejectIfRedisNotReady) {
          return true;
        }
        if (this.client.status && this.client.status !== "ready") {
          return false;
        }
        if (typeof this.client.isReady === "function" && !this.client.isReady()) {
          return false;
        }
        return true;
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        let [consumed, resTtlMs] = result;
        if (Array.isArray(consumed)) {
          [, consumed] = consumed;
          [, resTtlMs] = resTtlMs;
        }
        const res = new RateLimiterRes();
        res.consumedPoints = parseInt(consumed);
        res.isFirstInDuration = res.consumedPoints === changedPoints;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = resTtlMs;
        return res;
      }
      _upsert(rlKey, points, msDuration, forceExpire = false) {
        return new Promise((resolve7, reject) => {
          if (!this._isRedisReady()) {
            return reject(new Error("Redis connection is not ready"));
          }
          const secDuration = Math.floor(msDuration / 1e3);
          const multi = this.client.multi();
          if (forceExpire) {
            if (secDuration > 0) {
              multi.set(rlKey, points, "EX", secDuration);
            } else {
              multi.set(rlKey, points);
            }
            multi.pttl(rlKey).exec((err2, res) => {
              if (err2) {
                return reject(err2);
              }
              return resolve7(res);
            });
          } else {
            if (secDuration > 0) {
              const incrCallback = function(err2, result) {
                if (err2) {
                  return reject(err2);
                }
                return resolve7(result);
              };
              if (typeof this.client.rlflxIncr === "function") {
                this.client.rlflxIncr(rlKey, points, secDuration, incrCallback);
              } else {
                this.client.eval(incrTtlLuaScript, 1, rlKey, points, secDuration, incrCallback);
              }
            } else {
              multi.incrby(rlKey, points).pttl(rlKey).exec((err2, res) => {
                if (err2) {
                  return reject(err2);
                }
                return resolve7(res);
              });
            }
          }
        });
      }
      _get(rlKey) {
        return new Promise((resolve7, reject) => {
          if (!this._isRedisReady()) {
            return reject(new Error("Redis connection is not ready"));
          }
          this.client.multi().get(rlKey).pttl(rlKey).exec((err2, res) => {
            if (err2) {
              reject(err2);
            } else {
              const [points] = res;
              if (points === null) {
                return resolve7(null);
              }
              resolve7(res);
            }
          });
        });
      }
      _delete(rlKey) {
        return new Promise((resolve7, reject) => {
          this.client.del(rlKey, (err2, res) => {
            if (err2) {
              reject(err2);
            } else {
              resolve7(res > 0);
            }
          });
        });
      }
    };
    module2.exports = RateLimiterRedis;
  }
});
var require_RateLimiterMongo = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterMongo.js"(exports2, module2) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    function getDriverVersion(client) {
      try {
        const _client = client.client ? client.client : client;
        const { version: version3 } = _client.topology.s.options.metadata.driver;
        const _v = version3.split(".").map((v) => parseInt(v));
        return {
          major: _v[0],
          feature: _v[1],
          patch: _v[2]
        };
      } catch (err2) {
        return { major: 0, feature: 0, patch: 0 };
      }
    }
    var RateLimiterMongo = class extends RateLimiterStoreAbstract {
      /**
       *
       * @param {Object} opts
       * Defaults {
       *   indexKeyPrefix: {attr1: 1, attr2: 1}
       *   ... see other in RateLimiterStoreAbstract
       *
       *   mongo: MongoClient
       * }
       */
      constructor(opts) {
        super(opts);
        this.dbName = opts.dbName;
        this.tableName = opts.tableName;
        this.indexKeyPrefix = opts.indexKeyPrefix;
        if (opts.mongo) {
          this.client = opts.mongo;
        } else {
          this.client = opts.storeClient;
        }
        if (typeof this.client.then === "function") {
          this.client.then((conn) => {
            this.client = conn;
            this._initCollection();
            this._driverVersion = getDriverVersion(this.client);
          });
        } else {
          this._initCollection();
          this._driverVersion = getDriverVersion(this.client);
        }
      }
      get dbName() {
        return this._dbName;
      }
      set dbName(value2) {
        this._dbName = typeof value2 === "undefined" ? RateLimiterMongo.getDbName() : value2;
      }
      static getDbName() {
        return "node-rate-limiter-flexible";
      }
      get tableName() {
        return this._tableName;
      }
      set tableName(value2) {
        this._tableName = typeof value2 === "undefined" ? this.keyPrefix : value2;
      }
      get client() {
        return this._client;
      }
      set client(value2) {
        if (typeof value2 === "undefined") {
          throw new Error("mongo is not set");
        }
        this._client = value2;
      }
      get indexKeyPrefix() {
        return this._indexKeyPrefix;
      }
      set indexKeyPrefix(obj) {
        this._indexKeyPrefix = obj || {};
      }
      _initCollection() {
        const db = typeof this.client.db === "function" ? this.client.db(this.dbName) : this.client;
        const collection = db.collection(this.tableName);
        collection.createIndex({ expire: -1 }, { expireAfterSeconds: 0 });
        collection.createIndex(Object.assign({}, this.indexKeyPrefix, { key: 1 }), { unique: true });
        this._collection = collection;
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        let doc;
        if (typeof result.value === "undefined") {
          doc = result;
        } else {
          doc = result.value;
        }
        res.isFirstInDuration = doc.points === changedPoints;
        res.consumedPoints = doc.points;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = doc.expire !== null ? Math.max(new Date(doc.expire).getTime() - Date.now(), 0) : -1;
        return res;
      }
      _upsert(key, points, msDuration, forceExpire = false, options = {}) {
        if (!this._collection) {
          return Promise.reject(Error("Mongo connection is not established"));
        }
        const docAttrs = options.attrs || {};
        let where;
        let upsertData;
        if (forceExpire) {
          where = { key };
          where = Object.assign(where, docAttrs);
          upsertData = {
            $set: {
              key,
              points,
              expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
            }
          };
          upsertData.$set = Object.assign(upsertData.$set, docAttrs);
        } else {
          where = {
            $or: [
              { expire: { $gt: new Date() } },
              { expire: { $eq: null } }
            ],
            key
          };
          where = Object.assign(where, docAttrs);
          upsertData = {
            $setOnInsert: {
              key,
              expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
            },
            $inc: { points }
          };
          upsertData.$setOnInsert = Object.assign(upsertData.$setOnInsert, docAttrs);
        }
        const upsertOptions = {
          upsert: true
        };
        if (this._driverVersion.major >= 4 || (this._driverVersion.major === 3 && this._driverVersion.feature >= 7 || this._driverVersion.feature >= 6 && this._driverVersion.patch >= 7)) {
          upsertOptions.returnDocument = "after";
        } else {
          upsertOptions.returnOriginal = false;
        }
        return new Promise((resolve7, reject) => {
          this._collection.findOneAndUpdate(
            where,
            upsertData,
            upsertOptions
          ).then((res) => {
            resolve7(res);
          }).catch((errUpsert) => {
            if (errUpsert && errUpsert.code === 11e3) {
              const replaceWhere = Object.assign({
                // try to replace OLD limit doc
                $or: [
                  { expire: { $lte: new Date() } },
                  { expire: { $eq: null } }
                ],
                key
              }, docAttrs);
              const replaceTo = {
                $set: Object.assign({
                  key,
                  points,
                  expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
                }, docAttrs)
              };
              this._collection.findOneAndUpdate(
                replaceWhere,
                replaceTo,
                upsertOptions
              ).then((res) => {
                resolve7(res);
              }).catch((errReplace) => {
                if (errReplace && errReplace.code === 11e3) {
                  this._upsert(key, points, msDuration, forceExpire).then((res) => resolve7(res)).catch((err2) => reject(err2));
                } else {
                  reject(errReplace);
                }
              });
            } else {
              reject(errUpsert);
            }
          });
        });
      }
      _get(rlKey, options = {}) {
        if (!this._collection) {
          return Promise.reject(Error("Mongo connection is not established"));
        }
        const docAttrs = options.attrs || {};
        const where = Object.assign({
          key: rlKey,
          $or: [
            { expire: { $gt: new Date() } },
            { expire: { $eq: null } }
          ]
        }, docAttrs);
        return this._collection.findOne(where);
      }
      _delete(rlKey, options = {}) {
        if (!this._collection) {
          return Promise.reject(Error("Mongo connection is not established"));
        }
        const docAttrs = options.attrs || {};
        const where = Object.assign({ key: rlKey }, docAttrs);
        return this._collection.deleteOne(where).then((res) => res.deletedCount > 0);
      }
    };
    module2.exports = RateLimiterMongo;
  }
});
var require_RateLimiterMySQL = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterMySQL.js"(exports2, module2) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterMySQL = class extends RateLimiterStoreAbstract {
      /**
       * @callback callback
       * @param {Object} err
       *
       * @param {Object} opts
       * @param {callback} cb
       * Defaults {
       *   ... see other in RateLimiterStoreAbstract
       *
       *   storeClient: anySqlClient,
       *   storeType: 'knex', // required only for Knex instance
       *   dbName: 'string',
       *   tableName: 'string',
       * }
       */
      constructor(opts, cb = null) {
        super(opts);
        this.client = opts.storeClient;
        this.clientType = opts.storeType;
        this.dbName = opts.dbName;
        this.tableName = opts.tableName;
        this.clearExpiredByTimeout = opts.clearExpiredByTimeout;
        this.tableCreated = opts.tableCreated;
        if (!this.tableCreated) {
          this._createDbAndTable().then(() => {
            this.tableCreated = true;
            if (this.clearExpiredByTimeout) {
              this._clearExpiredHourAgo();
            }
            if (typeof cb === "function") {
              cb();
            }
          }).catch((err2) => {
            if (typeof cb === "function") {
              cb(err2);
            } else {
              throw err2;
            }
          });
        } else {
          if (this.clearExpiredByTimeout) {
            this._clearExpiredHourAgo();
          }
          if (typeof cb === "function") {
            cb();
          }
        }
      }
      clearExpired(expire) {
        return new Promise((resolve7) => {
          this._getConnection().then((conn) => {
            conn.query(`DELETE FROM ??.?? WHERE expire < ?`, [this.dbName, this.tableName, expire], () => {
              this._releaseConnection(conn);
              resolve7();
            });
          }).catch(() => {
            resolve7();
          });
        });
      }
      _clearExpiredHourAgo() {
        if (this._clearExpiredTimeoutId) {
          clearTimeout(this._clearExpiredTimeoutId);
        }
        this._clearExpiredTimeoutId = setTimeout(() => {
          this.clearExpired(Date.now() - 36e5).then(() => {
            this._clearExpiredHourAgo();
          });
        }, 3e5);
        this._clearExpiredTimeoutId.unref();
      }
      /**
       *
       * @return Promise<any>
       * @private
       */
      _getConnection() {
        switch (this.clientType) {
          case "pool":
            return new Promise((resolve7, reject) => {
              this.client.getConnection((errConn, conn) => {
                if (errConn) {
                  return reject(errConn);
                }
                resolve7(conn);
              });
            });
          case "sequelize":
            return this.client.connectionManager.getConnection();
          case "knex":
            return this.client.client.acquireConnection();
          default:
            return Promise.resolve(this.client);
        }
      }
      _releaseConnection(conn) {
        switch (this.clientType) {
          case "pool":
            return conn.release();
          case "sequelize":
            return this.client.connectionManager.releaseConnection(conn);
          case "knex":
            return this.client.client.releaseConnection(conn);
          default:
            return true;
        }
      }
      /**
       *
       * @returns {Promise<any>}
       * @private
       */
      _createDbAndTable() {
        return new Promise((resolve7, reject) => {
          this._getConnection().then((conn) => {
            conn.query(`CREATE DATABASE IF NOT EXISTS \`${this.dbName}\`;`, (errDb) => {
              if (errDb) {
                this._releaseConnection(conn);
                return reject(errDb);
              }
              conn.query(this._getCreateTableStmt(), (err2) => {
                if (err2) {
                  this._releaseConnection(conn);
                  return reject(err2);
                }
                this._releaseConnection(conn);
                resolve7();
              });
            });
          }).catch((err2) => {
            reject(err2);
          });
        });
      }
      _getCreateTableStmt() {
        return `CREATE TABLE IF NOT EXISTS \`${this.dbName}\`.\`${this.tableName}\` (\`key\` VARCHAR(255) CHARACTER SET utf8 NOT NULL,\`points\` INT(9) NOT NULL default 0,\`expire\` BIGINT UNSIGNED,PRIMARY KEY (\`key\`)) ENGINE = INNODB;`;
      }
      get clientType() {
        return this._clientType;
      }
      set clientType(value2) {
        if (typeof value2 === "undefined") {
          if (this.client.constructor.name === "Connection") {
            value2 = "connection";
          } else if (this.client.constructor.name === "Pool") {
            value2 = "pool";
          } else if (this.client.constructor.name === "Sequelize") {
            value2 = "sequelize";
          } else {
            throw new Error("storeType is not defined");
          }
        }
        this._clientType = value2.toLowerCase();
      }
      get dbName() {
        return this._dbName;
      }
      set dbName(value2) {
        this._dbName = typeof value2 === "undefined" ? "rtlmtrflx" : value2;
      }
      get tableName() {
        return this._tableName;
      }
      set tableName(value2) {
        this._tableName = typeof value2 === "undefined" ? this.keyPrefix : value2;
      }
      get tableCreated() {
        return this._tableCreated;
      }
      set tableCreated(value2) {
        this._tableCreated = typeof value2 === "undefined" ? false : !!value2;
      }
      get clearExpiredByTimeout() {
        return this._clearExpiredByTimeout;
      }
      set clearExpiredByTimeout(value2) {
        this._clearExpiredByTimeout = typeof value2 === "undefined" ? true : Boolean(value2);
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        const [row] = result;
        res.isFirstInDuration = changedPoints === row.points;
        res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;
        return res;
      }
      _upsertTransaction(conn, key, points, msDuration, forceExpire) {
        return new Promise((resolve7, reject) => {
          conn.query("BEGIN", (errBegin) => {
            if (errBegin) {
              conn.rollback();
              return reject(errBegin);
            }
            const dateNow = Date.now();
            const newExpire = msDuration > 0 ? dateNow + msDuration : null;
            let q;
            let values;
            if (forceExpire) {
              q = `INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = ?, 
            expire = ?;`;
              values = [
                this.dbName,
                this.tableName,
                key,
                points,
                newExpire,
                points,
                newExpire
              ];
            } else {
              q = `INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = IF(expire <= ?, ?, points + (?)), 
            expire = IF(expire <= ?, ?, expire);`;
              values = [
                this.dbName,
                this.tableName,
                key,
                points,
                newExpire,
                dateNow,
                points,
                points,
                dateNow,
                newExpire
              ];
            }
            conn.query(q, values, (errUpsert) => {
              if (errUpsert) {
                conn.rollback();
                return reject(errUpsert);
              }
              conn.query("SELECT points, expire FROM ??.?? WHERE `key` = ?;", [this.dbName, this.tableName, key], (errSelect, res) => {
                if (errSelect) {
                  conn.rollback();
                  return reject(errSelect);
                }
                conn.query("COMMIT", (err2) => {
                  if (err2) {
                    conn.rollback();
                    return reject(err2);
                  }
                  resolve7(res);
                });
              });
            });
          });
        });
      }
      _upsert(key, points, msDuration, forceExpire = false) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve7, reject) => {
          this._getConnection().then((conn) => {
            this._upsertTransaction(conn, key, points, msDuration, forceExpire).then((res) => {
              resolve7(res);
              this._releaseConnection(conn);
            }).catch((err2) => {
              reject(err2);
              this._releaseConnection(conn);
            });
          }).catch((err2) => {
            reject(err2);
          });
        });
      }
      _get(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve7, reject) => {
          this._getConnection().then((conn) => {
            conn.query(
              "SELECT points, expire FROM ??.?? WHERE `key` = ? AND (`expire` > ? OR `expire` IS NULL)",
              [this.dbName, this.tableName, rlKey, Date.now()],
              (err2, res) => {
                if (err2) {
                  reject(err2);
                } else if (res.length === 0) {
                  resolve7(null);
                } else {
                  resolve7(res);
                }
                this._releaseConnection(conn);
              }
              // eslint-disable-line
            );
          }).catch((err2) => {
            reject(err2);
          });
        });
      }
      _delete(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve7, reject) => {
          this._getConnection().then((conn) => {
            conn.query(
              "DELETE FROM ??.?? WHERE `key` = ?",
              [this.dbName, this.tableName, rlKey],
              (err2, res) => {
                if (err2) {
                  reject(err2);
                } else {
                  resolve7(res.affectedRows > 0);
                }
                this._releaseConnection(conn);
              }
              // eslint-disable-line
            );
          }).catch((err2) => {
            reject(err2);
          });
        });
      }
    };
    module2.exports = RateLimiterMySQL;
  }
});
var require_RateLimiterPostgres = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterPostgres.js"(exports2, module2) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterPostgres = class extends RateLimiterStoreAbstract {
      /**
       * @callback callback
       * @param {Object} err
       *
       * @param {Object} opts
       * @param {callback} cb
       * Defaults {
       *   ... see other in RateLimiterStoreAbstract
       *
       *   storeClient: postgresClient,
       *   storeType: 'knex', // required only for Knex instance
       *   tableName: 'string',
       * }
       */
      constructor(opts, cb = null) {
        super(opts);
        this.client = opts.storeClient;
        this.clientType = opts.storeType;
        this.tableName = opts.tableName;
        this.clearExpiredByTimeout = opts.clearExpiredByTimeout;
        this.tableCreated = opts.tableCreated;
        if (!this.tableCreated) {
          this._createTable().then(() => {
            this.tableCreated = true;
            if (this.clearExpiredByTimeout) {
              this._clearExpiredHourAgo();
            }
            if (typeof cb === "function") {
              cb();
            }
          }).catch((err2) => {
            if (typeof cb === "function") {
              cb(err2);
            } else {
              throw err2;
            }
          });
        } else {
          if (typeof cb === "function") {
            cb();
          }
        }
      }
      clearExpired(expire) {
        return new Promise((resolve7) => {
          const q = {
            name: "rlflx-clear-expired",
            text: `DELETE FROM ${this.tableName} WHERE expire < $1`,
            values: [expire]
          };
          this._query(q).then(() => {
            resolve7();
          }).catch(() => {
            resolve7();
          });
        });
      }
      /**
       * Delete all rows expired 1 hour ago once per 5 minutes
       *
       * @private
       */
      _clearExpiredHourAgo() {
        if (this._clearExpiredTimeoutId) {
          clearTimeout(this._clearExpiredTimeoutId);
        }
        this._clearExpiredTimeoutId = setTimeout(() => {
          this.clearExpired(Date.now() - 36e5).then(() => {
            this._clearExpiredHourAgo();
          });
        }, 3e5);
        this._clearExpiredTimeoutId.unref();
      }
      /**
       *
       * @return Promise<any>
       * @private
       */
      _getConnection() {
        switch (this.clientType) {
          case "pool":
            return Promise.resolve(this.client);
          case "sequelize":
            return this.client.connectionManager.getConnection();
          case "knex":
            return this.client.client.acquireConnection();
          case "typeorm":
            return Promise.resolve(this.client.driver.master);
          default:
            return Promise.resolve(this.client);
        }
      }
      _releaseConnection(conn) {
        switch (this.clientType) {
          case "pool":
            return true;
          case "sequelize":
            return this.client.connectionManager.releaseConnection(conn);
          case "knex":
            return this.client.client.releaseConnection(conn);
          case "typeorm":
            return true;
          default:
            return true;
        }
      }
      /**
       *
       * @returns {Promise<any>}
       * @private
       */
      _createTable() {
        return new Promise((resolve7, reject) => {
          this._query({
            text: this._getCreateTableStmt()
          }).then(() => {
            resolve7();
          }).catch((err2) => {
            if (err2.code === "23505") {
              resolve7();
            } else {
              reject(err2);
            }
          });
        });
      }
      _getCreateTableStmt() {
        return `CREATE TABLE IF NOT EXISTS ${this.tableName} ( 
      key varchar(255) PRIMARY KEY,
      points integer NOT NULL DEFAULT 0,
      expire bigint
    );`;
      }
      get clientType() {
        return this._clientType;
      }
      set clientType(value2) {
        const constructorName = this.client.constructor.name;
        if (typeof value2 === "undefined") {
          if (constructorName === "Client") {
            value2 = "client";
          } else if (constructorName === "Pool" || constructorName === "BoundPool") {
            value2 = "pool";
          } else if (constructorName === "Sequelize") {
            value2 = "sequelize";
          } else {
            throw new Error("storeType is not defined");
          }
        }
        this._clientType = value2.toLowerCase();
      }
      get tableName() {
        return this._tableName;
      }
      set tableName(value2) {
        this._tableName = typeof value2 === "undefined" ? this.keyPrefix : value2;
      }
      get tableCreated() {
        return this._tableCreated;
      }
      set tableCreated(value2) {
        this._tableCreated = typeof value2 === "undefined" ? false : !!value2;
      }
      get clearExpiredByTimeout() {
        return this._clearExpiredByTimeout;
      }
      set clearExpiredByTimeout(value2) {
        this._clearExpiredByTimeout = typeof value2 === "undefined" ? true : Boolean(value2);
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        const row = result.rows[0];
        res.isFirstInDuration = changedPoints === row.points;
        res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;
        return res;
      }
      _query(q) {
        const prefix = this.tableName.toLowerCase();
        const queryObj = { name: `${prefix}:${q.name}`, text: q.text, values: q.values };
        return new Promise((resolve7, reject) => {
          this._getConnection().then((conn) => {
            conn.query(queryObj).then((res) => {
              resolve7(res);
              this._releaseConnection(conn);
            }).catch((err2) => {
              reject(err2);
              this._releaseConnection(conn);
            });
          }).catch((err2) => {
            reject(err2);
          });
        });
      }
      _upsert(key, points, msDuration, forceExpire = false) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        const newExpire = msDuration > 0 ? Date.now() + msDuration : null;
        const expireQ = forceExpire ? " $3 " : ` CASE
             WHEN ${this.tableName}.expire <= $4 THEN $3
             ELSE ${this.tableName}.expire
            END `;
        return this._query({
          name: forceExpire ? "rlflx-upsert-force" : "rlflx-upsert",
          text: `
            INSERT INTO ${this.tableName} VALUES ($1, $2, $3)
              ON CONFLICT(key) DO UPDATE SET
                points = CASE
                          WHEN (${this.tableName}.expire <= $4 OR 1=${forceExpire ? 1 : 0}) THEN $2
                          ELSE ${this.tableName}.points + ($2)
                         END,
                expire = ${expireQ}
            RETURNING points, expire;`,
          values: [key, points, newExpire, Date.now()]
        });
      }
      _get(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve7, reject) => {
          this._query({
            name: "rlflx-get",
            text: `
            SELECT points, expire FROM ${this.tableName} WHERE key = $1 AND (expire > $2 OR expire IS NULL);`,
            values: [rlKey, Date.now()]
          }).then((res) => {
            if (res.rowCount === 0) {
              res = null;
            }
            resolve7(res);
          }).catch((err2) => {
            reject(err2);
          });
        });
      }
      _delete(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return this._query({
          name: "rlflx-delete",
          text: `DELETE FROM ${this.tableName} WHERE key = $1`,
          values: [rlKey]
        }).then((res) => res.rowCount > 0);
      }
    };
    module2.exports = RateLimiterPostgres;
  }
});
var require_cluster = __commonJS({
  "browser-external:cluster"(exports2, module2) {
    module2.exports = {};
  }
});
var require_Record = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/MemoryStorage/Record.js"(exports2, module2) {
    module2.exports = class Record {
      /**
       *
       * @param value int
       * @param expiresAt Date|int
       * @param timeoutId
       */
      constructor(value2, expiresAt, timeoutId = null) {
        this.value = value2;
        this.expiresAt = expiresAt;
        this.timeoutId = timeoutId;
      }
      get value() {
        return this._value;
      }
      set value(value2) {
        this._value = parseInt(value2);
      }
      get expiresAt() {
        return this._expiresAt;
      }
      set expiresAt(value2) {
        if (!(value2 instanceof Date) && Number.isInteger(value2)) {
          value2 = new Date(value2);
        }
        this._expiresAt = value2;
      }
      get timeoutId() {
        return this._timeoutId;
      }
      set timeoutId(value2) {
        this._timeoutId = value2;
      }
    };
  }
});
var require_MemoryStorage = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/MemoryStorage/MemoryStorage.js"(exports2, module2) {
    var Record3 = require_Record();
    var RateLimiterRes = require_RateLimiterRes();
    module2.exports = class MemoryStorage {
      constructor() {
        this._storage = {};
      }
      incrby(key, value2, durationSec) {
        if (this._storage[key]) {
          const msBeforeExpires = this._storage[key].expiresAt ? this._storage[key].expiresAt.getTime() - new Date().getTime() : -1;
          if (msBeforeExpires !== 0) {
            this._storage[key].value = this._storage[key].value + value2;
            return new RateLimiterRes(0, msBeforeExpires, this._storage[key].value, false);
          }
          return this.set(key, value2, durationSec);
        }
        return this.set(key, value2, durationSec);
      }
      set(key, value2, durationSec) {
        const durationMs = durationSec * 1e3;
        if (this._storage[key] && this._storage[key].timeoutId) {
          clearTimeout(this._storage[key].timeoutId);
        }
        this._storage[key] = new Record3(
          value2,
          durationMs > 0 ? new Date(Date.now() + durationMs) : null
        );
        if (durationMs > 0) {
          this._storage[key].timeoutId = setTimeout(() => {
            delete this._storage[key];
          }, durationMs);
          if (this._storage[key].timeoutId.unref) {
            this._storage[key].timeoutId.unref();
          }
        }
        return new RateLimiterRes(0, durationMs === 0 ? -1 : durationMs, this._storage[key].value, true);
      }
      /**
       *
       * @param key
       * @returns {*}
       */
      get(key) {
        if (this._storage[key]) {
          const msBeforeExpires = this._storage[key].expiresAt ? this._storage[key].expiresAt.getTime() - new Date().getTime() : -1;
          return new RateLimiterRes(0, msBeforeExpires, this._storage[key].value, false);
        }
        return null;
      }
      /**
       *
       * @param key
       * @returns {boolean}
       */
      delete(key) {
        if (this._storage[key]) {
          if (this._storage[key].timeoutId) {
            clearTimeout(this._storage[key].timeoutId);
          }
          delete this._storage[key];
          return true;
        }
        return false;
      }
    };
  }
});
var require_RateLimiterMemory = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterMemory.js"(exports2, module2) {
    var RateLimiterAbstract = require_RateLimiterAbstract();
    var MemoryStorage = require_MemoryStorage();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterMemory3 = class extends RateLimiterAbstract {
      constructor(opts = {}) {
        super(opts);
        this._memoryStorage = new MemoryStorage();
      }
      /**
       *
       * @param key
       * @param pointsToConsume
       * @param {Object} options
       * @returns {Promise<RateLimiterRes>}
       */
      consume(key, pointsToConsume = 1, options = {}) {
        return new Promise((resolve7, reject) => {
          const rlKey = this.getKey(key);
          const secDuration = this._getKeySecDuration(options);
          let res = this._memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
          if (res.consumedPoints > this.points) {
            if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {
              res = this._memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
            }
            reject(res);
          } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
            let delay3 = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
            if (delay3 < this.execEvenlyMinDelayMs) {
              delay3 = res.consumedPoints * this.execEvenlyMinDelayMs;
            }
            setTimeout(resolve7, delay3, res);
          } else {
            resolve7(res);
          }
        });
      }
      penalty(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve7) => {
          const secDuration = this._getKeySecDuration(options);
          const res = this._memoryStorage.incrby(rlKey, points, secDuration);
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
          resolve7(res);
        });
      }
      reward(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve7) => {
          const secDuration = this._getKeySecDuration(options);
          const res = this._memoryStorage.incrby(rlKey, -points, secDuration);
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
          resolve7(res);
        });
      }
      /**
       * Block any key for secDuration seconds
       *
       * @param key
       * @param secDuration
       */
      block(key, secDuration) {
        const msDuration = secDuration * 1e3;
        const initPoints = this.points + 1;
        this._memoryStorage.set(this.getKey(key), initPoints, secDuration);
        return Promise.resolve(
          new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, initPoints)
        );
      }
      set(key, points, secDuration) {
        const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
        this._memoryStorage.set(this.getKey(key), points, secDuration);
        return Promise.resolve(
          new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, points)
        );
      }
      get(key) {
        const res = this._memoryStorage.get(this.getKey(key));
        if (res !== null) {
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        }
        return Promise.resolve(res);
      }
      delete(key) {
        return Promise.resolve(this._memoryStorage.delete(this.getKey(key)));
      }
    };
    module2.exports = RateLimiterMemory3;
  }
});
var require_RateLimiterCluster = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterCluster.js"(exports2, module2) {
    var cluster = require_cluster();
    var crypto4 = require_crypto();
    var RateLimiterAbstract = require_RateLimiterAbstract();
    var RateLimiterMemory3 = require_RateLimiterMemory();
    var RateLimiterRes = require_RateLimiterRes();
    var channel = "rate_limiter_flexible";
    var masterInstance = null;
    var masterSendToWorker = function(worker, msg, type, res) {
      let data;
      if (res === null || res === true || res === false) {
        data = res;
      } else {
        data = {
          remainingPoints: res.remainingPoints,
          msBeforeNext: res.msBeforeNext,
          consumedPoints: res.consumedPoints,
          isFirstInDuration: res.isFirstInDuration
        };
      }
      worker.send({
        channel,
        keyPrefix: msg.keyPrefix,
        // which rate limiter exactly
        promiseId: msg.promiseId,
        type,
        data
      });
    };
    var workerWaitInit = function(payload) {
      setTimeout(() => {
        if (this._initiated) {
          process.send(payload);
        } else if (typeof this._promises[payload.promiseId] !== "undefined") {
          workerWaitInit.call(this, payload);
        }
      }, 30);
    };
    var workerSendToMaster = function(func, promiseId, key, arg, opts) {
      const payload = {
        channel,
        keyPrefix: this.keyPrefix,
        func,
        promiseId,
        data: {
          key,
          arg,
          opts
        }
      };
      if (!this._initiated) {
        workerWaitInit.call(this, payload);
      } else {
        process.send(payload);
      }
    };
    var masterProcessMsg = function(worker, msg) {
      if (!msg || msg.channel !== channel || typeof this._rateLimiters[msg.keyPrefix] === "undefined") {
        return false;
      }
      let promise;
      switch (msg.func) {
        case "consume":
          promise = this._rateLimiters[msg.keyPrefix].consume(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "penalty":
          promise = this._rateLimiters[msg.keyPrefix].penalty(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "reward":
          promise = this._rateLimiters[msg.keyPrefix].reward(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "block":
          promise = this._rateLimiters[msg.keyPrefix].block(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "get":
          promise = this._rateLimiters[msg.keyPrefix].get(msg.data.key, msg.data.opts);
          break;
        case "delete":
          promise = this._rateLimiters[msg.keyPrefix].delete(msg.data.key, msg.data.opts);
          break;
        default:
          return false;
      }
      if (promise) {
        promise.then((res) => {
          masterSendToWorker(worker, msg, "resolve", res);
        }).catch((rejRes) => {
          masterSendToWorker(worker, msg, "reject", rejRes);
        });
      }
    };
    var workerProcessMsg = function(msg) {
      if (!msg || msg.channel !== channel || msg.keyPrefix !== this.keyPrefix) {
        return false;
      }
      if (this._promises[msg.promiseId]) {
        clearTimeout(this._promises[msg.promiseId].timeoutId);
        let res;
        if (msg.data === null || msg.data === true || msg.data === false) {
          res = msg.data;
        } else {
          res = new RateLimiterRes(
            msg.data.remainingPoints,
            msg.data.msBeforeNext,
            msg.data.consumedPoints,
            msg.data.isFirstInDuration
            // eslint-disable-line comma-dangle
          );
        }
        switch (msg.type) {
          case "resolve":
            this._promises[msg.promiseId].resolve(res);
            break;
          case "reject":
            this._promises[msg.promiseId].reject(res);
            break;
          default:
            throw new Error(`RateLimiterCluster: no such message type '${msg.type}'`);
        }
        delete this._promises[msg.promiseId];
      }
    };
    var getOpts = function() {
      return {
        points: this.points,
        duration: this.duration,
        blockDuration: this.blockDuration,
        execEvenly: this.execEvenly,
        execEvenlyMinDelayMs: this.execEvenlyMinDelayMs,
        keyPrefix: this.keyPrefix
      };
    };
    var savePromise = function(resolve7, reject) {
      const hrtime = process.hrtime();
      let promiseId = hrtime[0].toString() + hrtime[1].toString();
      if (typeof this._promises[promiseId] !== "undefined") {
        promiseId += crypto4.randomBytes(12).toString("base64");
      }
      this._promises[promiseId] = {
        resolve: resolve7,
        reject,
        timeoutId: setTimeout(() => {
          delete this._promises[promiseId];
          reject(new Error("RateLimiterCluster timeout: no answer from master in time"));
        }, this.timeoutMs)
      };
      return promiseId;
    };
    var RateLimiterClusterMaster = class {
      constructor() {
        if (masterInstance) {
          return masterInstance;
        }
        this._rateLimiters = {};
        cluster.setMaxListeners(0);
        cluster.on("message", (worker, msg) => {
          if (msg && msg.channel === channel && msg.type === "init") {
            if (typeof this._rateLimiters[msg.opts.keyPrefix] === "undefined") {
              this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory3(msg.opts);
            }
            worker.send({
              channel,
              type: "init",
              keyPrefix: msg.opts.keyPrefix
            });
          } else {
            masterProcessMsg.call(this, worker, msg);
          }
        });
        masterInstance = this;
      }
    };
    var RateLimiterClusterMasterPM2 = class {
      constructor(pm2) {
        if (masterInstance) {
          return masterInstance;
        }
        this._rateLimiters = {};
        pm2.launchBus((err2, pm2Bus) => {
          pm2Bus.on("process:msg", (packet) => {
            const msg = packet.raw;
            if (msg && msg.channel === channel && msg.type === "init") {
              if (typeof this._rateLimiters[msg.opts.keyPrefix] === "undefined") {
                this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory3(msg.opts);
              }
              pm2.sendDataToProcessId(packet.process.pm_id, {
                data: {},
                topic: channel,
                channel,
                type: "init",
                keyPrefix: msg.opts.keyPrefix
              }, (sendErr, res) => {
                if (sendErr) {
                  console.log(sendErr, res);
                }
              });
            } else {
              const worker = {
                send: (msgData) => {
                  const pm2Message = msgData;
                  pm2Message.topic = channel;
                  if (typeof pm2Message.data === "undefined") {
                    pm2Message.data = {};
                  }
                  pm2.sendDataToProcessId(packet.process.pm_id, pm2Message, (sendErr, res) => {
                    if (sendErr) {
                      console.log(sendErr, res);
                    }
                  });
                }
              };
              masterProcessMsg.call(this, worker, msg);
            }
          });
        });
        masterInstance = this;
      }
    };
    var RateLimiterClusterWorker = class extends RateLimiterAbstract {
      get timeoutMs() {
        return this._timeoutMs;
      }
      set timeoutMs(value2) {
        this._timeoutMs = typeof value2 === "undefined" ? 5e3 : Math.abs(parseInt(value2));
      }
      constructor(opts = {}) {
        super(opts);
        process.setMaxListeners(0);
        this.timeoutMs = opts.timeoutMs;
        this._initiated = false;
        process.on("message", (msg) => {
          if (msg && msg.channel === channel && msg.type === "init" && msg.keyPrefix === this.keyPrefix) {
            this._initiated = true;
          } else {
            workerProcessMsg.call(this, msg);
          }
        });
        process.send({
          channel,
          type: "init",
          opts: getOpts.call(this)
        });
        this._promises = {};
      }
      consume(key, pointsToConsume = 1, options = {}) {
        return new Promise((resolve7, reject) => {
          const promiseId = savePromise.call(this, resolve7, reject);
          workerSendToMaster.call(this, "consume", promiseId, key, pointsToConsume, options);
        });
      }
      penalty(key, points = 1, options = {}) {
        return new Promise((resolve7, reject) => {
          const promiseId = savePromise.call(this, resolve7, reject);
          workerSendToMaster.call(this, "penalty", promiseId, key, points, options);
        });
      }
      reward(key, points = 1, options = {}) {
        return new Promise((resolve7, reject) => {
          const promiseId = savePromise.call(this, resolve7, reject);
          workerSendToMaster.call(this, "reward", promiseId, key, points, options);
        });
      }
      block(key, secDuration, options = {}) {
        return new Promise((resolve7, reject) => {
          const promiseId = savePromise.call(this, resolve7, reject);
          workerSendToMaster.call(this, "block", promiseId, key, secDuration, options);
        });
      }
      get(key, options = {}) {
        return new Promise((resolve7, reject) => {
          const promiseId = savePromise.call(this, resolve7, reject);
          workerSendToMaster.call(this, "get", promiseId, key, options);
        });
      }
      delete(key, options = {}) {
        return new Promise((resolve7, reject) => {
          const promiseId = savePromise.call(this, resolve7, reject);
          workerSendToMaster.call(this, "delete", promiseId, key, options);
        });
      }
    };
    module2.exports = {
      RateLimiterClusterMaster,
      RateLimiterClusterMasterPM2,
      RateLimiterCluster: RateLimiterClusterWorker
    };
  }
});
var require_RateLimiterMemcache = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterMemcache.js"(exports2, module2) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterMemcache = class extends RateLimiterStoreAbstract {
      /**
       *
       * @param {Object} opts
       * Defaults {
       *   ... see other in RateLimiterStoreAbstract
       *
       *   storeClient: memcacheClient
       * }
       */
      constructor(opts) {
        super(opts);
        this.client = opts.storeClient;
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        res.consumedPoints = parseInt(result.consumedPoints);
        res.isFirstInDuration = result.consumedPoints === changedPoints;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = result.msBeforeNext;
        return res;
      }
      _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {
        return new Promise((resolve7, reject) => {
          const nowMs = Date.now();
          const secDuration = Math.floor(msDuration / 1e3);
          if (forceExpire) {
            this.client.set(rlKey, points, secDuration, (err2) => {
              if (!err2) {
                this.client.set(
                  `${rlKey}_expire`,
                  secDuration > 0 ? nowMs + secDuration * 1e3 : -1,
                  secDuration,
                  () => {
                    const res = {
                      consumedPoints: points,
                      msBeforeNext: secDuration > 0 ? secDuration * 1e3 : -1
                    };
                    resolve7(res);
                  }
                );
              } else {
                reject(err2);
              }
            });
          } else {
            this.client.incr(rlKey, points, (err2, consumedPoints) => {
              if (err2 || consumedPoints === false) {
                this.client.add(rlKey, points, secDuration, (errAddKey, createdNew) => {
                  if (errAddKey || !createdNew) {
                    if (typeof options.attemptNumber === "undefined" || options.attemptNumber < 3) {
                      const nextOptions = Object.assign({}, options);
                      nextOptions.attemptNumber = nextOptions.attemptNumber ? nextOptions.attemptNumber + 1 : 1;
                      this._upsert(rlKey, points, msDuration, forceExpire, nextOptions).then((resUpsert) => resolve7(resUpsert)).catch((errUpsert) => reject(errUpsert));
                    } else {
                      reject(new Error("Can not add key"));
                    }
                  } else {
                    this.client.add(
                      `${rlKey}_expire`,
                      secDuration > 0 ? nowMs + secDuration * 1e3 : -1,
                      secDuration,
                      () => {
                        const res = {
                          consumedPoints: points,
                          msBeforeNext: secDuration > 0 ? secDuration * 1e3 : -1
                        };
                        resolve7(res);
                      }
                    );
                  }
                });
              } else {
                this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {
                  if (errGetExpire) {
                    reject(errGetExpire);
                  } else {
                    const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;
                    const res = {
                      consumedPoints,
                      msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1
                    };
                    resolve7(res);
                  }
                });
              }
            });
          }
        });
      }
      _get(rlKey) {
        return new Promise((resolve7, reject) => {
          const nowMs = Date.now();
          this.client.get(rlKey, (err2, consumedPoints) => {
            if (!consumedPoints) {
              resolve7(null);
            } else {
              this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {
                if (errGetExpire) {
                  reject(errGetExpire);
                } else {
                  const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;
                  const res = {
                    consumedPoints,
                    msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1
                  };
                  resolve7(res);
                }
              });
            }
          });
        });
      }
      _delete(rlKey) {
        return new Promise((resolve7, reject) => {
          this.client.del(rlKey, (err2, res) => {
            if (err2) {
              reject(err2);
            } else if (res === false) {
              resolve7(res);
            } else {
              this.client.del(`${rlKey}_expire`, (errDelExpire) => {
                if (errDelExpire) {
                  reject(errDelExpire);
                } else {
                  resolve7(res);
                }
              });
            }
          });
        });
      }
    };
    module2.exports = RateLimiterMemcache;
  }
});
var require_RLWrapperBlackAndWhite = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RLWrapperBlackAndWhite.js"(exports2, module2) {
    var RateLimiterRes = require_RateLimiterRes();
    module2.exports = class RLWrapperBlackAndWhite {
      constructor(opts = {}) {
        this.limiter = opts.limiter;
        this.blackList = opts.blackList;
        this.whiteList = opts.whiteList;
        this.isBlackListed = opts.isBlackListed;
        this.isWhiteListed = opts.isWhiteListed;
        this.runActionAnyway = opts.runActionAnyway;
      }
      get limiter() {
        return this._limiter;
      }
      set limiter(value2) {
        if (typeof value2 === "undefined") {
          throw new Error("limiter is not set");
        }
        this._limiter = value2;
      }
      get runActionAnyway() {
        return this._runActionAnyway;
      }
      set runActionAnyway(value2) {
        this._runActionAnyway = typeof value2 === "undefined" ? false : value2;
      }
      get blackList() {
        return this._blackList;
      }
      set blackList(value2) {
        this._blackList = Array.isArray(value2) ? value2 : [];
      }
      get isBlackListed() {
        return this._isBlackListed;
      }
      set isBlackListed(func) {
        if (typeof func === "undefined") {
          func = () => false;
        }
        if (typeof func !== "function") {
          throw new Error("isBlackListed must be function");
        }
        this._isBlackListed = func;
      }
      get whiteList() {
        return this._whiteList;
      }
      set whiteList(value2) {
        this._whiteList = Array.isArray(value2) ? value2 : [];
      }
      get isWhiteListed() {
        return this._isWhiteListed;
      }
      set isWhiteListed(func) {
        if (typeof func === "undefined") {
          func = () => false;
        }
        if (typeof func !== "function") {
          throw new Error("isWhiteListed must be function");
        }
        this._isWhiteListed = func;
      }
      isBlackListedSomewhere(key) {
        return this.blackList.indexOf(key) >= 0 || this.isBlackListed(key);
      }
      isWhiteListedSomewhere(key) {
        return this.whiteList.indexOf(key) >= 0 || this.isWhiteListed(key);
      }
      getBlackRes() {
        return new RateLimiterRes(0, Number.MAX_SAFE_INTEGER, 0, false);
      }
      getWhiteRes() {
        return new RateLimiterRes(Number.MAX_SAFE_INTEGER, 0, 0, false);
      }
      rejectBlack() {
        return Promise.reject(this.getBlackRes());
      }
      resolveBlack() {
        return Promise.resolve(this.getBlackRes());
      }
      resolveWhite() {
        return Promise.resolve(this.getWhiteRes());
      }
      consume(key, pointsToConsume = 1) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.rejectBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.consume(key, pointsToConsume);
        }
        if (this.runActionAnyway) {
          this.limiter.consume(key, pointsToConsume).catch(() => {
          });
        }
        return res;
      }
      block(key, secDuration) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.block(key, secDuration);
        }
        if (this.runActionAnyway) {
          this.limiter.block(key, secDuration).catch(() => {
          });
        }
        return res;
      }
      penalty(key, points) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.penalty(key, points);
        }
        if (this.runActionAnyway) {
          this.limiter.penalty(key, points).catch(() => {
          });
        }
        return res;
      }
      reward(key, points) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.reward(key, points);
        }
        if (this.runActionAnyway) {
          this.limiter.reward(key, points).catch(() => {
          });
        }
        return res;
      }
      get(key) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined" || this.runActionAnyway) {
          return this.limiter.get(key);
        }
        return res;
      }
      delete(key) {
        return this.limiter.delete(key);
      }
    };
  }
});
var require_RateLimiterUnion = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterUnion.js"(exports2, module2) {
    var RateLimiterAbstract = require_RateLimiterAbstract();
    module2.exports = class RateLimiterUnion {
      constructor(...limiters) {
        if (limiters.length < 1) {
          throw new Error("RateLimiterUnion: at least one limiter have to be passed");
        }
        limiters.forEach((limiter) => {
          if (!(limiter instanceof RateLimiterAbstract)) {
            throw new Error("RateLimiterUnion: all limiters have to be instance of RateLimiterAbstract");
          }
        });
        this._limiters = limiters;
      }
      consume(key, points = 1) {
        return new Promise((resolve7, reject) => {
          const promises = [];
          this._limiters.forEach((limiter) => {
            promises.push(limiter.consume(key, points).catch((rej) => ({ rejected: true, rej })));
          });
          Promise.all(promises).then((res) => {
            const resObj = {};
            let rejected = false;
            res.forEach((item) => {
              if (item.rejected === true) {
                rejected = true;
              }
            });
            for (let i2 = 0; i2 < res.length; i2++) {
              if (rejected && res[i2].rejected === true) {
                resObj[this._limiters[i2].keyPrefix] = res[i2].rej;
              } else if (!rejected) {
                resObj[this._limiters[i2].keyPrefix] = res[i2];
              }
            }
            if (rejected) {
              reject(resObj);
            } else {
              resolve7(resObj);
            }
          });
        });
      }
    };
  }
});
var require_RateLimiterQueueError = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/RateLimiterQueueError.js"(exports2, module2) {
    module2.exports = class RateLimiterQueueError extends Error {
      constructor(message2, extra) {
        super();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "CustomError";
        this.message = message2;
        if (extra) {
          this.extra = extra;
        }
      }
    };
  }
});
var require_RateLimiterQueue = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterQueue.js"(exports2, module2) {
    var RateLimiterQueueError = require_RateLimiterQueueError();
    var MAX_QUEUE_SIZE = 4294967295;
    var KEY_DEFAULT = "limiter";
    module2.exports = class RateLimiterQueue {
      constructor(limiterFlexible, opts = {
        maxQueueSize: MAX_QUEUE_SIZE
      }) {
        this._queueLimiters = {
          KEY_DEFAULT: new RateLimiterQueueInternal(limiterFlexible, opts)
        };
        this._limiterFlexible = limiterFlexible;
        this._maxQueueSize = opts.maxQueueSize;
      }
      getTokensRemaining(key = KEY_DEFAULT) {
        if (this._queueLimiters[key]) {
          return this._queueLimiters[key].getTokensRemaining();
        } else {
          return Promise.resolve(this._limiterFlexible.points);
        }
      }
      removeTokens(tokens, key = KEY_DEFAULT) {
        if (!this._queueLimiters[key]) {
          this._queueLimiters[key] = new RateLimiterQueueInternal(
            this._limiterFlexible,
            {
              key,
              maxQueueSize: this._maxQueueSize
            }
          );
        }
        return this._queueLimiters[key].removeTokens(tokens);
      }
    };
    var RateLimiterQueueInternal = class {
      constructor(limiterFlexible, opts = {
        maxQueueSize: MAX_QUEUE_SIZE,
        key: KEY_DEFAULT
      }) {
        this._key = opts.key;
        this._waitTimeout = null;
        this._queue = [];
        this._limiterFlexible = limiterFlexible;
        this._maxQueueSize = opts.maxQueueSize;
      }
      getTokensRemaining() {
        return this._limiterFlexible.get(this._key).then((rlRes) => {
          return rlRes !== null ? rlRes.remainingPoints : this._limiterFlexible.points;
        });
      }
      removeTokens(tokens) {
        const _this = this;
        return new Promise((resolve7, reject) => {
          if (tokens > _this._limiterFlexible.points) {
            reject(new RateLimiterQueueError(`Requested tokens ${tokens} exceeds maximum ${_this._limiterFlexible.points} tokens per interval`));
            return;
          }
          if (_this._queue.length > 0) {
            _this._queueRequest.call(_this, resolve7, reject, tokens);
          } else {
            _this._limiterFlexible.consume(_this._key, tokens).then((res) => {
              resolve7(res.remainingPoints);
            }).catch((rej) => {
              if (rej instanceof Error) {
                reject(rej);
              } else {
                _this._queueRequest.call(_this, resolve7, reject, tokens);
                if (_this._waitTimeout === null) {
                  _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);
                }
              }
            });
          }
        });
      }
      _queueRequest(resolve7, reject, tokens) {
        const _this = this;
        if (_this._queue.length < _this._maxQueueSize) {
          _this._queue.push({ resolve: resolve7, reject, tokens });
        } else {
          reject(new RateLimiterQueueError(`Number of requests reached it's maximum ${_this._maxQueueSize}`));
        }
      }
      _processFIFO() {
        const _this = this;
        if (_this._waitTimeout !== null) {
          clearTimeout(_this._waitTimeout);
          _this._waitTimeout = null;
        }
        if (_this._queue.length === 0) {
          return;
        }
        const item = _this._queue.shift();
        _this._limiterFlexible.consume(_this._key, item.tokens).then((res) => {
          item.resolve(res.remainingPoints);
          _this._processFIFO.call(_this);
        }).catch((rej) => {
          if (rej instanceof Error) {
            item.reject(rej);
            _this._processFIFO.call(_this);
          } else {
            _this._queue.unshift(item);
            if (_this._waitTimeout === null) {
              _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);
            }
          }
        });
      }
    };
  }
});
var require_BurstyRateLimiter = __commonJS({
  "node_modules/rate-limiter-flexible/lib/BurstyRateLimiter.js"(exports2, module2) {
    var RateLimiterRes = require_RateLimiterRes();
    module2.exports = class BurstyRateLimiter {
      constructor(rateLimiter, burstLimiter) {
        this._rateLimiter = rateLimiter;
        this._burstLimiter = burstLimiter;
      }
      /**
       * Merge rate limiter response objects. Responses can be null
       *
       * @param {RateLimiterRes} [rlRes] Rate limiter response
       * @param {RateLimiterRes} [blRes] Bursty limiter response
       */
      _combineRes(rlRes, blRes) {
        return new RateLimiterRes(
          rlRes.remainingPoints,
          Math.min(rlRes.msBeforeNext, blRes.msBeforeNext),
          rlRes.consumedPoints,
          rlRes.isFirstInDuration
        );
      }
      /**
       * @param key
       * @param pointsToConsume
       * @param options
       * @returns {Promise<any>}
       */
      consume(key, pointsToConsume = 1, options = {}) {
        return this._rateLimiter.consume(key, pointsToConsume, options).catch((rlRej) => {
          if (rlRej instanceof RateLimiterRes) {
            return this._burstLimiter.consume(key, pointsToConsume, options).then((blRes) => {
              return Promise.resolve(this._combineRes(rlRej, blRes));
            }).catch(
              (blRej) => {
                if (blRej instanceof RateLimiterRes) {
                  return Promise.reject(this._combineRes(rlRej, blRej));
                } else {
                  return Promise.reject(blRej);
                }
              }
            );
          } else {
            return Promise.reject(rlRej);
          }
        });
      }
      /**
       * It doesn't expose available points from burstLimiter
       *
       * @param key
       * @returns {Promise<RateLimiterRes>}
       */
      get(key) {
        return Promise.all([
          this._rateLimiter.get(key),
          this._burstLimiter.get(key)
        ]).then(([rlRes, blRes]) => {
          return this._combineRes(rlRes, blRes);
        });
      }
      get points() {
        return this._rateLimiter.points;
      }
    };
  }
});
var require_rate_limiter_flexible = __commonJS({
  "node_modules/rate-limiter-flexible/index.js"(exports2, module2) {
    var RateLimiterRedis = require_RateLimiterRedis();
    var RateLimiterMongo = require_RateLimiterMongo();
    var RateLimiterMySQL = require_RateLimiterMySQL();
    var RateLimiterPostgres = require_RateLimiterPostgres();
    var { RateLimiterClusterMaster, RateLimiterClusterMasterPM2, RateLimiterCluster } = require_RateLimiterCluster();
    var RateLimiterMemory3 = require_RateLimiterMemory();
    var RateLimiterMemcache = require_RateLimiterMemcache();
    var RLWrapperBlackAndWhite = require_RLWrapperBlackAndWhite();
    var RateLimiterUnion = require_RateLimiterUnion();
    var RateLimiterQueue = require_RateLimiterQueue();
    var BurstyRateLimiter = require_BurstyRateLimiter();
    var RateLimiterRes = require_RateLimiterRes();
    module2.exports = {
      RateLimiterRedis,
      RateLimiterMongo,
      RateLimiterMySQL,
      RateLimiterPostgres,
      RateLimiterMemory: RateLimiterMemory3,
      RateLimiterMemcache,
      RateLimiterClusterMaster,
      RateLimiterClusterMasterPM2,
      RateLimiterCluster,
      RLWrapperBlackAndWhite,
      RateLimiterUnion,
      RateLimiterQueue,
      BurstyRateLimiter,
      RateLimiterRes
    };
  }
});
var require_netmask = __commonJS({
  "node_modules/netmask/lib/netmask.js"(exports2) {
    (function() {
      var Netmask2, atob, chr, chr0, chrA, chra, ip2long, long2ip;
      long2ip = function(long) {
        var a, b, c, d;
        a = (long & 255 << 24) >>> 24;
        b = (long & 255 << 16) >>> 16;
        c = (long & 255 << 8) >>> 8;
        d = long & 255;
        return [a, b, c, d].join(".");
      };
      ip2long = function(ip) {
        var b, c, i2, j, n, ref;
        b = [];
        for (i2 = j = 0; j <= 3; i2 = ++j) {
          if (ip.length === 0) {
            break;
          }
          if (i2 > 0) {
            if (ip[0] !== ".") {
              throw new Error("Invalid IP");
            }
            ip = ip.substring(1);
          }
          ref = atob(ip), n = ref[0], c = ref[1];
          ip = ip.substring(c);
          b.push(n);
        }
        if (ip.length !== 0) {
          throw new Error("Invalid IP");
        }
        switch (b.length) {
          case 1:
            if (b[0] > 4294967295) {
              throw new Error("Invalid IP");
            }
            return b[0] >>> 0;
          case 2:
            if (b[0] > 255 || b[1] > 16777215) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1]) >>> 0;
          case 3:
            if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
          case 4:
            if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
          default:
            throw new Error("Invalid IP");
        }
      };
      chr = function(b) {
        return b.charCodeAt(0);
      };
      chr0 = chr("0");
      chra = chr("a");
      chrA = chr("A");
      atob = function(s) {
        var base3, dmax, i2, n, start;
        n = 0;
        base3 = 10;
        dmax = "9";
        i2 = 0;
        if (s.length > 1 && s[i2] === "0") {
          if (s[i2 + 1] === "x" || s[i2 + 1] === "X") {
            i2 += 2;
            base3 = 16;
          } else if ("0" <= s[i2 + 1] && s[i2 + 1] <= "9") {
            i2++;
            base3 = 8;
            dmax = "7";
          }
        }
        start = i2;
        while (i2 < s.length) {
          if ("0" <= s[i2] && s[i2] <= dmax) {
            n = n * base3 + (chr(s[i2]) - chr0) >>> 0;
          } else if (base3 === 16) {
            if ("a" <= s[i2] && s[i2] <= "f") {
              n = n * base3 + (10 + chr(s[i2]) - chra) >>> 0;
            } else if ("A" <= s[i2] && s[i2] <= "F") {
              n = n * base3 + (10 + chr(s[i2]) - chrA) >>> 0;
            } else {
              break;
            }
          } else {
            break;
          }
          if (n > 4294967295) {
            throw new Error("too large");
          }
          i2++;
        }
        if (i2 === start) {
          throw new Error("empty octet");
        }
        return [n, i2];
      };
      Netmask2 = function() {
        function Netmask3(net, mask) {
          var i2, j, ref;
          if (typeof net !== "string") {
            throw new Error("Missing `net' parameter");
          }
          if (!mask) {
            ref = net.split("/", 2), net = ref[0], mask = ref[1];
          }
          if (!mask) {
            mask = 32;
          }
          if (typeof mask === "string" && mask.indexOf(".") > -1) {
            try {
              this.maskLong = ip2long(mask);
            } catch (error1) {
              throw new Error("Invalid mask: " + mask);
            }
            for (i2 = j = 32; j >= 0; i2 = --j) {
              if (this.maskLong === 4294967295 << 32 - i2 >>> 0) {
                this.bitmask = i2;
                break;
              }
            }
          } else if (mask || mask === 0) {
            this.bitmask = parseInt(mask, 10);
            this.maskLong = 0;
            if (this.bitmask > 0) {
              this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
            }
          } else {
            throw new Error("Invalid mask: empty");
          }
          try {
            this.netLong = (ip2long(net) & this.maskLong) >>> 0;
          } catch (error1) {
            throw new Error("Invalid net address: " + net);
          }
          if (!(this.bitmask <= 32)) {
            throw new Error("Invalid mask for ip4: " + mask);
          }
          this.size = Math.pow(2, 32 - this.bitmask);
          this.base = long2ip(this.netLong);
          this.mask = long2ip(this.maskLong);
          this.hostmask = long2ip(~this.maskLong);
          this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
          this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
          this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
        }
        Netmask3.prototype.contains = function(ip) {
          if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
            ip = new Netmask3(ip);
          }
          if (ip instanceof Netmask3) {
            return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
          } else {
            return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
          }
        };
        Netmask3.prototype.next = function(count) {
          if (count == null) {
            count = 1;
          }
          return new Netmask3(long2ip(this.netLong + this.size * count), this.mask);
        };
        Netmask3.prototype.forEach = function(fn) {
          var index2, lastLong, long;
          long = ip2long(this.first);
          lastLong = ip2long(this.last);
          index2 = 0;
          while (long <= lastLong) {
            fn(long2ip(long), long, index2);
            index2++;
            long++;
          }
        };
        Netmask3.prototype.toString = function() {
          return this.base + "/" + this.bitmask;
        };
        return Netmask3;
      }();
      exports2.ip2long = ip2long;
      exports2.long2ip = long2ip;
      exports2.Netmask = Netmask2;
    }).call(exports2);
  }
});
var require_ipaddr = __commonJS({
  "node_modules/ipaddr.js/lib/ipaddr.js"(exports2, module2) {
    (function(root2) {
      const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      const ipv4Regexes = {
        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
        longValue: new RegExp(`^${ipv4Part}$`, "i")
      };
      const octalRegex = new RegExp(`^0[0-7]+$`, "i");
      const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
      const zoneIndex = "%[0-9a-z]{1,}";
      const ipv6Part = "(?:[0-9a-f]+::?)+";
      const ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
      };
      function expandIPv6(string2, parts2) {
        if (string2.indexOf("::") !== string2.lastIndexOf("::")) {
          return null;
        }
        let colonCount = 0;
        let lastColon = -1;
        let zoneId = (string2.match(ipv6Regexes.zoneIndex) || [])[0];
        let replacement, replacementCount;
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string2 = string2.replace(/%.+$/, "");
        }
        while ((lastColon = string2.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string2.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string2.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts2) {
          return null;
        }
        replacementCount = parts2 - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string2 = string2.replace("::", replacement);
        if (string2[0] === ":") {
          string2 = string2.slice(1);
        }
        if (string2[string2.length - 1] === ":") {
          string2 = string2.slice(0, -1);
        }
        parts2 = function() {
          const ref = string2.split(":");
          const results = [];
          for (let i2 = 0; i2 < ref.length; i2++) {
            results.push(parseInt(ref[i2], 16));
          }
          return results;
        }();
        return {
          parts: parts2,
          zoneId
        };
      }
      function matchCIDR(first2, second3, partSize, cidrBits) {
        if (first2.length !== second3.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        let part = 0;
        let shift;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first2[part] >> shift !== second3[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      }
      function parseIntAuto(string2) {
        if (hexRegex.test(string2)) {
          return parseInt(string2, 16);
        }
        if (string2[0] === "0" && !isNaN(parseInt(string2[1], 10))) {
          if (octalRegex.test(string2)) {
            return parseInt(string2, 8);
          }
          throw new Error(`ipaddr: cannot parse ${string2} as octal`);
        }
        return parseInt(string2, 10);
      }
      function padPart(part, length3) {
        while (part.length < length3) {
          part = `0${part}`;
        }
        return part;
      }
      const ipaddr2 = {};
      ipaddr2.IPv4 = function() {
        function IPv4(octets) {
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          let i2, octet;
          for (i2 = 0; i2 < octets.length; i2++) {
            octet = octets[i2];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          // RFC3171
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          // RFC3927
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          // RFC5735
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          // RFC6598
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          // RFC1918
          "private": [
            [new IPv4([10, 0, 0, 0]), 8],
            [new IPv4([172, 16, 0, 0]), 12],
            [new IPv4([192, 168, 0, 0]), 16]
          ],
          // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700
          reserved: [
            [new IPv4([192, 0, 0, 0]), 24],
            [new IPv4([192, 0, 2, 0]), 24],
            [new IPv4([192, 88, 99, 0]), 24],
            [new IPv4([198, 51, 100, 0]), 24],
            [new IPv4([203, 0, 113, 0]), 24],
            [new IPv4([240, 0, 0, 0]), 4]
          ]
        };
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop2 = false;
          const zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          let i2, octet, zeros;
          for (i2 = 3; i2 >= 0; i2 -= 1) {
            octet = this.octets[i2];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop2 && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop2 = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        IPv4.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr2.IPv6.parse(`::ffff:${this.toString()}`);
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        return IPv4;
      }();
      ipaddr2.IPv4.broadcastAddressFromCIDR = function(string2) {
        try {
          const cidr = this.parseCIDR(string2);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i2 = 0;
          while (i2 < 4) {
            octets.push(parseInt(ipInterfaceOctets[i2], 10) | parseInt(subnetMaskOctets[i2], 10) ^ 255);
            i2++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv4.isIPv4 = function(string2) {
        return this.parser(string2) !== null;
      };
      ipaddr2.IPv4.isValid = function(string2) {
        try {
          new this(this.parser(string2));
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr2.IPv4.isValidFourPartDecimal = function(string2) {
        if (ipaddr2.IPv4.isValid(string2) && string2.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr2.IPv4.networkAddressFromCIDR = function(string2) {
        let cidr, i2, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string2);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i2 = 0;
          while (i2 < 4) {
            octets.push(parseInt(ipInterfaceOctets[i2], 10) & parseInt(subnetMaskOctets[i2], 10));
            i2++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv4.parse = function(string2) {
        const parts2 = this.parser(string2);
        if (parts2 === null) {
          throw new Error("ipaddr: string is not formatted like an IPv4 Address");
        }
        return new this(parts2);
      };
      ipaddr2.IPv4.parseCIDR = function(string2) {
        let match;
        if (match = string2.match(/^(.+)\/(\d+)$/)) {
          const maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            const parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr2.IPv4.parser = function(string2) {
        let match, part, value2;
        if (match = string2.match(ipv4Regexes.fourOctet)) {
          return function() {
            const ref = match.slice(1, 6);
            const results = [];
            for (let i2 = 0; i2 < ref.length; i2++) {
              part = ref[i2];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string2.match(ipv4Regexes.longValue)) {
          value2 = parseIntAuto(match[1]);
          if (value2 > 4294967295 || value2 < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            const results = [];
            let shift;
            for (shift = 0; shift <= 24; shift += 8) {
              results.push(value2 >> shift & 255);
            }
            return results;
          }().reverse();
        } else if (match = string2.match(ipv4Regexes.twoOctet)) {
          return function() {
            const ref = match.slice(1, 4);
            const results = [];
            value2 = parseIntAuto(ref[1]);
            if (value2 > 16777215 || value2 < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(value2 >> 16 & 255);
            results.push(value2 >> 8 & 255);
            results.push(value2 & 255);
            return results;
          }();
        } else if (match = string2.match(ipv4Regexes.threeOctet)) {
          return function() {
            const ref = match.slice(1, 5);
            const results = [];
            value2 = parseIntAuto(ref[2]);
            if (value2 > 65535 || value2 < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(parseIntAuto(ref[1]));
            results.push(value2 >> 8 & 255);
            results.push(value2 & 255);
            return results;
          }();
        } else {
          return null;
        }
      };
      ipaddr2.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        const octets = [0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr2.IPv6 = function() {
        function IPv6(parts2, zoneId) {
          let i2, part;
          if (parts2.length === 16) {
            this.parts = [];
            for (i2 = 0; i2 <= 14; i2 += 2) {
              this.parts.push(parts2[i2] << 8 | parts2[i2 + 1]);
            }
          } else if (parts2.length === 8) {
            this.parts = parts2;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          for (i2 = 0; i2 < this.parts.length; i2++) {
            part = this.parts[i2];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.SpecialRanges = {
          // RFC4291, here and after
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          // RFC6145
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          // RFC6052
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          // RFC3056
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          // RFC6052, RFC6146
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          // RFC4291
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop2 = false;
          const zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          let part, zeros;
          for (let i2 = 7; i2 >= 0; i2 -= 1) {
            part = this.parts[i2];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop2 && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop2 = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        IPv6.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.toByteArray = function() {
          let part;
          const bytes2 = [];
          const ref = this.parts;
          for (let i2 = 0; i2 < ref.length; i2++) {
            part = ref[i2];
            bytes2.push(part >> 8);
            bytes2.push(part & 255);
          }
          return bytes2;
        };
        IPv6.prototype.toFixedLengthString = function() {
          const addr = function() {
            const results = [];
            for (let i2 = 0; i2 < this.parts.length; i2++) {
              results.push(padPart(this.parts[i2].toString(16), 4));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toIPv4Address = function() {
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          const ref = this.parts.slice(-2);
          const high = ref[0];
          const low = ref[1];
          return new ipaddr2.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.toNormalizedString = function() {
          const addr = function() {
            const results = [];
            for (let i2 = 0; i2 < this.parts.length; i2++) {
              results.push(this.parts[i2].toString(16));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toRFC5952String = function() {
          const regex = /((^|:)(0(:|$)){2,})/g;
          const string2 = this.toNormalizedString();
          let bestMatchIndex = 0;
          let bestMatchLength = -1;
          let match;
          while (match = regex.exec(string2)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string2;
          }
          return `${string2.substring(0, bestMatchIndex)}::${string2.substring(bestMatchIndex + bestMatchLength)}`;
        };
        IPv6.prototype.toString = function() {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
        };
        return IPv6;
      }();
      ipaddr2.IPv6.broadcastAddressFromCIDR = function(string2) {
        try {
          const cidr = this.parseCIDR(string2);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i2 = 0;
          while (i2 < 16) {
            octets.push(parseInt(ipInterfaceOctets[i2], 10) | parseInt(subnetMaskOctets[i2], 10) ^ 255);
            i2++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr2.IPv6.isIPv6 = function(string2) {
        return this.parser(string2) !== null;
      };
      ipaddr2.IPv6.isValid = function(string2) {
        if (typeof string2 === "string" && string2.indexOf(":") === -1) {
          return false;
        }
        try {
          const addr = this.parser(string2);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr2.IPv6.networkAddressFromCIDR = function(string2) {
        let cidr, i2, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string2);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i2 = 0;
          while (i2 < 16) {
            octets.push(parseInt(ipInterfaceOctets[i2], 10) & parseInt(subnetMaskOctets[i2], 10));
            i2++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr2.IPv6.parse = function(string2) {
        const addr = this.parser(string2);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv6 Address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr2.IPv6.parseCIDR = function(string2) {
        let maskLength, match, parsed;
        if (match = string2.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr2.IPv6.parser = function(string2) {
        let addr, i2, match, octet, octets, zoneId;
        if (match = string2.match(ipv6Regexes.deprecatedTransitional)) {
          return this.parser(`::ffff:${match[1]}`);
        }
        if (ipv6Regexes.native.test(string2)) {
          return expandIPv6(string2, 8);
        }
        if (match = string2.match(ipv6Regexes.transitional)) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [
              parseInt(match[2]),
              parseInt(match[3]),
              parseInt(match[4]),
              parseInt(match[5])
            ];
            for (i2 = 0; i2 < octets.length; i2++) {
              octet = octets[i2];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr2.IPv6.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 128) {
          throw new Error("ipaddr: invalid IPv6 prefix length");
        }
        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 16) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr2.fromByteArray = function(bytes2) {
        const length3 = bytes2.length;
        if (length3 === 4) {
          return new ipaddr2.IPv4(bytes2);
        } else if (length3 === 16) {
          return new ipaddr2.IPv6(bytes2);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr2.isValid = function(string2) {
        return ipaddr2.IPv6.isValid(string2) || ipaddr2.IPv4.isValid(string2);
      };
      ipaddr2.parse = function(string2) {
        if (ipaddr2.IPv6.isValid(string2)) {
          return ipaddr2.IPv6.parse(string2);
        } else if (ipaddr2.IPv4.isValid(string2)) {
          return ipaddr2.IPv4.parse(string2);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr2.parseCIDR = function(string2) {
        try {
          return ipaddr2.IPv6.parseCIDR(string2);
        } catch (e) {
          try {
            return ipaddr2.IPv4.parseCIDR(string2);
          } catch (e2) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr2.process = function(string2) {
        const addr = this.parse(string2);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
      ipaddr2.subnetMatch = function(address, rangeList, defaultName) {
        let i2, rangeName, rangeSubnets, subnet;
        if (defaultName === void 0 || defaultName === null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
            rangeSubnets = rangeList[rangeName];
            if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
              rangeSubnets = [rangeSubnets];
            }
            for (i2 = 0; i2 < rangeSubnets.length; i2++) {
              subnet = rangeSubnets[i2];
              if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = ipaddr2;
      } else {
        root2.ipaddr = ipaddr2;
      }
    })(exports2);
  }
});
var require_truncate = __commonJS({
  "node_modules/truncate-utf8-bytes/lib/truncate.js"(exports2, module2) {
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module2.exports = function truncate2(getLength, string2, byteLength2) {
      if (typeof string2 !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string2.length;
      var curByteLength = 0;
      var codePoint;
      var segment;
      for (var i2 = 0; i2 < charLength; i2 += 1) {
        codePoint = string2.charCodeAt(i2);
        segment = string2[i2];
        if (isHighSurrogate(codePoint) && isLowSurrogate(string2.charCodeAt(i2 + 1))) {
          i2 += 1;
          segment += string2[i2];
        }
        curByteLength += getLength(segment);
        if (curByteLength === byteLength2) {
          return string2.slice(0, i2 + 1);
        } else if (curByteLength > byteLength2) {
          return string2.slice(0, i2 - segment.length + 1);
        }
      }
      return string2;
    };
  }
});
var require_browser4 = __commonJS({
  "node_modules/utf8-byte-length/browser.js"(exports2, module2) {
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module2.exports = function getByteLength(string2) {
      if (typeof string2 !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string2.length;
      var byteLength2 = 0;
      var codePoint = null;
      var prevCodePoint = null;
      for (var i2 = 0; i2 < charLength; i2++) {
        codePoint = string2.charCodeAt(i2);
        if (isLowSurrogate(codePoint)) {
          if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
            byteLength2 += 1;
          } else {
            byteLength2 += 3;
          }
        } else if (codePoint <= 127) {
          byteLength2 += 1;
        } else if (codePoint >= 128 && codePoint <= 2047) {
          byteLength2 += 2;
        } else if (codePoint >= 2048 && codePoint <= 65535) {
          byteLength2 += 3;
        }
        prevCodePoint = codePoint;
      }
      return byteLength2;
    };
  }
});
var require_browser5 = __commonJS({
  "node_modules/truncate-utf8-bytes/browser.js"(exports2, module2) {
    var truncate2 = require_truncate();
    var getLength = require_browser4();
    module2.exports = truncate2.bind(null, getLength);
  }
});
var require_sanitize_filename = __commonJS({
  "node_modules/sanitize-filename/index.js"(exports2, module2) {
    var truncate2 = require_browser5();
    var illegalRe = /[\/\?<>\\:\*\|"]/g;
    var controlRe = /[\x00-\x1f\x80-\x9f]/g;
    var reservedRe = /^\.+$/;
    var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
    var windowsTrailingRe = /[\. ]+$/;
    function sanitize2(input, replacement) {
      if (typeof input !== "string") {
        throw new Error("Input must be string");
      }
      var sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
      return truncate2(sanitized, 255);
    }
    module2.exports = function(input, options) {
      var replacement = options && options.replacement || "";
      var output = sanitize2(input, replacement);
      if (replacement === "") {
        return output;
      }
      return sanitize2(output, "");
    };
  }
});
var require_pkcs7asn1 = __commonJS({
  "node_modules/node-forge/lib/pkcs7asn1.js"(exports2, module2) {
    var forge9 = require_forge();
    require_asn1();
    require_util();
    var asn1 = forge9.asn1;
    var p7v = module2.exports = forge9.pkcs7asn1 = forge9.pkcs7asn1 || {};
    forge9.pkcs7 = forge9.pkcs7 || {};
    forge9.pkcs7.asn1 = p7v;
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "ContentInfo.ContentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        captureAsn1: "content"
      }]
    };
    p7v.contentInfoValidator = contentInfoValidator;
    var encryptedContentInfoValidator = {
      name: "EncryptedContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "EncryptedContentInfo.encryptedContent",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        /* The PKCS#7 structure output by OpenSSL somewhat differs from what
         * other implementations do generate.
         *
         * OpenSSL generates a structure like this:
         * SEQUENCE {
         *    ...
         *    [0]
         *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
         *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
         *       ...
         * }
         *
         * Whereas other implementations (and this PKCS#7 module) generate:
         * SEQUENCE {
         *    ...
         *    [0] {
         *       OCTET STRING
         *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
         *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
         *          ...
         *    }
         * }
         *
         * In order to support both, we just capture the context specific
         * field here.  The OCTET STRING bit is removed below.
         */
        capture: "encryptedContent",
        captureAsn1: "encryptedContentAsn1"
      }]
    };
    p7v.envelopedDataValidator = {
      name: "EnvelopedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EnvelopedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "EnvelopedData.RecipientInfos",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: "recipientInfos"
      }].concat(encryptedContentInfoValidator)
    };
    p7v.encryptedDataValidator = {
      name: "EncryptedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }].concat(encryptedContentInfoValidator)
    };
    var signerValidator = {
      name: "SignerInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false
      }, {
        name: "SignerInfo.issuerAndSerialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.issuerAndSerialNumber.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "SignerInfo.issuerAndSerialNumber.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "SignerInfo.digestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.digestAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "digestAlgorithm"
        }, {
          name: "SignerInfo.digestAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "digestParameter",
          optional: true
        }]
      }, {
        name: "SignerInfo.authenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: "authenticatedAttributes"
      }, {
        name: "SignerInfo.digestEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        capture: "signatureAlgorithm"
      }, {
        name: "SignerInfo.encryptedDigest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "signature"
      }, {
        name: "SignerInfo.unauthenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        capture: "unauthenticatedAttributes"
      }]
    };
    p7v.signedDataValidator = {
      name: "SignedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "SignedData.Version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        {
          name: "SignedData.DigestAlgorithms",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          constructed: true,
          captureAsn1: "digestAlgorithms"
        },
        contentInfoValidator,
        {
          name: "SignedData.Certificates",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          optional: true,
          captureAsn1: "certificates"
        },
        {
          name: "SignedData.CertificateRevocationLists",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          optional: true,
          captureAsn1: "crls"
        },
        {
          name: "SignedData.SignerInfos",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          capture: "signerInfos",
          optional: true,
          value: [signerValidator]
        }
      ]
    };
    p7v.recipientInfoValidator = {
      name: "RecipientInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "RecipientInfo.issuerAndSerial",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.issuerAndSerial.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "RecipientInfo.issuerAndSerial.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "encParameter",
          optional: true
        }]
      }, {
        name: "RecipientInfo.encryptedKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encKey"
      }]
    };
  }
});
var require_mgf1 = __commonJS({
  "node_modules/node-forge/lib/mgf1.js"(exports2, module2) {
    var forge9 = require_forge();
    require_util();
    forge9.mgf = forge9.mgf || {};
    var mgf1 = module2.exports = forge9.mgf.mgf1 = forge9.mgf1 = forge9.mgf1 || {};
    mgf1.create = function(md) {
      var mgf = {
        /**
         * Generate mask of specified length.
         *
         * @param {String} seed The seed for mask generation.
         * @param maskLen Number of bytes to generate.
         * @return {String} The generated mask.
         */
        generate: function(seed2, maskLen) {
          var t = new forge9.util.ByteBuffer();
          var len = Math.ceil(maskLen / md.digestLength);
          for (var i2 = 0; i2 < len; i2++) {
            var c = new forge9.util.ByteBuffer();
            c.putInt32(i2);
            md.start();
            md.update(seed2 + c.getBytes());
            t.putBuffer(md.digest());
          }
          t.truncate(t.length() - maskLen);
          return t.getBytes();
        }
      };
      return mgf;
    };
  }
});
var require_mgf = __commonJS({
  "node_modules/node-forge/lib/mgf.js"(exports2, module2) {
    var forge9 = require_forge();
    require_mgf1();
    module2.exports = forge9.mgf = forge9.mgf || {};
    forge9.mgf.mgf1 = forge9.mgf1;
  }
});
var require_pss = __commonJS({
  "node_modules/node-forge/lib/pss.js"(exports2, module2) {
    var forge9 = require_forge();
    require_random();
    require_util();
    var pss = module2.exports = forge9.pss = forge9.pss || {};
    pss.create = function(options) {
      if (arguments.length === 3) {
        options = {
          md: arguments[0],
          mgf: arguments[1],
          saltLength: arguments[2]
        };
      }
      var hash3 = options.md;
      var mgf = options.mgf;
      var hLen = hash3.digestLength;
      var salt_ = options.salt || null;
      if (typeof salt_ === "string") {
        salt_ = forge9.util.createBuffer(salt_);
      }
      var sLen;
      if ("saltLength" in options) {
        sLen = options.saltLength;
      } else if (salt_ !== null) {
        sLen = salt_.length();
      } else {
        throw new Error("Salt length not specified or specific salt not given.");
      }
      if (salt_ !== null && salt_.length() !== sLen) {
        throw new Error("Given salt length does not match length of given salt.");
      }
      var prng = options.prng || forge9.random;
      var pssobj = {};
      pssobj.encode = function(md, modBits) {
        var i2;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        var mHash = md.digest().getBytes();
        if (emLen < hLen + sLen + 2) {
          throw new Error("Message is too long to encrypt.");
        }
        var salt;
        if (salt_ === null) {
          salt = prng.getBytesSync(sLen);
        } else {
          salt = salt_.bytes();
        }
        var m_ = new forge9.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash3.start();
        hash3.update(m_.getBytes());
        var h = hash3.digest().getBytes();
        var ps = new forge9.util.ByteBuffer();
        ps.fillWithByte(0, emLen - sLen - hLen - 2);
        ps.putByte(1);
        ps.putBytes(salt);
        var db = ps.getBytes();
        var maskLen = emLen - hLen - 1;
        var dbMask = mgf.generate(h, maskLen);
        var maskedDB = "";
        for (i2 = 0; i2 < maskLen; i2++) {
          maskedDB += String.fromCharCode(db.charCodeAt(i2) ^ dbMask.charCodeAt(i2));
        }
        var mask = 65280 >> 8 * emLen - emBits & 255;
        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
        return maskedDB + h + String.fromCharCode(188);
      };
      pssobj.verify = function(mHash, em, modBits) {
        var i2;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        em = em.substr(-emLen);
        if (emLen < hLen + sLen + 2) {
          throw new Error("Inconsistent parameters to PSS signature verification.");
        }
        if (em.charCodeAt(emLen - 1) !== 188) {
          throw new Error("Encoded message does not end in 0xBC.");
        }
        var maskLen = emLen - hLen - 1;
        var maskedDB = em.substr(0, maskLen);
        var h = em.substr(maskLen, hLen);
        var mask = 65280 >> 8 * emLen - emBits & 255;
        if ((maskedDB.charCodeAt(0) & mask) !== 0) {
          throw new Error("Bits beyond keysize not zero as expected.");
        }
        var dbMask = mgf.generate(h, maskLen);
        var db = "";
        for (i2 = 0; i2 < maskLen; i2++) {
          db += String.fromCharCode(maskedDB.charCodeAt(i2) ^ dbMask.charCodeAt(i2));
        }
        db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
        var checkLen = emLen - hLen - sLen - 2;
        for (i2 = 0; i2 < checkLen; i2++) {
          if (db.charCodeAt(i2) !== 0) {
            throw new Error("Leftmost octets not zero as expected");
          }
        }
        if (db.charCodeAt(checkLen) !== 1) {
          throw new Error("Inconsistent PSS signature, 0x01 marker not found");
        }
        var salt = db.substr(-sLen);
        var m_ = new forge9.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash3.start();
        hash3.update(m_.getBytes());
        var h_ = hash3.digest().getBytes();
        return h === h_;
      };
      return pssobj;
    };
  }
});
var require_x509 = __commonJS({
  "node_modules/node-forge/lib/x509.js"(exports2, module2) {
    var forge9 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_mgf();
    require_oids();
    require_pem();
    require_pss();
    require_rsa();
    require_util();
    var asn1 = forge9.asn1;
    var pki2 = module2.exports = forge9.pki = forge9.pki || {};
    var oids = pki2.oids;
    var _shortNames = {};
    _shortNames["CN"] = oids["commonName"];
    _shortNames["commonName"] = "CN";
    _shortNames["C"] = oids["countryName"];
    _shortNames["countryName"] = "C";
    _shortNames["L"] = oids["localityName"];
    _shortNames["localityName"] = "L";
    _shortNames["ST"] = oids["stateOrProvinceName"];
    _shortNames["stateOrProvinceName"] = "ST";
    _shortNames["O"] = oids["organizationName"];
    _shortNames["organizationName"] = "O";
    _shortNames["OU"] = oids["organizationalUnitName"];
    _shortNames["organizationalUnitName"] = "OU";
    _shortNames["E"] = oids["emailAddress"];
    _shortNames["emailAddress"] = "E";
    var publicKeyValidator = forge9.pki.rsa.publicKeyValidator;
    var x509CertificateValidator = {
      name: "Certificate",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Certificate.TBSCertificate",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "tbsCertificate",
        value: [
          {
            name: "Certificate.TBSCertificate.version",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.version.integer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "certVersion"
            }]
          },
          {
            name: "Certificate.TBSCertificate.serialNumber",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "certSerialNumber"
          },
          {
            name: "Certificate.TBSCertificate.signature",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.signature.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "certinfoSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certinfoSignatureParams"
            }]
          },
          {
            name: "Certificate.TBSCertificate.issuer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certIssuer"
          },
          {
            name: "Certificate.TBSCertificate.validity",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            // Note: UTC and generalized times may both appear so the capture
            // names are based on their detected order, the names used below
            // are only for the common case, which validity time really means
            // "notBefore" and which means "notAfter" will be determined by order
            value: [{
              // notBefore (Time) (UTC time case)
              name: "Certificate.TBSCertificate.validity.notBefore (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity1UTCTime"
            }, {
              // notBefore (Time) (generalized time case)
              name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity2GeneralizedTime"
            }, {
              // notAfter (Time) (only UTC time is supported)
              name: "Certificate.TBSCertificate.validity.notAfter (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity3UTCTime"
            }, {
              // notAfter (Time) (only UTC time is supported)
              name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity4GeneralizedTime"
            }]
          },
          {
            // Name (subject) (RDNSequence)
            name: "Certificate.TBSCertificate.subject",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certSubject"
          },
          // SubjectPublicKeyInfo
          publicKeyValidator,
          {
            // issuerUniqueID (optional)
            name: "Certificate.TBSCertificate.issuerUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.issuerUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              // TODO: support arbitrary bit length ids
              captureBitStringValue: "certIssuerUniqueId"
            }]
          },
          {
            // subjectUniqueID (optional)
            name: "Certificate.TBSCertificate.subjectUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 2,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.subjectUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              // TODO: support arbitrary bit length ids
              captureBitStringValue: "certSubjectUniqueId"
            }]
          },
          {
            // Extensions (optional)
            name: "Certificate.TBSCertificate.extensions",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 3,
            constructed: true,
            captureAsn1: "certExtensions",
            optional: true
          }
        ]
      }, {
        // AlgorithmIdentifier (signature algorithm)
        name: "Certificate.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          // algorithm
          name: "Certificate.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "certSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "certSignatureParams"
        }]
      }, {
        // SignatureValue
        name: "Certificate.signatureValue",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        captureBitStringValue: "certSignature"
      }]
    };
    var rsassaPssParameterValidator = {
      name: "rsapss",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "rsapss.hashAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "hashOid"
            /* parameter block omitted, for SHA1 NULL anyhow. */
          }]
        }]
      }, {
        name: "rsapss.maskGenAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "maskGenOid"
          }, {
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "maskGenHashOid"
              /* parameter block omitted, for SHA1 NULL anyhow. */
            }]
          }]
        }]
      }, {
        name: "rsapss.saltLength",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: true,
        value: [{
          name: "rsapss.saltLength.saltLength",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "saltLength"
        }]
      }, {
        name: "rsapss.trailerField",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: true,
        value: [{
          name: "rsapss.trailer.trailer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "trailer"
        }]
      }]
    };
    var certificationRequestInfoValidator = {
      name: "CertificationRequestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfo",
      value: [
        {
          name: "CertificationRequestInfo.integer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "certificationRequestInfoVersion"
        },
        {
          // Name (subject) (RDNSequence)
          name: "CertificationRequestInfo.subject",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfoSubject"
        },
        // SubjectPublicKeyInfo
        publicKeyValidator,
        {
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          capture: "certificationRequestInfoAttributes",
          value: [{
            name: "CertificationRequestInfo.attributes",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "CertificationRequestInfo.attributes.type",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false
            }, {
              name: "CertificationRequestInfo.attributes.value",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SET,
              constructed: true
            }]
          }]
        }
      ]
    };
    var certificationRequestValidator = {
      name: "CertificationRequest",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "csr",
      value: [
        certificationRequestInfoValidator,
        {
          // AlgorithmIdentifier (signature algorithm)
          name: "CertificationRequest.signatureAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            // algorithm
            name: "CertificationRequest.signatureAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "csrSignatureOid"
          }, {
            name: "CertificationRequest.signatureAlgorithm.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "csrSignatureParams"
          }]
        },
        {
          // signature
          name: "CertificationRequest.signature",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "csrSignature"
        }
      ]
    };
    pki2.RDNAttributesAsArray = function(rdn, md) {
      var rval = [];
      var set2, attr, obj;
      for (var si = 0; si < rdn.value.length; ++si) {
        set2 = rdn.value[si];
        for (var i2 = 0; i2 < set2.value.length; ++i2) {
          obj = {};
          attr = set2.value[i2];
          obj.type = asn1.derToOid(attr.value[0].value);
          obj.value = attr.value[1].value;
          obj.valueTagClass = attr.value[1].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (md) {
            md.update(obj.type);
            md.update(obj.value);
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    pki2.CRIAttributesAsArray = function(attributes) {
      var rval = [];
      for (var si = 0; si < attributes.length; ++si) {
        var seq = attributes[si];
        var type = asn1.derToOid(seq.value[0].value);
        var values = seq.value[1].value;
        for (var vi = 0; vi < values.length; ++vi) {
          var obj = {};
          obj.type = type;
          obj.value = values[vi].value;
          obj.valueTagClass = values[vi].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (obj.type === oids.extensionRequest) {
            obj.extensions = [];
            for (var ei = 0; ei < obj.value.length; ++ei) {
              obj.extensions.push(pki2.certificateExtensionFromAsn1(obj.value[ei]));
            }
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    function _getAttribute(obj, options) {
      if (typeof options === "string") {
        options = { shortName: options };
      }
      var rval = null;
      var attr;
      for (var i2 = 0; rval === null && i2 < obj.attributes.length; ++i2) {
        attr = obj.attributes[i2];
        if (options.type && options.type === attr.type) {
          rval = attr;
        } else if (options.name && options.name === attr.name) {
          rval = attr;
        } else if (options.shortName && options.shortName === attr.shortName) {
          rval = attr;
        }
      }
      return rval;
    }
    var _readSignatureParameters = function(oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids["RSASSA-PSS"]) {
        return params;
      }
      if (fillDefaults) {
        params = {
          hash: {
            algorithmOid: oids["sha1"]
          },
          mgf: {
            algorithmOid: oids["mgf1"],
            hash: {
              algorithmOid: oids["sha1"]
            }
          },
          saltLength: 20
        };
      }
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors2)) {
        var error = new Error("Cannot read RSASSA-PSS parameter block.");
        error.errors = errors2;
        throw error;
      }
      if (capture.hashOid !== void 0) {
        params.hash = params.hash || {};
        params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
      }
      if (capture.maskGenOid !== void 0) {
        params.mgf = params.mgf || {};
        params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
        params.mgf.hash = params.mgf.hash || {};
        params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
      }
      if (capture.saltLength !== void 0) {
        params.saltLength = capture.saltLength.charCodeAt(0);
      }
      return params;
    };
    var _createSignatureDigest = function(options) {
      switch (oids[options.signatureOid]) {
        case "sha1WithRSAEncryption":
        case "sha1WithRSASignature":
          return forge9.md.sha1.create();
        case "md5WithRSAEncryption":
          return forge9.md.md5.create();
        case "sha256WithRSAEncryption":
          return forge9.md.sha256.create();
        case "sha384WithRSAEncryption":
          return forge9.md.sha384.create();
        case "sha512WithRSAEncryption":
          return forge9.md.sha512.create();
        case "RSASSA-PSS":
          return forge9.md.sha256.create();
        default:
          var error = new Error(
            "Could not compute " + options.type + " digest. Unknown signature OID."
          );
          error.signatureOid = options.signatureOid;
          throw error;
      }
    };
    var _verifySignature = function(options) {
      var cert = options.certificate;
      var scheme;
      switch (cert.signatureOid) {
        case oids.sha1WithRSAEncryption:
        case oids.sha1WithRSASignature:
          break;
        case oids["RSASSA-PSS"]:
          var hash3, mgf;
          hash3 = oids[cert.signatureParameters.mgf.hash.algorithmOid];
          if (hash3 === void 0 || forge9.md[hash3] === void 0) {
            var error = new Error("Unsupported MGF hash function.");
            error.oid = cert.signatureParameters.mgf.hash.algorithmOid;
            error.name = hash3;
            throw error;
          }
          mgf = oids[cert.signatureParameters.mgf.algorithmOid];
          if (mgf === void 0 || forge9.mgf[mgf] === void 0) {
            var error = new Error("Unsupported MGF function.");
            error.oid = cert.signatureParameters.mgf.algorithmOid;
            error.name = mgf;
            throw error;
          }
          mgf = forge9.mgf[mgf].create(forge9.md[hash3].create());
          hash3 = oids[cert.signatureParameters.hash.algorithmOid];
          if (hash3 === void 0 || forge9.md[hash3] === void 0) {
            var error = new Error("Unsupported RSASSA-PSS hash function.");
            error.oid = cert.signatureParameters.hash.algorithmOid;
            error.name = hash3;
            throw error;
          }
          scheme = forge9.pss.create(
            forge9.md[hash3].create(),
            mgf,
            cert.signatureParameters.saltLength
          );
          break;
      }
      return cert.publicKey.verify(
        options.md.digest().getBytes(),
        options.signature,
        scheme
      );
    };
    pki2.certificateFromPem = function(pem, computeHash, strict) {
      var msg = forge9.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
        var error = new Error(
          'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
        );
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error(
          "Could not convert certificate from PEM; PEM is encrypted."
        );
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki2.certificateFromAsn1(obj, computeHash);
    };
    pki2.certificateToPem = function(cert, maxline) {
      var msg = {
        type: "CERTIFICATE",
        body: asn1.toDer(pki2.certificateToAsn1(cert)).getBytes()
      };
      return forge9.pem.encode(msg, { maxline });
    };
    pki2.publicKeyFromPem = function(pem) {
      var msg = forge9.pem.decode(pem)[0];
      if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
        var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert public key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki2.publicKeyFromAsn1(obj);
    };
    pki2.publicKeyToPem = function(key, maxline) {
      var msg = {
        type: "PUBLIC KEY",
        body: asn1.toDer(pki2.publicKeyToAsn1(key)).getBytes()
      };
      return forge9.pem.encode(msg, { maxline });
    };
    pki2.publicKeyToRSAPublicKeyPem = function(key, maxline) {
      var msg = {
        type: "RSA PUBLIC KEY",
        body: asn1.toDer(pki2.publicKeyToRSAPublicKey(key)).getBytes()
      };
      return forge9.pem.encode(msg, { maxline });
    };
    pki2.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md = options.md || forge9.md.sha1.create();
      var type = options.type || "RSAPublicKey";
      var bytes2;
      switch (type) {
        case "RSAPublicKey":
          bytes2 = asn1.toDer(pki2.publicKeyToRSAPublicKey(key)).getBytes();
          break;
        case "SubjectPublicKeyInfo":
          bytes2 = asn1.toDer(pki2.publicKeyToAsn1(key)).getBytes();
          break;
        default:
          throw new Error('Unknown fingerprint type "' + options.type + '".');
      }
      md.start();
      md.update(bytes2);
      var digest2 = md.digest();
      if (options.encoding === "hex") {
        var hex = digest2.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === "binary") {
        return digest2.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest2;
    };
    pki2.certificationRequestFromPem = function(pem, computeHash, strict) {
      var msg = forge9.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE REQUEST") {
        var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki2.certificationRequestFromAsn1(obj, computeHash);
    };
    pki2.certificationRequestToPem = function(csr, maxline) {
      var msg = {
        type: "CERTIFICATE REQUEST",
        body: asn1.toDer(pki2.certificationRequestToAsn1(csr)).getBytes()
      };
      return forge9.pem.encode(msg, { maxline });
    };
    pki2.createCertificate = function() {
      var cert = {};
      cert.version = 2;
      cert.serialNumber = "00";
      cert.signatureOid = null;
      cert.signature = null;
      cert.siginfo = {};
      cert.siginfo.algorithmOid = null;
      cert.validity = {};
      cert.validity.notBefore = new Date();
      cert.validity.notAfter = new Date();
      cert.issuer = {};
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = [];
      cert.issuer.hash = null;
      cert.subject = {};
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = [];
      cert.subject.hash = null;
      cert.extensions = [];
      cert.publicKey = null;
      cert.md = null;
      cert.setSubject = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.subject.attributes = attrs;
        delete cert.subject.uniqueId;
        if (uniqueId) {
          cert.subject.uniqueId = uniqueId;
        }
        cert.subject.hash = null;
      };
      cert.setIssuer = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.issuer.attributes = attrs;
        delete cert.issuer.uniqueId;
        if (uniqueId) {
          cert.issuer.uniqueId = uniqueId;
        }
        cert.issuer.hash = null;
      };
      cert.setExtensions = function(exts) {
        for (var i2 = 0; i2 < exts.length; ++i2) {
          _fillMissingExtensionFields(exts[i2], { cert });
        }
        cert.extensions = exts;
      };
      cert.getExtension = function(options) {
        if (typeof options === "string") {
          options = { name: options };
        }
        var rval = null;
        var ext;
        for (var i2 = 0; rval === null && i2 < cert.extensions.length; ++i2) {
          ext = cert.extensions[i2];
          if (options.id && ext.id === options.id) {
            rval = ext;
          } else if (options.name && ext.name === options.name) {
            rval = ext;
          }
        }
        return rval;
      };
      cert.sign = function(key, md) {
        cert.md = md || forge9.md.sha1.create();
        var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
          error.algorithm = cert.md.algorithm;
          throw error;
        }
        cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
        cert.tbsCertificate = pki2.getTBSCertificate(cert);
        var bytes2 = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes2.getBytes());
        cert.signature = key.sign(cert.md);
      };
      cert.verify = function(child) {
        var rval = false;
        if (!cert.issued(child)) {
          var issuer = child.issuer;
          var subject = cert.subject;
          var error = new Error(
            "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
          );
          error.expectedIssuer = subject.attributes;
          error.actualIssuer = issuer.attributes;
          throw error;
        }
        var md = child.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: child.signatureOid,
            type: "certificate"
          });
          var tbsCertificate = child.tbsCertificate || pki2.getTBSCertificate(child);
          var bytes2 = asn1.toDer(tbsCertificate);
          md.update(bytes2.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: cert,
            md,
            signature: child.signature
          });
        }
        return rval;
      };
      cert.isIssuer = function(parent2) {
        var rval = false;
        var i2 = cert.issuer;
        var s = parent2.subject;
        if (i2.hash && s.hash) {
          rval = i2.hash === s.hash;
        } else if (i2.attributes.length === s.attributes.length) {
          rval = true;
          var iattr, sattr;
          for (var n = 0; rval && n < i2.attributes.length; ++n) {
            iattr = i2.attributes[n];
            sattr = s.attributes[n];
            if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
              rval = false;
            }
          }
        }
        return rval;
      };
      cert.issued = function(child) {
        return child.isIssuer(cert);
      };
      cert.generateSubjectKeyIdentifier = function() {
        return pki2.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
      };
      cert.verifySubjectKeyIdentifier = function() {
        var oid = oids["subjectKeyIdentifier"];
        for (var i2 = 0; i2 < cert.extensions.length; ++i2) {
          var ext = cert.extensions[i2];
          if (ext.id === oid) {
            var ski = cert.generateSubjectKeyIdentifier().getBytes();
            return forge9.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
          }
        }
        return false;
      };
      return cert;
    };
    pki2.certificateFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, x509CertificateValidator, capture, errors2)) {
        var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
        error.errors = errors2;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki2.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var cert = pki2.createCertificate();
      cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
      var serial = forge9.util.createBuffer(capture.certSerialNumber);
      cert.serialNumber = serial.toHex();
      cert.signatureOid = forge9.asn1.derToOid(capture.certSignatureOid);
      cert.signatureParameters = _readSignatureParameters(
        cert.signatureOid,
        capture.certSignatureParams,
        true
      );
      cert.siginfo.algorithmOid = forge9.asn1.derToOid(capture.certinfoSignatureOid);
      cert.siginfo.parameters = _readSignatureParameters(
        cert.siginfo.algorithmOid,
        capture.certinfoSignatureParams,
        false
      );
      cert.signature = capture.certSignature;
      var validity = [];
      if (capture.certValidity1UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
      }
      if (capture.certValidity2GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity2GeneralizedTime
        ));
      }
      if (capture.certValidity3UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
      }
      if (capture.certValidity4GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity4GeneralizedTime
        ));
      }
      if (validity.length > 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
      }
      if (validity.length < 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
      }
      cert.validity.notBefore = validity[0];
      cert.validity.notAfter = validity[1];
      cert.tbsCertificate = capture.tbsCertificate;
      if (computeHash) {
        cert.md = _createSignatureDigest({
          signatureOid: cert.signatureOid,
          type: "certificate"
        });
        var bytes2 = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes2.getBytes());
      }
      var imd = forge9.md.sha1.create();
      var ibytes = asn1.toDer(capture.certIssuer);
      imd.update(ibytes.getBytes());
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = pki2.RDNAttributesAsArray(capture.certIssuer);
      if (capture.certIssuerUniqueId) {
        cert.issuer.uniqueId = capture.certIssuerUniqueId;
      }
      cert.issuer.hash = imd.digest().toHex();
      var smd = forge9.md.sha1.create();
      var sbytes = asn1.toDer(capture.certSubject);
      smd.update(sbytes.getBytes());
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = pki2.RDNAttributesAsArray(capture.certSubject);
      if (capture.certSubjectUniqueId) {
        cert.subject.uniqueId = capture.certSubjectUniqueId;
      }
      cert.subject.hash = smd.digest().toHex();
      if (capture.certExtensions) {
        cert.extensions = pki2.certificateExtensionsFromAsn1(capture.certExtensions);
      } else {
        cert.extensions = [];
      }
      cert.publicKey = pki2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      return cert;
    };
    pki2.certificateExtensionsFromAsn1 = function(exts) {
      var rval = [];
      for (var i2 = 0; i2 < exts.value.length; ++i2) {
        var extseq = exts.value[i2];
        for (var ei = 0; ei < extseq.value.length; ++ei) {
          rval.push(pki2.certificateExtensionFromAsn1(extseq.value[ei]));
        }
      }
      return rval;
    };
    pki2.certificateExtensionFromAsn1 = function(ext) {
      var e = {};
      e.id = asn1.derToOid(ext.value[0].value);
      e.critical = false;
      if (ext.value[1].type === asn1.Type.BOOLEAN) {
        e.critical = ext.value[1].value.charCodeAt(0) !== 0;
        e.value = ext.value[2].value;
      } else {
        e.value = ext.value[1].value;
      }
      if (e.id in oids) {
        e.name = oids[e.id];
        if (e.name === "keyUsage") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          var b3 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
            b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
          }
          e.digitalSignature = (b2 & 128) === 128;
          e.nonRepudiation = (b2 & 64) === 64;
          e.keyEncipherment = (b2 & 32) === 32;
          e.dataEncipherment = (b2 & 16) === 16;
          e.keyAgreement = (b2 & 8) === 8;
          e.keyCertSign = (b2 & 4) === 4;
          e.cRLSign = (b2 & 2) === 2;
          e.encipherOnly = (b2 & 1) === 1;
          e.decipherOnly = (b3 & 128) === 128;
        } else if (e.name === "basicConstraints") {
          var ev = asn1.fromDer(e.value);
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
            e.cA = ev.value[0].value.charCodeAt(0) !== 0;
          } else {
            e.cA = false;
          }
          var value2 = null;
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
            value2 = ev.value[0].value;
          } else if (ev.value.length > 1) {
            value2 = ev.value[1].value;
          }
          if (value2 !== null) {
            e.pathLenConstraint = asn1.derToInteger(value2);
          }
        } else if (e.name === "extKeyUsage") {
          var ev = asn1.fromDer(e.value);
          for (var vi = 0; vi < ev.value.length; ++vi) {
            var oid = asn1.derToOid(ev.value[vi].value);
            if (oid in oids) {
              e[oids[oid]] = true;
            } else {
              e[oid] = true;
            }
          }
        } else if (e.name === "nsCertType") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
          }
          e.client = (b2 & 128) === 128;
          e.server = (b2 & 64) === 64;
          e.email = (b2 & 32) === 32;
          e.objsign = (b2 & 16) === 16;
          e.reserved = (b2 & 8) === 8;
          e.sslCA = (b2 & 4) === 4;
          e.emailCA = (b2 & 2) === 2;
          e.objCA = (b2 & 1) === 1;
        } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
          e.altNames = [];
          var gn;
          var ev = asn1.fromDer(e.value);
          for (var n = 0; n < ev.value.length; ++n) {
            gn = ev.value[n];
            var altName = {
              type: gn.type,
              value: gn.value
            };
            e.altNames.push(altName);
            switch (gn.type) {
              case 1:
              case 2:
              case 6:
                break;
              case 7:
                altName.ip = forge9.util.bytesToIP(gn.value);
                break;
              case 8:
                altName.oid = asn1.derToOid(gn.value);
                break;
            }
          }
        } else if (e.name === "subjectKeyIdentifier") {
          var ev = asn1.fromDer(e.value);
          e.subjectKeyIdentifier = forge9.util.bytesToHex(ev.value);
        }
      }
      return e;
    };
    pki2.certificationRequestFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, certificationRequestValidator, capture, errors2)) {
        var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
        error.errors = errors2;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki2.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var csr = pki2.createCertificationRequest();
      csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
      csr.signatureOid = forge9.asn1.derToOid(capture.csrSignatureOid);
      csr.signatureParameters = _readSignatureParameters(
        csr.signatureOid,
        capture.csrSignatureParams,
        true
      );
      csr.siginfo.algorithmOid = forge9.asn1.derToOid(capture.csrSignatureOid);
      csr.siginfo.parameters = _readSignatureParameters(
        csr.siginfo.algorithmOid,
        capture.csrSignatureParams,
        false
      );
      csr.signature = capture.csrSignature;
      csr.certificationRequestInfo = capture.certificationRequestInfo;
      if (computeHash) {
        csr.md = _createSignatureDigest({
          signatureOid: csr.signatureOid,
          type: "certification request"
        });
        var bytes2 = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes2.getBytes());
      }
      var smd = forge9.md.sha1.create();
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = pki2.RDNAttributesAsArray(
        capture.certificationRequestInfoSubject,
        smd
      );
      csr.subject.hash = smd.digest().toHex();
      csr.publicKey = pki2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.attributes = pki2.CRIAttributesAsArray(
        capture.certificationRequestInfoAttributes || []
      );
      return csr;
    };
    pki2.createCertificationRequest = function() {
      var csr = {};
      csr.version = 0;
      csr.signatureOid = null;
      csr.signature = null;
      csr.siginfo = {};
      csr.siginfo.algorithmOid = null;
      csr.subject = {};
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = [];
      csr.subject.hash = null;
      csr.publicKey = null;
      csr.attributes = [];
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.md = null;
      csr.setSubject = function(attrs) {
        _fillMissingFields(attrs);
        csr.subject.attributes = attrs;
        csr.subject.hash = null;
      };
      csr.setAttributes = function(attrs) {
        _fillMissingFields(attrs);
        csr.attributes = attrs;
      };
      csr.sign = function(key, md) {
        csr.md = md || forge9.md.sha1.create();
        var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
          error.algorithm = csr.md.algorithm;
          throw error;
        }
        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
        csr.certificationRequestInfo = pki2.getCertificationRequestInfo(csr);
        var bytes2 = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes2.getBytes());
        csr.signature = key.sign(csr.md);
      };
      csr.verify = function() {
        var rval = false;
        var md = csr.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: csr.signatureOid,
            type: "certification request"
          });
          var cri = csr.certificationRequestInfo || pki2.getCertificationRequestInfo(csr);
          var bytes2 = asn1.toDer(cri);
          md.update(bytes2.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: csr,
            md,
            signature: csr.signature
          });
        }
        return rval;
      };
      return csr;
    };
    function _dnToAsn1(obj) {
      var rval = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var attr, set2;
      var attrs = obj.attributes;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        attr = attrs[i2];
        var value2 = attr.value;
        var valueTagClass = asn1.Type.PRINTABLESTRING;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
          if (valueTagClass === asn1.Type.UTF8) {
            value2 = forge9.util.encodeUtf8(value2);
          }
        }
        set2 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // AttributeType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(attr.type).getBytes()
            ),
            // AttributeValue
            asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value2)
          ])
        ]);
        rval.value.push(set2);
      }
      return rval;
    }
    function _fillMissingFields(attrs) {
      var attr;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        attr = attrs[i2];
        if (typeof attr.name === "undefined") {
          if (attr.type && attr.type in pki2.oids) {
            attr.name = pki2.oids[attr.type];
          } else if (attr.shortName && attr.shortName in _shortNames) {
            attr.name = pki2.oids[_shortNames[attr.shortName]];
          }
        }
        if (typeof attr.type === "undefined") {
          if (attr.name && attr.name in pki2.oids) {
            attr.type = pki2.oids[attr.name];
          } else {
            var error = new Error("Attribute type not specified.");
            error.attribute = attr;
            throw error;
          }
        }
        if (typeof attr.shortName === "undefined") {
          if (attr.name && attr.name in _shortNames) {
            attr.shortName = _shortNames[attr.name];
          }
        }
        if (attr.type === oids.extensionRequest) {
          attr.valueConstructed = true;
          attr.valueTagClass = asn1.Type.SEQUENCE;
          if (!attr.value && attr.extensions) {
            attr.value = [];
            for (var ei = 0; ei < attr.extensions.length; ++ei) {
              attr.value.push(pki2.certificateExtensionToAsn1(
                _fillMissingExtensionFields(attr.extensions[ei])
              ));
            }
          }
        }
        if (typeof attr.value === "undefined") {
          var error = new Error("Attribute value not specified.");
          error.attribute = attr;
          throw error;
        }
      }
    }
    function _fillMissingExtensionFields(e, options) {
      options = options || {};
      if (typeof e.name === "undefined") {
        if (e.id && e.id in pki2.oids) {
          e.name = pki2.oids[e.id];
        }
      }
      if (typeof e.id === "undefined") {
        if (e.name && e.name in pki2.oids) {
          e.id = pki2.oids[e.name];
        } else {
          var error = new Error("Extension ID not specified.");
          error.extension = e;
          throw error;
        }
      }
      if (typeof e.value !== "undefined") {
        return e;
      }
      if (e.name === "keyUsage") {
        var unused = 0;
        var b2 = 0;
        var b3 = 0;
        if (e.digitalSignature) {
          b2 |= 128;
          unused = 7;
        }
        if (e.nonRepudiation) {
          b2 |= 64;
          unused = 6;
        }
        if (e.keyEncipherment) {
          b2 |= 32;
          unused = 5;
        }
        if (e.dataEncipherment) {
          b2 |= 16;
          unused = 4;
        }
        if (e.keyAgreement) {
          b2 |= 8;
          unused = 3;
        }
        if (e.keyCertSign) {
          b2 |= 4;
          unused = 2;
        }
        if (e.cRLSign) {
          b2 |= 2;
          unused = 1;
        }
        if (e.encipherOnly) {
          b2 |= 1;
          unused = 0;
        }
        if (e.decipherOnly) {
          b3 |= 128;
          unused = 7;
        }
        var value2 = String.fromCharCode(unused);
        if (b3 !== 0) {
          value2 += String.fromCharCode(b2) + String.fromCharCode(b3);
        } else if (b2 !== 0) {
          value2 += String.fromCharCode(b2);
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value2
        );
      } else if (e.name === "basicConstraints") {
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        if (e.cA) {
          e.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.BOOLEAN,
            false,
            String.fromCharCode(255)
          ));
        }
        if ("pathLenConstraint" in e) {
          e.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(e.pathLenConstraint).getBytes()
          ));
        }
      } else if (e.name === "extKeyUsage") {
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var seq = e.value.value;
        for (var key in e) {
          if (e[key] !== true) {
            continue;
          }
          if (key in oids) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids[key]).getBytes()
            ));
          } else if (key.indexOf(".") !== -1) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(key).getBytes()
            ));
          }
        }
      } else if (e.name === "nsCertType") {
        var unused = 0;
        var b2 = 0;
        if (e.client) {
          b2 |= 128;
          unused = 7;
        }
        if (e.server) {
          b2 |= 64;
          unused = 6;
        }
        if (e.email) {
          b2 |= 32;
          unused = 5;
        }
        if (e.objsign) {
          b2 |= 16;
          unused = 4;
        }
        if (e.reserved) {
          b2 |= 8;
          unused = 3;
        }
        if (e.sslCA) {
          b2 |= 4;
          unused = 2;
        }
        if (e.emailCA) {
          b2 |= 2;
          unused = 1;
        }
        if (e.objCA) {
          b2 |= 1;
          unused = 0;
        }
        var value2 = String.fromCharCode(unused);
        if (b2 !== 0) {
          value2 += String.fromCharCode(b2);
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value2
        );
      } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value2 = altName.value;
          if (altName.type === 7 && altName.ip) {
            value2 = forge9.util.bytesFromIP(altName.ip);
            if (value2 === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value2 = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value2 = asn1.oidToDer(value2);
            }
          }
          e.value.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value2
          ));
        }
      } else if (e.name === "nsComment" && options.cert) {
        if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
          throw new Error('Invalid "nsComment" content.');
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.IA5STRING,
          false,
          e.comment
        );
      } else if (e.name === "subjectKeyIdentifier" && options.cert) {
        var ski = options.cert.generateSubjectKeyIdentifier();
        e.subjectKeyIdentifier = ski.toHex();
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          ski.getBytes()
        );
      } else if (e.name === "authorityKeyIdentifier" && options.cert) {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        if (e.keyIdentifier) {
          var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)
          );
        }
        if (e.authorityCertIssuer) {
          var authorityCertIssuer = [
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
              _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
            ])
          ];
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)
          );
        }
        if (e.serialNumber) {
          var serialNumber = forge9.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)
          );
        }
      } else if (e.name === "cRLDistributionPoints") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        var subSeq = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var fullNameGeneralNames = asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          []
        );
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value2 = altName.value;
          if (altName.type === 7 && altName.ip) {
            value2 = forge9.util.bytesFromIP(altName.ip);
            if (value2 === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value2 = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value2 = asn1.oidToDer(value2);
            }
          }
          fullNameGeneralNames.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value2
          ));
        }
        subSeq.value.push(asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          [fullNameGeneralNames]
        ));
        seq.push(subSeq);
      }
      if (typeof e.value === "undefined") {
        var error = new Error("Extension value not specified.");
        error.extension = e;
        throw error;
      }
      return e;
    }
    function _signatureParametersToAsn1(oid, params) {
      switch (oid) {
        case oids["RSASSA-PSS"]:
          var parts2 = [];
          if (params.hash.algorithmOid !== void 0) {
            parts2.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.hash.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
              ])
            ]));
          }
          if (params.mgf.algorithmOid !== void 0) {
            parts2.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.mgf.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.OID,
                    false,
                    asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()
                  ),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                ])
              ])
            ]));
          }
          if (params.saltLength !== void 0) {
            parts2.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(params.saltLength).getBytes()
              )
            ]));
          }
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts2);
        default:
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
      }
    }
    function _CRIAttributesToAsn1(csr) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
      if (csr.attributes.length === 0) {
        return rval;
      }
      var attrs = csr.attributes;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        var attr = attrs[i2];
        var value2 = attr.value;
        var valueTagClass = asn1.Type.UTF8;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
        }
        if (valueTagClass === asn1.Type.UTF8) {
          value2 = forge9.util.encodeUtf8(value2);
        }
        var valueConstructed = false;
        if ("valueConstructed" in attr) {
          valueConstructed = attr.valueConstructed;
        }
        var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // AttributeType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(attr.type).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
            // AttributeValue
            asn1.create(
              asn1.Class.UNIVERSAL,
              valueTagClass,
              valueConstructed,
              value2
            )
          ])
        ]);
        rval.value.push(seq);
      }
      return rval;
    }
    var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
    var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
    function _dateToAsn1(date) {
      if (date >= jan_1_1950 && date < jan_1_2050) {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.UTCTIME,
          false,
          asn1.dateToUtcTime(date)
        );
      } else {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.GENERALIZEDTIME,
          false,
          asn1.dateToGeneralizedTime(date)
        );
      }
    }
    pki2.getTBSCertificate = function(cert) {
      var notBefore = _dateToAsn1(cert.validity.notBefore);
      var notAfter = _dateToAsn1(cert.validity.notAfter);
      var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          // integer
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(cert.version).getBytes()
          )
        ]),
        // serialNumber
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          forge9.util.hexToBytes(cert.serialNumber)
        ),
        // signature
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(
            cert.siginfo.algorithmOid,
            cert.siginfo.parameters
          )
        ]),
        // issuer
        _dnToAsn1(cert.issuer),
        // validity
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          notBefore,
          notAfter
        ]),
        // subject
        _dnToAsn1(cert.subject),
        // SubjectPublicKeyInfo
        pki2.publicKeyToAsn1(cert.publicKey)
      ]);
      if (cert.issuer.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              // TODO: support arbitrary bit length ids
              String.fromCharCode(0) + cert.issuer.uniqueId
            )
          ])
        );
      }
      if (cert.subject.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              // TODO: support arbitrary bit length ids
              String.fromCharCode(0) + cert.subject.uniqueId
            )
          ])
        );
      }
      if (cert.extensions.length > 0) {
        tbs.value.push(pki2.certificateExtensionsToAsn1(cert.extensions));
      }
      return tbs;
    };
    pki2.getCertificationRequestInfo = function(csr) {
      var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(csr.version).getBytes()
        ),
        // subject
        _dnToAsn1(csr.subject),
        // SubjectPublicKeyInfo
        pki2.publicKeyToAsn1(csr.publicKey),
        // attributes
        _CRIAttributesToAsn1(csr)
      ]);
      return cri;
    };
    pki2.distinguishedNameToAsn1 = function(dn) {
      return _dnToAsn1(dn);
    };
    pki2.certificateToAsn1 = function(cert) {
      var tbsCertificate = cert.tbsCertificate || pki2.getTBSCertificate(cert);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // TBSCertificate
        tbsCertificate,
        // AlgorithmIdentifier (signature algorithm)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert.signatureOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
        ]),
        // SignatureValue
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + cert.signature
        )
      ]);
    };
    pki2.certificateExtensionsToAsn1 = function(exts) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      rval.value.push(seq);
      for (var i2 = 0; i2 < exts.length; ++i2) {
        seq.value.push(pki2.certificateExtensionToAsn1(exts[i2]));
      }
      return rval;
    };
    pki2.certificateExtensionToAsn1 = function(ext) {
      var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(ext.id).getBytes()
      ));
      if (ext.critical) {
        extseq.value.push(asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BOOLEAN,
          false,
          String.fromCharCode(255)
        ));
      }
      var value2 = ext.value;
      if (typeof ext.value !== "string") {
        value2 = asn1.toDer(value2).getBytes();
      }
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        value2
      ));
      return extseq;
    };
    pki2.certificationRequestToAsn1 = function(csr) {
      var cri = csr.certificationRequestInfo || pki2.getCertificationRequestInfo(csr);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // CertificationRequestInfo
        cri,
        // AlgorithmIdentifier (signature algorithm)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(csr.signatureOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
        ]),
        // signature
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + csr.signature
        )
      ]);
    };
    pki2.createCaStore = function(certs) {
      var caStore = {
        // stored certificates
        certs: {}
      };
      caStore.getIssuer = function(cert2) {
        var rval = getBySubject(cert2.issuer);
        return rval;
      };
      caStore.addCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge9.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          if (cert2.subject.hash in caStore.certs) {
            var tmp = caStore.certs[cert2.subject.hash];
            if (!forge9.util.isArray(tmp)) {
              tmp = [tmp];
            }
            tmp.push(cert2);
            caStore.certs[cert2.subject.hash] = tmp;
          } else {
            caStore.certs[cert2.subject.hash] = cert2;
          }
        }
      };
      caStore.hasCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge9.pki.certificateFromPem(cert2);
        }
        var match = getBySubject(cert2.subject);
        if (!match) {
          return false;
        }
        if (!forge9.util.isArray(match)) {
          match = [match];
        }
        var der1 = asn1.toDer(pki2.certificateToAsn1(cert2)).getBytes();
        for (var i3 = 0; i3 < match.length; ++i3) {
          var der2 = asn1.toDer(pki2.certificateToAsn1(match[i3])).getBytes();
          if (der1 === der2) {
            return true;
          }
        }
        return false;
      };
      caStore.listAllCertificates = function() {
        var certList = [];
        for (var hash3 in caStore.certs) {
          if (caStore.certs.hasOwnProperty(hash3)) {
            var value2 = caStore.certs[hash3];
            if (!forge9.util.isArray(value2)) {
              certList.push(value2);
            } else {
              for (var i3 = 0; i3 < value2.length; ++i3) {
                certList.push(value2[i3]);
              }
            }
          }
        }
        return certList;
      };
      caStore.removeCertificate = function(cert2) {
        var result;
        if (typeof cert2 === "string") {
          cert2 = forge9.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          return null;
        }
        var match = getBySubject(cert2.subject);
        if (!forge9.util.isArray(match)) {
          result = caStore.certs[cert2.subject.hash];
          delete caStore.certs[cert2.subject.hash];
          return result;
        }
        var der1 = asn1.toDer(pki2.certificateToAsn1(cert2)).getBytes();
        for (var i3 = 0; i3 < match.length; ++i3) {
          var der2 = asn1.toDer(pki2.certificateToAsn1(match[i3])).getBytes();
          if (der1 === der2) {
            result = match[i3];
            match.splice(i3, 1);
          }
        }
        if (match.length === 0) {
          delete caStore.certs[cert2.subject.hash];
        }
        return result;
      };
      function getBySubject(subject) {
        ensureSubjectHasHash(subject);
        return caStore.certs[subject.hash] || null;
      }
      function ensureSubjectHasHash(subject) {
        if (!subject.hash) {
          var md = forge9.md.sha1.create();
          subject.attributes = pki2.RDNAttributesAsArray(_dnToAsn1(subject), md);
          subject.hash = md.digest().toHex();
        }
      }
      if (certs) {
        for (var i2 = 0; i2 < certs.length; ++i2) {
          var cert = certs[i2];
          caStore.addCertificate(cert);
        }
      }
      return caStore;
    };
    pki2.certificateError = {
      bad_certificate: "forge.pki.BadCertificate",
      unsupported_certificate: "forge.pki.UnsupportedCertificate",
      certificate_revoked: "forge.pki.CertificateRevoked",
      certificate_expired: "forge.pki.CertificateExpired",
      certificate_unknown: "forge.pki.CertificateUnknown",
      unknown_ca: "forge.pki.UnknownCertificateAuthority"
    };
    pki2.verifyCertificateChain = function(caStore, chain, options) {
      if (typeof options === "function") {
        options = { verify: options };
      }
      options = options || {};
      chain = chain.slice(0);
      var certs = chain.slice(0);
      var validityCheckDate = options.validityCheckDate;
      if (typeof validityCheckDate === "undefined") {
        validityCheckDate = new Date();
      }
      var first2 = true;
      var error = null;
      var depth = 0;
      do {
        var cert = chain.shift();
        var parent2 = null;
        var selfSigned = false;
        if (validityCheckDate) {
          if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
            error = {
              message: "Certificate is not valid yet or has expired.",
              error: pki2.certificateError.certificate_expired,
              notBefore: cert.validity.notBefore,
              notAfter: cert.validity.notAfter,
              // TODO: we might want to reconsider renaming 'now' to
              // 'validityCheckDate' should this API be changed in the future.
              now: validityCheckDate
            };
          }
        }
        if (error === null) {
          parent2 = chain[0] || caStore.getIssuer(cert);
          if (parent2 === null) {
            if (cert.isIssuer(cert)) {
              selfSigned = true;
              parent2 = cert;
            }
          }
          if (parent2) {
            var parents = parent2;
            if (!forge9.util.isArray(parents)) {
              parents = [parents];
            }
            var verified = false;
            while (!verified && parents.length > 0) {
              parent2 = parents.shift();
              try {
                verified = parent2.verify(cert);
              } catch (ex) {
              }
            }
            if (!verified) {
              error = {
                message: "Certificate signature is invalid.",
                error: pki2.certificateError.bad_certificate
              };
            }
          }
          if (error === null && (!parent2 || selfSigned) && !caStore.hasCertificate(cert)) {
            error = {
              message: "Certificate is not trusted.",
              error: pki2.certificateError.unknown_ca
            };
          }
        }
        if (error === null && parent2 && !cert.isIssuer(parent2)) {
          error = {
            message: "Certificate issuer is invalid.",
            error: pki2.certificateError.bad_certificate
          };
        }
        if (error === null) {
          var se = {
            keyUsage: true,
            basicConstraints: true
          };
          for (var i2 = 0; error === null && i2 < cert.extensions.length; ++i2) {
            var ext = cert.extensions[i2];
            if (ext.critical && !(ext.name in se)) {
              error = {
                message: "Certificate has an unsupported critical extension.",
                error: pki2.certificateError.unsupported_certificate
              };
            }
          }
        }
        if (error === null && (!first2 || chain.length === 0 && (!parent2 || selfSigned))) {
          var bcExt = cert.getExtension("basicConstraints");
          var keyUsageExt = cert.getExtension("keyUsage");
          if (keyUsageExt !== null) {
            if (!keyUsageExt.keyCertSign || bcExt === null) {
              error = {
                message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                error: pki2.certificateError.bad_certificate
              };
            }
          }
          if (error === null && bcExt !== null && !bcExt.cA) {
            error = {
              message: "Certificate basicConstraints indicates the certificate is not a CA.",
              error: pki2.certificateError.bad_certificate
            };
          }
          if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
            var pathLen = depth - 1;
            if (pathLen > bcExt.pathLenConstraint) {
              error = {
                message: "Certificate basicConstraints pathLenConstraint violated.",
                error: pki2.certificateError.bad_certificate
              };
            }
          }
        }
        var vfd = error === null ? true : error.error;
        var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
        if (ret === true) {
          error = null;
        } else {
          if (vfd === true) {
            error = {
              message: "The application rejected the certificate.",
              error: pki2.certificateError.bad_certificate
            };
          }
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge9.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.error) {
                error.error = ret.error;
              }
            } else if (typeof ret === "string") {
              error.error = ret;
            }
          }
          throw error;
        }
        first2 = false;
        ++depth;
      } while (chain.length > 0);
      return true;
    };
  }
});
var require_pkcs7 = __commonJS({
  "node_modules/node-forge/lib/pkcs7.js"(exports2, module2) {
    var forge9 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_oids();
    require_pem();
    require_pkcs7asn1();
    require_random();
    require_util();
    require_x509();
    var asn1 = forge9.asn1;
    var p7 = module2.exports = forge9.pkcs7 = forge9.pkcs7 || {};
    p7.messageFromPem = function(pem) {
      var msg = forge9.pem.decode(pem)[0];
      if (msg.type !== "PKCS7") {
        var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return p7.messageFromAsn1(obj);
    };
    p7.messageToPem = function(msg, maxline) {
      var pemObj = {
        type: "PKCS7",
        body: asn1.toDer(msg.toAsn1()).getBytes()
      };
      return forge9.pem.encode(pemObj, { maxline });
    };
    p7.messageFromAsn1 = function(obj) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors2)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
        error.errors = errors2;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      var msg;
      switch (contentType) {
        case forge9.pki.oids.envelopedData:
          msg = p7.createEnvelopedData();
          break;
        case forge9.pki.oids.encryptedData:
          msg = p7.createEncryptedData();
          break;
        case forge9.pki.oids.signedData:
          msg = p7.createSignedData();
          break;
        default:
          throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
      }
      msg.fromAsn1(capture.content.value[0]);
      return msg;
    };
    p7.createSignedData = function() {
      var msg = null;
      msg = {
        type: forge9.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        // TODO: add json-formatted signer stuff here?
        signers: [],
        // populated during sign()
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
          msg.certificates = [];
          msg.crls = [];
          msg.digestAlgorithmIdentifiers = [];
          msg.contentInfo = null;
          msg.signerInfos = [];
          if (msg.rawCapture.certificates) {
            var certs = msg.rawCapture.certificates.value;
            for (var i2 = 0; i2 < certs.length; ++i2) {
              msg.certificates.push(forge9.pki.certificateFromAsn1(certs[i2]));
            }
          }
        },
        toAsn1: function() {
          if (!msg.contentInfo) {
            msg.sign();
          }
          var certs = [];
          for (var i2 = 0; i2 < msg.certificates.length; ++i2) {
            certs.push(forge9.pki.certificateToAsn1(msg.certificates[i2]));
          }
          var crls = [];
          var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // Version
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(msg.version).getBytes()
              ),
              // DigestAlgorithmIdentifiers
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.SET,
                true,
                msg.digestAlgorithmIdentifiers
              ),
              // ContentInfo
              msg.contentInfo
            ])
          ]);
          if (certs.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs)
            );
          }
          if (crls.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls)
            );
          }
          signedData.value[0].value.push(
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              msg.signerInfos
            )
          );
          return asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SEQUENCE,
            true,
            [
              // ContentType
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(msg.type).getBytes()
              ),
              // [0] SignedData
              signedData
            ]
          );
        },
        /**
         * Add (another) entity to list of signers.
         *
         * Note: If authenticatedAttributes are provided, then, per RFC 2315,
         * they must include at least two attributes: content type and
         * message digest. The message digest attribute value will be
         * auto-calculated during signing and will be ignored if provided.
         *
         * Here's an example of providing these two attributes:
         *
         * forge.pkcs7.createSignedData();
         * p7.addSigner({
         *   issuer: cert.issuer.attributes,
         *   serialNumber: cert.serialNumber,
         *   key: privateKey,
         *   digestAlgorithm: forge.pki.oids.sha1,
         *   authenticatedAttributes: [{
         *     type: forge.pki.oids.contentType,
         *     value: forge.pki.oids.data
         *   }, {
         *     type: forge.pki.oids.messageDigest
         *   }]
         * });
         *
         * TODO: Support [subjectKeyIdentifier] as signer's ID.
         *
         * @param signer the signer information:
         *          key the signer's private key.
         *          [certificate] a certificate containing the public key
         *            associated with the signer's private key; use this option as
         *            an alternative to specifying signer.issuer and
         *            signer.serialNumber.
         *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
         *          [serialNumber] the signer's certificate's serial number in
         *           hexadecimal (eg: cert.serialNumber).
         *          [digestAlgorithm] the message digest OID, as a string, to use
         *            (eg: forge.pki.oids.sha1).
         *          [authenticatedAttributes] an optional array of attributes
         *            to also sign along with the content.
         */
        addSigner: function(signer) {
          var issuer = signer.issuer;
          var serialNumber = signer.serialNumber;
          if (signer.certificate) {
            var cert = signer.certificate;
            if (typeof cert === "string") {
              cert = forge9.pki.certificateFromPem(cert);
            }
            issuer = cert.issuer.attributes;
            serialNumber = cert.serialNumber;
          }
          var key = signer.key;
          if (!key) {
            throw new Error(
              "Could not add PKCS#7 signer; no private key specified."
            );
          }
          if (typeof key === "string") {
            key = forge9.pki.privateKeyFromPem(key);
          }
          var digestAlgorithm = signer.digestAlgorithm || forge9.pki.oids.sha1;
          switch (digestAlgorithm) {
            case forge9.pki.oids.sha1:
            case forge9.pki.oids.sha256:
            case forge9.pki.oids.sha384:
            case forge9.pki.oids.sha512:
            case forge9.pki.oids.md5:
              break;
            default:
              throw new Error(
                "Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm
              );
          }
          var authenticatedAttributes = signer.authenticatedAttributes || [];
          if (authenticatedAttributes.length > 0) {
            var contentType = false;
            var messageDigest = false;
            for (var i2 = 0; i2 < authenticatedAttributes.length; ++i2) {
              var attr = authenticatedAttributes[i2];
              if (!contentType && attr.type === forge9.pki.oids.contentType) {
                contentType = true;
                if (messageDigest) {
                  break;
                }
                continue;
              }
              if (!messageDigest && attr.type === forge9.pki.oids.messageDigest) {
                messageDigest = true;
                if (contentType) {
                  break;
                }
                continue;
              }
            }
            if (!contentType || !messageDigest) {
              throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
            }
          }
          msg.signers.push({
            key,
            version: 1,
            issuer,
            serialNumber,
            digestAlgorithm,
            signatureAlgorithm: forge9.pki.oids.rsaEncryption,
            signature: null,
            authenticatedAttributes,
            unauthenticatedAttributes: []
          });
        },
        /**
         * Signs the content.
         * @param options Options to apply when signing:
         *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
         */
        sign: function(options) {
          options = options || {};
          if (typeof msg.content !== "object" || msg.contentInfo === null) {
            msg.contentInfo = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              [
                // ContentType
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(forge9.pki.oids.data).getBytes()
                )
              ]
            );
            if ("content" in msg) {
              var content;
              if (msg.content instanceof forge9.util.ByteBuffer) {
                content = msg.content.bytes();
              } else if (typeof msg.content === "string") {
                content = forge9.util.encodeUtf8(msg.content);
              }
              if (options.detached) {
                msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
              } else {
                msg.contentInfo.value.push(
                  // [0] EXPLICIT content
                  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.OCTETSTRING,
                      false,
                      content
                    )
                  ])
                );
              }
            }
          }
          if (msg.signers.length === 0) {
            return;
          }
          var mds = addDigestAlgorithmIds();
          addSignerInfos(mds);
        },
        verify: function() {
          throw new Error("PKCS#7 signature verification not yet implemented.");
        },
        /**
         * Add a certificate.
         *
         * @param cert the certificate to add.
         */
        addCertificate: function(cert) {
          if (typeof cert === "string") {
            cert = forge9.pki.certificateFromPem(cert);
          }
          msg.certificates.push(cert);
        },
        /**
         * Add a certificate revokation list.
         *
         * @param crl the certificate revokation list to add.
         */
        addCertificateRevokationList: function(crl) {
          throw new Error("PKCS#7 CRL support not yet implemented.");
        }
      };
      return msg;
      function addDigestAlgorithmIds() {
        var mds = {};
        for (var i2 = 0; i2 < msg.signers.length; ++i2) {
          var signer = msg.signers[i2];
          var oid = signer.digestAlgorithm;
          if (!(oid in mds)) {
            mds[oid] = forge9.md[forge9.pki.oids[oid]].create();
          }
          if (signer.authenticatedAttributes.length === 0) {
            signer.md = mds[oid];
          } else {
            signer.md = forge9.md[forge9.pki.oids[oid]].create();
          }
        }
        msg.digestAlgorithmIdentifiers = [];
        for (var oid in mds) {
          msg.digestAlgorithmIdentifiers.push(
            // AlgorithmIdentifier
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(oid).getBytes()
              ),
              // parameters (null)
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ])
          );
        }
        return mds;
      }
      function addSignerInfos(mds) {
        var content;
        if (msg.detachedContent) {
          content = msg.detachedContent;
        } else {
          content = msg.contentInfo.value[1];
          content = content.value[0];
        }
        if (!content) {
          throw new Error(
            "Could not sign PKCS#7 message; there is no content to sign."
          );
        }
        var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
        var bytes2 = asn1.toDer(content);
        bytes2.getByte();
        asn1.getBerValueLength(bytes2);
        bytes2 = bytes2.getBytes();
        for (var oid in mds) {
          mds[oid].start().update(bytes2);
        }
        var signingTime = new Date();
        for (var i2 = 0; i2 < msg.signers.length; ++i2) {
          var signer = msg.signers[i2];
          if (signer.authenticatedAttributes.length === 0) {
            if (contentType !== forge9.pki.oids.data) {
              throw new Error(
                "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
              );
            }
          } else {
            signer.authenticatedAttributesAsn1 = asn1.create(
              asn1.Class.CONTEXT_SPECIFIC,
              0,
              true,
              []
            );
            var attrsAsn1 = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              []
            );
            for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
              var attr = signer.authenticatedAttributes[ai];
              if (attr.type === forge9.pki.oids.messageDigest) {
                attr.value = mds[signer.digestAlgorithm].digest();
              } else if (attr.type === forge9.pki.oids.signingTime) {
                if (!attr.value) {
                  attr.value = signingTime;
                }
              }
              attrsAsn1.value.push(_attributeToAsn1(attr));
              signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
            }
            bytes2 = asn1.toDer(attrsAsn1).getBytes();
            signer.md.start().update(bytes2);
          }
          signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
        }
        msg.signerInfos = _signersToAsn1(msg.signers);
      }
    };
    p7.createEncryptedData = function() {
      var msg = null;
      msg = {
        type: forge9.pki.oids.encryptedData,
        version: 0,
        encryptedContent: {
          algorithm: forge9.pki.oids["aes256-CBC"]
        },
        /**
         * Reads an EncryptedData content block (in ASN.1 format)
         *
         * @param obj The ASN.1 representation of the EncryptedData content block
         */
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
        },
        /**
         * Decrypt encrypted content
         *
         * @param key The (symmetric) key as a byte buffer
         */
        decrypt: function(key) {
          if (key !== void 0) {
            msg.encryptedContent.key = key;
          }
          _decryptContent(msg);
        }
      };
      return msg;
    };
    p7.createEnvelopedData = function() {
      var msg = null;
      msg = {
        type: forge9.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: {
          algorithm: forge9.pki.oids["aes256-CBC"]
        },
        /**
         * Reads an EnvelopedData content block (in ASN.1 format)
         *
         * @param obj the ASN.1 representation of the EnvelopedData content block.
         */
        fromAsn1: function(obj) {
          var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
          msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
        },
        toAsn1: function() {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // ContentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(msg.type).getBytes()
            ),
            // [0] EnvelopedData
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                // Version
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.INTEGER,
                  false,
                  asn1.integerToDer(msg.version).getBytes()
                ),
                // RecipientInfos
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SET,
                  true,
                  _recipientsToAsn1(msg.recipients)
                ),
                // EncryptedContentInfo
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SEQUENCE,
                  true,
                  _encryptedContentToAsn1(msg.encryptedContent)
                )
              ])
            ])
          ]);
        },
        /**
         * Find recipient by X.509 certificate's issuer.
         *
         * @param cert the certificate with the issuer to look for.
         *
         * @return the recipient object.
         */
        findRecipient: function(cert) {
          var sAttr = cert.issuer.attributes;
          for (var i2 = 0; i2 < msg.recipients.length; ++i2) {
            var r = msg.recipients[i2];
            var rAttr = r.issuer;
            if (r.serialNumber !== cert.serialNumber) {
              continue;
            }
            if (rAttr.length !== sAttr.length) {
              continue;
            }
            var match = true;
            for (var j = 0; j < sAttr.length; ++j) {
              if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
                match = false;
                break;
              }
            }
            if (match) {
              return r;
            }
          }
          return null;
        },
        /**
         * Decrypt enveloped content
         *
         * @param recipient The recipient object related to the private key
         * @param privKey The (RSA) private key object
         */
        decrypt: function(recipient, privKey) {
          if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
            switch (recipient.encryptedContent.algorithm) {
              case forge9.pki.oids.rsaEncryption:
              case forge9.pki.oids.desCBC:
                var key = privKey.decrypt(recipient.encryptedContent.content);
                msg.encryptedContent.key = forge9.util.createBuffer(key);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
          _decryptContent(msg);
        },
        /**
         * Add (another) entity to list of recipients.
         *
         * @param cert The certificate of the entity to add.
         */
        addRecipient: function(cert) {
          msg.recipients.push({
            version: 0,
            issuer: cert.issuer.attributes,
            serialNumber: cert.serialNumber,
            encryptedContent: {
              // We simply assume rsaEncryption here, since forge.pki only
              // supports RSA so far.  If the PKI module supports other
              // ciphers one day, we need to modify this one as well.
              algorithm: forge9.pki.oids.rsaEncryption,
              key: cert.publicKey
            }
          });
        },
        /**
         * Encrypt enveloped content.
         *
         * This function supports two optional arguments, cipher and key, which
         * can be used to influence symmetric encryption.  Unless cipher is
         * provided, the cipher specified in encryptedContent.algorithm is used
         * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
         * is (re-)used.  If that one's not set, a random key will be generated
         * automatically.
         *
         * @param [key] The key to be used for symmetric encryption.
         * @param [cipher] The OID of the symmetric cipher to use.
         */
        encrypt: function(key, cipher) {
          if (msg.encryptedContent.content === void 0) {
            cipher = cipher || msg.encryptedContent.algorithm;
            key = key || msg.encryptedContent.key;
            var keyLen, ivLen, ciphFn;
            switch (cipher) {
              case forge9.pki.oids["aes128-CBC"]:
                keyLen = 16;
                ivLen = 16;
                ciphFn = forge9.aes.createEncryptionCipher;
                break;
              case forge9.pki.oids["aes192-CBC"]:
                keyLen = 24;
                ivLen = 16;
                ciphFn = forge9.aes.createEncryptionCipher;
                break;
              case forge9.pki.oids["aes256-CBC"]:
                keyLen = 32;
                ivLen = 16;
                ciphFn = forge9.aes.createEncryptionCipher;
                break;
              case forge9.pki.oids["des-EDE3-CBC"]:
                keyLen = 24;
                ivLen = 8;
                ciphFn = forge9.des.createEncryptionCipher;
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + cipher);
            }
            if (key === void 0) {
              key = forge9.util.createBuffer(forge9.random.getBytes(keyLen));
            } else if (key.length() != keyLen) {
              throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
            }
            msg.encryptedContent.algorithm = cipher;
            msg.encryptedContent.key = key;
            msg.encryptedContent.parameter = forge9.util.createBuffer(
              forge9.random.getBytes(ivLen)
            );
            var ciph = ciphFn(key);
            ciph.start(msg.encryptedContent.parameter.copy());
            ciph.update(msg.content);
            if (!ciph.finish()) {
              throw new Error("Symmetric encryption failed.");
            }
            msg.encryptedContent.content = ciph.output;
          }
          for (var i2 = 0; i2 < msg.recipients.length; ++i2) {
            var recipient = msg.recipients[i2];
            if (recipient.encryptedContent.content !== void 0) {
              continue;
            }
            switch (recipient.encryptedContent.algorithm) {
              case forge9.pki.oids.rsaEncryption:
                recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(
                  msg.encryptedContent.key.data
                );
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
        }
      };
      return msg;
    };
    function _recipientFromAsn1(obj) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors2)) {
        var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
        error.errors = errors2;
        throw error;
      }
      return {
        version: capture.version.charCodeAt(0),
        issuer: forge9.pki.RDNAttributesAsArray(capture.issuer),
        serialNumber: forge9.util.createBuffer(capture.serial).toHex(),
        encryptedContent: {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: capture.encParameter ? capture.encParameter.value : void 0,
          content: capture.encKey
        }
      };
    }
    function _recipientToAsn1(obj) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // Version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        // IssuerAndSerialNumber
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Name
          forge9.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          // Serial
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge9.util.hexToBytes(obj.serialNumber)
          )
        ]),
        // KeyEncryptionAlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()
          ),
          // Parameter, force NULL, only RSA supported for now.
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // EncryptedKey
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          obj.encryptedContent.content
        )
      ]);
    }
    function _recipientsFromAsn1(infos) {
      var ret = [];
      for (var i2 = 0; i2 < infos.length; ++i2) {
        ret.push(_recipientFromAsn1(infos[i2]));
      }
      return ret;
    }
    function _recipientsToAsn1(recipients) {
      var ret = [];
      for (var i2 = 0; i2 < recipients.length; ++i2) {
        ret.push(_recipientToAsn1(recipients[i2]));
      }
      return ret;
    }
    function _signerToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        // issuerAndSerialNumber
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // name
          forge9.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          // serial
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge9.util.hexToBytes(obj.serialNumber)
          )
        ]),
        // digestAlgorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.digestAlgorithm).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ])
      ]);
      if (obj.authenticatedAttributesAsn1) {
        rval.value.push(obj.authenticatedAttributesAsn1);
      }
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // algorithm
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(obj.signatureAlgorithm).getBytes()
        ),
        // parameters (null)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]));
      rval.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        obj.signature
      ));
      if (obj.unauthenticatedAttributes.length > 0) {
        var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
        for (var i2 = 0; i2 < obj.unauthenticatedAttributes.length; ++i2) {
          var attr = obj.unauthenticatedAttributes[i2];
          attrsAsn1.values.push(_attributeToAsn1(attr));
        }
        rval.value.push(attrsAsn1);
      }
      return rval;
    }
    function _signersToAsn1(signers) {
      var ret = [];
      for (var i2 = 0; i2 < signers.length; ++i2) {
        ret.push(_signerToAsn1(signers[i2]));
      }
      return ret;
    }
    function _attributeToAsn1(attr) {
      var value2;
      if (attr.type === forge9.pki.oids.contentType) {
        value2 = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.value).getBytes()
        );
      } else if (attr.type === forge9.pki.oids.messageDigest) {
        value2 = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          attr.value.bytes()
        );
      } else if (attr.type === forge9.pki.oids.signingTime) {
        var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
        var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
        var date = attr.value;
        if (typeof date === "string") {
          var timestamp = Date.parse(date);
          if (!isNaN(timestamp)) {
            date = new Date(timestamp);
          } else if (date.length === 13) {
            date = asn1.utcTimeToDate(date);
          } else {
            date = asn1.generalizedTimeToDate(date);
          }
        }
        if (date >= jan_1_1950 && date < jan_1_2050) {
          value2 = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.UTCTIME,
            false,
            asn1.dateToUtcTime(date)
          );
        } else {
          value2 = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.GENERALIZEDTIME,
            false,
            asn1.dateToGeneralizedTime(date)
          );
        }
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AttributeType
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.type).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          // AttributeValue
          value2
        ])
      ]);
    }
    function _encryptedContentToAsn1(ec) {
      return [
        // ContentType, always Data for the moment
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(forge9.pki.oids.data).getBytes()
        ),
        // ContentEncryptionAlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(ec.algorithm).getBytes()
          ),
          // Parameters (IV)
          !ec.parameter ? void 0 : asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec.parameter.getBytes()
          )
        ]),
        // [0] EncryptedContent
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec.content.getBytes()
          )
        ])
      ];
    }
    function _fromAsn1(msg, obj, validator) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, validator, capture, errors2)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
        error.errors = error;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      if (contentType !== forge9.pki.oids.data) {
        throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
      }
      if (capture.encryptedContent) {
        var content = "";
        if (forge9.util.isArray(capture.encryptedContent)) {
          for (var i2 = 0; i2 < capture.encryptedContent.length; ++i2) {
            if (capture.encryptedContent[i2].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
            }
            content += capture.encryptedContent[i2].value;
          }
        } else {
          content = capture.encryptedContent;
        }
        msg.encryptedContent = {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: forge9.util.createBuffer(capture.encParameter.value),
          content: forge9.util.createBuffer(content)
        };
      }
      if (capture.content) {
        var content = "";
        if (forge9.util.isArray(capture.content)) {
          for (var i2 = 0; i2 < capture.content.length; ++i2) {
            if (capture.content[i2].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
            }
            content += capture.content[i2].value;
          }
        } else {
          content = capture.content;
        }
        msg.content = forge9.util.createBuffer(content);
      }
      msg.version = capture.version.charCodeAt(0);
      msg.rawCapture = capture;
      return capture;
    }
    function _decryptContent(msg) {
      if (msg.encryptedContent.key === void 0) {
        throw new Error("Symmetric key not available.");
      }
      if (msg.content === void 0) {
        var ciph;
        switch (msg.encryptedContent.algorithm) {
          case forge9.pki.oids["aes128-CBC"]:
          case forge9.pki.oids["aes192-CBC"]:
          case forge9.pki.oids["aes256-CBC"]:
            ciph = forge9.aes.createDecryptionCipher(msg.encryptedContent.key);
            break;
          case forge9.pki.oids["desCBC"]:
          case forge9.pki.oids["des-EDE3-CBC"]:
            ciph = forge9.des.createDecryptionCipher(msg.encryptedContent.key);
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
        }
        ciph.start(msg.encryptedContent.parameter);
        ciph.update(msg.encryptedContent.content);
        if (!ciph.finish()) {
          throw new Error("Symmetric decryption failed.");
        }
        msg.content = ciph.output;
      }
    }
  }
});
var require_receptacle = __commonJS({
  "node_modules/receptacle/index.js"(exports2, module2) {
    module2.exports = Receptacle2;
    var toMS = require_ms();
    var cache4 = Receptacle2.prototype;
    var counter = new Date() % 1e9;
    function getUID() {
      return (Math.random() * 1e9 >>> 0) + counter++;
    }
    function Receptacle2(options) {
      options = options || {};
      this.id = options.id || getUID();
      this.max = options.max || Infinity;
      this.items = options.items || [];
      this._lookup = {};
      this.size = this.items.length;
      this.lastModified = new Date(options.lastModified || new Date());
      for (var item, ttl2, i2 = this.items.length; i2--; ) {
        item = this.items[i2];
        ttl2 = new Date(item.expires) - new Date();
        this._lookup[item.key] = item;
        if (ttl2 > 0)
          this.expire(item.key, ttl2);
        else if (ttl2 <= 0)
          this.delete(item.key);
      }
    }
    cache4.has = function(key) {
      return key in this._lookup;
    };
    cache4.get = function(key) {
      if (!this.has(key))
        return null;
      var record = this._lookup[key];
      if (record.refresh)
        this.expire(key, record.refresh);
      this.items.splice(this.items.indexOf(record), 1);
      this.items.push(record);
      return record.value;
    };
    cache4.meta = function(key) {
      if (!this.has(key))
        return null;
      var record = this._lookup[key];
      if (!("meta" in record))
        return null;
      return record.meta;
    };
    cache4.set = function(key, value2, options) {
      var oldRecord = this._lookup[key];
      var record = this._lookup[key] = { key, value: value2 };
      this.lastModified = new Date();
      if (oldRecord) {
        clearTimeout(oldRecord.timeout);
        this.items.splice(this.items.indexOf(oldRecord), 1, record);
      } else {
        if (this.size >= this.max)
          this.delete(this.items[0].key);
        this.items.push(record);
        this.size++;
      }
      if (options) {
        if ("ttl" in options)
          this.expire(key, options.ttl);
        if ("meta" in options)
          record.meta = options.meta;
        if (options.refresh)
          record.refresh = options.ttl;
      }
      return this;
    };
    cache4.delete = function(key) {
      var record = this._lookup[key];
      if (!record)
        return false;
      this.lastModified = new Date();
      this.items.splice(this.items.indexOf(record), 1);
      clearTimeout(record.timeout);
      delete this._lookup[key];
      this.size--;
      return this;
    };
    cache4.expire = function(key, ttl2) {
      var ms = ttl2 || 0;
      var record = this._lookup[key];
      if (!record)
        return this;
      if (typeof ms === "string")
        ms = toMS(ttl2);
      if (typeof ms !== "number")
        throw new TypeError("Expiration time must be a string or number.");
      clearTimeout(record.timeout);
      record.timeout = setTimeout(this.delete.bind(this, record.key), ms);
      record.expires = Number(new Date()) + ms;
      return this;
    };
    cache4.clear = function() {
      for (var i2 = this.items.length; i2--; )
        this.delete(this.items[i2].key);
      return this;
    };
    cache4.toJSON = function() {
      var items = new Array(this.items.length);
      var item;
      for (var i2 = items.length; i2--; ) {
        item = this.items[i2];
        items[i2] = {
          key: item.key,
          meta: item.meta,
          value: item.value,
          expires: item.expires,
          refresh: item.refresh
        };
      }
      return {
        id: this.id,
        max: isFinite(this.max) ? this.max : void 0,
        lastModified: this.lastModified,
        items
      };
    };
  }
});
var require_fixed_size = __commonJS({
  "node_modules/fast-fifo/fixed-size.js"(exports2, module2) {
    module2.exports = class FixedFIFO {
      constructor(hwm) {
        if (!(hwm > 0) || (hwm - 1 & hwm) !== 0)
          throw new Error("Max size for a FixedFIFO should be a power of two");
        this.buffer = new Array(hwm);
        this.mask = hwm - 1;
        this.top = 0;
        this.btm = 0;
        this.next = null;
      }
      push(data) {
        if (this.buffer[this.top] !== void 0)
          return false;
        this.buffer[this.top] = data;
        this.top = this.top + 1 & this.mask;
        return true;
      }
      shift() {
        const last2 = this.buffer[this.btm];
        if (last2 === void 0)
          return void 0;
        this.buffer[this.btm] = void 0;
        this.btm = this.btm + 1 & this.mask;
        return last2;
      }
      peek() {
        return this.buffer[this.btm];
      }
      isEmpty() {
        return this.buffer[this.btm] === void 0;
      }
    };
  }
});
var require_fast_fifo = __commonJS({
  "node_modules/fast-fifo/index.js"(exports2, module2) {
    var FixedFIFO2 = require_fixed_size();
    module2.exports = class FastFIFO {
      constructor(hwm) {
        this.hwm = hwm || 16;
        this.head = new FixedFIFO2(this.hwm);
        this.tail = this.head;
      }
      push(val) {
        if (!this.head.push(val)) {
          const prev2 = this.head;
          this.head = prev2.next = new FixedFIFO2(2 * this.head.buffer.length);
          this.head.push(val);
        }
      }
      shift() {
        const val = this.tail.shift();
        if (val === void 0 && this.tail.next) {
          const next = this.tail.next;
          this.tail.next = null;
          this.tail = next;
          return this.tail.shift();
        }
        return val;
      }
      peek() {
        return this.tail.peek();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
    };
  }
});
var require_p_defer = __commonJS({
  "node_modules/p-fifo/node_modules/p-defer/index.js"(exports2, module2) {
    var pDefer2 = () => {
      const deferred = {};
      deferred.promise = new Promise((resolve7, reject) => {
        deferred.resolve = resolve7;
        deferred.reject = reject;
      });
      return deferred;
    };
    module2.exports = pDefer2;
  }
});
var require_p_fifo = __commonJS({
  "node_modules/p-fifo/index.js"(exports2, module2) {
    var Fifo = require_fast_fifo();
    var defer = require_p_defer();
    module2.exports = class PFifo {
      constructor() {
        this._buffer = new Fifo();
        this._waitingConsumers = new Fifo();
      }
      push(chunk) {
        const { promise, resolve: resolve7 } = defer();
        this._buffer.push({ chunk, resolve: resolve7 });
        this._consume();
        return promise;
      }
      _consume() {
        while (!this._waitingConsumers.isEmpty() && !this._buffer.isEmpty()) {
          const nextConsumer = this._waitingConsumers.shift();
          const nextChunk = this._buffer.shift();
          nextConsumer.resolve(nextChunk.chunk);
          nextChunk.resolve();
        }
      }
      shift() {
        const { promise, resolve: resolve7 } = defer();
        this._waitingConsumers.push({ resolve: resolve7 });
        this._consume();
        return promise;
      }
      isEmpty() {
        return this._buffer.isEmpty();
      }
    };
  }
});
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer2 = require_buffer();
    var Buffer2 = buffer2.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length3) {
      return Buffer2(arg, encodingOrOffset, length3);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length3) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length3);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf2 = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf2.fill(fill, encoding);
        } else {
          buf2.fill(fill);
        }
      } else {
        buf2.fill(0);
      }
      return buf2;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  }
});
var require_browser6 = __commonJS({
  "node_modules/randombytes/browser.js"(exports2, module2) {
    var MAX_BYTES = 65536;
    var MAX_UINT32 = 4294967295;
    function oldBrowser() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto4 = globalThis.crypto || globalThis.msCrypto;
    if (crypto4 && crypto4.getRandomValues) {
      module2.exports = randomBytes3;
    } else {
      module2.exports = oldBrowser;
    }
    function randomBytes3(size, cb) {
      if (size > MAX_UINT32)
        throw new RangeError("requested too many random bytes");
      var bytes2 = Buffer2.allocUnsafe(size);
      if (size > 0) {
        if (size > MAX_BYTES) {
          for (var generated = 0; generated < size; generated += MAX_BYTES) {
            crypto4.getRandomValues(bytes2.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto4.getRandomValues(bytes2);
        }
      }
      if (typeof cb === "function") {
        return process.nextTick(function() {
          cb(null, bytes2);
        });
      }
      return bytes2;
    }
  }
});
var require_k_bucket = __commonJS({
  "node_modules/k-bucket/index.js"(exports2, module2) {
    var randomBytes3 = require_browser6();
    var { EventEmitter: EventEmitter6 } = require_events();
    function arrayEquals2(array1, array2) {
      if (array1 === array2) {
        return true;
      }
      if (array1.length !== array2.length) {
        return false;
      }
      for (let i2 = 0, length3 = array1.length; i2 < length3; ++i2) {
        if (array1[i2] !== array2[i2]) {
          return false;
        }
      }
      return true;
    }
    function createNode3() {
      return { contacts: [], dontSplit: false, left: null, right: null };
    }
    function ensureInt8(name9, val) {
      if (!(val instanceof Uint8Array)) {
        throw new TypeError(name9 + " is not a Uint8Array");
      }
    }
    var KBucket = class extends EventEmitter6 {
      /**
       * `options`:
       *   `distance`: _Function_
       *     `function (firstId, secondId) { return distance }` An optional
       *     `distance` function that gets two `id` Uint8Arrays
       *     and return distance (as number) between them.
       *   `arbiter`: _Function_ _(Default: vectorClock arbiter)_
       *     `function (incumbent, candidate) { return contact; }` An optional
       *     `arbiter` function that givent two `contact` objects with the same `id`
       *     returns the desired object to be used for updating the k-bucket. For
       *     more details, see [arbiter function](#arbiter-function).
       *   `localNodeId`: _Uint8Array_ An optional Uint8Array representing the local node id.
       *     If not provided, a local node id will be created via `randomBytes(20)`.
       *     `metadata`: _Object_ _(Default: {})_ Optional satellite data to include
       *     with the k-bucket. `metadata` property is guaranteed not be altered by,
       *     it is provided as an explicit container for users of k-bucket to store
       *     implementation-specific data.
       *   `numberOfNodesPerKBucket`: _Integer_ _(Default: 20)_ The number of nodes
       *     that a k-bucket can contain before being full or split.
       *     `numberOfNodesToPing`: _Integer_ _(Default: 3)_ The number of nodes to
       *     ping when a bucket that should not be split becomes full. KBucket will
       *     emit a `ping` event that contains `numberOfNodesToPing` nodes that have
       *     not been contacted the longest.
       *
       * @param {Object=} options optional
       */
      constructor(options = {}) {
        super();
        this.localNodeId = options.localNodeId || randomBytes3(20);
        this.numberOfNodesPerKBucket = options.numberOfNodesPerKBucket || 20;
        this.numberOfNodesToPing = options.numberOfNodesToPing || 3;
        this.distance = options.distance || KBucket.distance;
        this.arbiter = options.arbiter || KBucket.arbiter;
        this.metadata = Object.assign({}, options.metadata);
        ensureInt8("option.localNodeId as parameter 1", this.localNodeId);
        this.root = createNode3();
      }
      /**
       * Default arbiter function for contacts with the same id. Uses
       * contact.vectorClock to select which contact to update the k-bucket with.
       * Contact with larger vectorClock field will be selected. If vectorClock is
       * the same, candidat will be selected.
       *
       * @param  {Object} incumbent Contact currently stored in the k-bucket.
       * @param  {Object} candidate Contact being added to the k-bucket.
       * @return {Object}           Contact to updated the k-bucket with.
       */
      static arbiter(incumbent, candidate) {
        return incumbent.vectorClock > candidate.vectorClock ? incumbent : candidate;
      }
      /**
       * Default distance function. Finds the XOR
       * distance between firstId and secondId.
       *
       * @param  {Uint8Array} firstId  Uint8Array containing first id.
       * @param  {Uint8Array} secondId Uint8Array containing second id.
       * @return {Number}              Integer The XOR distance between firstId
       *                               and secondId.
       */
      static distance(firstId, secondId) {
        let distance = 0;
        let i2 = 0;
        const min = Math.min(firstId.length, secondId.length);
        const max = Math.max(firstId.length, secondId.length);
        for (; i2 < min; ++i2) {
          distance = distance * 256 + (firstId[i2] ^ secondId[i2]);
        }
        for (; i2 < max; ++i2)
          distance = distance * 256 + 255;
        return distance;
      }
      /**
       * Adds a contact to the k-bucket.
       *
       * @param {Object} contact the contact object to add
       */
      add(contact) {
        ensureInt8("contact.id", (contact || {}).id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, contact.id, bitIndex++);
        }
        const index2 = this._indexOf(node, contact.id);
        if (index2 >= 0) {
          this._update(node, index2, contact);
          return this;
        }
        if (node.contacts.length < this.numberOfNodesPerKBucket) {
          node.contacts.push(contact);
          this.emit("added", contact);
          return this;
        }
        if (node.dontSplit) {
          this.emit("ping", node.contacts.slice(0, this.numberOfNodesToPing), contact);
          return this;
        }
        this._split(node, bitIndex);
        return this.add(contact);
      }
      /**
       * Get the n closest contacts to the provided node id. "Closest" here means:
       * closest according to the XOR metric of the contact node id.
       *
       * @param  {Uint8Array} id  Contact node id
       * @param  {Number=} n      Integer (Default: Infinity) The maximum number of
       *                          closest contacts to return
       * @return {Array}          Array Maximum of n closest contacts to the node id
       */
      closest(id, n = Infinity) {
        ensureInt8("id", id);
        if (!Number.isInteger(n) && n !== Infinity || n <= 0) {
          throw new TypeError("n is not positive number");
        }
        let contacts = [];
        for (let nodes = [this.root], bitIndex = 0; nodes.length > 0 && contacts.length < n; ) {
          const node = nodes.pop();
          if (node.contacts === null) {
            const detNode = this._determineNode(node, id, bitIndex++);
            nodes.push(node.left === detNode ? node.right : node.left);
            nodes.push(detNode);
          } else {
            contacts = contacts.concat(node.contacts);
          }
        }
        return contacts.map((a) => [this.distance(a.id, id), a]).sort((a, b) => a[0] - b[0]).slice(0, n).map((a) => a[1]);
      }
      /**
       * Counts the total number of contacts in the tree.
       *
       * @return {Number} The number of contacts held in the tree
       */
      count() {
        let count = 0;
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null)
            nodes.push(node.right, node.left);
          else
            count += node.contacts.length;
        }
        return count;
      }
      /**
       * Determines whether the id at the bitIndex is 0 or 1.
       * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise
       *
       * @param  {Object} node     internal object that has 2 leafs: left and right
       * @param  {Uint8Array} id   Id to compare localNodeId with.
       * @param  {Number} bitIndex Integer (Default: 0) The bit index to which bit
       *                           to check in the id Uint8Array.
       * @return {Object}          left leaf if id at bitIndex is 0, right leaf otherwise.
       */
      _determineNode(node, id, bitIndex) {
        const bytesDescribedByBitIndex = bitIndex >> 3;
        const bitIndexWithinByte = bitIndex % 8;
        if (id.length <= bytesDescribedByBitIndex && bitIndexWithinByte !== 0) {
          return node.left;
        }
        const byteUnderConsideration = id[bytesDescribedByBitIndex];
        if (byteUnderConsideration & 1 << 7 - bitIndexWithinByte) {
          return node.right;
        }
        return node.left;
      }
      /**
       * Get a contact by its exact ID.
       * If this is a leaf, loop through the bucket contents and return the correct
       * contact if we have it or null if not. If this is an inner node, determine
       * which branch of the tree to traverse and repeat.
       *
       * @param  {Uint8Array} id The ID of the contact to fetch.
       * @return {Object|Null}   The contact if available, otherwise null
       */
      get(id) {
        ensureInt8("id", id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, id, bitIndex++);
        }
        const index2 = this._indexOf(node, id);
        return index2 >= 0 ? node.contacts[index2] : null;
      }
      /**
       * Returns the index of the contact with provided
       * id if it exists, returns -1 otherwise.
       *
       * @param  {Object} node    internal object that has 2 leafs: left and right
       * @param  {Uint8Array} id  Contact node id.
       * @return {Number}         Integer Index of contact with provided id if it
       *                          exists, -1 otherwise.
       */
      _indexOf(node, id) {
        for (let i2 = 0; i2 < node.contacts.length; ++i2) {
          if (arrayEquals2(node.contacts[i2].id, id))
            return i2;
        }
        return -1;
      }
      /**
       * Removes contact with the provided id.
       *
       * @param  {Uint8Array} id The ID of the contact to remove.
       * @return {Object}        The k-bucket itself.
       */
      remove(id) {
        ensureInt8("the id as parameter 1", id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, id, bitIndex++);
        }
        const index2 = this._indexOf(node, id);
        if (index2 >= 0) {
          const contact = node.contacts.splice(index2, 1)[0];
          this.emit("removed", contact);
        }
        return this;
      }
      /**
       * Splits the node, redistributes contacts to the new nodes, and marks the
       * node that was split as an inner node of the binary tree of nodes by
       * setting this.root.contacts = null
       *
       * @param  {Object} node     node for splitting
       * @param  {Number} bitIndex the bitIndex to which byte to check in the
       *                           Uint8Array for navigating the binary tree
       */
      _split(node, bitIndex) {
        node.left = createNode3();
        node.right = createNode3();
        for (const contact of node.contacts) {
          this._determineNode(node, contact.id, bitIndex).contacts.push(contact);
        }
        node.contacts = null;
        const detNode = this._determineNode(node, this.localNodeId, bitIndex);
        const otherNode = node.left === detNode ? node.right : node.left;
        otherNode.dontSplit = true;
      }
      /**
       * Returns all the contacts contained in the tree as an array.
       * If this is a leaf, return a copy of the bucket. If this is not a leaf,
       * return the union of the low and high branches (themselves also as arrays).
       *
       * @return {Array} All of the contacts in the tree, as an array
       */
      toArray() {
        let result = [];
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null)
            nodes.push(node.right, node.left);
          else
            result = result.concat(node.contacts);
        }
        return result;
      }
      /**
       * Similar to `toArray()` but instead of buffering everything up into an
       * array before returning it, yields contacts as they are encountered while
       * walking the tree.
       *
       * @return {Iterable} All of the contacts in the tree, as an iterable
       */
      *toIterable() {
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null) {
            nodes.push(node.right, node.left);
          } else {
            yield* node.contacts;
          }
        }
      }
      /**
       * Updates the contact selected by the arbiter.
       * If the selection is our old contact and the candidate is some new contact
       * then the new contact is abandoned (not added).
       * If the selection is our old contact and the candidate is our old contact
       * then we are refreshing the contact and it is marked as most recently
       * contacted (by being moved to the right/end of the bucket array).
       * If the selection is our new contact, the old contact is removed and the new
       * contact is marked as most recently contacted.
       *
       * @param  {Object} node    internal object that has 2 leafs: left and right
       * @param  {Number} index   the index in the bucket where contact exists
       *                          (index has already been computed in a previous
       *                          calculation)
       * @param  {Object} contact The contact object to update.
       */
      _update(node, index2, contact) {
        if (!arrayEquals2(node.contacts[index2].id, contact.id)) {
          throw new Error("wrong index for _update");
        }
        const incumbent = node.contacts[index2];
        const selection = this.arbiter(incumbent, contact);
        if (selection === incumbent && incumbent !== contact)
          return;
        node.contacts.splice(index2, 1);
        node.contacts.push(selection);
        this.emit("updated", incumbent, selection);
      }
    };
    module2.exports = KBucket;
  }
});
var require_event_iterator = __commonJS({
  "node_modules/event-iterator/lib/event-iterator.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var EventQueue = class {
      constructor() {
        this.pullQueue = [];
        this.pushQueue = [];
        this.eventHandlers = {};
        this.isPaused = false;
        this.isStopped = false;
      }
      push(value2) {
        if (this.isStopped)
          return;
        const resolution = { value: value2, done: false };
        if (this.pullQueue.length) {
          const placeholder = this.pullQueue.shift();
          if (placeholder)
            placeholder.resolve(resolution);
        } else {
          this.pushQueue.push(Promise.resolve(resolution));
          if (this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
            this.isPaused = true;
            if (this.eventHandlers.highWater) {
              this.eventHandlers.highWater();
            } else if (console) {
              console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
            }
          }
        }
      }
      stop() {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        for (const placeholder of this.pullQueue) {
          placeholder.resolve({ value: void 0, done: true });
        }
        this.pullQueue.length = 0;
      }
      fail(error) {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        if (this.pullQueue.length) {
          for (const placeholder of this.pullQueue) {
            placeholder.reject(error);
          }
          this.pullQueue.length = 0;
        } else {
          const rejection = Promise.reject(error);
          rejection.catch(() => {
          });
          this.pushQueue.push(rejection);
        }
      }
      remove() {
        Promise.resolve().then(() => {
          if (this.removeCallback)
            this.removeCallback();
        });
      }
      [Symbol.asyncIterator]() {
        return {
          next: (value2) => {
            const result = this.pushQueue.shift();
            if (result) {
              if (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
                this.isPaused = false;
                if (this.eventHandlers.lowWater) {
                  this.eventHandlers.lowWater();
                }
              }
              return result;
            } else if (this.isStopped) {
              return Promise.resolve({ value: void 0, done: true });
            } else {
              return new Promise((resolve7, reject) => {
                this.pullQueue.push({ resolve: resolve7, reject });
              });
            }
          },
          return: () => {
            this.isStopped = true;
            this.pushQueue.length = 0;
            this.remove();
            return Promise.resolve({ value: void 0, done: true });
          }
        };
      }
    };
    var EventIterator2 = class {
      constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
        const queue = new EventQueue();
        queue.highWaterMark = highWaterMark;
        queue.lowWaterMark = lowWaterMark;
        queue.removeCallback = listen({
          push: (value2) => queue.push(value2),
          stop: () => queue.stop(),
          fail: (error) => queue.fail(error),
          on: (event, fn) => {
            queue.eventHandlers[event] = fn;
          }
        }) || (() => {
        });
        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
        Object.freeze(this);
      }
    };
    exports2.EventIterator = EventIterator2;
    exports2.default = EventIterator2;
  }
});
var require_dom = __commonJS({
  "node_modules/event-iterator/lib/dom.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var event_iterator_1 = require_event_iterator();
    exports2.EventIterator = event_iterator_1.EventIterator;
    function subscribe(event, options, evOptions) {
      return new event_iterator_1.EventIterator(({ push }) => {
        this.addEventListener(event, push, options);
        return () => this.removeEventListener(event, push, options);
      }, evOptions);
    }
    exports2.subscribe = subscribe;
    exports2.default = event_iterator_1.EventIterator;
  }
});
var require_hash = __commonJS({
  "node_modules/@stablelib/hash/lib/hash.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isSerializableHash(h) {
      return typeof h.saveState !== "undefined" && typeof h.restoreState !== "undefined" && typeof h.cleanSavedState !== "undefined";
    }
    exports2.isSerializableHash = isSerializableHash;
  }
});
var require_constant_time = __commonJS({
  "node_modules/@stablelib/constant-time/lib/constant-time.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    function select2(subject, resultIfOne, resultIfZero) {
      return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
    }
    exports2.select = select2;
    function lessOrEqual(a, b) {
      return (a | 0) - (b | 0) - 1 >>> 31 & 1;
    }
    exports2.lessOrEqual = lessOrEqual;
    function compare3(a, b) {
      if (a.length !== b.length) {
        return 0;
      }
      var result = 0;
      for (var i2 = 0; i2 < a.length; i2++) {
        result |= a[i2] ^ b[i2];
      }
      return 1 & result - 1 >>> 8;
    }
    exports2.compare = compare3;
    function equal(a, b) {
      if (a.length === 0 || b.length === 0) {
        return false;
      }
      return compare3(a, b) !== 0;
    }
    exports2.equal = equal;
  }
});
var require_wipe = __commonJS({
  "node_modules/@stablelib/wipe/lib/wipe.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    function wipe(array) {
      for (var i2 = 0; i2 < array.length; i2++) {
        array[i2] = 0;
      }
      return array;
    }
    exports2.wipe = wipe;
  }
});
var require_hmac2 = __commonJS({
  "node_modules/@stablelib/hmac/lib/hmac.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var hash_1 = require_hash();
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    var HMAC = (
      /** @class */
      function() {
        function HMAC2(hash3, key) {
          this._finished = false;
          this._inner = new hash3();
          this._outer = new hash3();
          this.blockSize = this._outer.blockSize;
          this.digestLength = this._outer.digestLength;
          var pad = new Uint8Array(this.blockSize);
          if (key.length > this.blockSize) {
            this._inner.update(key).finish(pad).clean();
          } else {
            pad.set(key);
          }
          for (var i2 = 0; i2 < pad.length; i2++) {
            pad[i2] ^= 54;
          }
          this._inner.update(pad);
          for (var i2 = 0; i2 < pad.length; i2++) {
            pad[i2] ^= 54 ^ 92;
          }
          this._outer.update(pad);
          if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
            this._innerKeyedState = this._inner.saveState();
            this._outerKeyedState = this._outer.saveState();
          }
          wipe_1.wipe(pad);
        }
        HMAC2.prototype.reset = function() {
          if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
          }
          this._inner.restoreState(this._innerKeyedState);
          this._outer.restoreState(this._outerKeyedState);
          this._finished = false;
          return this;
        };
        HMAC2.prototype.clean = function() {
          if (hash_1.isSerializableHash(this._inner)) {
            this._inner.cleanSavedState(this._innerKeyedState);
          }
          if (hash_1.isSerializableHash(this._outer)) {
            this._outer.cleanSavedState(this._outerKeyedState);
          }
          this._inner.clean();
          this._outer.clean();
        };
        HMAC2.prototype.update = function(data) {
          this._inner.update(data);
          return this;
        };
        HMAC2.prototype.finish = function(out) {
          if (this._finished) {
            this._outer.finish(out);
            return this;
          }
          this._inner.finish(out);
          this._outer.update(out.subarray(0, this.digestLength)).finish(out);
          this._finished = true;
          return this;
        };
        HMAC2.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        HMAC2.prototype.saveState = function() {
          if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't saveState() because hash doesn't implement it");
          }
          return this._inner.saveState();
        };
        HMAC2.prototype.restoreState = function(savedState) {
          if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't restoreState() because hash doesn't implement it");
          }
          this._inner.restoreState(savedState);
          this._outer.restoreState(this._outerKeyedState);
          this._finished = false;
          return this;
        };
        HMAC2.prototype.cleanSavedState = function(savedState) {
          if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
          }
          this._inner.cleanSavedState(savedState);
        };
        return HMAC2;
      }()
    );
    exports2.HMAC = HMAC;
    function hmac(hash3, key, data) {
      var h = new HMAC(hash3, key);
      h.update(data);
      var digest2 = h.digest();
      h.clean();
      return digest2;
    }
    exports2.hmac = hmac;
    exports2.equal = constant_time_1.equal;
  }
});
var require_hkdf = __commonJS({
  "node_modules/@stablelib/hkdf/lib/hkdf.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var hmac_1 = require_hmac2();
    var wipe_1 = require_wipe();
    var HKDF2 = (
      /** @class */
      function() {
        function HKDF3(hash3, key, salt, info) {
          if (salt === void 0) {
            salt = new Uint8Array(0);
          }
          this._counter = new Uint8Array(1);
          this._hash = hash3;
          this._info = info;
          var okm = hmac_1.hmac(this._hash, salt, key);
          this._hmac = new hmac_1.HMAC(hash3, okm);
          this._buffer = new Uint8Array(this._hmac.digestLength);
          this._bufpos = this._buffer.length;
        }
        HKDF3.prototype._fillBuffer = function() {
          this._counter[0]++;
          var ctr = this._counter[0];
          if (ctr === 0) {
            throw new Error("hkdf: cannot expand more");
          }
          this._hmac.reset();
          if (ctr > 1) {
            this._hmac.update(this._buffer);
          }
          if (this._info) {
            this._hmac.update(this._info);
          }
          this._hmac.update(this._counter);
          this._hmac.finish(this._buffer);
          this._bufpos = 0;
        };
        HKDF3.prototype.expand = function(length3) {
          var out = new Uint8Array(length3);
          for (var i2 = 0; i2 < out.length; i2++) {
            if (this._bufpos === this._buffer.length) {
              this._fillBuffer();
            }
            out[i2] = this._buffer[this._bufpos++];
          }
          return out;
        };
        HKDF3.prototype.clean = function() {
          this._hmac.clean();
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._counter);
          this._bufpos = 0;
        };
        return HKDF3;
      }()
    );
    exports2.HKDF = HKDF2;
  }
});
var require_browser7 = __commonJS({
  "node_modules/@stablelib/random/lib/source/browser.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BrowserRandomSource = void 0;
    var QUOTA = 65536;
    var BrowserRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
          this._crypto = browserCrypto;
          this.isAvailable = true;
          this.isInstantiated = true;
        }
      }
      randomBytes(length3) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Browser random byte generator is not available.");
        }
        const out = new Uint8Array(length3);
        for (let i2 = 0; i2 < out.length; i2 += QUOTA) {
          this._crypto.getRandomValues(out.subarray(i2, i2 + Math.min(out.length - i2, QUOTA)));
        }
        return out;
      }
    };
    exports2.BrowserRandomSource = BrowserRandomSource;
  }
});
var require_node = __commonJS({
  "node_modules/@stablelib/random/lib/source/node.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeRandomSource = void 0;
    var wipe_1 = require_wipe();
    var NodeRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (typeof __require !== "undefined") {
          const nodeCrypto3 = require_crypto();
          if (nodeCrypto3 && nodeCrypto3.randomBytes) {
            this._crypto = nodeCrypto3;
            this.isAvailable = true;
            this.isInstantiated = true;
          }
        }
      }
      randomBytes(length3) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Node.js random byte generator is not available.");
        }
        let buffer2 = this._crypto.randomBytes(length3);
        if (buffer2.length !== length3) {
          throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        const out = new Uint8Array(length3);
        for (let i2 = 0; i2 < out.length; i2++) {
          out[i2] = buffer2[i2];
        }
        (0, wipe_1.wipe)(buffer2);
        return out;
      }
    };
    exports2.NodeRandomSource = NodeRandomSource;
  }
});
var require_system = __commonJS({
  "node_modules/@stablelib/random/lib/source/system.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SystemRandomSource = void 0;
    var browser_1 = require_browser7();
    var node_1 = require_node();
    var SystemRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.name = "";
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Browser";
          return;
        }
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Node";
          return;
        }
      }
      randomBytes(length3) {
        if (!this.isAvailable) {
          throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length3);
      }
    };
    exports2.SystemRandomSource = SystemRandomSource;
  }
});
var require_int = __commonJS({
  "node_modules/@stablelib/int/lib/int.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    function imulShim(a, b) {
      var ah = a >>> 16 & 65535, al = a & 65535;
      var bh = b >>> 16 & 65535, bl = b & 65535;
      return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    }
    exports2.mul = Math.imul || imulShim;
    function add(a, b) {
      return a + b | 0;
    }
    exports2.add = add;
    function sub(a, b) {
      return a - b | 0;
    }
    exports2.sub = sub;
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    exports2.rotl = rotl;
    function rotr(x, n) {
      return x << 32 - n | x >>> n;
    }
    exports2.rotr = rotr;
    function isIntegerShim(n) {
      return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
    }
    exports2.isInteger = Number.isInteger || isIntegerShim;
    exports2.MAX_SAFE_INTEGER = 9007199254740991;
    exports2.isSafeInteger = function(n) {
      return exports2.isInteger(n) && (n >= -exports2.MAX_SAFE_INTEGER && n <= exports2.MAX_SAFE_INTEGER);
    };
  }
});
var require_binary = __commonJS({
  "node_modules/@stablelib/binary/lib/binary.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var int_1 = require_int();
    function readInt16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
    }
    exports2.readInt16BE = readInt16BE;
    function readUint16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
    }
    exports2.readUint16BE = readUint16BE;
    function readInt16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
    }
    exports2.readInt16LE = readInt16LE;
    function readUint16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports2.readUint16LE = readUint16LE;
    function writeUint16BE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value2 >>> 8;
      out[offset + 1] = value2 >>> 0;
      return out;
    }
    exports2.writeUint16BE = writeUint16BE;
    exports2.writeInt16BE = writeUint16BE;
    function writeUint16LE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value2 >>> 0;
      out[offset + 1] = value2 >>> 8;
      return out;
    }
    exports2.writeUint16LE = writeUint16LE;
    exports2.writeInt16LE = writeUint16LE;
    function readInt32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
    }
    exports2.readInt32BE = readInt32BE;
    function readUint32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
    }
    exports2.readUint32BE = readUint32BE;
    function readInt32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
    }
    exports2.readInt32LE = readInt32LE;
    function readUint32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports2.readUint32LE = readUint32LE;
    function writeUint32BE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value2 >>> 24;
      out[offset + 1] = value2 >>> 16;
      out[offset + 2] = value2 >>> 8;
      out[offset + 3] = value2 >>> 0;
      return out;
    }
    exports2.writeUint32BE = writeUint32BE;
    exports2.writeInt32BE = writeUint32BE;
    function writeUint32LE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value2 >>> 0;
      out[offset + 1] = value2 >>> 8;
      out[offset + 2] = value2 >>> 16;
      out[offset + 3] = value2 >>> 24;
      return out;
    }
    exports2.writeUint32LE = writeUint32LE;
    exports2.writeInt32LE = writeUint32LE;
    function readInt64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readInt32BE(array, offset);
      var lo = readInt32BE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports2.readInt64BE = readInt64BE;
    function readUint64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readUint32BE(array, offset);
      var lo = readUint32BE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports2.readUint64BE = readUint64BE;
    function readInt64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readInt32LE(array, offset);
      var hi = readInt32LE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports2.readInt64LE = readInt64LE;
    function readUint64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readUint32LE(array, offset);
      var hi = readUint32LE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports2.readUint64LE = readUint64LE;
    function writeUint64BE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32BE(value2 / 4294967296 >>> 0, out, offset);
      writeUint32BE(value2 >>> 0, out, offset + 4);
      return out;
    }
    exports2.writeUint64BE = writeUint64BE;
    exports2.writeInt64BE = writeUint64BE;
    function writeUint64LE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32LE(value2 >>> 0, out, offset);
      writeUint32LE(value2 / 4294967296 >>> 0, out, offset + 4);
      return out;
    }
    exports2.writeUint64LE = writeUint64LE;
    exports2.writeInt64LE = writeUint64LE;
    function readUintBE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i2 = bitLength / 8 + offset - 1; i2 >= offset; i2--) {
        result += array[i2] * mul;
        mul *= 256;
      }
      return result;
    }
    exports2.readUintBE = readUintBE;
    function readUintLE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i2 = offset; i2 < offset + bitLength / 8; i2++) {
        result += array[i2] * mul;
        mul *= 256;
      }
      return result;
    }
    exports2.readUintLE = readUintLE;
    function writeUintBE(bitLength, value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value2)) {
        throw new Error("writeUintBE value must be an integer");
      }
      var div = 1;
      for (var i2 = bitLength / 8 + offset - 1; i2 >= offset; i2--) {
        out[i2] = value2 / div & 255;
        div *= 256;
      }
      return out;
    }
    exports2.writeUintBE = writeUintBE;
    function writeUintLE(bitLength, value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value2)) {
        throw new Error("writeUintLE value must be an integer");
      }
      var div = 1;
      for (var i2 = offset; i2 < offset + bitLength / 8; i2++) {
        out[i2] = value2 / div & 255;
        div *= 256;
      }
      return out;
    }
    exports2.writeUintLE = writeUintLE;
    function readFloat32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset);
    }
    exports2.readFloat32BE = readFloat32BE;
    function readFloat32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset, true);
    }
    exports2.readFloat32LE = readFloat32LE;
    function readFloat64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset);
    }
    exports2.readFloat64BE = readFloat64BE;
    function readFloat64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset, true);
    }
    exports2.readFloat64LE = readFloat64LE;
    function writeFloat32BE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value2);
      return out;
    }
    exports2.writeFloat32BE = writeFloat32BE;
    function writeFloat32LE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value2, true);
      return out;
    }
    exports2.writeFloat32LE = writeFloat32LE;
    function writeFloat64BE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value2);
      return out;
    }
    exports2.writeFloat64BE = writeFloat64BE;
    function writeFloat64LE(value2, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value2, true);
      return out;
    }
    exports2.writeFloat64LE = writeFloat64LE;
  }
});
var require_random2 = __commonJS({
  "node_modules/@stablelib/random/lib/random.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.randomStringForEntropy = exports2.randomString = exports2.randomUint32 = exports2.randomBytes = exports2.defaultRandomSource = void 0;
    var system_1 = require_system();
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports2.defaultRandomSource = new system_1.SystemRandomSource();
    function randomBytes3(length3, prng = exports2.defaultRandomSource) {
      return prng.randomBytes(length3);
    }
    exports2.randomBytes = randomBytes3;
    function randomUint32(prng = exports2.defaultRandomSource) {
      const buf2 = randomBytes3(4, prng);
      const result = (0, binary_1.readUint32LE)(buf2);
      (0, wipe_1.wipe)(buf2);
      return result;
    }
    exports2.randomUint32 = randomUint32;
    var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function randomString(length3, charset = ALPHANUMERIC, prng = exports2.defaultRandomSource) {
      if (charset.length < 2) {
        throw new Error("randomString charset is too short");
      }
      if (charset.length > 256) {
        throw new Error("randomString charset is too long");
      }
      let out = "";
      const charsLen = charset.length;
      const maxByte = 256 - 256 % charsLen;
      while (length3 > 0) {
        const buf2 = randomBytes3(Math.ceil(length3 * 256 / maxByte), prng);
        for (let i2 = 0; i2 < buf2.length && length3 > 0; i2++) {
          const randomByte = buf2[i2];
          if (randomByte < maxByte) {
            out += charset.charAt(randomByte % charsLen);
            length3--;
          }
        }
        (0, wipe_1.wipe)(buf2);
      }
      return out;
    }
    exports2.randomString = randomString;
    function randomStringForEntropy(bits2, charset = ALPHANUMERIC, prng = exports2.defaultRandomSource) {
      const length3 = Math.ceil(bits2 / (Math.log(charset.length) / Math.LN2));
      return randomString(length3, charset, prng);
    }
    exports2.randomStringForEntropy = randomStringForEntropy;
  }
});
var require_x25519 = __commonJS({
  "node_modules/@stablelib/x25519/lib/x25519.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sharedKey = exports2.generateKeyPair = exports2.generateKeyPairFromSeed = exports2.scalarMultBase = exports2.scalarMult = exports2.SHARED_KEY_LENGTH = exports2.SECRET_KEY_LENGTH = exports2.PUBLIC_KEY_LENGTH = void 0;
    var random_1 = require_random2();
    var wipe_1 = require_wipe();
    exports2.PUBLIC_KEY_LENGTH = 32;
    exports2.SECRET_KEY_LENGTH = 32;
    exports2.SHARED_KEY_LENGTH = 32;
    function gf(init) {
      const r = new Float64Array(16);
      if (init) {
        for (let i2 = 0; i2 < init.length; i2++) {
          r[i2] = init[i2];
        }
      }
      return r;
    }
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var _121665 = gf([56129, 1]);
    function car25519(o) {
      let c = 1;
      for (let i2 = 0; i2 < 16; i2++) {
        let v = o[i2] + c + 65535;
        c = Math.floor(v / 65536);
        o[i2] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q, b) {
      const c = ~(b - 1);
      for (let i2 = 0; i2 < 16; i2++) {
        const t = c & (p[i2] ^ q[i2]);
        p[i2] ^= t;
        q[i2] ^= t;
      }
    }
    function pack25519(o, n) {
      const m = gf();
      const t = gf();
      for (let i2 = 0; i2 < 16; i2++) {
        t[i2] = n[i2];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (let j = 0; j < 2; j++) {
        m[0] = t[0] - 65517;
        for (let i2 = 1; i2 < 15; i2++) {
          m[i2] = t[i2] - 65535 - (m[i2 - 1] >> 16 & 1);
          m[i2 - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        const b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (let i2 = 0; i2 < 16; i2++) {
        o[2 * i2] = t[i2] & 255;
        o[2 * i2 + 1] = t[i2] >> 8;
      }
    }
    function unpack25519(o, n) {
      for (let i2 = 0; i2 < 16; i2++) {
        o[i2] = n[2 * i2] + (n[2 * i2 + 1] << 8);
      }
      o[15] &= 32767;
    }
    function add(o, a, b) {
      for (let i2 = 0; i2 < 16; i2++) {
        o[i2] = a[i2] + b[i2];
      }
    }
    function sub(o, a, b) {
      for (let i2 = 0; i2 < 16; i2++) {
        o[i2] = a[i2] - b[i2];
      }
    }
    function mul(o, a, b) {
      let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function square(o, a) {
      mul(o, a, a);
    }
    function inv25519(o, inp) {
      const c = gf();
      for (let i2 = 0; i2 < 16; i2++) {
        c[i2] = inp[i2];
      }
      for (let i2 = 253; i2 >= 0; i2--) {
        square(c, c);
        if (i2 !== 2 && i2 !== 4) {
          mul(c, c, inp);
        }
      }
      for (let i2 = 0; i2 < 16; i2++) {
        o[i2] = c[i2];
      }
    }
    function scalarMult(n, p) {
      const z = new Uint8Array(32);
      const x = new Float64Array(80);
      const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
      for (let i2 = 0; i2 < 31; i2++) {
        z[i2] = n[i2];
      }
      z[31] = n[31] & 127 | 64;
      z[0] &= 248;
      unpack25519(x, p);
      for (let i2 = 0; i2 < 16; i2++) {
        b[i2] = x[i2];
      }
      a[0] = d[0] = 1;
      for (let i2 = 254; i2 >= 0; --i2) {
        const r = z[i2 >>> 3] >>> (i2 & 7) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        add(e, a, c);
        sub(a, a, c);
        add(c, b, d);
        sub(b, b, d);
        square(d, e);
        square(f, a);
        mul(a, c, a);
        mul(c, b, e);
        add(e, a, c);
        sub(a, a, c);
        square(b, a);
        sub(c, d, f);
        mul(a, c, _121665);
        add(a, a, d);
        mul(c, c, a);
        mul(a, d, f);
        mul(d, b, x);
        square(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
      }
      for (let i2 = 0; i2 < 16; i2++) {
        x[i2 + 16] = a[i2];
        x[i2 + 32] = c[i2];
        x[i2 + 48] = b[i2];
        x[i2 + 64] = d[i2];
      }
      const x32 = x.subarray(32);
      const x16 = x.subarray(16);
      inv25519(x32, x32);
      mul(x16, x16, x32);
      const q = new Uint8Array(32);
      pack25519(q, x16);
      return q;
    }
    exports2.scalarMult = scalarMult;
    function scalarMultBase(n) {
      return scalarMult(n, _9);
    }
    exports2.scalarMultBase = scalarMultBase;
    function generateKeyPairFromSeed4(seed2) {
      if (seed2.length !== exports2.SECRET_KEY_LENGTH) {
        throw new Error(`x25519: seed must be ${exports2.SECRET_KEY_LENGTH} bytes`);
      }
      const secretKey = new Uint8Array(seed2);
      const publicKey = scalarMultBase(secretKey);
      return {
        publicKey,
        secretKey
      };
    }
    exports2.generateKeyPairFromSeed = generateKeyPairFromSeed4;
    function generateKeyPair6(prng) {
      const seed2 = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed4(seed2);
      (0, wipe_1.wipe)(seed2);
      return result;
    }
    exports2.generateKeyPair = generateKeyPair6;
    function sharedKey2(mySecretKey, theirPublicKey, rejectZero = false) {
      if (mySecretKey.length !== exports2.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect secret key length");
      }
      if (theirPublicKey.length !== exports2.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect public key length");
      }
      const result = scalarMult(mySecretKey, theirPublicKey);
      if (rejectZero) {
        let zeros = 0;
        for (let i2 = 0; i2 < result.length; i2++) {
          zeros |= result[i2];
        }
        if (zeros === 0) {
          throw new Error("X25519: invalid shared key");
        }
      }
      return result;
    }
    exports2.sharedKey = sharedKey2;
  }
});
var require_sha2562 = __commonJS({
  "node_modules/@stablelib/sha256/lib/sha256.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports2.DIGEST_LENGTH = 32;
    exports2.BLOCK_SIZE = 64;
    var SHA2562 = (
      /** @class */
      function() {
        function SHA2563() {
          this.digestLength = exports2.DIGEST_LENGTH;
          this.blockSize = exports2.BLOCK_SIZE;
          this._state = new Int32Array(8);
          this._temp = new Int32Array(64);
          this._buffer = new Uint8Array(128);
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          this.reset();
        }
        SHA2563.prototype._initState = function() {
          this._state[0] = 1779033703;
          this._state[1] = 3144134277;
          this._state[2] = 1013904242;
          this._state[3] = 2773480762;
          this._state[4] = 1359893119;
          this._state[5] = 2600822924;
          this._state[6] = 528734635;
          this._state[7] = 1541459225;
        };
        SHA2563.prototype.reset = function() {
          this._initState();
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          return this;
        };
        SHA2563.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._temp);
          this.reset();
        };
        SHA2563.prototype.update = function(data, dataLength) {
          if (dataLength === void 0) {
            dataLength = data.length;
          }
          if (this._finished) {
            throw new Error("SHA256: can't update because hash was finished.");
          }
          var dataPos = 0;
          this._bytesHashed += dataLength;
          if (this._bufferLength > 0) {
            while (this._bufferLength < this.blockSize && dataLength > 0) {
              this._buffer[this._bufferLength++] = data[dataPos++];
              dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
              hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
              this._bufferLength = 0;
            }
          }
          if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
            dataLength %= this.blockSize;
          }
          while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          return this;
        };
        SHA2563.prototype.finish = function(out) {
          if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = bytesHashed / 536870912 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 64 < 56 ? 64 : 128;
            this._buffer[left] = 128;
            for (var i2 = left + 1; i2 < padLength - 8; i2++) {
              this._buffer[i2] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
            this._finished = true;
          }
          for (var i2 = 0; i2 < this.digestLength / 4; i2++) {
            binary_1.writeUint32BE(this._state[i2], out, i2 * 4);
          }
          return this;
        };
        SHA2563.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        SHA2563.prototype.saveState = function() {
          if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
          }
          return {
            state: new Int32Array(this._state),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          };
        };
        SHA2563.prototype.restoreState = function(savedState) {
          this._state.set(savedState.state);
          this._bufferLength = savedState.bufferLength;
          if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
          }
          this._bytesHashed = savedState.bytesHashed;
          this._finished = false;
          return this;
        };
        SHA2563.prototype.cleanSavedState = function(savedState) {
          wipe_1.wipe(savedState.state);
          if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
          }
          savedState.bufferLength = 0;
          savedState.bytesHashed = 0;
        };
        return SHA2563;
      }()
    );
    exports2.SHA256 = SHA2562;
    var K2 = new Int32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    function hashBlocks(w, v, p, pos, len) {
      while (len >= 64) {
        var a = v[0];
        var b = v[1];
        var c = v[2];
        var d = v[3];
        var e = v[4];
        var f = v[5];
        var g = v[6];
        var h = v[7];
        for (var i2 = 0; i2 < 16; i2++) {
          var j = pos + i2 * 4;
          w[i2] = binary_1.readUint32BE(p, j);
        }
        for (var i2 = 16; i2 < 64; i2++) {
          var u = w[i2 - 2];
          var t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
          u = w[i2 - 15];
          var t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
          w[i2] = (t1 + w[i2 - 7] | 0) + (t2 + w[i2 - 16] | 0);
        }
        for (var i2 = 0; i2 < 64; i2++) {
          var t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K2[i2] + w[i2] | 0) | 0) | 0;
          var t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
          h = g;
          g = f;
          f = e;
          e = d + t1 | 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 | 0;
        }
        v[0] += a;
        v[1] += b;
        v[2] += c;
        v[3] += d;
        v[4] += e;
        v[5] += f;
        v[6] += g;
        v[7] += h;
        pos += 64;
        len -= 64;
      }
      return pos;
    }
    function hash3(data) {
      var h = new SHA2562();
      h.update(data);
      var digest2 = h.digest();
      h.clean();
      return digest2;
    }
    exports2.hash = hash3;
  }
});
var require_chacha = __commonJS({
  "node_modules/@stablelib/chacha/lib/chacha.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    var ROUNDS = 20;
    function core(out, input, key) {
      var j0 = 1634760805;
      var j1 = 857760878;
      var j2 = 2036477234;
      var j3 = 1797285236;
      var j4 = key[3] << 24 | key[2] << 16 | key[1] << 8 | key[0];
      var j5 = key[7] << 24 | key[6] << 16 | key[5] << 8 | key[4];
      var j6 = key[11] << 24 | key[10] << 16 | key[9] << 8 | key[8];
      var j7 = key[15] << 24 | key[14] << 16 | key[13] << 8 | key[12];
      var j8 = key[19] << 24 | key[18] << 16 | key[17] << 8 | key[16];
      var j9 = key[23] << 24 | key[22] << 16 | key[21] << 8 | key[20];
      var j10 = key[27] << 24 | key[26] << 16 | key[25] << 8 | key[24];
      var j11 = key[31] << 24 | key[30] << 16 | key[29] << 8 | key[28];
      var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
      var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
      var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
      var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
      var x0 = j0;
      var x1 = j1;
      var x2 = j2;
      var x3 = j3;
      var x4 = j4;
      var x5 = j5;
      var x6 = j6;
      var x7 = j7;
      var x8 = j8;
      var x9 = j9;
      var x10 = j10;
      var x11 = j11;
      var x12 = j12;
      var x13 = j13;
      var x14 = j14;
      var x15 = j15;
      for (var i2 = 0; i2 < ROUNDS; i2 += 2) {
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 7 | x5 << 7;
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 7 | x5 << 7;
      }
      binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
      binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
      binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
      binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
      binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
      binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
      binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
      binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
      binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
      binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
      binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
      binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
      binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
      binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
      binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
      binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
    }
    function streamXOR(key, nonce, src2, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      if (key.length !== 32) {
        throw new Error("ChaCha: key size must be 32 bytes");
      }
      if (dst.length < src2.length) {
        throw new Error("ChaCha: destination is shorter than source");
      }
      var nc;
      var counterLength;
      if (nonceInplaceCounterLength === 0) {
        if (nonce.length !== 8 && nonce.length !== 12) {
          throw new Error("ChaCha nonce must be 8 or 12 bytes");
        }
        nc = new Uint8Array(16);
        counterLength = nc.length - nonce.length;
        nc.set(nonce, counterLength);
      } else {
        if (nonce.length !== 16) {
          throw new Error("ChaCha nonce with counter must be 16 bytes");
        }
        nc = nonce;
        counterLength = nonceInplaceCounterLength;
      }
      var block = new Uint8Array(64);
      for (var i2 = 0; i2 < src2.length; i2 += 64) {
        core(block, nc, key);
        for (var j = i2; j < i2 + 64 && j < src2.length; j++) {
          dst[j] = src2[j] ^ block[j - i2];
        }
        incrementCounter(nc, 0, counterLength);
      }
      wipe_1.wipe(block);
      if (nonceInplaceCounterLength === 0) {
        wipe_1.wipe(nc);
      }
      return dst;
    }
    exports2.streamXOR = streamXOR;
    function stream(key, nonce, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      wipe_1.wipe(dst);
      return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
    }
    exports2.stream = stream;
    function incrementCounter(counter, pos, len) {
      var carry = 1;
      while (len--) {
        carry = carry + (counter[pos] & 255) | 0;
        counter[pos] = carry & 255;
        carry >>>= 8;
        pos++;
      }
      if (carry > 0) {
        throw new Error("ChaCha: counter overflow");
      }
    }
  }
});
var require_poly1305 = __commonJS({
  "node_modules/@stablelib/poly1305/lib/poly1305.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    exports2.DIGEST_LENGTH = 16;
    var Poly1305 = (
      /** @class */
      function() {
        function Poly13052(key) {
          this.digestLength = exports2.DIGEST_LENGTH;
          this._buffer = new Uint8Array(16);
          this._r = new Uint16Array(10);
          this._h = new Uint16Array(10);
          this._pad = new Uint16Array(8);
          this._leftover = 0;
          this._fin = 0;
          this._finished = false;
          var t0 = key[0] | key[1] << 8;
          this._r[0] = t0 & 8191;
          var t1 = key[2] | key[3] << 8;
          this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
          var t2 = key[4] | key[5] << 8;
          this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
          var t3 = key[6] | key[7] << 8;
          this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
          var t4 = key[8] | key[9] << 8;
          this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
          this._r[5] = t4 >>> 1 & 8190;
          var t5 = key[10] | key[11] << 8;
          this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = key[12] | key[13] << 8;
          this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
          var t7 = key[14] | key[15] << 8;
          this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
          this._r[9] = t7 >>> 5 & 127;
          this._pad[0] = key[16] | key[17] << 8;
          this._pad[1] = key[18] | key[19] << 8;
          this._pad[2] = key[20] | key[21] << 8;
          this._pad[3] = key[22] | key[23] << 8;
          this._pad[4] = key[24] | key[25] << 8;
          this._pad[5] = key[26] | key[27] << 8;
          this._pad[6] = key[28] | key[29] << 8;
          this._pad[7] = key[30] | key[31] << 8;
        }
        Poly13052.prototype._blocks = function(m, mpos, bytes2) {
          var hibit = this._fin ? 0 : 1 << 11;
          var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
          var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
          while (bytes2 >= 16) {
            var t0 = m[mpos + 0] | m[mpos + 1] << 8;
            h0 += t0 & 8191;
            var t1 = m[mpos + 2] | m[mpos + 3] << 8;
            h1 += (t0 >>> 13 | t1 << 3) & 8191;
            var t2 = m[mpos + 4] | m[mpos + 5] << 8;
            h2 += (t1 >>> 10 | t2 << 6) & 8191;
            var t3 = m[mpos + 6] | m[mpos + 7] << 8;
            h3 += (t2 >>> 7 | t3 << 9) & 8191;
            var t4 = m[mpos + 8] | m[mpos + 9] << 8;
            h4 += (t3 >>> 4 | t4 << 12) & 8191;
            h5 += t4 >>> 1 & 8191;
            var t5 = m[mpos + 10] | m[mpos + 11] << 8;
            h6 += (t4 >>> 14 | t5 << 2) & 8191;
            var t6 = m[mpos + 12] | m[mpos + 13] << 8;
            h7 += (t5 >>> 11 | t6 << 5) & 8191;
            var t7 = m[mpos + 14] | m[mpos + 15] << 8;
            h8 += (t6 >>> 8 | t7 << 8) & 8191;
            h9 += t7 >>> 5 | hibit;
            var c = 0;
            var d0 = c;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h2 * (5 * r8);
            d0 += h3 * (5 * r7);
            d0 += h4 * (5 * r6);
            c = d0 >>> 13;
            d0 &= 8191;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c += d0 >>> 13;
            d0 &= 8191;
            var d1 = c;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h2 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c = d1 >>> 13;
            d1 &= 8191;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c += d1 >>> 13;
            d1 &= 8191;
            var d2 = c;
            d2 += h0 * r2;
            d2 += h1 * r1;
            d2 += h2 * r0;
            d2 += h3 * (5 * r9);
            d2 += h4 * (5 * r8);
            c = d2 >>> 13;
            d2 &= 8191;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c += d2 >>> 13;
            d2 &= 8191;
            var d32 = c;
            d32 += h0 * r3;
            d32 += h1 * r2;
            d32 += h2 * r1;
            d32 += h3 * r0;
            d32 += h4 * (5 * r9);
            c = d32 >>> 13;
            d32 &= 8191;
            d32 += h5 * (5 * r8);
            d32 += h6 * (5 * r7);
            d32 += h7 * (5 * r6);
            d32 += h8 * (5 * r5);
            d32 += h9 * (5 * r4);
            c += d32 >>> 13;
            d32 &= 8191;
            var d4 = c;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h2 * r2;
            d4 += h3 * r1;
            d4 += h4 * r0;
            c = d4 >>> 13;
            d4 &= 8191;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c += d4 >>> 13;
            d4 &= 8191;
            var d5 = c;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h2 * r3;
            d5 += h3 * r2;
            d5 += h4 * r1;
            c = d5 >>> 13;
            d5 &= 8191;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c += d5 >>> 13;
            d5 &= 8191;
            var d6 = c;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h2 * r4;
            d6 += h3 * r3;
            d6 += h4 * r2;
            c = d6 >>> 13;
            d6 &= 8191;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c += d6 >>> 13;
            d6 &= 8191;
            var d7 = c;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h2 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c = d7 >>> 13;
            d7 &= 8191;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c += d7 >>> 13;
            d7 &= 8191;
            var d8 = c;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h2 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c = d8 >>> 13;
            d8 &= 8191;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c += d8 >>> 13;
            d8 &= 8191;
            var d9 = c;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h2 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c = d9 >>> 13;
            d9 &= 8191;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c += d9 >>> 13;
            d9 &= 8191;
            c = (c << 2) + c | 0;
            c = c + d0 | 0;
            d0 = c & 8191;
            c = c >>> 13;
            d1 += c;
            h0 = d0;
            h1 = d1;
            h2 = d2;
            h3 = d32;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes2 -= 16;
          }
          this._h[0] = h0;
          this._h[1] = h1;
          this._h[2] = h2;
          this._h[3] = h3;
          this._h[4] = h4;
          this._h[5] = h5;
          this._h[6] = h6;
          this._h[7] = h7;
          this._h[8] = h8;
          this._h[9] = h9;
        };
        Poly13052.prototype.finish = function(mac, macpos) {
          if (macpos === void 0) {
            macpos = 0;
          }
          var g = new Uint16Array(10);
          var c;
          var mask;
          var f;
          var i2;
          if (this._leftover) {
            i2 = this._leftover;
            this._buffer[i2++] = 1;
            for (; i2 < 16; i2++) {
              this._buffer[i2] = 0;
            }
            this._fin = 1;
            this._blocks(this._buffer, 0, 16);
          }
          c = this._h[1] >>> 13;
          this._h[1] &= 8191;
          for (i2 = 2; i2 < 10; i2++) {
            this._h[i2] += c;
            c = this._h[i2] >>> 13;
            this._h[i2] &= 8191;
          }
          this._h[0] += c * 5;
          c = this._h[0] >>> 13;
          this._h[0] &= 8191;
          this._h[1] += c;
          c = this._h[1] >>> 13;
          this._h[1] &= 8191;
          this._h[2] += c;
          g[0] = this._h[0] + 5;
          c = g[0] >>> 13;
          g[0] &= 8191;
          for (i2 = 1; i2 < 10; i2++) {
            g[i2] = this._h[i2] + c;
            c = g[i2] >>> 13;
            g[i2] &= 8191;
          }
          g[9] -= 1 << 13;
          mask = (c ^ 1) - 1;
          for (i2 = 0; i2 < 10; i2++) {
            g[i2] &= mask;
          }
          mask = ~mask;
          for (i2 = 0; i2 < 10; i2++) {
            this._h[i2] = this._h[i2] & mask | g[i2];
          }
          this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
          this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
          this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
          this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
          this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
          this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
          this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
          this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
          f = this._h[0] + this._pad[0];
          this._h[0] = f & 65535;
          for (i2 = 1; i2 < 8; i2++) {
            f = (this._h[i2] + this._pad[i2] | 0) + (f >>> 16) | 0;
            this._h[i2] = f & 65535;
          }
          mac[macpos + 0] = this._h[0] >>> 0;
          mac[macpos + 1] = this._h[0] >>> 8;
          mac[macpos + 2] = this._h[1] >>> 0;
          mac[macpos + 3] = this._h[1] >>> 8;
          mac[macpos + 4] = this._h[2] >>> 0;
          mac[macpos + 5] = this._h[2] >>> 8;
          mac[macpos + 6] = this._h[3] >>> 0;
          mac[macpos + 7] = this._h[3] >>> 8;
          mac[macpos + 8] = this._h[4] >>> 0;
          mac[macpos + 9] = this._h[4] >>> 8;
          mac[macpos + 10] = this._h[5] >>> 0;
          mac[macpos + 11] = this._h[5] >>> 8;
          mac[macpos + 12] = this._h[6] >>> 0;
          mac[macpos + 13] = this._h[6] >>> 8;
          mac[macpos + 14] = this._h[7] >>> 0;
          mac[macpos + 15] = this._h[7] >>> 8;
          this._finished = true;
          return this;
        };
        Poly13052.prototype.update = function(m) {
          var mpos = 0;
          var bytes2 = m.length;
          var want;
          if (this._leftover) {
            want = 16 - this._leftover;
            if (want > bytes2) {
              want = bytes2;
            }
            for (var i2 = 0; i2 < want; i2++) {
              this._buffer[this._leftover + i2] = m[mpos + i2];
            }
            bytes2 -= want;
            mpos += want;
            this._leftover += want;
            if (this._leftover < 16) {
              return this;
            }
            this._blocks(this._buffer, 0, 16);
            this._leftover = 0;
          }
          if (bytes2 >= 16) {
            want = bytes2 - bytes2 % 16;
            this._blocks(m, mpos, want);
            mpos += want;
            bytes2 -= want;
          }
          if (bytes2) {
            for (var i2 = 0; i2 < bytes2; i2++) {
              this._buffer[this._leftover + i2] = m[mpos + i2];
            }
            this._leftover += bytes2;
          }
          return this;
        };
        Poly13052.prototype.digest = function() {
          if (this._finished) {
            throw new Error("Poly1305 was finished");
          }
          var mac = new Uint8Array(16);
          this.finish(mac);
          return mac;
        };
        Poly13052.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._r);
          wipe_1.wipe(this._h);
          wipe_1.wipe(this._pad);
          this._leftover = 0;
          this._fin = 0;
          this._finished = true;
          return this;
        };
        return Poly13052;
      }()
    );
    exports2.Poly1305 = Poly1305;
    function oneTimeAuth(key, data) {
      var h = new Poly1305(key);
      h.update(data);
      var digest2 = h.digest();
      h.clean();
      return digest2;
    }
    exports2.oneTimeAuth = oneTimeAuth;
    function equal(a, b) {
      if (a.length !== exports2.DIGEST_LENGTH || b.length !== exports2.DIGEST_LENGTH) {
        return false;
      }
      return constant_time_1.equal(a, b);
    }
    exports2.equal = equal;
  }
});
var require_chacha20poly1305 = __commonJS({
  "node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var chacha_1 = require_chacha();
    var poly1305_1 = require_poly1305();
    var wipe_1 = require_wipe();
    var binary_1 = require_binary();
    var constant_time_1 = require_constant_time();
    exports2.KEY_LENGTH = 32;
    exports2.NONCE_LENGTH = 12;
    exports2.TAG_LENGTH = 16;
    var ZEROS2 = new Uint8Array(16);
    var ChaCha20Poly13052 = (
      /** @class */
      function() {
        function ChaCha20Poly13053(key) {
          this.nonceLength = exports2.NONCE_LENGTH;
          this.tagLength = exports2.TAG_LENGTH;
          if (key.length !== exports2.KEY_LENGTH) {
            throw new Error("ChaCha20Poly1305 needs 32-byte key");
          }
          this._key = new Uint8Array(key);
        }
        ChaCha20Poly13053.prototype.seal = function(nonce, plaintext, associatedData, dst) {
          if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
          }
          var counter = new Uint8Array(16);
          counter.set(nonce, counter.length - nonce.length);
          var authKey = new Uint8Array(32);
          chacha_1.stream(this._key, counter, authKey, 4);
          var resultLength = plaintext.length + this.tagLength;
          var result;
          if (dst) {
            if (dst.length !== resultLength) {
              throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
          } else {
            result = new Uint8Array(resultLength);
          }
          chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
          this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
          wipe_1.wipe(counter);
          return result;
        };
        ChaCha20Poly13053.prototype.open = function(nonce, sealed, associatedData, dst) {
          if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
          }
          if (sealed.length < this.tagLength) {
            return null;
          }
          var counter = new Uint8Array(16);
          counter.set(nonce, counter.length - nonce.length);
          var authKey = new Uint8Array(32);
          chacha_1.stream(this._key, counter, authKey, 4);
          var calculatedTag = new Uint8Array(this.tagLength);
          this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
          if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
            return null;
          }
          var resultLength = sealed.length - this.tagLength;
          var result;
          if (dst) {
            if (dst.length !== resultLength) {
              throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
          } else {
            result = new Uint8Array(resultLength);
          }
          chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
          wipe_1.wipe(counter);
          return result;
        };
        ChaCha20Poly13053.prototype.clean = function() {
          wipe_1.wipe(this._key);
          return this;
        };
        ChaCha20Poly13053.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
          var h = new poly1305_1.Poly1305(authKey);
          if (associatedData) {
            h.update(associatedData);
            if (associatedData.length % 16 > 0) {
              h.update(ZEROS2.subarray(associatedData.length % 16));
            }
          }
          h.update(ciphertext);
          if (ciphertext.length % 16 > 0) {
            h.update(ZEROS2.subarray(ciphertext.length % 16));
          }
          var length3 = new Uint8Array(8);
          if (associatedData) {
            binary_1.writeUint64LE(associatedData.length, length3);
          }
          h.update(length3);
          binary_1.writeUint64LE(ciphertext.length, length3);
          h.update(length3);
          var tag = h.digest();
          for (var i2 = 0; i2 < tag.length; i2++) {
            tagOut[i2] = tag[i2];
          }
          h.clean();
          wipe_1.wipe(tag);
          wipe_1.wipe(length3);
        };
        return ChaCha20Poly13053;
      }()
    );
    exports2.ChaCha20Poly1305 = ChaCha20Poly13052;
  }
});
var require_encode2 = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/encode.js"(exports2, module2) {
    module2.exports = encode21;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode21(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode21.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});
var require_decode2 = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/decode.js"(exports2, module2) {
    module2.exports = read2;
    var MSB2 = 128;
    var REST2 = 127;
    function read2(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB2);
      read2.bytes = counter - offset;
      return res;
    }
  }
});
var require_length2 = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/length.js"(exports2, module2) {
    var N12 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N32 = Math.pow(2, 21);
    var N42 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    module2.exports = function(value2) {
      return value2 < N12 ? 1 : value2 < N22 ? 2 : value2 < N32 ? 3 : value2 < N42 ? 4 : value2 < N52 ? 5 : value2 < N62 ? 6 : value2 < N72 ? 7 : value2 < N82 ? 8 : value2 < N92 ? 9 : 10;
    };
  }
});
var require_varint2 = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/index.js"(exports2, module2) {
    module2.exports = {
      encode: require_encode2(),
      decode: require_decode2(),
      encodingLength: require_length2()
    };
  }
});
var require_src4 = __commonJS({
  "node_modules/varint-decoder/src/index.js"(exports2, module2) {
    var varint10 = require_varint2();
    module2.exports = (buf2) => {
      if (!(buf2 instanceof Uint8Array)) {
        throw new Error("arg needs to be a Uint8Array");
      }
      const result = [];
      while (buf2.length > 0) {
        const num = varint10.decode(buf2);
        result.push(num);
        buf2 = buf2.slice(varint10.decode.bytes);
      }
      return result;
    };
  }
});
var require_moving_average = __commonJS({
  "node_modules/@vascosantos/moving-average/index.js"(exports2, module2) {
    var exp = Math.exp;
    module2.exports = function MovingAverage2(timespan) {
      if (typeof timespan !== "number") {
        throw new Error("must provide a timespan to the moving average constructor");
      }
      if (timespan <= 0) {
        throw new Error("must provide a timespan > 0 to the moving average constructor");
      }
      let ma;
      let v = 0;
      let d = 0;
      let f = 0;
      let previousTime;
      let ret = {};
      function alpha(t, pt) {
        return 1 - exp(-(t - pt) / timespan);
      }
      ret.push = function push(time, value2) {
        if (previousTime) {
          const a = alpha(time, previousTime);
          const diff = value2 - ma;
          const incr = a * diff;
          ma = a * value2 + (1 - a) * ma;
          v = (1 - a) * (v + diff * incr);
          d = Math.sqrt(v);
          f = ma + a * diff;
        } else {
          ma = value2;
        }
        previousTime = time;
      };
      ret.movingAverage = function movingAverage() {
        return ma;
      };
      ret.variance = function variance() {
        return v;
      };
      ret.deviation = function deviation() {
        return d;
      };
      ret.forecast = function forecast() {
        return f;
      };
      return ret;
    };
  }
});
var import_index = __toESM(require_merge_options(), 1);
var merge_options_default = import_index.default;
var import_env2 = __toESM(require_env(), 1);
var import_debug = __toESM(require_browser$1());
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
import_debug.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc.baseEncode(v);
};
import_debug.default.formatters.t = (v) => {
  return v == null ? "undefined" : base32.baseEncode(v);
};
import_debug.default.formatters.m = (v) => {
  return v == null ? "undefined" : base64.baseEncode(v);
};
import_debug.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
function logger(name9) {
  return Object.assign((0, import_debug.default)(name9), {
    error: (0, import_debug.default)(`${name9}:error`),
    trace: (0, import_debug.default)(`${name9}:trace`)
  });
}
var import_err_code144 = __toESM(require_err_code(), 1);
var import_err_code = __toESM(require_err_code());
var import_minimal = __toESM(require_minimal2(), 1);
var $Reader = import_minimal.default.Reader;
var $Writer = import_minimal.default.Writer;
var $util = import_minimal.default.util;
var $root = import_minimal.default.roots["ipfs-unixfs"] || (import_minimal.default.roots["ipfs-unixfs"] = {});
var Data = $root.Data = (() => {
  function Data2(p) {
    this.blocksizes = [];
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Data2.prototype.Type = 0;
  Data2.prototype.Data = $util.newBuffer([]);
  Data2.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.blocksizes = $util.emptyArray;
  Data2.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.mode = 0;
  Data2.prototype.mtime = null;
  Data2.encode = function encode21(m, w) {
    if (!w)
      w = $Writer.create();
    w.uint32(8).int32(m.Type);
    if (m.Data != null && Object.hasOwnProperty.call(m, "Data"))
      w.uint32(18).bytes(m.Data);
    if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize"))
      w.uint32(24).uint64(m.filesize);
    if (m.blocksizes != null && m.blocksizes.length) {
      for (var i2 = 0; i2 < m.blocksizes.length; ++i2)
        w.uint32(32).uint64(m.blocksizes[i2]);
    }
    if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType"))
      w.uint32(40).uint64(m.hashType);
    if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
      w.uint32(48).uint64(m.fanout);
    if (m.mode != null && Object.hasOwnProperty.call(m, "mode"))
      w.uint32(56).uint32(m.mode);
    if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime"))
      $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
    return w;
  };
  Data2.decode = function decode17(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.Data();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.Type = r.int32();
          break;
        case 2:
          m.Data = r.bytes();
          break;
        case 3:
          m.filesize = r.uint64();
          break;
        case 4:
          if (!(m.blocksizes && m.blocksizes.length))
            m.blocksizes = [];
          if ((t & 7) === 2) {
            var c2 = r.uint32() + r.pos;
            while (r.pos < c2)
              m.blocksizes.push(r.uint64());
          } else
            m.blocksizes.push(r.uint64());
          break;
        case 5:
          m.hashType = r.uint64();
          break;
        case 6:
          m.fanout = r.uint64();
          break;
        case 7:
          m.mode = r.uint32();
          break;
        case 8:
          m.mtime = $root.UnixTime.decode(r, r.uint32());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.hasOwnProperty("Type"))
      throw $util.ProtocolError("missing required 'Type'", { instance: m });
    return m;
  };
  Data2.fromObject = function fromObject(d) {
    if (d instanceof $root.Data)
      return d;
    var m = new $root.Data();
    switch (d.Type) {
      case "Raw":
      case 0:
        m.Type = 0;
        break;
      case "Directory":
      case 1:
        m.Type = 1;
        break;
      case "File":
      case 2:
        m.Type = 2;
        break;
      case "Metadata":
      case 3:
        m.Type = 3;
        break;
      case "Symlink":
      case 4:
        m.Type = 4;
        break;
      case "HAMTShard":
      case 5:
        m.Type = 5;
        break;
    }
    if (d.Data != null) {
      if (typeof d.Data === "string")
        $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
      else if (d.Data.length)
        m.Data = d.Data;
    }
    if (d.filesize != null) {
      if ($util.Long)
        (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;
      else if (typeof d.filesize === "string")
        m.filesize = parseInt(d.filesize, 10);
      else if (typeof d.filesize === "number")
        m.filesize = d.filesize;
      else if (typeof d.filesize === "object")
        m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
    }
    if (d.blocksizes) {
      if (!Array.isArray(d.blocksizes))
        throw TypeError(".Data.blocksizes: array expected");
      m.blocksizes = [];
      for (var i2 = 0; i2 < d.blocksizes.length; ++i2) {
        if ($util.Long)
          (m.blocksizes[i2] = $util.Long.fromValue(d.blocksizes[i2])).unsigned = true;
        else if (typeof d.blocksizes[i2] === "string")
          m.blocksizes[i2] = parseInt(d.blocksizes[i2], 10);
        else if (typeof d.blocksizes[i2] === "number")
          m.blocksizes[i2] = d.blocksizes[i2];
        else if (typeof d.blocksizes[i2] === "object")
          m.blocksizes[i2] = new $util.LongBits(d.blocksizes[i2].low >>> 0, d.blocksizes[i2].high >>> 0).toNumber(true);
      }
    }
    if (d.hashType != null) {
      if ($util.Long)
        (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;
      else if (typeof d.hashType === "string")
        m.hashType = parseInt(d.hashType, 10);
      else if (typeof d.hashType === "number")
        m.hashType = d.hashType;
      else if (typeof d.hashType === "object")
        m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
    }
    if (d.fanout != null) {
      if ($util.Long)
        (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;
      else if (typeof d.fanout === "string")
        m.fanout = parseInt(d.fanout, 10);
      else if (typeof d.fanout === "number")
        m.fanout = d.fanout;
      else if (typeof d.fanout === "object")
        m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
    }
    if (d.mode != null) {
      m.mode = d.mode >>> 0;
    }
    if (d.mtime != null) {
      if (typeof d.mtime !== "object")
        throw TypeError(".Data.mtime: object expected");
      m.mtime = $root.UnixTime.fromObject(d.mtime);
    }
    return m;
  };
  Data2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.blocksizes = [];
    }
    if (o.defaults) {
      d.Type = o.enums === String ? "Raw" : 0;
      if (o.bytes === String)
        d.Data = "";
      else {
        d.Data = [];
        if (o.bytes !== Array)
          d.Data = $util.newBuffer(d.Data);
      }
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.filesize = o.longs === String ? "0" : 0;
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.hashType = o.longs === String ? "0" : 0;
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.fanout = o.longs === String ? "0" : 0;
      d.mode = 0;
      d.mtime = null;
    }
    if (m.Type != null && m.hasOwnProperty("Type")) {
      d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;
    }
    if (m.Data != null && m.hasOwnProperty("Data")) {
      d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
    }
    if (m.filesize != null && m.hasOwnProperty("filesize")) {
      if (typeof m.filesize === "number")
        d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
      else
        d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
    }
    if (m.blocksizes && m.blocksizes.length) {
      d.blocksizes = [];
      for (var j = 0; j < m.blocksizes.length; ++j) {
        if (typeof m.blocksizes[j] === "number")
          d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
        else
          d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
      }
    }
    if (m.hashType != null && m.hasOwnProperty("hashType")) {
      if (typeof m.hashType === "number")
        d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
      else
        d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
    }
    if (m.fanout != null && m.hasOwnProperty("fanout")) {
      if (typeof m.fanout === "number")
        d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
      else
        d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
    }
    if (m.mode != null && m.hasOwnProperty("mode")) {
      d.mode = m.mode;
    }
    if (m.mtime != null && m.hasOwnProperty("mtime")) {
      d.mtime = $root.UnixTime.toObject(m.mtime, o);
    }
    return d;
  };
  Data2.prototype.toJSON = function toJSON2() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  Data2.DataType = function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "Raw"] = 0;
    values[valuesById[1] = "Directory"] = 1;
    values[valuesById[2] = "File"] = 2;
    values[valuesById[3] = "Metadata"] = 3;
    values[valuesById[4] = "Symlink"] = 4;
    values[valuesById[5] = "HAMTShard"] = 5;
    return values;
  }();
  return Data2;
})();
$root.UnixTime = (() => {
  function UnixTime2(p) {
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  UnixTime2.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
  UnixTime2.prototype.FractionalNanoseconds = 0;
  UnixTime2.encode = function encode21(m, w) {
    if (!w)
      w = $Writer.create();
    w.uint32(8).int64(m.Seconds);
    if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds"))
      w.uint32(21).fixed32(m.FractionalNanoseconds);
    return w;
  };
  UnixTime2.decode = function decode17(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.UnixTime();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.Seconds = r.int64();
          break;
        case 2:
          m.FractionalNanoseconds = r.fixed32();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.hasOwnProperty("Seconds"))
      throw $util.ProtocolError("missing required 'Seconds'", { instance: m });
    return m;
  };
  UnixTime2.fromObject = function fromObject(d) {
    if (d instanceof $root.UnixTime)
      return d;
    var m = new $root.UnixTime();
    if (d.Seconds != null) {
      if ($util.Long)
        (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;
      else if (typeof d.Seconds === "string")
        m.Seconds = parseInt(d.Seconds, 10);
      else if (typeof d.Seconds === "number")
        m.Seconds = d.Seconds;
      else if (typeof d.Seconds === "object")
        m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
    }
    if (d.FractionalNanoseconds != null) {
      m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
    }
    return m;
  };
  UnixTime2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if ($util.Long) {
        var n = new $util.Long(0, 0, false);
        d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.Seconds = o.longs === String ? "0" : 0;
      d.FractionalNanoseconds = 0;
    }
    if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
      if (typeof m.Seconds === "number")
        d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
      else
        d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
    }
    if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
      d.FractionalNanoseconds = m.FractionalNanoseconds;
    }
    return d;
  };
  UnixTime2.prototype.toJSON = function toJSON2() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  return UnixTime2;
})();
$root.Metadata = (() => {
  function Metadata4(p) {
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Metadata4.prototype.MimeType = "";
  Metadata4.encode = function encode21(m, w) {
    if (!w)
      w = $Writer.create();
    if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType"))
      w.uint32(10).string(m.MimeType);
    return w;
  };
  Metadata4.decode = function decode17(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.Metadata();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.MimeType = r.string();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Metadata4.fromObject = function fromObject(d) {
    if (d instanceof $root.Metadata)
      return d;
    var m = new $root.Metadata();
    if (d.MimeType != null) {
      m.MimeType = String(d.MimeType);
    }
    return m;
  };
  Metadata4.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      d.MimeType = "";
    }
    if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
      d.MimeType = m.MimeType;
    }
    return d;
  };
  Metadata4.prototype.toJSON = function toJSON2() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  return Metadata4;
})();
var PBData = Data;
var types = [
  "raw",
  "directory",
  "file",
  "metadata",
  "symlink",
  "hamt-sharded-directory"
];
var dirTypes = [
  "directory",
  "hamt-sharded-directory"
];
var DEFAULT_FILE_MODE = parseInt("0644", 8);
var DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
function parseMode(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "number") {
    return mode & 4095;
  }
  mode = mode.toString();
  if (mode.substring(0, 1) === "0") {
    return parseInt(mode, 8) & 4095;
  }
  return parseInt(mode, 10) & 4095;
}
function parseMtime(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
var UnixFS = class {
  /**
   * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md
   *
   * @param {Uint8Array} marshaled
   */
  static unmarshal(marshaled) {
    const message2 = PBData.decode(marshaled);
    const decoded = PBData.toObject(message2, {
      defaults: false,
      arrays: true,
      longs: Number,
      objects: false
    });
    const data = new UnixFS({
      type: types[decoded.Type],
      data: decoded.Data,
      blockSizes: decoded.blocksizes,
      mode: decoded.mode,
      mtime: decoded.mtime ? {
        secs: decoded.mtime.Seconds,
        nsecs: decoded.mtime.FractionalNanoseconds
      } : void 0
    });
    data._originalMode = decoded.mode || 0;
    return data;
  }
  /**
   * @param {object} [options]
   * @param {string} [options.type='file']
   * @param {Uint8Array} [options.data]
   * @param {number[]} [options.blockSizes]
   * @param {number} [options.hashType]
   * @param {number} [options.fanout]
   * @param {MtimeLike | null} [options.mtime]
   * @param {number | string} [options.mode]
   */
  constructor(options = {
    type: "file"
  }) {
    const {
      type,
      data,
      blockSizes,
      hashType,
      fanout,
      mtime,
      mode
    } = options;
    if (type && !types.includes(type)) {
      throw (0, import_err_code.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    this.type = type || "file";
    this.data = data;
    this.hashType = hashType;
    this.fanout = fanout;
    this.blockSizes = blockSizes || [];
    this._originalMode = 0;
    this.mode = parseMode(mode);
    if (mtime) {
      this.mtime = parseMtime(mtime);
      if (this.mtime && !this.mtime.nsecs) {
        this.mtime.nsecs = 0;
      }
    }
  }
  /**
   * @param {number | undefined} mode
   */
  set mode(mode) {
    this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
    const parsedMode = parseMode(mode);
    if (parsedMode !== void 0) {
      this._mode = parsedMode;
    }
  }
  /**
   * @returns {number | undefined}
   */
  get mode() {
    return this._mode;
  }
  isDirectory() {
    return Boolean(this.type && dirTypes.includes(this.type));
  }
  /**
   * @param {number} size
   */
  addBlockSize(size) {
    this.blockSizes.push(size);
  }
  /**
   * @param {number} index
   */
  removeBlockSize(index2) {
    this.blockSizes.splice(index2, 1);
  }
  /**
   * Returns `0` for directories or `data.length + sum(blockSizes)` for everything else
   */
  fileSize() {
    if (this.isDirectory()) {
      return 0;
    }
    let sum = 0;
    this.blockSizes.forEach((size) => {
      sum += size;
    });
    if (this.data) {
      sum += this.data.length;
    }
    return sum;
  }
  /**
   * encode to protobuf Uint8Array
   */
  marshal() {
    let type;
    switch (this.type) {
      case "raw":
        type = PBData.DataType.Raw;
        break;
      case "directory":
        type = PBData.DataType.Directory;
        break;
      case "file":
        type = PBData.DataType.File;
        break;
      case "metadata":
        type = PBData.DataType.Metadata;
        break;
      case "symlink":
        type = PBData.DataType.Symlink;
        break;
      case "hamt-sharded-directory":
        type = PBData.DataType.HAMTShard;
        break;
      default:
        throw (0, import_err_code.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    let data = this.data;
    if (!this.data || !this.data.length) {
      data = void 0;
    }
    let mode;
    if (this.mode != null) {
      mode = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);
      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {
        mode = void 0;
      }
      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
        mode = void 0;
      }
    }
    let mtime;
    if (this.mtime != null) {
      const parsed = parseMtime(this.mtime);
      if (parsed) {
        mtime = {
          Seconds: parsed.secs,
          FractionalNanoseconds: parsed.nsecs
        };
        if (mtime.FractionalNanoseconds === 0) {
          delete mtime.FractionalNanoseconds;
        }
      }
    }
    const pbData = {
      Type: type,
      Data: data,
      filesize: this.isDirectory() ? void 0 : this.fileSize(),
      blocksizes: this.blockSizes,
      hashType: this.hashType,
      fanout: this.fanout,
      mode,
      mtime
    };
    return PBData.encode(pbData).finish();
  }
};
var src_exports = {};
__export(src_exports, {
  code: () => code,
  createLink: () => createLink,
  createNode: () => createNode,
  decode: () => decode2$1,
  encode: () => encode$1,
  name: () => name,
  prepare: () => prepare,
  validate: () => validate
});
var textDecoder = new TextDecoder();
function decodeVarint(bytes2, offset) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes2.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b = bytes2[offset++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [v, offset];
}
function decodeBytes(bytes2, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint(bytes2, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes2.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [bytes2.subarray(offset, postOffset), postOffset];
}
function decodeKey(bytes2, index2) {
  let wire;
  [wire, index2] = decodeVarint(bytes2, index2);
  return [wire & 7, wire >> 3, index2];
}
function decodeLink(bytes2) {
  const link = {};
  const l = bytes2.length;
  let index2 = 0;
  while (index2 < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index2] = decodeKey(bytes2, index2);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      [link.Hash, index2] = decodeBytes(bytes2, index2);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index2] = decodeBytes(bytes2, index2);
      link.Name = textDecoder.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      [link.Tsize, index2] = decodeVarint(bytes2, index2);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index2 > l) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode(bytes2) {
  const l = bytes2.length;
  let index2 = 0;
  let links3;
  let linksBeforeData = false;
  let data;
  while (index2 < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index2] = decodeKey(bytes2, index2);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      [data, index2] = decodeBytes(bytes2, index2);
      if (links3) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links3) {
        links3 = [];
      }
      let byts;
      [byts, index2] = decodeBytes(bytes2, index2);
      links3.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index2 > l) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links3 || [];
  return node;
}
var textEncoder = new TextEncoder();
var maxInt32 = 2 ** 32;
var maxUInt32 = 2 ** 31;
function encodeLink(link, bytes2) {
  let i2 = bytes2.length;
  if (typeof link.Tsize === "number") {
    if (link.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i2 = encodeVarint(bytes2, i2, link.Tsize) - 1;
    bytes2[i2] = 24;
  }
  if (typeof link.Name === "string") {
    const nameBytes = textEncoder.encode(link.Name);
    i2 -= nameBytes.length;
    bytes2.set(nameBytes, i2);
    i2 = encodeVarint(bytes2, i2, nameBytes.length) - 1;
    bytes2[i2] = 18;
  }
  if (link.Hash) {
    i2 -= link.Hash.length;
    bytes2.set(link.Hash, i2);
    i2 = encodeVarint(bytes2, i2, link.Hash.length) - 1;
    bytes2[i2] = 10;
  }
  return bytes2.length - i2;
}
function encodeNode(node) {
  const size = sizeNode(node);
  const bytes2 = new Uint8Array(size);
  let i2 = size;
  if (node.Data) {
    i2 -= node.Data.length;
    bytes2.set(node.Data, i2);
    i2 = encodeVarint(bytes2, i2, node.Data.length) - 1;
    bytes2[i2] = 10;
  }
  if (node.Links) {
    for (let index2 = node.Links.length - 1; index2 >= 0; index2--) {
      const size2 = encodeLink(node.Links[index2], bytes2.subarray(0, i2));
      i2 -= size2;
      i2 = encodeVarint(bytes2, i2, size2) - 1;
      bytes2[i2] = 18;
    }
  }
  return bytes2;
}
function sizeLink(link) {
  let n = 0;
  if (link.Hash) {
    const l = link.Hash.length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Name === "string") {
    const l = textEncoder.encode(link.Name).length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Tsize === "number") {
    n += 1 + sov(link.Tsize);
  }
  return n;
}
function sizeNode(node) {
  let n = 0;
  if (node.Data) {
    const l = node.Data.length;
    n += 1 + l + sov(l);
  }
  if (node.Links) {
    for (const link of node.Links) {
      const l = sizeLink(link);
      n += 1 + l + sov(l);
    }
  }
  return n;
}
function encodeVarint(bytes2, offset, v) {
  offset -= sov(v);
  const base3 = offset;
  while (v >= maxUInt32) {
    bytes2[offset++] = v & 127 | 128;
    v /= 128;
  }
  while (v >= 128) {
    bytes2[offset++] = v & 127 | 128;
    v >>>= 7;
  }
  bytes2[offset] = v;
  return base3;
}
function sov(x) {
  if (x % 2 === 0) {
    x++;
  }
  return Math.floor((len64(x) + 6) / 7);
}
function len64(x) {
  let n = 0;
  if (x >= maxInt32) {
    x = Math.floor(x / maxInt32);
    n = 32;
  }
  if (x >= 1 << 16) {
    x >>>= 16;
    n += 16;
  }
  if (x >= 1 << 8) {
    x >>>= 8;
    n += 8;
  }
  return n + len8tab[x];
}
var len8tab = [
  0,
  1,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8
];
var pbNodeProperties = ["Data", "Links"];
var pbLinkProperties = ["Hash", "Name", "Tsize"];
var textEncoder2 = new TextEncoder();
function linkComparator(a, b) {
  if (a === b) {
    return 0;
  }
  const abuf = a.Name ? textEncoder2.encode(a.Name) : [];
  const bbuf = b.Name ? textEncoder2.encode(b.Name) : [];
  let x = abuf.length;
  let y = bbuf.length;
  for (let i2 = 0, len = Math.min(x, y); i2 < len; ++i2) {
    if (abuf[i2] !== bbuf[i2]) {
      x = abuf[i2];
      y = bbuf[i2];
      break;
    }
  }
  return x < y ? -1 : y < x ? 1 : 0;
}
function hasOnlyProperties(node, properties) {
  return !Object.keys(node).some((p) => !properties.includes(p));
}
function asLink(link) {
  if (typeof link.asCID === "object") {
    const Hash = CID.asCID(link);
    if (!Hash) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash };
  }
  if (typeof link !== "object" || Array.isArray(link)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link.Hash) {
    let cid = CID.asCID(link.Hash);
    try {
      if (!cid) {
        if (typeof link.Hash === "string") {
          cid = CID.parse(link.Hash);
        } else if (link.Hash instanceof Uint8Array) {
          cid = CID.decode(link.Hash);
        }
      }
    } catch (e) {
      throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link.Name === "string") {
    pbl.Name = link.Name;
  }
  if (typeof link.Tsize === "number") {
    pbl.Tsize = link.Tsize;
  }
  return pbl;
}
function prepare(node) {
  if (node instanceof Uint8Array || typeof node === "string") {
    node = { Data: node };
  }
  if (typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node.Data !== void 0) {
    if (typeof node.Data === "string") {
      pbn.Data = textEncoder2.encode(node.Data);
    } else if (node.Data instanceof Uint8Array) {
      pbn.Data = node.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node.Links !== void 0) {
    if (Array.isArray(node.Links)) {
      pbn.Links = node.Links.map(asLink);
      pbn.Links.sort(linkComparator);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate(node) {
  if (!node || typeof node !== "object" || Array.isArray(node) || node instanceof Uint8Array || node["/"] && node["/"] === node.bytes) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties(node, pbNodeProperties)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be bytes)");
  }
  if (!Array.isArray(node.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be a list)");
  }
  for (let i2 = 0; i2 < node.Links.length; i2++) {
    const link = node.Links[i2];
    if (!link || typeof link !== "object" || Array.isArray(link) || link instanceof Uint8Array || link["/"] && link["/"] === link.bytes) {
      throw new TypeError("Invalid DAG-PB form (bad link)");
    }
    if (!hasOnlyProperties(link, pbLinkProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link)");
    }
    if (link.Hash === void 0) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link.Hash == null || !link.Hash["/"] || link.Hash["/"] !== link.Hash.bytes) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link.Name !== void 0 && typeof link.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link.Tsize !== void 0) {
      if (typeof link.Tsize !== "number" || link.Tsize % 1 !== 0) {
        throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
      }
      if (link.Tsize < 0) {
        throw new TypeError("Invalid DAG-PB form (link Tsize cannot be negative)");
      }
    }
    if (i2 > 0 && linkComparator(link, node.Links[i2 - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function createNode(data, links3 = []) {
  return prepare({ Data: data, Links: links3 });
}
function createLink(name9, size, cid) {
  return asLink({ Hash: cid, Name: name9, Tsize: size });
}
var name = "dag-pb";
var code = 112;
function encode$1(node) {
  validate(node);
  const pbn = {};
  if (node.Links) {
    pbn.Links = node.Links.map((l) => {
      const link = {};
      if (l.Hash) {
        link.Hash = l.Hash.bytes;
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  if (node.Data) {
    pbn.Data = node.Data;
  }
  return encodeNode(pbn);
}
function decode2$1(bytes2) {
  const pbn = decodeNode(bytes2);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l) => {
      const link = {};
      try {
        link.Hash = CID.decode(l.Hash);
      } catch (e) {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  return node;
}
var src_exports2 = {};
__export(src_exports2, {
  code: () => code2,
  decode: () => decode4,
  encode: () => encode3,
  name: () => name2
});
var typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value2) {
  if (value2 === null) {
    return "null";
  }
  if (value2 === void 0) {
    return "undefined";
  }
  if (value2 === true || value2 === false) {
    return "boolean";
  }
  const typeOf2 = typeof value2;
  if (typeofs.includes(typeOf2)) {
    return typeOf2;
  }
  if (typeOf2 === "function") {
    return "Function";
  }
  if (Array.isArray(value2)) {
    return "Array";
  }
  if (isBuffer$1(value2)) {
    return "Buffer";
  }
  const objectType = getObjectType(value2);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer$1(value2) {
  return value2 && value2.constructor && value2.constructor.isBuffer && value2.constructor.isBuffer.call(null, value2);
}
function getObjectType(value2) {
  const objectTypeName = Object.prototype.toString.call(value2).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
var Type = class {
  constructor(major, name9, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name9;
    this.terminal = terminal;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
};
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
var Token = class {
  constructor(type, value2, encodedLength) {
    this.type = type;
    this.value = value2;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};
var useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
var textDecoder2 = new TextDecoder();
var textEncoder3 = new TextEncoder();
function isBuffer2(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
var toString2 = useBuffer ? (bytes2, start, end) => {
  return end - start > 64 ? globalThis.Buffer.from(bytes2.subarray(start, end)).toString("utf8") : utf8Slice(bytes2, start, end);
} : (bytes2, start, end) => {
  return end - start > 64 ? textDecoder2.decode(bytes2.subarray(start, end)) : utf8Slice(bytes2, start, end);
};
var fromString2 = useBuffer ? (string2) => {
  return string2.length > 64 ? globalThis.Buffer.from(string2) : utf8ToBytes(string2);
} : (string2) => {
  return string2.length > 64 ? textEncoder3.encode(string2) : utf8ToBytes(string2);
};
var fromArray = (arr) => {
  return Uint8Array.from(arr);
};
var slice = useBuffer ? (bytes2, start, end) => {
  if (isBuffer2(bytes2)) {
    return new Uint8Array(bytes2.subarray(start, end));
  }
  return bytes2.slice(start, end);
} : (bytes2, start, end) => {
  return bytes2.slice(start, end);
};
var concat2 = useBuffer ? (chunks, length3) => {
  chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
  return asU8A(globalThis.Buffer.concat(chunks, length3));
} : (chunks, length3) => {
  const out = new Uint8Array(length3);
  let off = 0;
  for (let b of chunks) {
    if (off + b.length > out.length) {
      b = b.subarray(0, out.length - off);
    }
    out.set(b, off);
    off += b.length;
  }
  return out;
};
var alloc2 = useBuffer ? (size) => {
  return globalThis.Buffer.allocUnsafe(size);
} : (size) => {
  return new Uint8Array(size);
};
function compare(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i2 = 0; i2 < b1.length; i2++) {
    if (b1[i2] === b2[i2]) {
      continue;
    }
    return b1[i2] < b2[i2] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes(string2, units = Infinity) {
  let codePoint;
  const length3 = string2.length;
  let leadSurrogate = null;
  const bytes2 = [];
  for (let i2 = 0; i2 < length3; ++i2) {
    codePoint = string2.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length3) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes2.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes2.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes2.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes2.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes2.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes2;
}
function utf8Slice(buf2, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i2 = 0;
  while (i2 < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
var defaultChunkSize = 256;
var Bl = class {
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  push(bytes2) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes2.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes2, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes2.length < 64 && bytes2.length < this.chunkSize) {
        topChunk = alloc2(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes2, 0);
      } else {
        this.chunks.push(bytes2);
        this.maxCursor += bytes2.length;
      }
    }
    this.cursor += bytes2.length;
  }
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat2(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
};
var decodeErrPrefix = "CBOR decode error:";
var encodeErrPrefix = "CBOR encode error:";
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}
var uintBoundaries = [
  24,
  256,
  65536,
  4294967296,
  BigInt("18446744073709551616")
];
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value2 = data[offset];
  if (options.strict === true && value2 < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value2;
}
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value2 = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value2 < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value2;
}
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value2 = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value2 < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value2;
}
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value2 = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value2 < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value2 <= Number.MAX_SAFE_INTEGER) {
    return Number(value2);
  }
  if (options.allowBigInt === true) {
    return value2;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64$1(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf2, token) {
  return encodeUintValue(buf2, 0, token.value);
}
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set2 = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set2[8] = lo & 255;
      lo = lo >> 8;
      set2[7] = lo & 255;
      lo = lo >> 8;
      set2[6] = lo & 255;
      lo = lo >> 8;
      set2[5] = lo & 255;
      set2[4] = hi & 255;
      hi = hi >> 8;
      set2[3] = hi & 255;
      hi = hi >> 8;
      set2[2] = hi & 255;
      hi = hi >> 8;
      set2[1] = hi & 255;
      buf2.push(set2);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
};
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
var neg1b = BigInt(-1);
var pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value2 = -1 - int;
    if (value2 >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value2, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf2, token) {
  const negint = token.value;
  const unsigned2 = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token.type.majorEncoded, unsigned2);
}
encodeNegint.encodedSize = function encodedSize3(token) {
  const negint = token.value;
  const unsigned2 = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned2 < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned2 < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned2 < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned2 < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
};
function toToken(data, pos, prefix, length3) {
  assertEnoughData(data, pos, prefix + length3);
  const buf2 = slice(data, pos + prefix, pos + prefix + length3);
  return new Token(Type.bytes, buf2, prefix + length3);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString2(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf2, token) {
  const bytes2 = tokenBytes(token);
  encodeUintValue(buf2, token.type.majorEncoded, bytes2.length);
  buf2.push(bytes2);
}
encodeBytes.encodedSize = function encodedSize4(token) {
  const bytes2 = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes2.length) + bytes2.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
}
function toToken2(data, pos, prefix, length3, options) {
  const totLength = prefix + length3;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString2(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l, options);
}
var encodeString = encodeBytes;
function toToken3(_data, _pos, prefix, length3) {
  return new Token(Type.array, length3, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf2, token) {
  encodeUintValue(buf2, Type.array.majorEncoded, token.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
};
function toToken4(_data, _pos, prefix, length3) {
  return new Token(Type.map, length3, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf2, token) {
  encodeUintValue(buf2, Type.map.majorEncoded, token.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
};
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf2, token) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
};
var MINOR_FALSE = 20;
var MINOR_TRUE = 21;
var MINOR_NULL = 22;
var MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value2, bytes2, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value2)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value2 === Infinity || value2 === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value2, bytes2);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf2, token, options) {
  const float = token.value;
  if (float === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token, options) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float);
    let decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
};
var buffer = new ArrayBuffer(9);
var dataView = new DataView(buffer, 1);
var ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
var jump = [];
for (let i2 = 0; i2 <= 23; i2++) {
  jump[i2] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64$1;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i2 = 32; i2 <= 55; i2++) {
  jump[i2] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i2 = 64; i2 <= 87; i2++) {
  jump[i2] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i2 = 96; i2 <= 119; i2++) {
  jump[i2] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i2 = 128; i2 <= 151; i2++) {
  jump[i2] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i2 = 160; i2 <= 183; i2++) {
  jump[i2] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i2 = 192; i2 <= 215; i2++) {
  jump[i2] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i2 = 224; i2 <= 243; i2++) {
  jump[i2] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
var quick = [];
for (let i2 = 0; i2 < 24; i2++) {
  quick[i2] = new Token(Type.uint, i2, 1);
}
for (let i2 = -1; i2 >= -24; i2--) {
  quick[31 - i2] = new Token(Type.negint, i2, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}
var defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
var cborEncoders = makeCborEncoders();
var buf = new Bl();
var Ref = class {
  constructor(obj, parent2) {
    this.obj = obj;
    this.parent = parent2;
  }
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new Ref(obj, stack);
  }
};
var simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
var typeEncoders = {
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyArray,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i2 = 0;
    for (const e of obj) {
      entries[i2++] = objectToTokens(e, options, refStack);
    }
    if (options.addBreakTokens) {
      return [
        new Token(Type.array, obj.length),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.array, obj.length),
      entries
    ];
  },
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length3 = isMap ? obj.size : keys.length;
    if (!length3) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyMap,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i2 = 0;
    for (const key of keys) {
      entries[i2++] = [
        objectToTokens(key, options, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [
        new Token(Type.map, length3),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.map, length3),
      entries
    ];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf2, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder2 = encoders[tokens.type.major];
    if (encoder2.encodedSize) {
      const size = encoder2.encodedSize(tokens, options);
      const buf2 = new Bl(size);
      encoder2(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode2$2(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}
var defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
var Tokeniser = class {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    const byt = this.data[this.pos];
    let token = quick[byt];
    if (token === void 0) {
      const decoder = jump[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder(this.data, this.pos, minor, this.options);
    }
    this.pos += token.encodedLength;
    return token;
  }
};
var DONE = Symbol.for("DONE");
var BREAK = Symbol.for("BREAK");
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i2 = 0; i2 < token.value; i2++) {
    const value2 = tokensToObject(tokeniser, options);
    if (value2 === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value2 === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i2}, expected ${token.value})`);
    }
    arr[i2] = value2;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i2 = 0; i2 < token.value; i2++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
      }
    }
    const value2 = tokensToObject(tokeniser, options);
    if (value2 === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value2);
    } else {
      obj[key] = value2;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decode3$1(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}
var CID_CBOR_TAG = 42;
function cidEncoder(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes2)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
function cidDecoder(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes2.subarray(1));
}
var decodeOptions = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  // this will lead to BigInt for ints outside of
  // safe-integer range, which may surprise users
  strict: true,
  useMaps: false,
  rejectDuplicateMapKeys: true,
  /** @type {import('cborg').TagDecoder[]} */
  tags: []
};
decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
var name2 = "dag-cbor";
var code2 = 113;
var encode3 = (node) => encode2$2(node, encodeOptions);
var decode4 = (data) => decode3$1(data, decodeOptions);
var src_exports3 = {};
__export(src_exports3, {
  code: () => code3,
  decode: () => decode6,
  encode: () => encode5,
  format: () => format,
  name: () => name3,
  parse: () => parse,
  stringify: () => format
});
var JSONEncoder = class extends Array {
  constructor() {
    super();
    this.inRecursive = [];
  }
  prefix(buf2) {
    const recurs = this.inRecursive[this.inRecursive.length - 1];
    if (recurs) {
      if (recurs.type === Type.array) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          buf2.push([44]);
        }
      }
      if (recurs.type === Type.map) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          if (recurs.elements % 2 === 1) {
            buf2.push([44]);
          } else {
            buf2.push([58]);
          }
        }
      }
    }
  }
  [Type.uint.major](buf2, token) {
    this.prefix(buf2);
    const is2 = String(token.value);
    const isa = [];
    for (let i2 = 0; i2 < is2.length; i2++) {
      isa[i2] = is2.charCodeAt(i2);
    }
    buf2.push(isa);
  }
  [Type.negint.major](buf2, token) {
    this[Type.uint.major](buf2, token);
  }
  [Type.bytes.major](_buf, _token) {
    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`);
  }
  [Type.string.major](buf2, token) {
    this.prefix(buf2);
    const byts = fromString2(JSON.stringify(token.value));
    buf2.push(byts.length > 32 ? asU8A(byts) : byts);
  }
  [Type.array.major](buf2, _token) {
    this.prefix(buf2);
    this.inRecursive.push({
      type: Type.array,
      elements: 0
    });
    buf2.push([91]);
  }
  [Type.map.major](buf2, _token) {
    this.prefix(buf2);
    this.inRecursive.push({
      type: Type.map,
      elements: 0
    });
    buf2.push([123]);
  }
  [Type.tag.major](_buf, _token) {
  }
  [Type.float.major](buf2, token) {
    if (token.type.name === "break") {
      const recurs = this.inRecursive.pop();
      if (recurs) {
        if (recurs.type === Type.array) {
          buf2.push([93]);
        } else if (recurs.type === Type.map) {
          buf2.push([125]);
        } else {
          throw new Error("Unexpected recursive type; this should not happen!");
        }
        return;
      }
      throw new Error("Unexpected break; this should not happen!");
    }
    if (token.value === void 0) {
      throw new Error(`${encodeErrPrefix} unsupported type: undefined`);
    }
    this.prefix(buf2);
    if (token.type.name === "true") {
      buf2.push([
        116,
        114,
        117,
        101
      ]);
      return;
    } else if (token.type.name === "false") {
      buf2.push([
        102,
        97,
        108,
        115,
        101
      ]);
      return;
    } else if (token.type.name === "null") {
      buf2.push([
        110,
        117,
        108,
        108
      ]);
      return;
    }
    const is2 = String(token.value);
    const isa = [];
    let dp = false;
    for (let i2 = 0; i2 < is2.length; i2++) {
      isa[i2] = is2.charCodeAt(i2);
      if (!dp && (isa[i2] === 46 || isa[i2] === 101 || isa[i2] === 69)) {
        dp = true;
      }
    }
    if (!dp) {
      isa.push(46);
      isa.push(48);
    }
    buf2.push(isa);
  }
};
function mapSorter2(e1, e2) {
  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {
    throw new Error(`${encodeErrPrefix} complex map keys are not supported`);
  }
  const keyToken1 = e1[0];
  const keyToken2 = e2[0];
  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {
    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`);
  }
  if (keyToken1 < keyToken2) {
    return -1;
  }
  if (keyToken1 > keyToken2) {
    return 1;
  }
  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`);
}
var defaultEncodeOptions2 = {
  addBreakTokens: true,
  mapSorter: mapSorter2
};
function encode4(data, options) {
  options = Object.assign({}, defaultEncodeOptions2, options);
  return encodeCustom(data, new JSONEncoder(), options);
}
var Tokenizer = class {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
    this.modeStack = ["value"];
    this.lastToken = "";
  }
  done() {
    return this.pos >= this.data.length;
  }
  ch() {
    return this.data[this.pos];
  }
  currentMode() {
    return this.modeStack[this.modeStack.length - 1];
  }
  skipWhitespace() {
    let c = this.ch();
    while (c === 32 || c === 9 || c === 13 || c === 10) {
      c = this.data[++this.pos];
    }
  }
  expect(str) {
    if (this.data.length - this.pos < str.length) {
      throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this.pos}`);
    }
    for (let i2 = 0; i2 < str.length; i2++) {
      if (this.data[this.pos++] !== str[i2]) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}, expected to find '${String.fromCharCode(...str)}'`);
      }
    }
  }
  parseNumber() {
    const startPos = this.pos;
    let negative = false;
    let float = false;
    const swallow = (chars2) => {
      while (!this.done()) {
        const ch = this.ch();
        if (chars2.includes(ch)) {
          this.pos++;
        } else {
          break;
        }
      }
    };
    if (this.ch() === 45) {
      negative = true;
      this.pos++;
    }
    if (this.ch() === 48) {
      this.pos++;
      if (this.ch() === 46) {
        this.pos++;
        float = true;
      } else {
        return new Token(Type.uint, 0, this.pos - startPos);
      }
    }
    swallow([
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57
    ]);
    if (negative && this.pos === startPos + 1) {
      throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);
    }
    if (!this.done() && this.ch() === 46) {
      if (float) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);
      }
      float = true;
      this.pos++;
      swallow([
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57
      ]);
    }
    if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {
      float = true;
      this.pos++;
      if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {
        this.pos++;
      }
      swallow([
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57
      ]);
    }
    const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this.pos));
    const num = parseFloat(numStr);
    if (float) {
      return new Token(Type.float, num, this.pos - startPos);
    }
    if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {
      return new Token(num >= 0 ? Type.uint : Type.negint, num, this.pos - startPos);
    }
    return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this.pos - startPos);
  }
  parseString() {
    if (this.ch() !== 34) {
      throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}; this shouldn't happen`);
    }
    this.pos++;
    for (let i2 = this.pos, l = 0; i2 < this.data.length && l < 65536; i2++, l++) {
      const ch = this.data[i2];
      if (ch === 92 || ch < 32 || ch >= 128) {
        break;
      }
      if (ch === 34) {
        const str = String.fromCharCode.apply(null, this.data.subarray(this.pos, i2));
        this.pos = i2 + 1;
        return new Token(Type.string, str, l);
      }
    }
    const startPos = this.pos;
    const chars2 = [];
    const readu4 = () => {
      if (this.pos + 4 >= this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this.pos}`);
      }
      let u4 = 0;
      for (let i2 = 0; i2 < 4; i2++) {
        let ch = this.ch();
        if (ch >= 48 && ch <= 57) {
          ch -= 48;
        } else if (ch >= 97 && ch <= 102) {
          ch = ch - 97 + 10;
        } else if (ch >= 65 && ch <= 70) {
          ch = ch - 65 + 10;
        } else {
          throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this.pos}`);
        }
        u4 = u4 * 16 + ch;
        this.pos++;
      }
      return u4;
    };
    const readUtf8Char = () => {
      const firstByte = this.ch();
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (this.pos + bytesPerSequence > this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this.pos}`);
      }
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = this.data[this.pos + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = this.data[this.pos + 1];
          thirdByte = this.data[this.pos + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = this.data[this.pos + 1];
          thirdByte = this.data[this.pos + 2];
          fourthByte = this.data[this.pos + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        chars2.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      chars2.push(codePoint);
      this.pos += bytesPerSequence;
    };
    while (!this.done()) {
      const ch = this.ch();
      let ch1;
      switch (ch) {
        case 92:
          this.pos++;
          if (this.done()) {
            throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this.pos}`);
          }
          ch1 = this.ch();
          this.pos++;
          switch (ch1) {
            case 34:
            case 39:
            case 92:
            case 47:
              chars2.push(ch1);
              break;
            case 98:
              chars2.push(8);
              break;
            case 116:
              chars2.push(9);
              break;
            case 110:
              chars2.push(10);
              break;
            case 102:
              chars2.push(12);
              break;
            case 114:
              chars2.push(13);
              break;
            case 117:
              chars2.push(readu4());
              break;
            default:
              throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this.pos}`);
          }
          break;
        case 34:
          this.pos++;
          return new Token(Type.string, decodeCodePointsArray(chars2), this.pos - startPos);
        default:
          if (ch < 32) {
            throw new Error(`${decodeErrPrefix} invalid control character at position ${this.pos}`);
          } else if (ch < 128) {
            chars2.push(ch);
            this.pos++;
          } else {
            readUtf8Char();
          }
      }
    }
    throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this.pos}`);
  }
  parseValue() {
    switch (this.ch()) {
      case 123:
        this.modeStack.push("obj-start");
        this.pos++;
        return new Token(Type.map, Infinity, 1);
      case 91:
        this.modeStack.push("array-start");
        this.pos++;
        return new Token(Type.array, Infinity, 1);
      case 34: {
        return this.parseString();
      }
      case 110:
        this.expect([
          110,
          117,
          108,
          108
        ]);
        return new Token(Type.null, null, 4);
      case 102:
        this.expect([
          102,
          97,
          108,
          115,
          101
        ]);
        return new Token(Type.false, false, 5);
      case 116:
        this.expect([
          116,
          114,
          117,
          101
        ]);
        return new Token(Type.true, true, 4);
      case 45:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return this.parseNumber();
      default:
        throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}`);
    }
  }
  next() {
    this.skipWhitespace();
    switch (this.currentMode()) {
      case "value":
        this.modeStack.pop();
        return this.parseValue();
      case "array-value": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "array-start": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "obj-key":
        if (this.ch() === 125) {
          this.modeStack.pop();
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.skipWhitespace();
      case "obj-start": {
        this.modeStack.pop();
        if (this.ch() === 125) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        const token = this.parseString();
        this.skipWhitespace();
        if (this.ch() !== 58) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.modeStack.push("obj-value");
        return token;
      }
      case "obj-value": {
        this.modeStack.pop();
        this.modeStack.push("obj-key");
        this.skipWhitespace();
        return this.parseValue();
      }
      default:
        throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this.pos}; this shouldn't happen`);
    }
  }
};
function decode5(data, options) {
  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options);
  return decode3$1(data, options);
}
function cidEncoder2(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const cidString = cid.toString();
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    // key
    new Token(Type.string, cidString, cidString.length),
    // value
    new Token(Type.break, void 0, 1)
  ];
}
function bytesEncoder(bytes2) {
  const bytesString = base64.encode(bytes2).slice(1);
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    // key
    new Token(Type.map, Infinity, 1),
    // value
    new Token(Type.string, "bytes", 5),
    // inner key
    new Token(Type.string, bytesString, bytesString.length),
    // inner value
    new Token(Type.break, void 0, 1),
    new Token(Type.break, void 0, 1)
  ];
}
function undefinedEncoder2() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder2(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions2 = {
  typeEncoders: {
    Object: cidEncoder2,
    Uint8Array: bytesEncoder,
    // TODO: all the typedarrays
    Buffer: bytesEncoder,
    // TODO: all the typedarrays
    undefined: undefinedEncoder2,
    number: numberEncoder2
  }
};
var DagJsonTokenizer = class extends Tokenizer {
  /**
   * @param {Uint8Array} data
   * @param {object} [options]
   */
  constructor(data, options) {
    super(data, options);
    this.tokenBuffer = [];
  }
  /**
   * @returns {boolean}
   */
  done() {
    return this.tokenBuffer.length === 0 && super.done();
  }
  /**
   * @returns {Token}
   */
  _next() {
    if (this.tokenBuffer.length > 0) {
      return this.tokenBuffer.pop();
    }
    return super.next();
  }
  /**
   * Implements rules outlined in https://github.com/ipld/specs/pull/356
   *
   * @returns {Token}
   */
  next() {
    const token = this._next();
    if (token.type === Type.map) {
      const keyToken = this._next();
      if (keyToken.type === Type.string && keyToken.value === "/") {
        const valueToken = this._next();
        if (valueToken.type === Type.string) {
          const breakToken = this._next();
          if (breakToken.type !== Type.break) {
            throw new Error("Invalid encoded CID form");
          }
          this.tokenBuffer.push(valueToken);
          return new Token(Type.tag, 42, 0);
        }
        if (valueToken.type === Type.map) {
          const innerKeyToken = this._next();
          if (innerKeyToken.type === Type.string && innerKeyToken.value === "bytes") {
            const innerValueToken = this._next();
            if (innerValueToken.type === Type.string) {
              for (let i2 = 0; i2 < 2; i2++) {
                const breakToken = this._next();
                if (breakToken.type !== Type.break) {
                  throw new Error("Invalid encoded Bytes form");
                }
              }
              const bytes2 = base64.decode(`m${innerValueToken.value}`);
              return new Token(Type.bytes, bytes2, innerValueToken.value.length);
            }
            this.tokenBuffer.push(innerValueToken);
          }
          this.tokenBuffer.push(innerKeyToken);
        }
        this.tokenBuffer.push(valueToken);
      }
      this.tokenBuffer.push(keyToken);
    }
    return token;
  }
};
var decodeOptions2 = {
  allowIndefinite: false,
  allowUndefined: false,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  // this will lead to BigInt for ints outside of
  // safe-integer range, which may surprise users
  strict: true,
  useMaps: false,
  rejectDuplicateMapKeys: true,
  /** @type {import('cborg').TagDecoder[]} */
  tags: []
};
decodeOptions2.tags[42] = CID.parse;
var name3 = "dag-json";
var code3 = 297;
var encode5 = (node) => encode4(node, encodeOptions2);
var decode6 = (data) => {
  const options = Object.assign(decodeOptions2, { tokenizer: new DagJsonTokenizer(data, decodeOptions2) });
  return decode5(data, options);
};
var format = (node) => utf8Decoder.decode(encode5(node));
var utf8Decoder = new TextDecoder();
var parse = (data) => decode6(utf8Encoder.encode(data));
var utf8Encoder = new TextEncoder();
var lib_exports = {};
__export(lib_exports, {
  code: () => code4,
  decode: () => decode9,
  encode: () => encode8,
  name: () => name4,
  toGeneral: () => toGeneral
});
function toBase64url(b) {
  return base64url.encode(b).slice(1);
}
function fromBase64url(s) {
  return base64url.decode(`u${s}`);
}
function fromSplit(split) {
  const [protectedHeader, payload, signature] = split;
  return {
    payload,
    signatures: [{ protected: protectedHeader, signature }],
    link: CID.decode(fromBase64url(payload))
  };
}
function encodeSignature(signature) {
  const encoded = {
    signature: fromBase64url(signature.signature)
  };
  if (signature.header)
    encoded.header = signature.header;
  if (signature.protected)
    encoded.protected = fromBase64url(signature.protected);
  return encoded;
}
function encode6(jws) {
  const payload = fromBase64url(jws.payload);
  try {
    CID.decode(payload);
  } catch (e) {
    throw new Error("Not a valid DagJWS");
  }
  return {
    payload,
    signatures: jws.signatures.map(encodeSignature)
  };
}
function decodeSignature(encoded) {
  const sign4 = {
    signature: toBase64url(encoded.signature)
  };
  if (encoded.header)
    sign4.header = encoded.header;
  if (encoded.protected)
    sign4.protected = toBase64url(encoded.protected);
  return sign4;
}
function decode7(encoded) {
  const decoded = {
    payload: toBase64url(encoded.payload),
    signatures: encoded.signatures.map(decodeSignature)
  };
  decoded.link = CID.decode(new Uint8Array(encoded.payload));
  return decoded;
}
function fromSplit2(split) {
  const [protectedHeader, encrypted_key, iv, ciphertext, tag] = split;
  const jwe = {
    ciphertext,
    iv,
    protected: protectedHeader,
    tag
  };
  if (encrypted_key)
    jwe.recipients = [{ encrypted_key }];
  return jwe;
}
function encodeRecipient(recipient) {
  const encRec = {};
  if (recipient.encrypted_key)
    encRec.encrypted_key = fromBase64url(recipient.encrypted_key);
  if (recipient.header)
    encRec.header = recipient.header;
  return encRec;
}
function encode7(jwe) {
  const encJwe = {
    ciphertext: fromBase64url(jwe.ciphertext),
    protected: fromBase64url(jwe.protected),
    iv: fromBase64url(jwe.iv),
    tag: fromBase64url(jwe.tag)
  };
  if (jwe.aad)
    encJwe.aad = fromBase64url(jwe.aad);
  if (jwe.recipients)
    encJwe.recipients = jwe.recipients.map(encodeRecipient);
  if (jwe.unprotected)
    encJwe.unprotected = jwe.unprotected;
  return encJwe;
}
function decodeRecipient(encoded) {
  const recipient = {};
  if (encoded.encrypted_key)
    recipient.encrypted_key = toBase64url(encoded.encrypted_key);
  if (encoded.header)
    recipient.header = encoded.header;
  return recipient;
}
function decode8(encoded) {
  const jwe = {
    ciphertext: toBase64url(encoded.ciphertext),
    protected: toBase64url(encoded.protected),
    iv: toBase64url(encoded.iv),
    tag: toBase64url(encoded.tag)
  };
  if (encoded.aad)
    jwe.aad = toBase64url(encoded.aad);
  if (encoded.recipients)
    jwe.recipients = encoded.recipients.map(decodeRecipient);
  if (encoded.unprotected)
    jwe.unprotected = encoded.unprotected;
  return jwe;
}
var name4 = "dag-jose";
var code4 = 133;
function isDagJWS(jose) {
  return "payload" in jose && typeof jose.payload === "string" && "signatures" in jose && Array.isArray(jose.signatures);
}
function isEncodedJWS(jose) {
  return "payload" in jose && jose.payload instanceof Uint8Array && "signatures" in jose && Array.isArray(jose.signatures);
}
function isEncodedJWE(jose) {
  return "ciphertext" in jose && jose.ciphertext instanceof Uint8Array && "iv" in jose && jose.iv instanceof Uint8Array && "protected" in jose && jose.protected instanceof Uint8Array && "tag" in jose && jose.tag instanceof Uint8Array;
}
function isDagJWE(jose) {
  return "ciphertext" in jose && typeof jose.ciphertext === "string" && "iv" in jose && typeof jose.iv === "string" && "protected" in jose && typeof jose.protected === "string" && "tag" in jose && typeof jose.tag === "string";
}
function toGeneral(jose) {
  if (typeof jose === "string") {
    const split = jose.split(".");
    if (split.length === 3) {
      return fromSplit(split);
    } else if (split.length === 5) {
      return fromSplit2(split);
    }
    throw new Error("Not a valid JOSE string");
  }
  if (isDagJWS(jose) || isDagJWE(jose)) {
    return jose;
  }
  throw new Error("Not a valid unencoded JOSE object");
}
function encode8(obj) {
  if (typeof obj === "string") {
    obj = toGeneral(obj);
  }
  let encodedJose;
  if (isDagJWS(obj)) {
    encodedJose = encode6(obj);
  } else if (isDagJWE(obj)) {
    encodedJose = encode7(obj);
  } else {
    throw new Error("Not a valid JOSE object");
  }
  return new Uint8Array(encode3(encodedJose));
}
function decode9(data) {
  let encoded;
  try {
    encoded = decode4(data);
  } catch (e) {
    throw new Error("Not a valid DAG-JOSE object");
  }
  if (isEncodedJWS(encoded)) {
    return decode7(encoded);
  } else if (isEncodedJWE(encoded)) {
    return decode8(encoded);
  } else {
    throw new Error("Not a valid DAG-JOSE object");
  }
}
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var code5 = 0;
var name5 = "identity";
var encode9 = coerce;
var digest = (input) => create(code5, encode9(input));
var identity = { code: code5, name: name5, encode: encode9, digest };
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var identity2 = from({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString$2(buf2),
  decode: (str) => fromString(str)
});
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var alphabetBytesToChars = (
  /** @type {string[]} */
  alphabet.reduce(
    (p, c, i2) => {
      p[i2] = c;
      return p;
    },
    /** @type {string[]} */
    []
  )
);
var alphabetCharsToBytes = (
  /** @type {number[]} */
  alphabet.reduce(
    (p, c, i2) => {
      p[
        /** @type {number} */
        c.codePointAt(0)
      ] = i2;
      return p;
    },
    /** @type {number[]} */
    []
  )
);
function encode10(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode10(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[
      /** @type {number} */
      char.codePointAt(0)
    ];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from({
  prefix: "🚀",
  name: "base256emoji",
  encode: encode10,
  decode: decode10
});
var raw_exports = {};
__export(raw_exports, {
  code: () => code6,
  decode: () => decode11,
  encode: () => encode11,
  name: () => name6
});
var name6 = "raw";
var code6 = 85;
var encode11 = (node) => coerce(node);
var decode11 = (data) => coerce(data);
var json_exports2 = {};
__export(json_exports2, {
  code: () => code7,
  decode: () => decode12,
  encode: () => encode12,
  name: () => name7
});
var textEncoder4 = new TextEncoder();
var textDecoder3 = new TextDecoder();
var name7 = "json";
var code7 = 512;
var encode12 = (node) => textEncoder4.encode(JSON.stringify(node));
var decode12 = (data) => JSON.parse(textDecoder3.decode(data));
var bases = { ...identity_exports2, ...base2_exports, ...base8_exports, ...base10_exports, ...base16_exports, ...base32_exports, ...base36_exports, ...base58_exports, ...base64_exports, ...base256emoji_exports };
var hashes = { ...sha2_browser_exports, ...identity_exports };
var codecs = { raw: raw_exports, json: json_exports2 };
function initAssets() {
}
var NotInitializedError = class extends Error {
  constructor(message2 = "not initialized") {
    super(message2);
    this.name = "NotInitializedError";
    this.code = NotInitializedError.code;
  }
};
NotInitializedError.code = "ERR_NOT_INITIALIZED";
var AlreadyInitializingError = class extends Error {
  constructor(message2 = "cannot initialize an initializing node") {
    super(message2);
    this.name = "AlreadyInitializingError";
    this.code = AlreadyInitializedError.code;
  }
};
AlreadyInitializingError.code = "ERR_ALREADY_INITIALIZING";
var AlreadyInitializedError = class extends Error {
  constructor(message2 = "cannot re-initialize an initialized node") {
    super(message2);
    this.name = "AlreadyInitializedError";
    this.code = AlreadyInitializedError.code;
  }
};
AlreadyInitializedError.code = "ERR_ALREADY_INITIALIZED";
var NotStartedError = class extends Error {
  constructor(message2 = "not started") {
    super(message2);
    this.name = "NotStartedError";
    this.code = NotStartedError.code;
  }
};
NotStartedError.code = "ERR_NOT_STARTED";
var AlreadyStartingError = class extends Error {
  constructor(message2 = "cannot start, already startin") {
    super(message2);
    this.name = "AlreadyStartingError";
    this.code = AlreadyStartingError.code;
  }
};
AlreadyStartingError.code = "ERR_ALREADY_STARTING";
var AlreadyStartedError = class extends Error {
  constructor(message2 = "cannot start, already started") {
    super(message2);
    this.name = "AlreadyStartedError";
    this.code = AlreadyStartedError.code;
  }
};
AlreadyStartedError.code = "ERR_ALREADY_STARTED";
var NotEnabledError = class extends Error {
  constructor(message2 = "not enabled") {
    super(message2);
    this.name = "NotEnabledError";
    this.code = NotEnabledError.code;
  }
};
NotEnabledError.code = "ERR_NOT_ENABLED";
function createCodec(name9, prefix, encode21, decode17) {
  return {
    name: name9,
    prefix,
    encoder: {
      name: name9,
      prefix,
      encode: encode21
    },
    decoder: {
      decode: decode17
    }
  };
}
var string = createCodec("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf2) => {
  let string2 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string2 += String.fromCharCode(buf2[i2]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;
function fromString3(string2, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (base3 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
var import_timeout_abort_controller18 = __toESM(require_timeout_abort_controller(), 1);
var Parser = class {
  constructor() {
    __publicField(this, "index", 0);
    __publicField(this, "input", "");
  }
  new(input) {
    this.index = 0;
    this.input = input;
    return this;
  }
  /** Run a parser, and restore the pre-parse state if it fails. */
  readAtomically(fn) {
    const index2 = this.index;
    const result = fn();
    if (result === void 0) {
      this.index = index2;
    }
    return result;
  }
  /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */
  parseWith(fn) {
    const result = fn();
    if (this.index !== this.input.length) {
      return void 0;
    }
    return result;
  }
  /** Peek the next character from the input */
  peekChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index];
  }
  /** Read the next character from the input */
  readChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index++];
  }
  /** Read the next character from the input if it matches the target. */
  readGivenChar(target) {
    return this.readAtomically(() => {
      const char = this.readChar();
      if (char !== target) {
        return void 0;
      }
      return char;
    });
  }
  /**
   * Helper for reading separators in an indexed loop. Reads the separator
   * character iff index > 0, then runs the parser. When used in a loop,
   * the separator character will only be read on index > 0 (see
   * readIPv4Addr for an example)
   */
  readSeparator(sep, index2, inner) {
    return this.readAtomically(() => {
      if (index2 > 0) {
        if (this.readGivenChar(sep) === void 0) {
          return void 0;
        }
      }
      return inner();
    });
  }
  /**
   * Read a number off the front of the input in the given radix, stopping
   * at the first non-digit character or eof. Fails if the number has more
   * digits than max_digits or if there is no number.
   */
  readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
    return this.readAtomically(() => {
      let result = 0;
      let digitCount = 0;
      const leadingChar = this.peekChar();
      if (leadingChar === void 0) {
        return void 0;
      }
      const hasLeadingZero = leadingChar === "0";
      const maxValue = 2 ** (8 * maxBytes) - 1;
      while (true) {
        const digit = this.readAtomically(() => {
          const char = this.readChar();
          if (char === void 0) {
            return void 0;
          }
          const num = Number.parseInt(char, radix);
          if (Number.isNaN(num)) {
            return void 0;
          }
          return num;
        });
        if (digit === void 0) {
          break;
        }
        result *= radix;
        result += digit;
        if (result > maxValue) {
          return void 0;
        }
        digitCount += 1;
        if (maxDigits !== void 0) {
          if (digitCount > maxDigits) {
            return void 0;
          }
        }
      }
      if (digitCount === 0) {
        return void 0;
      } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
        return void 0;
      } else {
        return result;
      }
    });
  }
  /** Read an IPv4 address. */
  readIPv4Addr() {
    return this.readAtomically(() => {
      const out = new Uint8Array(4);
      for (let i2 = 0; i2 < out.length; i2++) {
        const ix = this.readSeparator(".", i2, () => this.readNumber(10, 3, false, 1));
        if (ix === void 0) {
          return void 0;
        }
        out[i2] = ix;
      }
      return out;
    });
  }
  /** Read an IPv6 Address. */
  readIPv6Addr() {
    const readGroups = (groups) => {
      for (let i2 = 0; i2 < groups.length / 2; i2++) {
        const ix = i2 * 2;
        if (i2 < groups.length - 3) {
          const ipv4 = this.readSeparator(":", i2, () => this.readIPv4Addr());
          if (ipv4 !== void 0) {
            groups[ix] = ipv4[0];
            groups[ix + 1] = ipv4[1];
            groups[ix + 2] = ipv4[2];
            groups[ix + 3] = ipv4[3];
            return [ix + 4, true];
          }
        }
        const group = this.readSeparator(":", i2, () => this.readNumber(16, 4, true, 2));
        if (group === void 0) {
          return [ix, false];
        }
        groups[ix] = group >> 8;
        groups[ix + 1] = group & 255;
      }
      return [groups.length, false];
    };
    return this.readAtomically(() => {
      const head = new Uint8Array(16);
      const [headSize, headIp4] = readGroups(head);
      if (headSize === 16) {
        return head;
      }
      if (headIp4) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      const tail = new Uint8Array(14);
      const limit = 16 - (headSize + 2);
      const [tailSize] = readGroups(tail.subarray(0, limit));
      head.set(tail.subarray(0, tailSize), 16 - tailSize);
      return head;
    });
  }
  /** Read an IP Address, either IPv4 or IPv6. */
  readIPAddr() {
    return this.readIPv4Addr() ?? this.readIPv6Addr();
  }
};
var MAX_IPV6_LENGTH = 45;
var MAX_IPV4_LENGTH = 15;
var parser = new Parser();
function parseIPv4(input) {
  if (input.length > MAX_IPV4_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv4Addr());
}
function parseIPv6(input) {
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv6Addr());
}
function parseIP(input) {
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPAddr());
}
function isIPv4(input) {
  return Boolean(parseIPv4(input));
}
function isIPv6(input) {
  return Boolean(parseIPv6(input));
}
function isIP(input) {
  return Boolean(parseIP(input));
}
function toString3(array, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (base3 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}
var isV4 = isIPv4;
var isV6 = isIPv6;
var toBytes = function(ip) {
  let offset = 0;
  ip = ip.toString().trim();
  if (isV4(ip)) {
    const bytes2 = new Uint8Array(offset + 4);
    ip.split(/\./g).forEach((byte) => {
      bytes2[offset++] = parseInt(byte, 10) & 255;
    });
    return bytes2;
  }
  if (isV6(ip)) {
    const sections = ip.split(":", 8);
    let i2;
    for (i2 = 0; i2 < sections.length; i2++) {
      const isv4 = isV4(sections[i2]);
      let v4Buffer;
      if (isv4) {
        v4Buffer = toBytes(sections[i2]);
        sections[i2] = toString3(v4Buffer.slice(0, 2), "base16");
      }
      if (v4Buffer != null && ++i2 < 8) {
        sections.splice(i2, 0, toString3(v4Buffer.slice(2, 4), "base16"));
      }
    }
    if (sections[0] === "") {
      while (sections.length < 8)
        sections.unshift("0");
    } else if (sections[sections.length - 1] === "") {
      while (sections.length < 8)
        sections.push("0");
    } else if (sections.length < 8) {
      for (i2 = 0; i2 < sections.length && sections[i2] !== ""; i2++)
        ;
      const argv = [i2, 1];
      for (i2 = 9 - sections.length; i2 > 0; i2--) {
        argv.push("0");
      }
      sections.splice.apply(sections, argv);
    }
    const bytes2 = new Uint8Array(offset + 16);
    for (i2 = 0; i2 < sections.length; i2++) {
      const word2 = parseInt(sections[i2], 16);
      bytes2[offset++] = word2 >> 8 & 255;
      bytes2[offset++] = word2 & 255;
    }
    return bytes2;
  }
  throw new Error("invalid ip address");
};
var toString4 = function(buf2, offset = 0, length3) {
  offset = ~~offset;
  length3 = length3 ?? buf2.length - offset;
  const view = new DataView(buf2.buffer);
  if (length3 === 4) {
    const result = [];
    for (let i2 = 0; i2 < length3; i2++) {
      result.push(buf2[offset + i2]);
    }
    return result.join(".");
  }
  if (length3 === 16) {
    const result = [];
    for (let i2 = 0; i2 < length3; i2 += 2) {
      result.push(view.getUint16(offset + i2).toString(16));
    }
    return result.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
  }
  return "";
};
var V = -1;
var names = {};
var codes = {};
var table = [
  [4, 32, "ip4"],
  [6, 16, "tcp"],
  [33, 16, "dccp"],
  [41, 128, "ip6"],
  [42, V, "ip6zone"],
  [43, 8, "ipcidr"],
  [53, V, "dns", true],
  [54, V, "dns4", true],
  [55, V, "dns6", true],
  [56, V, "dnsaddr", true],
  [132, 16, "sctp"],
  [273, 16, "udp"],
  [275, 0, "p2p-webrtc-star"],
  [276, 0, "p2p-webrtc-direct"],
  [277, 0, "p2p-stardust"],
  [280, 0, "webrtc"],
  [290, 0, "p2p-circuit"],
  [301, 0, "udt"],
  [302, 0, "utp"],
  [400, V, "unix", false, true],
  // `ipfs` is added before `p2p` for legacy support.
  // All text representations will default to `p2p`, but `ipfs` will
  // still be supported
  [421, V, "ipfs"],
  // `p2p` is the preferred name for 421, and is now the default
  [421, V, "p2p"],
  [443, 0, "https"],
  [444, 96, "onion"],
  [445, 296, "onion3"],
  [446, V, "garlic64"],
  [460, 0, "quic"],
  [461, 0, "quic-v1"],
  [465, 0, "webtransport"],
  [466, V, "certhash"],
  [477, 0, "ws"],
  [478, 0, "wss"],
  [479, 0, "p2p-websocket-star"],
  [480, 0, "http"],
  [777, V, "memory"]
];
table.forEach((row) => {
  const proto = createProtocol(...row);
  codes[proto.code] = proto;
  names[proto.name] = proto;
});
function createProtocol(code8, size, name9, resolvable, path2) {
  return {
    code: code8,
    size,
    name: name9,
    resolvable: Boolean(resolvable),
    path: Boolean(path2)
  };
}
function getProtocol(proto) {
  if (typeof proto === "number") {
    if (codes[proto] != null) {
      return codes[proto];
    }
    throw new Error(`no protocol with code: ${proto}`);
  } else if (typeof proto === "string") {
    if (names[proto] != null) {
      return names[proto];
    }
    throw new Error(`no protocol with name: ${proto}`);
  }
  throw new Error(`invalid protocol id type: ${typeof proto}`);
}
var import_varint = __toESM(require_varint(), 1);
function convertToString(proto, buf2) {
  const protocol4 = getProtocol(proto);
  switch (protocol4.code) {
    case 4:
    case 41:
      return bytes2ip(buf2);
    case 42:
      return bytes2str(buf2);
    case 6:
    case 273:
    case 33:
    case 132:
      return bytes2port(buf2).toString();
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 777:
      return bytes2str(buf2);
    case 421:
      return bytes2mh(buf2);
    case 444:
      return bytes2onion(buf2);
    case 445:
      return bytes2onion(buf2);
    case 466:
      return bytes2mb(buf2);
    default:
      return toString3(buf2, "base16");
  }
}
function convertToBytes(proto, str) {
  const protocol4 = getProtocol(proto);
  switch (protocol4.code) {
    case 4:
      return ip2bytes(str);
    case 41:
      return ip2bytes(str);
    case 42:
      return str2bytes(str);
    case 6:
    case 273:
    case 33:
    case 132:
      return port2bytes(parseInt(str, 10));
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 777:
      return str2bytes(str);
    case 421:
      return mh2bytes(str);
    case 444:
      return onion2bytes(str);
    case 445:
      return onion32bytes(str);
    case 466:
      return mb2bytes(str);
    default:
      return fromString3(str, "base16");
  }
}
var decoders = Object.values(bases).map((c) => c.decoder);
var anybaseDecoder = function() {
  let acc = decoders[0].or(decoders[1]);
  decoders.slice(2).forEach((d) => acc = acc.or(d));
  return acc;
}();
function ip2bytes(ipString) {
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return toBytes(ipString);
}
function bytes2ip(ipBuff) {
  const ipString = toString4(ipBuff, 0, ipBuff.length);
  if (ipString == null) {
    throw new Error("ipBuff is required");
  }
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return ipString;
}
function port2bytes(port) {
  const buf2 = new ArrayBuffer(2);
  const view = new DataView(buf2);
  view.setUint16(0, port);
  return new Uint8Array(buf2);
}
function bytes2port(buf2) {
  const view = new DataView(buf2.buffer);
  return view.getUint16(buf2.byteOffset);
}
function str2bytes(str) {
  const buf2 = fromString3(str);
  const size = Uint8Array.from(import_varint.default.encode(buf2.length));
  return concat([size, buf2], size.length + buf2.length);
}
function bytes2str(buf2) {
  const size = import_varint.default.decode(buf2);
  buf2 = buf2.slice(import_varint.default.decode.bytes);
  if (buf2.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString3(buf2);
}
function mh2bytes(hash3) {
  let mh;
  if (hash3[0] === "Q" || hash3[0] === "1") {
    mh = decode3$3(base58btc.decode(`z${hash3}`)).bytes;
  } else {
    mh = CID.parse(hash3).multihash.bytes;
  }
  const size = Uint8Array.from(import_varint.default.encode(mh.length));
  return concat([size, mh], size.length + mh.length);
}
function mb2bytes(mbstr) {
  const mb = anybaseDecoder.decode(mbstr);
  const size = Uint8Array.from(import_varint.default.encode(mb.length));
  return concat([size, mb], size.length + mb.length);
}
function bytes2mb(buf2) {
  const size = import_varint.default.decode(buf2);
  const hash3 = buf2.slice(import_varint.default.decode.bytes);
  if (hash3.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return "u" + toString3(hash3, "base64url");
}
function bytes2mh(buf2) {
  const size = import_varint.default.decode(buf2);
  const address = buf2.slice(import_varint.default.decode.bytes);
  if (address.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString3(address, "base58btc");
}
function onion2bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 16) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
  }
  const buf2 = base32.decode("b" + addr[0]);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat([buf2, portBuf], buf2.length + portBuf.length);
}
function onion32bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 56) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
  }
  const buf2 = base32.decode(`b${addr[0]}`);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat([buf2, portBuf], buf2.length + portBuf.length);
}
function bytes2onion(buf2) {
  const addrBytes = buf2.slice(0, buf2.length - 2);
  const portBytes = buf2.slice(buf2.length - 2);
  const addr = toString3(addrBytes, "base32");
  const port = bytes2port(portBytes);
  return `${addr}:${port}`;
}
var import_varint2 = __toESM(require_varint(), 1);
function stringToStringTuples(str) {
  const tuples = [];
  const parts2 = str.split("/").slice(1);
  if (parts2.length === 1 && parts2[0] === "") {
    return [];
  }
  for (let p = 0; p < parts2.length; p++) {
    const part = parts2[p];
    const proto = getProtocol(part);
    if (proto.size === 0) {
      tuples.push([part]);
      continue;
    }
    p++;
    if (p >= parts2.length) {
      throw ParseError("invalid address: " + str);
    }
    if (proto.path === true) {
      tuples.push([
        part,
        // should we need to check each path part to see if it's a proto?
        // This would allow for other protocols to be added after a unix path,
        // however it would have issues if the path had a protocol name in the path
        cleanPath(parts2.slice(p).join("/"))
      ]);
      break;
    }
    tuples.push([part, parts2[p]]);
  }
  return tuples;
}
function stringTuplesToString(tuples) {
  const parts2 = [];
  tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    parts2.push(proto.name);
    if (tup.length > 1 && tup[1] != null) {
      parts2.push(tup[1]);
    }
    return null;
  });
  return cleanPath(parts2.join("/"));
}
function stringTuplesToTuples(tuples) {
  return tuples.map((tup) => {
    if (!Array.isArray(tup)) {
      tup = [tup];
    }
    const proto = protoFromTuple(tup);
    if (tup.length > 1) {
      return [proto.code, convertToBytes(proto.code, tup[1])];
    }
    return [proto.code];
  });
}
function tuplesToStringTuples(tuples) {
  return tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    if (tup[1] != null) {
      return [proto.code, convertToString(proto.code, tup[1])];
    }
    return [proto.code];
  });
}
function tuplesToBytes(tuples) {
  return fromBytes(concat(tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    let buf2 = Uint8Array.from(import_varint2.default.encode(proto.code));
    if (tup.length > 1 && tup[1] != null) {
      buf2 = concat([buf2, tup[1]]);
    }
    return buf2;
  })));
}
function sizeForAddr(p, addr) {
  if (p.size > 0) {
    return p.size / 8;
  } else if (p.size === 0) {
    return 0;
  } else {
    const size = import_varint2.default.decode(addr);
    return size + (import_varint2.default.decode.bytes ?? 0);
  }
}
function bytesToTuples(buf2) {
  const tuples = [];
  let i2 = 0;
  while (i2 < buf2.length) {
    const code8 = import_varint2.default.decode(buf2, i2);
    const n = import_varint2.default.decode.bytes ?? 0;
    const p = getProtocol(code8);
    const size = sizeForAddr(p, buf2.slice(i2 + n));
    if (size === 0) {
      tuples.push([code8]);
      i2 += n;
      continue;
    }
    const addr = buf2.slice(i2 + n, i2 + n + size);
    i2 += size + n;
    if (i2 > buf2.length) {
      throw ParseError("Invalid address Uint8Array: " + toString3(buf2, "base16"));
    }
    tuples.push([code8, addr]);
  }
  return tuples;
}
function bytesToString(buf2) {
  const a = bytesToTuples(buf2);
  const b = tuplesToStringTuples(a);
  return stringTuplesToString(b);
}
function stringToBytes(str) {
  str = cleanPath(str);
  const a = stringToStringTuples(str);
  const b = stringTuplesToTuples(a);
  return tuplesToBytes(b);
}
function fromString4(str) {
  return stringToBytes(str);
}
function fromBytes(buf2) {
  const err2 = validateBytes(buf2);
  if (err2 != null) {
    throw err2;
  }
  return Uint8Array.from(buf2);
}
function validateBytes(buf2) {
  try {
    bytesToTuples(buf2);
  } catch (err2) {
    return err2;
  }
}
function cleanPath(str) {
  return "/" + str.trim().split("/").filter((a) => a).join("/");
}
function ParseError(str) {
  return new Error("Error parsing address: " + str);
}
function protoFromTuple(tup) {
  const proto = getProtocol(tup[0]);
  return proto;
}
var import_varint3 = __toESM(require_varint());
var import_err_code2 = __toESM(require_err_code());
function equals(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a.byteLength; i2++) {
    if (a[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value2, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var _DefaultMultiaddr_string;
var _DefaultMultiaddr_tuples;
var _DefaultMultiaddr_stringTuples;
var _a;
var inspect = Symbol.for("nodejs.util.inspect.custom");
var DNS_CODES = [
  getProtocol("dns").code,
  getProtocol("dns4").code,
  getProtocol("dns6").code,
  getProtocol("dnsaddr").code
];
var resolvers = /* @__PURE__ */ new Map();
var symbol = Symbol.for("@multiformats/js-multiaddr/multiaddr");
function fromNodeAddress(addr, transport) {
  if (addr == null) {
    throw new Error("requires node address object");
  }
  if (transport == null) {
    throw new Error("requires transport protocol");
  }
  let ip;
  let host = addr.address;
  switch (addr.family) {
    case 4:
      ip = "ip4";
      break;
    case 6:
      ip = "ip6";
      if (host.includes("%")) {
        const parts2 = host.split("%");
        if (parts2.length !== 2) {
          throw Error("Multiple ip6 zones in multiaddr");
        }
        host = parts2[0];
        const zone = parts2[1];
        ip = `/ip6zone/${zone}/ip6`;
      }
      break;
    default:
      throw Error("Invalid addr family, should be 4 or 6.");
  }
  return new DefaultMultiaddr("/" + [ip, host, transport, addr.port].join("/"));
}
function isName(addr) {
  if (!isMultiaddr(addr)) {
    return false;
  }
  return addr.protos().some((proto) => proto.resolvable);
}
function isMultiaddr(value2) {
  return Boolean(value2?.[symbol]);
}
var DefaultMultiaddr = class {
  constructor(addr) {
    _DefaultMultiaddr_string.set(this, void 0);
    _DefaultMultiaddr_tuples.set(this, void 0);
    _DefaultMultiaddr_stringTuples.set(this, void 0);
    this[_a] = true;
    if (addr == null) {
      addr = "";
    }
    if (addr instanceof Uint8Array) {
      this.bytes = fromBytes(addr);
    } else if (typeof addr === "string") {
      if (addr.length > 0 && addr.charAt(0) !== "/") {
        throw new Error(`multiaddr "${addr}" must start with a "/"`);
      }
      this.bytes = fromString4(addr);
    } else if (isMultiaddr(addr)) {
      this.bytes = fromBytes(addr.bytes);
    } else {
      throw new Error("addr must be a string, Buffer, or another Multiaddr");
    }
  }
  toString() {
    if (__classPrivateFieldGet(this, _DefaultMultiaddr_string, "f") == null) {
      __classPrivateFieldSet(this, _DefaultMultiaddr_string, bytesToString(this.bytes), "f");
    }
    return __classPrivateFieldGet(this, _DefaultMultiaddr_string, "f");
  }
  toJSON() {
    return this.toString();
  }
  toOptions() {
    let family;
    let transport;
    let host;
    let port;
    let zone = "";
    const tcp = getProtocol("tcp");
    const udp = getProtocol("udp");
    const ip4 = getProtocol("ip4");
    const ip6 = getProtocol("ip6");
    const dns6 = getProtocol("dns6");
    const ip6zone = getProtocol("ip6zone");
    for (const [code8, value2] of this.stringTuples()) {
      if (code8 === ip6zone.code) {
        zone = `%${value2 ?? ""}`;
      }
      if (DNS_CODES.includes(code8)) {
        transport = tcp.name;
        port = 443;
        host = `${value2 ?? ""}${zone}`;
        family = code8 === dns6.code ? 6 : 4;
      }
      if (code8 === tcp.code || code8 === udp.code) {
        transport = getProtocol(code8).name;
        port = parseInt(value2 ?? "");
      }
      if (code8 === ip4.code || code8 === ip6.code) {
        transport = getProtocol(code8).name;
        host = `${value2 ?? ""}${zone}`;
        family = code8 === ip6.code ? 6 : 4;
      }
    }
    if (family == null || transport == null || host == null || port == null) {
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
    }
    const opts = {
      family,
      host,
      transport,
      port
    };
    return opts;
  }
  protos() {
    return this.protoCodes().map((code8) => Object.assign({}, getProtocol(code8)));
  }
  protoCodes() {
    const codes6 = [];
    const buf2 = this.bytes;
    let i2 = 0;
    while (i2 < buf2.length) {
      const code8 = import_varint3.default.decode(buf2, i2);
      const n = import_varint3.default.decode.bytes ?? 0;
      const p = getProtocol(code8);
      const size = sizeForAddr(p, buf2.slice(i2 + n));
      i2 += size + n;
      codes6.push(code8);
    }
    return codes6;
  }
  protoNames() {
    return this.protos().map((proto) => proto.name);
  }
  tuples() {
    if (__classPrivateFieldGet(this, _DefaultMultiaddr_tuples, "f") == null) {
      __classPrivateFieldSet(this, _DefaultMultiaddr_tuples, bytesToTuples(this.bytes), "f");
    }
    return __classPrivateFieldGet(this, _DefaultMultiaddr_tuples, "f");
  }
  stringTuples() {
    if (__classPrivateFieldGet(this, _DefaultMultiaddr_stringTuples, "f") == null) {
      __classPrivateFieldSet(this, _DefaultMultiaddr_stringTuples, tuplesToStringTuples(this.tuples()), "f");
    }
    return __classPrivateFieldGet(this, _DefaultMultiaddr_stringTuples, "f");
  }
  encapsulate(addr) {
    addr = new DefaultMultiaddr(addr);
    return new DefaultMultiaddr(this.toString() + addr.toString());
  }
  decapsulate(addr) {
    const addrString = addr.toString();
    const s = this.toString();
    const i2 = s.lastIndexOf(addrString);
    if (i2 < 0) {
      throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
    }
    return new DefaultMultiaddr(s.slice(0, i2));
  }
  decapsulateCode(code8) {
    const tuples = this.tuples();
    for (let i2 = tuples.length - 1; i2 >= 0; i2--) {
      if (tuples[i2][0] === code8) {
        return new DefaultMultiaddr(tuplesToBytes(tuples.slice(0, i2)));
      }
    }
    return this;
  }
  getPeerId() {
    try {
      const tuples = this.stringTuples().filter((tuple2) => {
        if (tuple2[0] === names.ipfs.code) {
          return true;
        }
        return false;
      });
      const tuple = tuples.pop();
      if (tuple?.[1] != null) {
        const peerIdStr = tuple[1];
        if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
          return toString3(base58btc.decode(`z${peerIdStr}`), "base58btc");
        }
        return toString3(CID.parse(peerIdStr).multihash.bytes, "base58btc");
      }
      return null;
    } catch (e) {
      return null;
    }
  }
  getPath() {
    let path2 = null;
    try {
      path2 = this.stringTuples().filter((tuple) => {
        const proto = getProtocol(tuple[0]);
        if (proto.path === true) {
          return true;
        }
        return false;
      })[0][1];
      if (path2 == null) {
        path2 = null;
      }
    } catch {
      path2 = null;
    }
    return path2;
  }
  equals(addr) {
    return equals(this.bytes, addr.bytes);
  }
  async resolve(options) {
    const resolvableProto = this.protos().find((p) => p.resolvable);
    if (resolvableProto == null) {
      return [this];
    }
    const resolver = resolvers.get(resolvableProto.name);
    if (resolver == null) {
      throw (0, import_err_code2.default)(new Error(`no available resolver for ${resolvableProto.name}`), "ERR_NO_AVAILABLE_RESOLVER");
    }
    const addresses = await resolver(this, options);
    return addresses.map((a) => new DefaultMultiaddr(a));
  }
  nodeAddress() {
    const options = this.toOptions();
    if (options.transport !== "tcp" && options.transport !== "udp") {
      throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
    }
    return {
      family: options.family,
      address: options.host,
      port: options.port
    };
  }
  isThinWaistAddress(addr) {
    const protos = (addr ?? this).protos();
    if (protos.length !== 2) {
      return false;
    }
    if (protos[0].code !== 4 && protos[0].code !== 41) {
      return false;
    }
    if (protos[1].code !== 6 && protos[1].code !== 273) {
      return false;
    }
    return true;
  }
  /**
   * Returns Multiaddr as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { multiaddr } from '@multiformats/multiaddr'
   *
   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
   * ```
   */
  [(_DefaultMultiaddr_string = /* @__PURE__ */ new WeakMap(), _DefaultMultiaddr_tuples = /* @__PURE__ */ new WeakMap(), _DefaultMultiaddr_stringTuples = /* @__PURE__ */ new WeakMap(), _a = symbol, inspect)]() {
    return `Multiaddr(${bytesToString(this.bytes)})`;
  }
};
function multiaddr(addr) {
  return new DefaultMultiaddr(addr);
}
var DNS4 = base("dns4");
var DNS6 = base("dns6");
var DNSADDR = base("dnsaddr");
var DNS = or(base("dns"), DNSADDR, DNS4, DNS6);
var IP = or(base("ip4"), base("ip6"));
var TCP = or(and(IP, base("tcp")), and(DNS, base("tcp")));
var UDP = and(IP, base("udp"));
var UTP = and(UDP, base("utp"));
var QUIC = and(UDP, base("quic"));
var WebSockets = or(and(TCP, base("ws")), and(DNS, base("ws")));
var WebSocketsSecure = or(and(TCP, base("wss")), and(DNS, base("wss")));
var HTTP = or(and(TCP, base("http")), and(IP, base("http")), and(DNS, base("http")));
var HTTPS = or(and(TCP, base("https")), and(IP, base("https")), and(DNS, base("https")));
var WebRTCStar = or(and(WebSockets, base("p2p-webrtc-star"), base("p2p")), and(WebSocketsSecure, base("p2p-webrtc-star"), base("p2p")), and(WebSockets, base("p2p-webrtc-star")), and(WebSocketsSecure, base("p2p-webrtc-star")));
var WebRTCDirect = or(and(HTTP, base("p2p-webrtc-direct"), base("p2p")), and(HTTPS, base("p2p-webrtc-direct"), base("p2p")), and(HTTP, base("p2p-webrtc-direct")), and(HTTPS, base("p2p-webrtc-direct")));
var Reliable = or(WebSockets, WebSocketsSecure, HTTP, HTTPS, WebRTCStar, WebRTCDirect, TCP, UTP, QUIC, DNS);
var _P2P = or(and(Reliable, base("p2p")), WebRTCStar, WebRTCDirect, base("p2p"));
var _Circuit = or(and(_P2P, base("p2p-circuit"), _P2P), and(_P2P, base("p2p-circuit")), and(base("p2p-circuit"), _P2P), and(Reliable, base("p2p-circuit")), and(base("p2p-circuit"), Reliable), base("p2p-circuit"));
var CircuitRecursive = () => or(and(_Circuit, CircuitRecursive), _Circuit);
var Circuit = CircuitRecursive();
var P2P = or(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);
var IPFS = P2P;
function makeMatchesFunction(partialMatch) {
  function matches(a) {
    let ma;
    try {
      ma = multiaddr(a);
    } catch (err2) {
      return false;
    }
    const out = partialMatch(ma.protoNames());
    if (out === null) {
      return false;
    }
    if (out === true || out === false) {
      return out;
    }
    return out.length === 0;
  }
  return matches;
}
function and(...args) {
  function partialMatch(a) {
    if (a.length < args.length) {
      return null;
    }
    let out = a;
    args.some((arg) => {
      out = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
      if (Array.isArray(out)) {
        a = out;
      }
      if (out === null) {
        return true;
      }
      return false;
    });
    return out;
  }
  return {
    toString: function() {
      return "{ " + args.join(" ") + " }";
    },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch
  };
}
function or(...args) {
  function partialMatch(a) {
    let out = null;
    args.some((arg) => {
      const res = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
      if (res != null) {
        out = res;
        return true;
      }
      return false;
    });
    return out;
  }
  const result = {
    toString: function() {
      return "{ " + args.join(" ") + " }";
    },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch
  };
  return result;
}
function base(n) {
  const name9 = n;
  function matches(a) {
    let ma;
    try {
      ma = multiaddr(a);
    } catch (err2) {
      return false;
    }
    const pnames = ma.protoNames();
    if (pnames.length === 1 && pnames[0] === name9) {
      return true;
    }
    return false;
  }
  function partialMatch(protos) {
    if (protos.length === 0) {
      return null;
    }
    if (protos[0] === name9) {
      return protos.slice(1);
    }
    return null;
  }
  return {
    toString: function() {
      return name9;
    },
    matches,
    partialMatch
  };
}
var import_iso_url = __toESM(require_iso_url());
var pathPattern = /^\/(ip[fn]s)\/([^/?#]+)/;
var defaultProtocolMatch = 1;
var defaultHashMath = 2;
var subdomainGatewayPattern = /^https?:\/\/([^/]+)\.(ip[fn]s)\.[^/?]+/;
var fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;
function isCID(hash3) {
  try {
    if (isString$1(hash3)) {
      return Boolean(CID.parse(hash3));
    }
    if (hash3 instanceof Uint8Array) {
      return Boolean(CID.decode(hash3));
    }
    return Boolean(CID.asCID(hash3));
  } catch {
    return false;
  }
}
function isIpfs(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
  const formatted = convertToString2(input);
  if (formatted === false) {
    return false;
  }
  const match = formatted.match(pattern);
  if (match == null) {
    return false;
  }
  if (match[protocolMatch] !== "ipfs") {
    return false;
  }
  let hash3 = match[hashMatch];
  if (hash3 != null && pattern === subdomainGatewayPattern) {
    hash3 = hash3.toLowerCase();
  }
  return isCID(hash3);
}
function isIpns(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
  const formatted = convertToString2(input);
  if (formatted === false) {
    return false;
  }
  const match = formatted.match(pattern);
  if (match == null) {
    return false;
  }
  if (match[protocolMatch] !== "ipns") {
    return false;
  }
  let ipnsId = match[hashMatch];
  if (ipnsId != null && pattern === subdomainGatewayPattern) {
    ipnsId = ipnsId.toLowerCase();
    if (isCID(ipnsId))
      return true;
    try {
      if (!ipnsId.includes(".") && ipnsId.includes("-")) {
        ipnsId = ipnsId.replace(/--/g, "@").replace(/-/g, ".").replace(/@/g, "-");
      }
      const { hostname } = new import_iso_url.URL(`http://${ipnsId}`);
      return fqdnWithTld.test(hostname);
    } catch (e) {
      return false;
    }
  }
  return true;
}
function isString$1(input) {
  return typeof input === "string";
}
function convertToString2(input) {
  if (input instanceof Uint8Array) {
    return toString3(input, "base58btc");
  }
  if (isString$1(input)) {
    return input;
  }
  return false;
}
var path = (path2) => isIpfs(path2, pathPattern) || isIpns(path2, pathPattern);
var ipfsPath = (path2) => isIpfs(path2, pathPattern);
var ipnsPath = (path2) => isIpns(path2, pathPattern);
var nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");
var pathSepS = "/";
var pathSepB = new TextEncoder().encode(pathSepS);
var pathSep = pathSepB[0];
var Key = class {
  /**
   * @param {string | Uint8Array} s
   * @param {boolean} [clean]
   */
  constructor(s, clean) {
    if (typeof s === "string") {
      this._buf = fromString3(s);
    } else if (s instanceof Uint8Array) {
      this._buf = s;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean == null) {
      clean = true;
    }
    if (clean) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
      throw new Error("Invalid key");
    }
  }
  /**
   * Convert to the string representation
   *
   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.
   * @returns {string}
   */
  toString(encoding = "utf8") {
    return toString3(this._buf, encoding);
  }
  /**
   * Return the Uint8Array representation of the key
   *
   * @returns {Uint8Array}
   */
  uint8Array() {
    return this._buf;
  }
  /**
   * Return string representation of the key
   *
   * @returns {string}
   */
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list - The array of namespaces
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   * ```
   */
  static withNamespaces(list) {
    return new Key(list.join(pathSepS));
  }
  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.random()
   * // => Key('/f98719ea086343f7b71f32ea9d9d521d')
   * ```
   */
  static random() {
    return new Key(nanoid().replace(/-/g, ""));
  }
  /**
   * @param {*} other
   */
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new Key(other.uint8Array());
    }
    return null;
  }
  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB;
    }
    if (this._buf[0] !== pathSep) {
      const bytes2 = new Uint8Array(this._buf.byteLength + 1);
      bytes2.fill(pathSep, 0, 1);
      bytes2.set(this._buf, 1);
      this._buf = bytes2;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key - The other Key to check against
   * @returns {boolean}
   */
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i2 = 0; i2 < list1.length; i2++) {
      if (list2.length < i2 + 1) {
        return false;
      }
      const c1 = list1[i2];
      const c2 = list2[i2];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   * ```
   */
  reverse() {
    return Key.withNamespaces(this.list().slice().reverse());
  }
  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces() {
    return this.list();
  }
  /** Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   * ```
   */
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   * ```
   */
  list() {
    return this.toString().split(pathSepS).slice(1);
  }
  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   * ```
   */
  type() {
    return namespaceType(this.baseNamespace());
  }
  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   * ```
   */
  name() {
    return namespaceValue(this.baseNamespace());
  }
  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s - The string to append.
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  instance(s) {
    return new Key(this.toString() + ":" + s);
  }
  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   * ```
   */
  path() {
    let p = this.parent().toString();
    if (!p.endsWith(pathSepS)) {
      p += pathSepS;
    }
    p += this.type();
    return new Key(p);
  }
  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   * ```
   */
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new Key(pathSepS);
    }
    return new Key(list.slice(0, -1).join(pathSepS));
  }
  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key - The child Key to add
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  child(key) {
    if (this.toString() === pathSepS) {
      return key;
    } else if (key.toString() === pathSepS) {
      return this;
    }
    return new Key(this.toString() + key.toString(), false);
  }
  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other - The other key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   * ```
   */
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other - The other Key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   * ```
   */
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  /**
   * Checks if this key has only one namespace.
   *
   * @returns {boolean}
   *
   */
  isTopLevel() {
    return this.list().length === 1;
  }
  /**
   * Concats one or more Keys into one new Key.
   *
   * @param {Array<Key>} keys - The array of keys to concatenate
   * @returns {Key}
   */
  concat(...keys) {
    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
  }
};
function namespaceType(ns) {
  const parts2 = ns.split(":");
  if (parts2.length < 2) {
    return "";
  }
  return parts2.slice(0, -1).join(":");
}
function namespaceValue(ns) {
  const parts2 = ns.split(":");
  return parts2[parts2.length - 1];
}
function flatten(arr) {
  return [].concat(...arr);
}
var import_err_code4 = __toESM(require_err_code(), 1);
var import_timeout_abort_controller = __toESM(require_timeout_abort_controller());
var import_any_signal = __toESM(require_any_signal());
var durationRE = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig;
parse2.nanosecond = parse2.ns = 1 / 1e6;
parse2["µs"] = parse2["μs"] = parse2.us = parse2.microsecond = 1 / 1e3;
parse2.millisecond = parse2.ms = parse2[""] = 1;
parse2.second = parse2.sec = parse2.s = parse2.ms * 1e3;
parse2.minute = parse2.min = parse2.m = parse2.s * 60;
parse2.hour = parse2.hr = parse2.h = parse2.m * 60;
parse2.day = parse2.d = parse2.h * 24;
parse2.week = parse2.wk = parse2.w = parse2.d * 7;
parse2.month = parse2.b = parse2.d * (365.25 / 12);
parse2.year = parse2.yr = parse2.y = parse2.d * 365.25;
function parse2(str = "", format2 = "ms") {
  var result = null;
  str = (str + "").replace(/(\d)[,_](\d)/g, "$1$2");
  str.replace(durationRE, function(_, n, units) {
    units = unitRatio(units);
    if (units)
      result = (result || 0) + parseFloat(n, 10) * units;
  });
  return result && result / (unitRatio(format2) || 1);
}
function unitRatio(str) {
  return parse2[str] || parse2[str.toLowerCase().replace(/s$/, "")];
}
var parse_duration_default = parse2;
var TimeoutError = class extends Error {
  constructor(message2 = "request timed out") {
    super(message2);
    this.name = "TimeoutError";
    this.code = TimeoutError.code;
  }
};
TimeoutError.code = "ERR_TIMEOUT";
function withTimeoutOption(fn, optionsArgIndex) {
  return (
    /** @returns {R} */
    (...args) => {
      const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex];
      if (!options || !options.timeout)
        return fn(...args);
      const timeout = typeof options.timeout === "string" ? parse_duration_default(options.timeout) : options.timeout;
      const controller = new import_timeout_abort_controller.TimeoutController(timeout);
      options.signal = (0, import_any_signal.anySignal)([options.signal, controller.signal]);
      const fnRes = fn(...args);
      const timeoutPromise = new Promise((_resolve, reject) => {
        controller.signal.addEventListener("abort", () => {
          reject(new TimeoutError());
        });
      });
      const start = Date.now();
      const maybeThrowTimeoutError = () => {
        if (controller.signal.aborted) {
          throw new TimeoutError();
        }
        const timeTaken = Date.now() - start;
        if (timeTaken > timeout) {
          controller.abort();
          throw new TimeoutError();
        }
      };
      if (fnRes[Symbol.asyncIterator]) {
        return async function* () {
          const it = fnRes[Symbol.asyncIterator]();
          try {
            while (true) {
              const { value: value2, done } = await Promise.race([it.next(), timeoutPromise]);
              if (done) {
                break;
              }
              maybeThrowTimeoutError();
              yield value2;
            }
          } catch (err2) {
            maybeThrowTimeoutError();
            throw err2;
          } finally {
            controller.clear();
            if (it.return) {
              it.return();
            }
          }
        }();
      }
      return (async () => {
        try {
          const res = await Promise.race([fnRes, timeoutPromise]);
          maybeThrowTimeoutError();
          return res;
        } catch (err2) {
          maybeThrowTimeoutError();
          throw err2;
        } finally {
          controller.clear();
        }
      })();
    }
  );
}
var import_err_code3 = __toESM(require_err_code());
var IPFS_PREFIX = "/ipfs/";
function toCidAndPath(string2) {
  if (string2 instanceof Uint8Array) {
    try {
      string2 = CID.decode(string2);
    } catch (err2) {
      throw (0, import_err_code3.default)(err2, "ERR_INVALID_CID");
    }
  }
  let cid = CID.asCID(string2);
  if (cid) {
    return {
      cid,
      path: void 0
    };
  }
  string2 = string2.toString();
  if (string2.startsWith(IPFS_PREFIX)) {
    string2 = string2.substring(IPFS_PREFIX.length);
  }
  const parts2 = string2.split("/");
  let path2;
  try {
    cid = CID.parse(parts2.shift() || "");
  } catch (err2) {
    throw (0, import_err_code3.default)(err2, "ERR_INVALID_CID");
  }
  if (parts2.length) {
    path2 = `/${parts2.join("/")}`;
  }
  return {
    cid,
    path: path2
  };
}
var ERR_BAD_PATH = "ERR_BAD_PATH";
var OFFLINE_ERROR = "This command must be run in online mode. Try running 'ipfs daemon' first.";
var MFS_ROOT_KEY = new Key("/local/filesroot");
var MFS_MAX_CHUNK_SIZE = 262144;
var normalizePath = (pathStr) => {
  const cid = CID.asCID(pathStr);
  if (cid) {
    return `/ipfs/${pathStr}`;
  }
  const str = pathStr.toString();
  try {
    return `/ipfs/${CID.parse(str)}`;
  } catch {
  }
  if (path(str)) {
    return str;
  } else {
    throw (0, import_err_code4.default)(new Error(`invalid path: ${pathStr}`), ERR_BAD_PATH);
  }
};
var normalizeCidPath = (path2) => {
  if (path2 instanceof Uint8Array) {
    return CID.decode(path2).toString();
  }
  path2 = path2.toString();
  if (path2.indexOf("/ipfs/") === 0) {
    path2 = path2.substring("/ipfs/".length);
  }
  if (path2.charAt(path2.length - 1) === "/") {
    path2 = path2.substring(0, path2.length - 1);
  }
  return path2;
};
var resolvePath = async function(repo, codecs2, ipfsPath3, options = {}) {
  const {
    cid,
    path: path2
  } = toCidAndPath(ipfsPath3);
  if (path2) {
    options.path = path2;
  }
  let lastCid = cid;
  let lastRemainderPath = options.path || "";
  if (lastRemainderPath.startsWith("/")) {
    lastRemainderPath = lastRemainderPath.substring(1);
  }
  if (options.path) {
    try {
      for await (const { value: value2, remainderPath } of resolve(cid, options.path, codecs2, repo, {
        signal: options.signal
      })) {
        if (!CID.asCID(value2)) {
          break;
        }
        lastRemainderPath = remainderPath;
        lastCid = value2;
      }
    } catch (err2) {
      if (err2.message.startsWith("Object has no property")) {
        err2.message = `no link named "${lastRemainderPath.split("/")[0]}" under ${lastCid}`;
        err2.code = "ERR_NO_LINK";
      }
      throw err2;
    }
  }
  return {
    cid: lastCid,
    remainderPath: lastRemainderPath || ""
  };
};
var mapFile = (file) => {
  if (file.type !== "file" && file.type !== "directory" && file.type !== "raw") {
    throw new Error(`Unknown node type '${file.type}'`);
  }
  const output = {
    cid: file.cid,
    path: file.path,
    name: file.name,
    size: file.size,
    type: "file"
  };
  if (file.type === "directory") {
    output.type = "dir";
  }
  if (file.type === "file") {
    output.size = file.unixfs.fileSize();
  }
  if (file.type === "file" || file.type === "directory") {
    output.mode = file.unixfs.mode;
    if (file.unixfs.mtime !== void 0) {
      output.mtime = file.unixfs.mtime;
    }
  }
  return output;
};
var withTimeout = withTimeoutOption(
  /**
   * @template T
   * @param {Promise<T>|T} promise
   * @param {AbortOptions} [_options]
   * @returns {Promise<T>}
   */
  async (promise, _options) => await promise
);
var resolve = async function* (cid, path2, codecs2, repo, options) {
  const load = async (cid2) => {
    const codec = await codecs2.getCodec(cid2.code);
    const block = await repo.blocks.get(cid2, options);
    return codec.decode(block);
  };
  const parts2 = path2.split("/").filter(Boolean);
  let value2 = await load(cid);
  let lastCid = cid;
  while (parts2.length) {
    const key = parts2.shift();
    if (!key) {
      throw (0, import_err_code4.default)(new Error(`Could not resolve path "${path2}"`), "ERR_INVALID_PATH");
    }
    if (cid.code === code && Array.isArray(value2.Links)) {
      const link = value2.Links.find((l) => l.Name === key);
      if (link) {
        yield {
          value: link.Hash,
          remainderPath: parts2.join("/")
        };
        value2 = await load(link.Hash);
        lastCid = link.Hash;
        continue;
      }
    }
    if (Object.prototype.hasOwnProperty.call(value2, key)) {
      value2 = value2[key];
      yield {
        value: value2,
        remainderPath: parts2.join("/")
      };
    } else {
      throw (0, import_err_code4.default)(new Error(`no link named "${key}" under ${lastCid}`), "ERR_NO_LINK");
    }
    if (CID.asCID(value2)) {
      lastCid = value2;
      value2 = await load(value2);
    }
  }
  yield {
    value: value2,
    remainderPath: ""
  };
};
var Service = class {
  /**
   * Takes `activation` function that takes `options` and (async) returns
   * an implementation.
   *
   * @template {(options:any) => Await<any>} T
   *
   * @param {object} config
   * @param {T} config.start
   * @param {(state:State<T>) => Await<void>} [config.stop]
   * @returns {Service<Parameters<T>[0], State<T>>}
   */
  static create({ start, stop: stop2 }) {
    return new Service(start, stop2);
  }
  /**
   * Starts the service (by running actiavtion function). Will (async) throw
   * unless service is stopped.
   *
   * @template Options, T
   * @param {Service<Options, T>} service
   * @param {Options} options
   * @returns {Promise<T>}
   */
  static async start(service, options) {
    const { state, activate } = service;
    switch (state.status) {
      case "stopped": {
        try {
          const promise = activate(options);
          service.state = { status: "starting", ready: promise };
          const result = await promise;
          service.state = { status: "started", value: result };
          return result;
        } catch (error) {
          service.state = { status: "stopped" };
          throw error;
        }
      }
      case "starting": {
        throw new AlreadyStartingError();
      }
      case "started": {
        throw new AlreadyStartedError();
      }
      case "stopping": {
        await state.ready;
        return await Service.start(service, options);
      }
      default: {
        return Service.panic(service);
      }
    }
  }
  /**
   * Stops the service by executing deactivation. If service is stopped
   * or is stopping this is noop. If service is starting up when called
   * it will await for start to complete and then retry stop afterwards.
   * This may (async) throw if `deactivate` does.
   *
   * @template T
   * @param {Service<any, T>} service
   * @returns {Promise<void>}
   */
  static async stop(service) {
    const { state, deactivate } = service;
    switch (state.status) {
      case "stopped": {
        break;
      }
      case "starting": {
        try {
          await state.ready;
        } catch (_) {
        }
        return await Service.stop(service);
      }
      case "stopping": {
        return await state.ready;
      }
      case "started": {
        if (deactivate) {
          await deactivate(state.value);
        }
        service.state = { status: "stopped" };
        break;
      }
      default: {
        Service.panic(state);
      }
    }
  }
  /**
   * @template T
   * @param {Service<any, T>} service
   * @returns {T|null}
   */
  static try({ state }) {
    switch (state.status) {
      case "started":
        return state.value;
      default:
        return null;
    }
  }
  /**
   * Unwraps state and returns underlying value. If state is in idle state it
   * will throw an error. If state is pending it will wait and return the
   * result or throw on failure. If state is ready returns result.
   *
   * @template T
   * @param {Service<any, T>} service
   * @param {AbortOptions} [options]
   * @returns {Promise<T>}
   */
  static async use({ state }, options) {
    switch (state.status) {
      case "started":
        return state.value;
      case "starting":
        return await withTimeout(state.ready, options);
      default:
        throw new NotStartedError();
    }
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * @private
   * @param {Service<any, any>} service
   * @returns {never}
   */
  static panic({ state }) {
    const status = JSON.stringify({ status: state.status });
    throw RangeError(`Service in invalid state ${status}, should never happen if you see this please report a bug`);
  }
  /**
   * Takes `activation` function that takes `options` and (async) returns
   * an implementation.
   *
   * @private
   * @param {(options:Options) => Await<T>} activate
   * @param {(state:T) => Await<void>} [deactivate]
   */
  constructor(activate, deactivate) {
    this.activate = activate;
    this.deactivate = deactivate;
    this.state = { status: "stopped" };
  }
  /**
   * Allows you to asynchronously obtain service implementation. If service
   * is starting it will await for completion. If service is stopped or stopping
   * this will (async) throw exception. This allows components that need to use
   * this service convenient API to do it.
   *
   * @param {AbortOptions} [options] - Abort options.
   * @returns {Promise<T>}
   */
  async use(options) {
    return await Service.use(this, options);
  }
  /**
   * @returns {T|null}
   */
  try() {
    return Service.try(this);
  }
};
function createStart({ network, preload: preload2, peerId, keychain, repo, ipns, mfsPreload, print, hashers, options }) {
  const start = async () => {
    const { libp2p } = await Service.start(network, {
      peerId,
      repo,
      print,
      hashers,
      options
    });
    await Promise.all([
      ipns.startOnline({ keychain, libp2p, peerId, repo }),
      preload2.start(),
      mfsPreload.start()
    ]);
  };
  return start;
}
function createStop({ network, preload: preload2, ipns, repo, mfsPreload }) {
  const stop2 = async () => {
    await Promise.all([
      preload2.stop(),
      ipns.stop(),
      mfsPreload.stop()
    ]);
    await Service.stop(network);
    await repo.close();
  };
  return stop2;
}
var import_hashlru = __toESM(require_hashlru(), 1);
var TLRU = class {
  /**
   * Creates an instance of TLRU.
   *
   * @param {number} maxSize
   */
  constructor(maxSize) {
    this.lru = (0, import_hashlru.default)(maxSize);
  }
  /**
   * Get the value from the a key
   *
   * @param {string} key
   * @returns {T|undefined}
   * @memberof TLoRU
   */
  get(key) {
    const value2 = this.lru.get(key);
    if (value2) {
      if (value2.expire && value2.expire < Date.now()) {
        this.lru.remove(key);
        return void 0;
      }
      return value2.value;
    }
    return void 0;
  }
  /**
   * Set a key value pair
   *
   * @param {string} key
   * @param {T} value
   * @param {number} ttl - in miliseconds
   * @returns {void}
   */
  set(key, value2, ttl2) {
    this.lru.set(key, { value: value2, expire: Date.now() + ttl2 });
  }
  /**
   * Find if the cache has the key
   *
   * @param {string} key
   * @returns {boolean}
   */
  has(key) {
    const value2 = this.get(key);
    if (value2) {
      return true;
    }
    return false;
  }
  /**
   * Remove key
   *
   * @param {string} key
   */
  remove(key) {
    this.lru.remove(key);
  }
  /**
   * Clears the cache
   *
   * @memberof TLRU
   */
  clear() {
    this.lru.clear();
  }
};
var import_eventemitter3 = __toESM(require_eventemitter3());
var TimeoutError2 = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "TimeoutError";
  }
};
var AbortError = class extends Error {
  constructor(message2) {
    super();
    this.name = "AbortError";
    this.message = message2;
  }
};
var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError(errorMessage) : new DOMException(errorMessage);
var getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout(promise, milliseconds, fallback, options) {
  let timer;
  const cancelablePromise = new Promise((resolve7, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve7(promise);
      return;
    }
    options = {
      customTimers: { setTimeout, clearTimeout },
      ...options
    };
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason(signal));
      });
    }
    timer = options.customTimers.setTimeout.call(void 0, () => {
      if (typeof fallback === "function") {
        try {
          resolve7(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const message2 = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError2 = fallback instanceof Error ? fallback : new TimeoutError2(message2);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError2);
    }, milliseconds);
    (async () => {
      try {
        resolve7(await promise);
      } catch (error) {
        reject(error);
      } finally {
        options.customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    clearTimeout(timer);
    timer = void 0;
  };
  return cancelablePromise;
}
function lowerBound(array, value2, comparator) {
  let first2 = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first2 + step;
    if (comparator(array[it], value2) <= 0) {
      first2 = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first2;
}
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PriorityQueue_queue;
var PriorityQueue = class {
  constructor() {
    _PriorityQueue_queue.set(this, []);
  }
  enqueue(run, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      run
    };
    if (this.size && __classPrivateFieldGet2(this, _PriorityQueue_queue, "f")[this.size - 1].priority >= options.priority) {
      __classPrivateFieldGet2(this, _PriorityQueue_queue, "f").push(element);
      return;
    }
    const index2 = lowerBound(__classPrivateFieldGet2(this, _PriorityQueue_queue, "f"), element, (a, b) => b.priority - a.priority);
    __classPrivateFieldGet2(this, _PriorityQueue_queue, "f").splice(index2, 0, element);
  }
  dequeue() {
    const item = __classPrivateFieldGet2(this, _PriorityQueue_queue, "f").shift();
    return item === null || item === void 0 ? void 0 : item.run;
  }
  filter(options) {
    return __classPrivateFieldGet2(this, _PriorityQueue_queue, "f").filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return __classPrivateFieldGet2(this, _PriorityQueue_queue, "f").length;
  }
};
_PriorityQueue_queue = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet2 = function(receiver, state, value2, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet3 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PQueue_instances;
var _PQueue_carryoverConcurrencyCount;
var _PQueue_isIntervalIgnored;
var _PQueue_intervalCount;
var _PQueue_intervalCap;
var _PQueue_interval;
var _PQueue_intervalEnd;
var _PQueue_intervalId;
var _PQueue_timeoutId;
var _PQueue_queue;
var _PQueue_queueClass;
var _PQueue_pendingCount;
var _PQueue_concurrency;
var _PQueue_isPaused;
var _PQueue_throwOnTimeout;
var _PQueue_doesIntervalAllowAnother_get;
var _PQueue_doesConcurrentAllowAnother_get;
var _PQueue_next;
var _PQueue_emitEvents;
var _PQueue_onResumeInterval;
var _PQueue_isIntervalPaused_get;
var _PQueue_tryToStartAnother;
var _PQueue_initializeIntervalIfNeeded;
var _PQueue_onInterval;
var _PQueue_processQueue;
var _PQueue_onEvent;
var timeoutError = new TimeoutError2();
var AbortError2 = class extends Error {
};
var PQueue = class extends import_eventemitter3.default {
  constructor(options) {
    var _a3, _b, _c, _d;
    super();
    _PQueue_instances.add(this);
    _PQueue_carryoverConcurrencyCount.set(this, void 0);
    _PQueue_isIntervalIgnored.set(this, void 0);
    _PQueue_intervalCount.set(this, 0);
    _PQueue_intervalCap.set(this, void 0);
    _PQueue_interval.set(this, void 0);
    _PQueue_intervalEnd.set(this, 0);
    _PQueue_intervalId.set(this, void 0);
    _PQueue_timeoutId.set(this, void 0);
    _PQueue_queue.set(this, void 0);
    _PQueue_queueClass.set(this, void 0);
    _PQueue_pendingCount.set(this, 0);
    _PQueue_concurrency.set(this, void 0);
    _PQueue_isPaused.set(this, void 0);
    _PQueue_throwOnTimeout.set(this, void 0);
    Object.defineProperty(this, "timeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a3 = options.intervalCap) === null || _a3 === void 0 ? void 0 : _a3.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
    }
    __classPrivateFieldSet2(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, "f");
    __classPrivateFieldSet2(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, "f");
    __classPrivateFieldSet2(this, _PQueue_intervalCap, options.intervalCap, "f");
    __classPrivateFieldSet2(this, _PQueue_interval, options.interval, "f");
    __classPrivateFieldSet2(this, _PQueue_queue, new options.queueClass(), "f");
    __classPrivateFieldSet2(this, _PQueue_queueClass, options.queueClass, "f");
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    __classPrivateFieldSet2(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, "f");
    __classPrivateFieldSet2(this, _PQueue_isPaused, options.autoStart === false, "f");
  }
  get concurrency() {
    return __classPrivateFieldGet3(this, _PQueue_concurrency, "f");
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __classPrivateFieldSet2(this, _PQueue_concurrency, newConcurrency, "f");
    __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
  }
  /**
  Adds a sync or async task to the queue. Always returns a promise.
  */
  async add(fn, options = {}) {
    return new Promise((resolve7, reject) => {
      const run = async () => {
        var _a3;
        var _b, _c;
        __classPrivateFieldSet2(this, _PQueue_pendingCount, (_b = __classPrivateFieldGet3(this, _PQueue_pendingCount, "f"), _b++, _b), "f");
        __classPrivateFieldSet2(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet3(this, _PQueue_intervalCount, "f"), _c++, _c), "f");
        try {
          if ((_a3 = options.signal) === null || _a3 === void 0 ? void 0 : _a3.aborted) {
            reject(new AbortError2("The task was aborted."));
            return;
          }
          const operation = this.timeout === void 0 && options.timeout === void 0 ? fn({ signal: options.signal }) : pTimeout(Promise.resolve(fn({ signal: options.signal })), options.timeout === void 0 ? this.timeout : options.timeout, () => {
            if (options.throwOnTimeout === void 0 ? __classPrivateFieldGet3(this, _PQueue_throwOnTimeout, "f") : options.throwOnTimeout) {
              reject(timeoutError);
            }
            return void 0;
          });
          const result = await operation;
          resolve7(result);
          this.emit("completed", result);
        } catch (error) {
          reject(error);
          this.emit("error", error);
        }
        __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_next).call(this);
      };
      __classPrivateFieldGet3(this, _PQueue_queue, "f").enqueue(run, options);
      __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
      this.emit("add");
    });
  }
  /**
      Same as `.add()`, but accepts an array of sync or async functions.
  
      @returns A promise that resolves when all functions are resolved.
      */
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!__classPrivateFieldGet3(this, _PQueue_isPaused, "f")) {
      return this;
    }
    __classPrivateFieldSet2(this, _PQueue_isPaused, false, "f");
    __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    __classPrivateFieldSet2(this, _PQueue_isPaused, true, "f");
  }
  /**
  Clear the queue.
  */
  clear() {
    __classPrivateFieldSet2(this, _PQueue_queue, new (__classPrivateFieldGet3(this, _PQueue_queueClass, "f"))(), "f");
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (__classPrivateFieldGet3(this, _PQueue_queue, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (__classPrivateFieldGet3(this, _PQueue_queue, "f").size < limit) {
      return;
    }
    await __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "next", () => __classPrivateFieldGet3(this, _PQueue_queue, "f").size < limit);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (__classPrivateFieldGet3(this, _PQueue_pendingCount, "f") === 0 && __classPrivateFieldGet3(this, _PQueue_queue, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "idle");
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return __classPrivateFieldGet3(this, _PQueue_queue, "f").size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options) {
    return __classPrivateFieldGet3(this, _PQueue_queue, "f").filter(options).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return __classPrivateFieldGet3(this, _PQueue_pendingCount, "f");
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return __classPrivateFieldGet3(this, _PQueue_isPaused, "f");
  }
};
_PQueue_carryoverConcurrencyCount = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap = /* @__PURE__ */ new WeakMap(), _PQueue_interval = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId = /* @__PURE__ */ new WeakMap(), _PQueue_queue = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass = /* @__PURE__ */ new WeakMap(), _PQueue_pendingCount = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout = /* @__PURE__ */ new WeakMap(), _PQueue_instances = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get2() {
  return __classPrivateFieldGet3(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet3(this, _PQueue_intervalCount, "f") < __classPrivateFieldGet3(this, _PQueue_intervalCap, "f");
}, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get2() {
  return __classPrivateFieldGet3(this, _PQueue_pendingCount, "f") < __classPrivateFieldGet3(this, _PQueue_concurrency, "f");
}, _PQueue_next = function _PQueue_next2() {
  var _a3;
  __classPrivateFieldSet2(this, _PQueue_pendingCount, (_a3 = __classPrivateFieldGet3(this, _PQueue_pendingCount, "f"), _a3--, _a3), "f");
  __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
  this.emit("next");
}, _PQueue_emitEvents = function _PQueue_emitEvents2() {
  this.emit("empty");
  if (__classPrivateFieldGet3(this, _PQueue_pendingCount, "f") === 0) {
    this.emit("idle");
  }
}, _PQueue_onResumeInterval = function _PQueue_onResumeInterval2() {
  __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
  __classPrivateFieldSet2(this, _PQueue_timeoutId, void 0, "f");
}, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get2() {
  const now = Date.now();
  if (__classPrivateFieldGet3(this, _PQueue_intervalId, "f") === void 0) {
    const delay3 = __classPrivateFieldGet3(this, _PQueue_intervalEnd, "f") - now;
    if (delay3 < 0) {
      __classPrivateFieldSet2(this, _PQueue_intervalCount, __classPrivateFieldGet3(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet3(this, _PQueue_pendingCount, "f") : 0, "f");
    } else {
      if (__classPrivateFieldGet3(this, _PQueue_timeoutId, "f") === void 0) {
        __classPrivateFieldSet2(this, _PQueue_timeoutId, setTimeout(() => {
          __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_onResumeInterval).call(this);
        }, delay3), "f");
      }
      return true;
    }
  }
  return false;
}, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother2() {
  if (__classPrivateFieldGet3(this, _PQueue_queue, "f").size === 0) {
    if (__classPrivateFieldGet3(this, _PQueue_intervalId, "f")) {
      clearInterval(__classPrivateFieldGet3(this, _PQueue_intervalId, "f"));
    }
    __classPrivateFieldSet2(this, _PQueue_intervalId, void 0, "f");
    __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_emitEvents).call(this);
    return false;
  }
  if (!__classPrivateFieldGet3(this, _PQueue_isPaused, "f")) {
    const canInitializeInterval = !__classPrivateFieldGet3(this, _PQueue_instances, "a", _PQueue_isIntervalPaused_get);
    if (__classPrivateFieldGet3(this, _PQueue_instances, "a", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet3(this, _PQueue_instances, "a", _PQueue_doesConcurrentAllowAnother_get)) {
      const job = __classPrivateFieldGet3(this, _PQueue_queue, "f").dequeue();
      if (!job) {
        return false;
      }
      this.emit("active");
      job();
      if (canInitializeInterval) {
        __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
      }
      return true;
    }
  }
  return false;
}, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded2() {
  if (__classPrivateFieldGet3(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet3(this, _PQueue_intervalId, "f") !== void 0) {
    return;
  }
  __classPrivateFieldSet2(this, _PQueue_intervalId, setInterval(() => {
    __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  }, __classPrivateFieldGet3(this, _PQueue_interval, "f")), "f");
  __classPrivateFieldSet2(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet3(this, _PQueue_interval, "f"), "f");
}, _PQueue_onInterval = function _PQueue_onInterval2() {
  if (__classPrivateFieldGet3(this, _PQueue_intervalCount, "f") === 0 && __classPrivateFieldGet3(this, _PQueue_pendingCount, "f") === 0 && __classPrivateFieldGet3(this, _PQueue_intervalId, "f")) {
    clearInterval(__classPrivateFieldGet3(this, _PQueue_intervalId, "f"));
    __classPrivateFieldSet2(this, _PQueue_intervalId, void 0, "f");
  }
  __classPrivateFieldSet2(this, _PQueue_intervalCount, __classPrivateFieldGet3(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet3(this, _PQueue_pendingCount, "f") : 0, "f");
  __classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
}, _PQueue_processQueue = function _PQueue_processQueue2() {
  while (__classPrivateFieldGet3(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this)) {
  }
}, _PQueue_onEvent = async function _PQueue_onEvent2(event, filter32) {
  return new Promise((resolve7) => {
    const listener = () => {
      if (filter32 && !filter32()) {
        return;
      }
      this.off(event, listener);
      resolve7();
    };
    this.on(event, listener);
  });
};
var import_http = __toESM(require_http());
var cache = new TLRU(1e3);
var ttl = 60 * 1e3;
var Queue = PQueue.default ? PQueue.default : PQueue;
var httpQueue = new Queue({ concurrency: 4 });
var ipfsPath2 = (response) => {
  if (response.Path)
    return response.Path;
  throw new Error(response.Message);
};
async function resolveDnslink(fqdn, opts) {
  const resolve7 = async (fqdn2, opts2 = {}) => {
    const searchParams = new URLSearchParams(opts2);
    searchParams.set("arg", fqdn2);
    const query = searchParams.toString();
    if (!opts2.nocache && cache.has(query)) {
      const response2 = cache.get(query);
      return ipfsPath2(response2);
    }
    const response = await httpQueue.add(async () => {
      const res = await import_http.default.get("https://ipfs.io/api/v0/dns", { searchParams });
      const query2 = new URL(res.url).search.slice(1);
      const json = await res.json();
      cache.set(query2, json, ttl);
      return json;
    });
    return ipfsPath2(response);
  };
  return resolve7(fqdn, opts);
}
function fqdnFixups(domain) {
  if (domain.endsWith(".eth")) {
    domain = domain.replace(/.eth$/, ".eth.link");
  }
  return domain;
}
function createDns() {
  const resolveDNS = async (domain, options = { recursive: true }) => {
    if (typeof domain !== "string") {
      throw new Error("Invalid arguments, domain must be a string");
    }
    domain = fqdnFixups(domain);
    return resolveDnslink(domain, options);
  };
  return withTimeoutOption(resolveDNS);
}
function createIsOnline({ network }) {
  return () => {
    const net = network.try();
    return net != null && Boolean(net.libp2p.isStarted());
  };
}
var AbortError3 = class extends Error {
  constructor(message2 = "The operation was aborted") {
    super(message2);
    this.code = AbortError3.code;
    this.type = AbortError3.type;
  }
  static get code() {
    return "ABORT_ERR";
  }
  static get type() {
    return "aborted";
  }
};
var CodeError = class extends Error {
  constructor(message2, code8, props) {
    super(message2);
    this.code = code8;
    this.name = props?.name ?? "CodeError";
    this.props = props ?? {};
  }
};
var symbol2 = Symbol.for("@libp2p/peer-id");
function isPeerId(other) {
  return other != null && Boolean(other[symbol2]);
}
var inspect2 = Symbol.for("nodejs.util.inspect.custom");
var baseDecoder = Object.values(bases).map((codec) => codec.decoder).reduce((acc, curr) => acc.or(curr), bases.identity.decoder);
var LIBP2P_KEY_CODE = 114;
var MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;
var MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;
var PeerIdImpl = class {
  constructor(init) {
    this.type = init.type;
    this.multihash = init.multihash;
    this.privateKey = init.privateKey;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  get [symbol2]() {
    return true;
  }
  toString() {
    if (this.string == null) {
      this.string = base58btc.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  // return self-describing String representation
  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
  toCID() {
    return CID.createV1(LIBP2P_KEY_CODE, this.multihash);
  }
  toBytes() {
    return this.multihash.bytes;
  }
  /**
   * Returns Multiaddr as a JSON string
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Checks the equality of `this` peer against a given PeerId
   */
  equals(id) {
    if (id instanceof Uint8Array) {
      return equals(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return peerIdFromString(id).equals(this);
    } else if (id?.multihash?.bytes != null) {
      return equals(this.multihash.bytes, id.multihash.bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  /**
   * Returns PeerId as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { peerIdFromString } from '@libp2p/peer-id'
   *
   * console.info(peerIdFromString('QmFoo'))
   * // 'PeerId(QmFoo)'
   * ```
   */
  [inspect2]() {
    return `PeerId(${this.toString()})`;
  }
};
var RSAPeerIdImpl = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "RSA" });
    this.type = "RSA";
    this.publicKey = init.publicKey;
  }
};
var Ed25519PeerIdImpl = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "Ed25519" });
    this.type = "Ed25519";
    this.publicKey = init.multihash.digest;
  }
};
var Secp256k1PeerIdImpl = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "secp256k1" });
    this.type = "secp256k1";
    this.publicKey = init.multihash.digest;
  }
};
function peerIdFromPeerId(other) {
  if (other.type === "RSA") {
    return new RSAPeerIdImpl(other);
  }
  if (other.type === "Ed25519") {
    return new Ed25519PeerIdImpl(other);
  }
  if (other.type === "secp256k1") {
    return new Secp256k1PeerIdImpl(other);
  }
  throw new CodeError("Not a PeerId", "ERR_INVALID_PARAMETERS");
}
function peerIdFromString(str, decoder) {
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    const multihash = decode3$3(base58btc.decode(`z${str}`));
    if (str.startsWith("12D")) {
      return new Ed25519PeerIdImpl({ multihash });
    } else if (str.startsWith("16U")) {
      return new Secp256k1PeerIdImpl({ multihash });
    } else {
      return new RSAPeerIdImpl({ multihash });
    }
  }
  return peerIdFromBytes(baseDecoder.decode(str));
}
function peerIdFromBytes(buf2) {
  try {
    const multihash = decode3$3(buf2);
    if (multihash.code === identity.code) {
      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
        return new Ed25519PeerIdImpl({ multihash });
      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
        return new Secp256k1PeerIdImpl({ multihash });
      }
    }
    if (multihash.code === sha256.code) {
      return new RSAPeerIdImpl({ multihash });
    }
  } catch {
    return peerIdFromCID(CID.decode(buf2));
  }
  throw new Error("Supplied PeerID CID is invalid");
}
function peerIdFromCID(cid) {
  if (cid == null || cid.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE) {
    throw new Error("Supplied PeerID CID is invalid");
  }
  const multihash = cid.multihash;
  if (multihash.code === sha256.code) {
    return new RSAPeerIdImpl({ multihash: cid.multihash });
  } else if (multihash.code === identity.code) {
    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
      return new Ed25519PeerIdImpl({ multihash: cid.multihash });
    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
      return new Secp256k1PeerIdImpl({ multihash: cid.multihash });
    }
  }
  throw new Error("Supplied PeerID CID is invalid");
}
async function peerIdFromKeys(publicKey, privateKey) {
  if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
    return new Ed25519PeerIdImpl({ multihash: create(identity.code, publicKey), privateKey });
  }
  if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
    return new Secp256k1PeerIdImpl({ multihash: create(identity.code, publicKey), privateKey });
  }
  return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey });
}
function createResolve({ repo, codecs: codecs2, bases: bases2, name: name9 }) {
  async function resolve7(path2, opts = {}) {
    if (!path(path2)) {
      throw new Error("invalid argument " + path2);
    }
    if (ipnsPath(path2)) {
      for await (const resolvedPath of name9.resolve(path2, opts)) {
        path2 = resolvedPath;
      }
    }
    const [, schema, hash3, ...rest] = path2.split("/");
    const base3 = opts.cidBase ? await bases2.getBase(opts.cidBase) : void 0;
    const bytes2 = parseBytes(hash3);
    if (rest.length === 0) {
      const str = base3 ? base3.encoder.encode(bytes2) : hash3;
      return `/${schema}/${str}`;
    }
    const cid = CID.decode(bytes2);
    path2 = rest.join("/");
    const results = resolve(cid, path2, codecs2, repo, opts);
    let value2 = cid;
    let remainderPath = path2;
    for await (const result of results) {
      if (CID.asCID(result.value)) {
        value2 = result.value;
        remainderPath = result.remainderPath;
      }
    }
    return `/ipfs/${value2.toString(base3 && base3.encoder)}${remainderPath ? "/" + remainderPath : ""}`;
  }
  return withTimeoutOption(resolve7);
}
function parseBytes(str) {
  try {
    return peerIdFromString(str).toBytes();
  } catch {
    return CID.parse(str).bytes;
  }
}
async function last(source) {
  let res;
  for await (const entry of source) {
    res = entry;
  }
  return res;
}
function createAdd({ addAll }) {
  return (path2, options = {}) => {
    let iter;
    const cid = CID.asCID(path2);
    if (cid) {
      iter = addAll([{
        cid,
        ...options
      }], options);
    } else {
      iter = addAll([{
        path: path2.toString(),
        ...options
      }], options);
    }
    return last(iter);
  };
}
var import_err_code5 = __toESM(require_err_code());
function isIterable(thing) {
  return Symbol.iterator in thing;
}
function isAsyncIterable(thing) {
  return Symbol.asyncIterator in thing;
}
function isCID2(thing) {
  return CID.asCID(thing) != null;
}
async function* normaliseInput(input) {
  if (input === null || input === void 0) {
    throw (0, import_err_code5.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  const cid = CID.asCID(input);
  if (cid) {
    yield toPin({ cid });
    return;
  }
  if (input instanceof String || typeof input === "string") {
    yield toPin({ path: input });
    return;
  }
  if (input.cid != null || input.path != null) {
    return yield toPin(input);
  }
  if (isIterable(input)) {
    const iterator = input[Symbol.iterator]();
    const first2 = iterator.next();
    if (first2.done) {
      return iterator;
    }
    if (isCID2(first2.value)) {
      yield toPin({ cid: first2.value });
      for (const cid2 of iterator) {
        yield toPin({ cid: cid2 });
      }
      return;
    }
    if (first2.value instanceof String || typeof first2.value === "string") {
      yield toPin({ path: first2.value });
      for (const path2 of iterator) {
        yield toPin({ path: path2 });
      }
      return;
    }
    if (first2.value.cid != null || first2.value.path != null) {
      yield toPin(first2.value);
      for (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw (0, import_err_code5.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  }
  if (isAsyncIterable(input)) {
    const iterator = input[Symbol.asyncIterator]();
    const first2 = await iterator.next();
    if (first2.done)
      return iterator;
    if (isCID2(first2.value)) {
      yield toPin({ cid: first2.value });
      for await (const cid2 of iterator) {
        yield toPin({ cid: cid2 });
      }
      return;
    }
    if (first2.value instanceof String || typeof first2.value === "string") {
      yield toPin({ path: first2.value });
      for await (const path2 of iterator) {
        yield toPin({ path: path2 });
      }
      return;
    }
    if (first2.value.cid != null || first2.value.path != null) {
      yield toPin(first2.value);
      for await (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw (0, import_err_code5.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  }
  throw (0, import_err_code5.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
}
function toPin(input) {
  const path2 = input.cid || `${input.path}`;
  if (!path2) {
    throw (0, import_err_code5.default)(new Error("Unexpected input: Please path either a CID or an IPFS path"), "ERR_UNEXPECTED_INPUT");
  }
  const pin = {
    path: path2,
    recursive: input.recursive !== false
  };
  if (input.metadata != null) {
    pin.metadata = input.metadata;
  }
  return pin;
}
var PinTypes = {
  /** @type {'direct'} */
  direct: "direct",
  /** @type {'recursive'} */
  recursive: "recursive",
  /** @type {'indirect'} */
  indirect: "indirect",
  /** @type {'all'} */
  all: "all"
};
function createAddAll({ repo, codecs: codecs2 }) {
  async function* addAll(source, options = {}) {
    const pinAdd = async function* () {
      for await (const { path: path2, recursive: recursive2, metadata } of normaliseInput(source)) {
        const { cid } = await resolvePath(repo, codecs2, path2);
        const { reason } = await repo.pins.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct]);
        if (reason === "recursive" && !recursive2) {
          throw new Error(`${cid} already pinned recursively`);
        }
        if (recursive2) {
          await repo.pins.pinRecursively(cid, { metadata });
        } else {
          await repo.pins.pinDirectly(cid, { metadata });
        }
        yield cid;
      }
    };
    const lock3 = Boolean(options.lock);
    if (!lock3) {
      yield* pinAdd();
      return;
    }
    const release = await repo.gcLock.readLock();
    try {
      yield* pinAdd();
    } finally {
      release();
    }
  }
  return withTimeoutOption(addAll);
}
var import_err_code6 = __toESM(require_err_code(), 1);
function toPin2(type, cid, metadata) {
  const output = {
    type,
    cid
  };
  if (metadata) {
    output.metadata = metadata;
  }
  return output;
}
function createLs({ repo, codecs: codecs2 }) {
  async function* ls(options = {}) {
    let type = PinTypes.all;
    if (options.type) {
      type = options.type;
      if (!Object.keys(PinTypes).includes(type)) {
        throw (0, import_err_code6.default)(new Error("Invalid pin type"), "ERR_INVALID_PIN_TYPE");
      }
    }
    if (options.paths) {
      let matched = false;
      for await (const { path: path2 } of normaliseInput(options.paths)) {
        const { cid } = await resolvePath(repo, codecs2, path2);
        const { reason, pinned, parent: parent2, metadata } = await repo.pins.isPinnedWithType(cid, type);
        if (!pinned) {
          throw (0, import_err_code6.default)(new Error(`path '${path2}' is not pinned`), "ERR_NOT_PINNED");
        }
        switch (reason) {
          case PinTypes.direct:
          case PinTypes.recursive:
            matched = true;
            yield toPin2(reason, cid, metadata);
            break;
          default:
            matched = true;
            yield toPin2(`${PinTypes.indirect} through ${parent2}`, cid, metadata);
        }
      }
      if (!matched) {
        throw new Error("No match found");
      }
      return;
    }
    if (type === PinTypes.recursive || type === PinTypes.all) {
      for await (const { cid, metadata } of repo.pins.recursiveKeys()) {
        yield toPin2(PinTypes.recursive, cid, metadata);
      }
    }
    if (type === PinTypes.indirect || type === PinTypes.all) {
      for await (const cid of repo.pins.indirectKeys(options)) {
        yield toPin2(PinTypes.indirect, cid);
      }
    }
    if (type === PinTypes.direct || type === PinTypes.all) {
      for await (const { cid, metadata } of repo.pins.directKeys()) {
        yield toPin2(PinTypes.direct, cid, metadata);
      }
    }
  }
  return withTimeoutOption(ls);
}
function createRm({ rmAll }) {
  async function rm(path2, options = {}) {
    const cid = await last(rmAll([{ path: path2, ...options }], options));
    if (!cid) {
      throw new Error("CID expected");
    }
    return cid;
  }
  return rm;
}
function createRmAll({ repo, codecs: codecs2 }) {
  async function* rmAll(source, _options = {}) {
    const release = await repo.gcLock.readLock();
    try {
      for await (const { path: path2, recursive: recursive2 } of normaliseInput(source)) {
        const { cid } = await resolvePath(repo, codecs2, path2);
        const { pinned, reason } = await repo.pins.isPinnedWithType(cid, PinTypes.all);
        if (!pinned) {
          throw new Error(`${cid} is not pinned`);
        }
        switch (reason) {
          case PinTypes.recursive:
            if (!recursive2) {
              throw new Error(`${cid} is pinned recursively`);
            }
            await repo.pins.unpin(cid);
            yield cid;
            break;
          case PinTypes.direct:
            await repo.pins.unpin(cid);
            yield cid;
            break;
          default:
            throw new Error(`${cid} is pinned indirectly under ${reason}`);
        }
      }
    } finally {
      release();
    }
  }
  return withTimeoutOption(rmAll);
}
var PinAPI = class {
  /**
   * @param {object} config
   * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs
   * @param {import('ipfs-repo').IPFSRepo} config.repo
   */
  constructor({ codecs: codecs2, repo }) {
    const addAll = createAddAll({ codecs: codecs2, repo });
    this.addAll = addAll;
    this.add = createAdd({ addAll });
    const rmAll = createRmAll({ codecs: codecs2, repo });
    this.rmAll = rmAll;
    this.rm = createRm({ rmAll });
    this.ls = createLs({ codecs: codecs2, repo });
    this.remote = {
      add: (cid, options = {}) => Promise.reject(new Error("Not implemented")),
      ls: async function* (query, options = {}) {
        return Promise.reject(new Error("Not implemented"));
      },
      // eslint-disable-line require-yield
      rm: (query, options = {}) => Promise.reject(new Error("Not implemented")),
      rmAll: (query, options = {}) => Promise.reject(new Error("Not implemented")),
      service: {
        add: (name9, credentials) => Promise.reject(new Error("Not implemented")),
        rm: (name9, options = {}) => Promise.reject(new Error("Not implemented")),
        // @ts-expect-error return types seem to be broken by a recent ts release. doesn't matter here because
        // we are just throwing. Will be removed by https://github.com/protocol/web3-dev-team/pull/58
        ls: (options = {}) => Promise.reject(new Error("Not implemented"))
      }
    };
  }
};
var import_err_code24 = __toESM(require_err_code(), 1);
var errors_exports = {};
__export(errors_exports, {
  abortedError: () => abortedError,
  dbDeleteFailedError: () => dbDeleteFailedError,
  dbOpenFailedError: () => dbOpenFailedError,
  dbWriteFailedError: () => dbWriteFailedError,
  notFoundError: () => notFoundError
});
var import_err_code7 = __toESM(require_err_code());
function dbOpenFailedError(err2) {
  err2 = err2 || new Error("Cannot open database");
  return (0, import_err_code7.default)(err2, "ERR_DB_OPEN_FAILED");
}
function dbDeleteFailedError(err2) {
  err2 = err2 || new Error("Delete failed");
  return (0, import_err_code7.default)(err2, "ERR_DB_DELETE_FAILED");
}
function dbWriteFailedError(err2) {
  err2 = err2 || new Error("Write failed");
  return (0, import_err_code7.default)(err2, "ERR_DB_WRITE_FAILED");
}
function notFoundError(err2) {
  err2 = err2 || new Error("Not Found");
  return (0, import_err_code7.default)(err2, "ERR_NOT_FOUND");
}
function abortedError(err2) {
  err2 = err2 || new Error("Aborted");
  return (0, import_err_code7.default)(err2, "ERR_ABORTED");
}
var import_err_code20 = __toESM(require_err_code(), 1);
var import_timestamp_nano = __toESM(require_timestamp_min());
var keys_exports2 = {};
__export(keys_exports2, {
  generateEphemeralKeyPair: () => ephemeral_keys_default,
  generateKeyPair: () => generateKeyPair4,
  generateKeyPairFromSeed: () => generateKeyPairFromSeed2,
  importKey: () => importKey,
  keyStretcher: () => keyStretcher,
  keysPBM: () => keys_exports,
  marshalPrivateKey: () => marshalPrivateKey,
  marshalPublicKey: () => marshalPublicKey2,
  supportedKeys: () => supportedKeys,
  unmarshalPrivateKey: () => unmarshalPrivateKey3,
  unmarshalPublicKey: () => unmarshalPublicKey2
});
var keys_exports = {};
__export(keys_exports, {
  KeyType: () => KeyType,
  PrivateKey: () => PrivateKey,
  PublicKey: () => PublicKey
});
var import_reader = __toESM(require_reader(), 1);
var import_reader_buffer = __toESM(require_reader_buffer(), 1);
var import_writer = __toESM(require_writer(), 1);
var import_writer_buffer = __toESM(require_writer_buffer(), 1);
var import_minimal2 = __toESM(require_minimal(), 1);
function configure() {
  import_minimal2.default._configure();
  import_reader.default._configure(import_reader_buffer.default);
  import_writer.default._configure(import_writer_buffer.default);
}
configure();
var methods = [
  "uint64",
  "int64",
  "sint64",
  "fixed64",
  "sfixed64"
];
function patchReader(obj) {
  for (const method of methods) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function() {
      return BigInt(original.call(this).toString());
    };
  }
  return obj;
}
function reader(buf2) {
  return patchReader(new import_reader.default(buf2));
}
function patchWriter(obj) {
  for (const method of methods) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function(val) {
      return original.call(this, val.toString());
    };
  }
  return obj;
}
function writer() {
  return patchWriter(import_writer.default.create());
}
function decodeMessage(buf2, codec) {
  const r = reader(buf2 instanceof Uint8Array ? buf2 : buf2.subarray());
  return codec.decode(r);
}
function encodeMessage(message2, codec) {
  const w = writer();
  codec.encode(message2, w, {
    lengthDelimited: false
  });
  return w.finish();
}
var CODEC_TYPES;
(function(CODEC_TYPES2) {
  CODEC_TYPES2[CODEC_TYPES2["VARINT"] = 0] = "VARINT";
  CODEC_TYPES2[CODEC_TYPES2["BIT64"] = 1] = "BIT64";
  CODEC_TYPES2[CODEC_TYPES2["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES2[CODEC_TYPES2["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES || (CODEC_TYPES = {}));
function createCodec2(name9, type, encode21, decode17) {
  return {
    name: name9,
    type,
    encode: encode21,
    decode: decode17
  };
}
function enumeration(v) {
  function findValue(val) {
    if (v[val.toString()] == null) {
      throw new Error("Invalid enum value");
    }
    return v[val];
  }
  const encode21 = function enumEncode(val, writer2) {
    const enumValue = findValue(val);
    writer2.int32(enumValue);
  };
  const decode17 = function enumDecode(reader3) {
    const val = reader3.int32();
    return findValue(val);
  };
  return createCodec2("enum", CODEC_TYPES.VARINT, encode21, decode17);
}
function message(encode21, decode17) {
  return createCodec2("message", CODEC_TYPES.LENGTH_DELIMITED, encode21, decode17);
}
var KeyType;
(function(KeyType2) {
  KeyType2["RSA"] = "RSA";
  KeyType2["Ed25519"] = "Ed25519";
  KeyType2["Secp256k1"] = "Secp256k1";
})(KeyType || (KeyType = {}));
var __KeyTypeValues;
(function(__KeyTypeValues2) {
  __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
  __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
  __KeyTypeValues2[__KeyTypeValues2["Secp256k1"] = 2] = "Secp256k1";
})(__KeyTypeValues || (__KeyTypeValues = {}));
(function(KeyType2) {
  KeyType2.codec = () => {
    return enumeration(__KeyTypeValues);
  };
})(KeyType || (KeyType = {}));
var PublicKey;
(function(PublicKey2) {
  let _codec;
  PublicKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {};
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = KeyType.codec().decode(reader3);
              break;
            case 2:
              obj.Data = reader3.bytes();
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PublicKey2.encode = (obj) => {
    return encodeMessage(obj, PublicKey2.codec());
  };
  PublicKey2.decode = (buf2) => {
    return decodeMessage(buf2, PublicKey2.codec());
  };
})(PublicKey || (PublicKey = {}));
var PrivateKey;
(function(PrivateKey2) {
  let _codec;
  PrivateKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {};
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = KeyType.codec().decode(reader3);
              break;
            case 2:
              obj.Data = reader3.bytes();
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PrivateKey2.encode = (obj) => {
    return encodeMessage(obj, PrivateKey2.codec());
  };
  PrivateKey2.decode = (buf2) => {
    return decodeMessage(buf2, PrivateKey2.codec());
  };
})(PrivateKey || (PrivateKey = {}));
__toESM(require_asn1());
__toESM(require_pbe());
var import_forge5 = __toESM(require_forge());
var import_err_code17 = __toESM(require_err_code());
var import_err_code8 = __toESM(require_err_code(), 1);
var webcrypto_default = {
  get(win = globalThis) {
    const nativeCrypto = win.crypto;
    if (nativeCrypto == null || nativeCrypto.subtle == null) {
      throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
    }
    return nativeCrypto;
  }
};
var lengths_default = {
  SHA1: 20,
  SHA256: 32,
  SHA512: 64
};
var hashTypes = {
  SHA1: "SHA-1",
  SHA256: "SHA-256",
  SHA512: "SHA-512"
};
var sign$1 = async (key, data) => {
  const buf2 = await webcrypto_default.get().subtle.sign({ name: "HMAC" }, key, data);
  return new Uint8Array(buf2, 0, buf2.byteLength);
};
async function create2(hashType, secret) {
  const hash3 = hashTypes[hashType];
  const key = await webcrypto_default.get().subtle.importKey("raw", secret, {
    name: "HMAC",
    hash: { name: hash3 }
  }, false, ["sign"]);
  return {
    async digest(data) {
      return await sign$1(key, data);
    },
    length: lengths_default[hashType]
  };
}
var cipherMap = {
  "AES-128": {
    ivSize: 16,
    keySize: 16
  },
  "AES-256": {
    ivSize: 16,
    keySize: 32
  },
  Blowfish: {
    ivSize: 8,
    keySize: 32
  }
};
async function keyStretcher(cipherType, hash3, secret) {
  const cipher = cipherMap[cipherType];
  if (cipher == null) {
    const allowed = Object.keys(cipherMap).join(" / ");
    throw (0, import_err_code8.default)(new Error(`unknown cipher type '${cipherType}'. Must be ${allowed}`), "ERR_INVALID_CIPHER_TYPE");
  }
  if (hash3 == null) {
    throw (0, import_err_code8.default)(new Error("missing hash type"), "ERR_MISSING_HASH_TYPE");
  }
  const cipherKeySize = cipher.keySize;
  const ivSize = cipher.ivSize;
  const hmacKeySize = 20;
  const seed2 = fromString3("key expansion");
  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);
  const m = await create2(hash3, secret);
  let a = await m.digest(seed2);
  const result = [];
  let j = 0;
  while (j < resultLength) {
    const b = await m.digest(concat([a, seed2]));
    let todo = b.length;
    if (j + todo > resultLength) {
      todo = resultLength - j;
    }
    result.push(b);
    j += todo;
    a = await m.digest(a);
  }
  const half = resultLength / 2;
  const resultBuffer = concat(result);
  const r1 = resultBuffer.subarray(0, half);
  const r2 = resultBuffer.subarray(half, resultLength);
  const createKey2 = (res) => ({
    iv: res.subarray(0, ivSize),
    cipherKey: res.subarray(ivSize, ivSize + cipherKeySize),
    macKey: res.subarray(ivSize + cipherKeySize)
  });
  return {
    k1: createKey2(r1),
    k2: createKey2(r2)
  };
}
var import_err_code9 = __toESM(require_err_code(), 1);
__toESM(require_util(), 1);
__toESM(require_jsbn(), 1);
var import_forge = __toESM(require_forge(), 1);
function bigIntegerToUintBase64url(num, len) {
  let buf2 = Uint8Array.from(num.abs().toByteArray());
  buf2 = buf2[0] === 0 ? buf2.subarray(1) : buf2;
  if (len != null) {
    if (buf2.length > len)
      throw new Error("byte array longer than desired length");
    buf2 = concat([new Uint8Array(len - buf2.length), buf2]);
  }
  return toString3(buf2, "base64url");
}
function base64urlToBigInteger(str) {
  const buf2 = base64urlToBuffer(str);
  return new import_forge.default.jsbn.BigInteger(toString3(buf2, "base16"), 16);
}
function base64urlToBuffer(str, len) {
  let buf2 = fromString3(str, "base64urlpad");
  if (len != null) {
    if (buf2.length > len)
      throw new Error("byte array longer than desired length");
    buf2 = concat([new Uint8Array(len - buf2.length), buf2]);
  }
  return buf2;
}
var bits = {
  "P-256": 256,
  "P-384": 384,
  "P-521": 521
};
var curveTypes = Object.keys(bits);
var names2 = curveTypes.join(" / ");
async function generateEphmeralKeyPair(curve) {
  if (curve !== "P-256" && curve !== "P-384" && curve !== "P-521") {
    throw (0, import_err_code9.default)(new Error(`Unknown curve: ${curve}. Must be ${names2}`), "ERR_INVALID_CURVE");
  }
  const pair2 = await webcrypto_default.get().subtle.generateKey({
    name: "ECDH",
    namedCurve: curve
  }, true, ["deriveBits"]);
  const genSharedKey = async (theirPub, forcePrivate) => {
    let privateKey;
    if (forcePrivate != null) {
      privateKey = await webcrypto_default.get().subtle.importKey("jwk", unmarshalPrivateKey(curve, forcePrivate), {
        name: "ECDH",
        namedCurve: curve
      }, false, ["deriveBits"]);
    } else {
      privateKey = pair2.privateKey;
    }
    const key = await webcrypto_default.get().subtle.importKey("jwk", unmarshalPublicKey(curve, theirPub), {
      name: "ECDH",
      namedCurve: curve
    }, false, []);
    const buffer2 = await webcrypto_default.get().subtle.deriveBits({
      name: "ECDH",
      // @ts-expect-error namedCurve is missing from the types
      namedCurve: curve,
      public: key
    }, privateKey, bits[curve]);
    return new Uint8Array(buffer2, 0, buffer2.byteLength);
  };
  const publicKey = await webcrypto_default.get().subtle.exportKey("jwk", pair2.publicKey);
  const ecdhKey = {
    key: marshalPublicKey(publicKey),
    genSharedKey
  };
  return ecdhKey;
}
var curveLengths = {
  "P-256": 32,
  "P-384": 48,
  "P-521": 66
};
function marshalPublicKey(jwk) {
  if (jwk.crv == null || jwk.x == null || jwk.y == null) {
    throw (0, import_err_code9.default)(new Error("JWK was missing components"), "ERR_INVALID_PARAMETERS");
  }
  if (jwk.crv !== "P-256" && jwk.crv !== "P-384" && jwk.crv !== "P-521") {
    throw (0, import_err_code9.default)(new Error(`Unknown curve: ${jwk.crv}. Must be ${names2}`), "ERR_INVALID_CURVE");
  }
  const byteLen = curveLengths[jwk.crv];
  return concat([
    Uint8Array.from([4]),
    base64urlToBuffer(jwk.x, byteLen),
    base64urlToBuffer(jwk.y, byteLen)
  ], 1 + byteLen * 2);
}
function unmarshalPublicKey(curve, key) {
  if (curve !== "P-256" && curve !== "P-384" && curve !== "P-521") {
    throw (0, import_err_code9.default)(new Error(`Unknown curve: ${curve}. Must be ${names2}`), "ERR_INVALID_CURVE");
  }
  const byteLen = curveLengths[curve];
  if (!equals(key.subarray(0, 1), Uint8Array.from([4]))) {
    throw (0, import_err_code9.default)(new Error("Cannot unmarshal public key - invalid key format"), "ERR_INVALID_KEY_FORMAT");
  }
  return {
    kty: "EC",
    crv: curve,
    x: toString3(key.subarray(1, byteLen + 1), "base64url"),
    y: toString3(key.subarray(1 + byteLen), "base64url"),
    ext: true
  };
}
var unmarshalPrivateKey = (curve, key) => ({
  ...unmarshalPublicKey(curve, key.public),
  d: toString3(key.private, "base64url")
});
var ephemeral_keys_default = generateEphmeralKeyPair;
function create3(opts) {
  const algorithm = opts?.algorithm ?? "AES-GCM";
  let keyLength = opts?.keyLength ?? 16;
  const nonceLength = opts?.nonceLength ?? 12;
  const digest2 = opts?.digest ?? "SHA-256";
  const saltLength = opts?.saltLength ?? 16;
  const iterations = opts?.iterations ?? 32767;
  const crypto4 = webcrypto_default.get();
  keyLength *= 8;
  async function encrypt2(data, password) {
    const salt = crypto4.getRandomValues(new Uint8Array(saltLength));
    const nonce = crypto4.getRandomValues(new Uint8Array(nonceLength));
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString3(password);
    }
    const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
    const rawKey = await crypto4.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
    const cryptoKey = await crypto4.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
    const ciphertext = await crypto4.subtle.encrypt(aesGcm, cryptoKey, data);
    return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
  }
  async function decrypt2(data, password) {
    const salt = data.subarray(0, saltLength);
    const nonce = data.subarray(saltLength, saltLength + nonceLength);
    const ciphertext = data.subarray(saltLength + nonceLength);
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString3(password);
    }
    const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
    const rawKey = await crypto4.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
    const cryptoKey = await crypto4.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
    const plaintext = await crypto4.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
    return new Uint8Array(plaintext);
  }
  const cipher = {
    encrypt: encrypt2,
    decrypt: decrypt2
  };
  return cipher;
}
async function importer(privateKey, password) {
  const encryptedKey = base64.decode(privateKey);
  const cipher = create3();
  return await cipher.decrypt(encryptedKey, password);
}
var rsa_class_exports = {};
__export(rsa_class_exports, {
  RsaPrivateKey: () => RsaPrivateKey,
  RsaPublicKey: () => RsaPublicKey,
  fromJwk: () => fromJwk,
  generateKeyPair: () => generateKeyPair,
  unmarshalRsaPrivateKey: () => unmarshalRsaPrivateKey,
  unmarshalRsaPublicKey: () => unmarshalRsaPublicKey
});
var import_err_code13 = __toESM(require_err_code(), 1);
__toESM(require_sha512$1(), 1);
var import_forge4 = __toESM(require_forge(), 1);
var nodeCrypto = __toESM(require_crypto());
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _3n = BigInt(3);
var _8n = BigInt(8);
var CURVE = Object.freeze({
  a: _0n,
  b: BigInt(7),
  P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: _1n,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
});
var divNearest = (a, b) => (a + b / _2n) / b;
var endo = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  splitScalar(k) {
    const { n } = CURVE;
    const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
    const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
    const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
    const b2 = a1;
    const POW_2_128 = BigInt("0x100000000000000000000000000000000");
    const c1 = divNearest(b2 * k, n);
    const c2 = divNearest(-b1 * k, n);
    let k1 = mod2(k - c1 * a1 - c2 * a2, n);
    let k2 = mod2(-c1 * b1 - c2 * b2, n);
    const k1neg = k1 > POW_2_128;
    const k2neg = k2 > POW_2_128;
    if (k1neg)
      k1 = n - k1;
    if (k2neg)
      k2 = n - k2;
    if (k1 > POW_2_128 || k2 > POW_2_128) {
      throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
    }
    return { k1neg, k1, k2neg, k2 };
  }
};
var fieldLen = 32;
var groupLen = 32;
var hashLen = 32;
var compressedLen = fieldLen + 1;
var uncompressedLen = 2 * fieldLen + 1;
function weierstrass(x) {
  const { a, b } = CURVE;
  const x2 = mod2(x * x);
  const x3 = mod2(x2 * x);
  return mod2(x3 + a * x + b);
}
var USE_ENDOMORPHISM = CURVE.a === _0n;
var ShaError = class extends Error {
  constructor(message2) {
    super(message2);
  }
};
function assertJacPoint(other) {
  if (!(other instanceof JacobianPoint))
    throw new TypeError("JacobianPoint expected");
}
var JacobianPoint = class {
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  static fromAffine(p) {
    if (!(p instanceof Point)) {
      throw new TypeError("JacobianPoint#fromAffine: expected Point");
    }
    if (p.equals(Point.ZERO))
      return JacobianPoint.ZERO;
    return new JacobianPoint(p.x, p.y, _1n);
  }
  static toAffineBatch(points) {
    const toInv = invertBatch(points.map((p) => p.z));
    return points.map((p, i2) => p.toAffine(toInv[i2]));
  }
  static normalizeZ(points) {
    return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
  }
  equals(other) {
    assertJacPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    const Z1Z1 = mod2(Z1 * Z1);
    const Z2Z2 = mod2(Z2 * Z2);
    const U1 = mod2(X1 * Z2Z2);
    const U2 = mod2(X2 * Z1Z1);
    const S1 = mod2(mod2(Y1 * Z2) * Z2Z2);
    const S2 = mod2(mod2(Y2 * Z1) * Z1Z1);
    return U1 === U2 && S1 === S2;
  }
  negate() {
    return new JacobianPoint(this.x, mod2(-this.y), this.z);
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const A = mod2(X1 * X1);
    const B = mod2(Y1 * Y1);
    const C = mod2(B * B);
    const x1b = X1 + B;
    const D = mod2(_2n * (mod2(x1b * x1b) - A - C));
    const E = mod2(_3n * A);
    const F = mod2(E * E);
    const X3 = mod2(F - _2n * D);
    const Y3 = mod2(E * (D - X3) - _8n * C);
    const Z3 = mod2(_2n * Y1 * Z1);
    return new JacobianPoint(X3, Y3, Z3);
  }
  add(other) {
    assertJacPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    if (X2 === _0n || Y2 === _0n)
      return this;
    if (X1 === _0n || Y1 === _0n)
      return other;
    const Z1Z1 = mod2(Z1 * Z1);
    const Z2Z2 = mod2(Z2 * Z2);
    const U1 = mod2(X1 * Z2Z2);
    const U2 = mod2(X2 * Z1Z1);
    const S1 = mod2(mod2(Y1 * Z2) * Z2Z2);
    const S2 = mod2(mod2(Y2 * Z1) * Z1Z1);
    const H = mod2(U2 - U1);
    const r = mod2(S2 - S1);
    if (H === _0n) {
      if (r === _0n) {
        return this.double();
      } else {
        return JacobianPoint.ZERO;
      }
    }
    const HH = mod2(H * H);
    const HHH = mod2(H * HH);
    const V2 = mod2(U1 * HH);
    const X3 = mod2(r * r - HHH - _2n * V2);
    const Y3 = mod2(r * (V2 - X3) - S1 * HHH);
    const Z3 = mod2(Z1 * Z2 * H);
    return new JacobianPoint(X3, Y3, Z3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiplyUnsafe(scalar) {
    const P0 = JacobianPoint.ZERO;
    if (typeof scalar === "bigint" && scalar === _0n)
      return P0;
    let n = normalizeScalar(scalar);
    if (n === _1n)
      return this;
    if (!USE_ENDOMORPHISM) {
      let p = P0;
      let d2 = this;
      while (n > _0n) {
        if (n & _1n)
          p = p.add(d2);
        d2 = d2.double();
        n >>= _1n;
      }
      return p;
    }
    let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
    let k1p = P0;
    let k2p = P0;
    let d = this;
    while (k1 > _0n || k2 > _0n) {
      if (k1 & _1n)
        k1p = k1p.add(d);
      if (k2 & _1n)
        k2p = k2p.add(d);
      d = d.double();
      k1 >>= _1n;
      k2 >>= _1n;
    }
    if (k1neg)
      k1p = k1p.negate();
    if (k2neg)
      k2p = k2p.negate();
    k2p = new JacobianPoint(mod2(k2p.x * endo.beta), k2p.y, k2p.z);
    return k1p.add(k2p);
  }
  precomputeWindow(W) {
    const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
    const points = [];
    let p = this;
    let base3 = p;
    for (let window2 = 0; window2 < windows; window2++) {
      base3 = p;
      points.push(base3);
      for (let i2 = 1; i2 < 2 ** (W - 1); i2++) {
        base3 = base3.add(p);
        points.push(base3);
      }
      p = base3.double();
    }
    return points;
  }
  wNAF(n, affinePoint) {
    if (!affinePoint && this.equals(JacobianPoint.BASE))
      affinePoint = Point.BASE;
    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W);
      if (affinePoint && W !== 1) {
        precomputes = JacobianPoint.normalizeZ(precomputes);
        pointPrecomputes.set(affinePoint, precomputes);
      }
    }
    let p = JacobianPoint.ZERO;
    let f = JacobianPoint.BASE;
    const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
    const windowSize = 2 ** (W - 1);
    const mask = BigInt(2 ** W - 1);
    const maxNumber = 2 ** W;
    const shiftBy = BigInt(W);
    for (let window2 = 0; window2 < windows; window2++) {
      const offset = window2 * windowSize;
      let wbits = Number(n & mask);
      n >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n += _1n;
      }
      const offset1 = offset;
      const offset2 = offset + Math.abs(wbits) - 1;
      const cond1 = window2 % 2 !== 0;
      const cond2 = wbits < 0;
      if (wbits === 0) {
        f = f.add(constTimeNegate(cond1, precomputes[offset1]));
      } else {
        p = p.add(constTimeNegate(cond2, precomputes[offset2]));
      }
    }
    return { p, f };
  }
  multiply(scalar, affinePoint) {
    let n = normalizeScalar(scalar);
    let point;
    let fake;
    if (USE_ENDOMORPHISM) {
      const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
      let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
      k1p = constTimeNegate(k1neg, k1p);
      k2p = constTimeNegate(k2neg, k2p);
      k2p = new JacobianPoint(mod2(k2p.x * endo.beta), k2p.y, k2p.z);
      point = k1p.add(k2p);
      fake = f1p.add(f2p);
    } else {
      const { p, f } = this.wNAF(n, affinePoint);
      point = p;
      fake = f;
    }
    return JacobianPoint.normalizeZ([point, fake])[0];
  }
  toAffine(invZ) {
    const { x, y, z } = this;
    const is0 = this.equals(JacobianPoint.ZERO);
    if (invZ == null)
      invZ = is0 ? _8n : invert(z);
    const iz1 = invZ;
    const iz2 = mod2(iz1 * iz1);
    const iz3 = mod2(iz2 * iz1);
    const ax = mod2(x * iz2);
    const ay = mod2(y * iz3);
    const zz = mod2(z * iz1);
    if (is0)
      return Point.ZERO;
    if (zz !== _1n)
      throw new Error("invZ was invalid");
    return new Point(ax, ay);
  }
};
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var Point = class {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes.delete(this);
  }
  hasEvenY() {
    return this.y % _2n === _0n;
  }
  static fromCompressedHex(bytes2) {
    const isShort = bytes2.length === 32;
    const x = bytesToNumber(isShort ? bytes2 : bytes2.subarray(1));
    if (!isValidFieldElement(x))
      throw new Error("Point is not on curve");
    const y2 = weierstrass(x);
    let y = sqrtMod(y2);
    const isYOdd = (y & _1n) === _1n;
    if (isShort) {
      if (isYOdd)
        y = mod2(-y);
    } else {
      const isFirstByteOdd = (bytes2[0] & 1) === 1;
      if (isFirstByteOdd !== isYOdd)
        y = mod2(-y);
    }
    const point = new Point(x, y);
    point.assertValidity();
    return point;
  }
  static fromUncompressedHex(bytes2) {
    const x = bytesToNumber(bytes2.subarray(1, fieldLen + 1));
    const y = bytesToNumber(bytes2.subarray(fieldLen + 1, fieldLen * 2 + 1));
    const point = new Point(x, y);
    point.assertValidity();
    return point;
  }
  static fromHex(hex) {
    const bytes2 = ensureBytes(hex);
    const len = bytes2.length;
    const header = bytes2[0];
    if (len === fieldLen)
      return this.fromCompressedHex(bytes2);
    if (len === compressedLen && (header === 2 || header === 3)) {
      return this.fromCompressedHex(bytes2);
    }
    if (len === uncompressedLen && header === 4)
      return this.fromUncompressedHex(bytes2);
    throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
  }
  static fromPrivateKey(privateKey) {
    return Point.BASE.multiply(normalizePrivateKey(privateKey));
  }
  static fromSignature(msgHash, signature, recovery) {
    const { r, s } = normalizeSignature(signature);
    if (![0, 1, 2, 3].includes(recovery))
      throw new Error("Cannot recover: invalid recovery bit");
    const h = truncateHash(ensureBytes(msgHash));
    const { n } = CURVE;
    const radj = recovery === 2 || recovery === 3 ? r + n : r;
    const rinv = invert(radj, n);
    const u1 = mod2(-h * rinv, n);
    const u2 = mod2(s * rinv, n);
    const prefix = recovery & 1 ? "03" : "02";
    const R = Point.fromHex(prefix + numTo32bStr(radj));
    const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
    if (!Q)
      throw new Error("Cannot recover signature: point at infinify");
    Q.assertValidity();
    return Q;
  }
  toRawBytes(isCompressed = false) {
    return hexToBytes(this.toHex(isCompressed));
  }
  toHex(isCompressed = false) {
    const x = numTo32bStr(this.x);
    if (isCompressed) {
      const prefix = this.hasEvenY() ? "02" : "03";
      return `${prefix}${x}`;
    } else {
      return `04${x}${numTo32bStr(this.y)}`;
    }
  }
  toHexX() {
    return this.toHex(true).slice(2);
  }
  toRawX() {
    return this.toRawBytes(true).slice(1);
  }
  assertValidity() {
    const msg = "Point is not on elliptic curve";
    const { x, y } = this;
    if (!isValidFieldElement(x) || !isValidFieldElement(y))
      throw new Error(msg);
    const left = mod2(y * y);
    const right = weierstrass(x);
    if (mod2(left - right) !== _0n)
      throw new Error(msg);
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new Point(this.x, mod2(-this.y));
  }
  double() {
    return JacobianPoint.fromAffine(this).double().toAffine();
  }
  add(other) {
    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
  multiplyAndAddUnsafe(Q, a, b) {
    const P = JacobianPoint.fromAffine(this);
    const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
    const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
    const sum = aP.add(bQ);
    return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
  }
};
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _0n);
function sliceDER(s) {
  return Number.parseInt(s[0], 16) >= 8 ? "00" + s : s;
}
function parseDERInt(data) {
  if (data.length < 2 || data[0] !== 2) {
    throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
  }
  const len = data[1];
  const res = data.subarray(2, len + 2);
  if (!len || res.length !== len) {
    throw new Error(`Invalid signature integer: wrong length`);
  }
  if (res[0] === 0 && res[1] <= 127) {
    throw new Error("Invalid signature integer: trailing length");
  }
  return { data: bytesToNumber(res), left: data.subarray(len + 2) };
}
function parseDERSignature(data) {
  if (data.length < 2 || data[0] != 48) {
    throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
  }
  if (data[1] !== data.length - 2) {
    throw new Error("Invalid signature: incorrect length");
  }
  const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
  const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
  if (rBytesLeft.length) {
    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
  }
  return { r, s };
}
var Signature = class {
  constructor(r, s) {
    this.r = r;
    this.s = s;
    this.assertValidity();
  }
  static fromCompact(hex) {
    const arr = hex instanceof Uint8Array;
    const name9 = "Signature.fromCompact";
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`${name9}: Expected string or Uint8Array`);
    const str = arr ? bytesToHex(hex) : hex;
    if (str.length !== 128)
      throw new Error(`${name9}: Expected 64-byte hex`);
    return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
  }
  static fromDER(hex) {
    const arr = hex instanceof Uint8Array;
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
    const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));
    return new Signature(r, s);
  }
  static fromHex(hex) {
    return this.fromDER(hex);
  }
  assertValidity() {
    const { r, s } = this;
    if (!isWithinCurveOrder(r))
      throw new Error("Invalid Signature: r must be 0 < r < n");
    if (!isWithinCurveOrder(s))
      throw new Error("Invalid Signature: s must be 0 < s < n");
  }
  hasHighS() {
    const HALF = CURVE.n >> _1n;
    return this.s > HALF;
  }
  normalizeS() {
    return this.hasHighS() ? new Signature(this.r, mod2(-this.s, CURVE.n)) : this;
  }
  toDERRawBytes() {
    return hexToBytes(this.toDERHex());
  }
  toDERHex() {
    const sHex = sliceDER(numberToHexUnpadded(this.s));
    const rHex = sliceDER(numberToHexUnpadded(this.r));
    const sHexL = sHex.length / 2;
    const rHexL = rHex.length / 2;
    const sLen = numberToHexUnpadded(sHexL);
    const rLen = numberToHexUnpadded(rHexL);
    const length3 = numberToHexUnpadded(rHexL + sHexL + 4);
    return `30${length3}02${rLen}${rHex}02${sLen}${sHex}`;
  }
  toRawBytes() {
    return this.toDERRawBytes();
  }
  toHex() {
    return this.toDERHex();
  }
  toCompactRawBytes() {
    return hexToBytes(this.toCompactHex());
  }
  toCompactHex() {
    return numTo32bStr(this.r) + numTo32bStr(this.s);
  }
};
function concatBytes(...arrays) {
  if (!arrays.every((b) => b instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length3 = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length3);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const arr = arrays[i2];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
var hexes = Array.from({ length: 256 }, (v, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  let hex = "";
  for (let i2 = 0; i2 < uint8a.length; i2++) {
    hex += hexes[uint8a[i2]];
  }
  return hex;
}
var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
function numTo32bStr(num) {
  if (typeof num !== "bigint")
    throw new Error("Expected bigint");
  if (!(_0n <= num && num < POW_2_256))
    throw new Error("Expected number 0 <= n < 2^256");
  return num.toString(16).padStart(64, "0");
}
function numTo32b(num) {
  const b = hexToBytes(numTo32bStr(num));
  if (b.length !== 32)
    throw new Error("Error: expected 32 bytes");
  return b;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToNumber: expected string, got " + typeof hex);
  }
  return BigInt(`0x${hex}`);
}
function hexToBytes(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex" + hex.length);
  const array = new Uint8Array(hex.length / 2);
  for (let i2 = 0; i2 < array.length; i2++) {
    const j = i2 * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i2] = byte;
  }
  return array;
}
function bytesToNumber(bytes2) {
  return hexToNumber(bytesToHex(bytes2));
}
function ensureBytes(hex) {
  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
}
function normalizeScalar(num) {
  if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
    return BigInt(num);
  if (typeof num === "bigint" && isWithinCurveOrder(num))
    return num;
  throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
function mod2(a, b = CURVE.P) {
  const result = a % b;
  return result >= _0n ? result : b + result;
}
function pow2(x, power) {
  const { P } = CURVE;
  let res = x;
  while (power-- > _0n) {
    res *= res;
    res %= P;
  }
  return res;
}
function sqrtMod(x) {
  const { P } = CURVE;
  const _6n = BigInt(6);
  const _11n = BigInt(11);
  const _22n = BigInt(22);
  const _23n = BigInt(23);
  const _44n = BigInt(44);
  const _88n = BigInt(88);
  const b2 = x * x * x % P;
  const b3 = b2 * b2 * x % P;
  const b6 = pow2(b3, _3n) * b3 % P;
  const b9 = pow2(b6, _3n) * b3 % P;
  const b11 = pow2(b9, _2n) * b2 % P;
  const b22 = pow2(b11, _11n) * b11 % P;
  const b44 = pow2(b22, _22n) * b22 % P;
  const b88 = pow2(b44, _44n) * b44 % P;
  const b176 = pow2(b88, _88n) * b88 % P;
  const b220 = pow2(b176, _44n) * b44 % P;
  const b223 = pow2(b220, _3n) * b3 % P;
  const t1 = pow2(b223, _23n) * b22 % P;
  const t2 = pow2(t1, _6n) * b2 % P;
  const rt = pow2(t2, _2n);
  const xc = rt * rt % P;
  if (xc !== x)
    throw new Error("Cannot find square root");
  return rt;
}
function invert(number, modulo = CURVE.P) {
  if (number === _0n || modulo <= _0n) {
    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
  }
  let a = mod2(number, modulo);
  let b = modulo;
  let x = _0n, u = _1n;
  while (a !== _0n) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    b = a, a = r, x = u, u = m;
  }
  const gcd = b;
  if (gcd !== _1n)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
  const scratch = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i2) => {
    if (num === _0n)
      return acc;
    scratch[i2] = acc;
    return mod2(acc * num, p);
  }, _1n);
  const inverted = invert(lastMultiplied, p);
  nums.reduceRight((acc, num, i2) => {
    if (num === _0n)
      return acc;
    scratch[i2] = mod2(acc * scratch[i2], p);
    return mod2(acc * num, p);
  }, inverted);
  return scratch;
}
function bits2int_2(bytes2) {
  const delta = bytes2.length * 8 - groupLen * 8;
  const num = bytesToNumber(bytes2);
  return delta > 0 ? num >> BigInt(delta) : num;
}
function truncateHash(hash3, truncateOnly = false) {
  const h = bits2int_2(hash3);
  if (truncateOnly)
    return h;
  const { n } = CURVE;
  return h >= n ? h - n : h;
}
var _sha256Sync;
var _hmacSha256Sync;
var HmacDrbg = class {
  constructor(hashLen2, qByteLen) {
    this.hashLen = hashLen2;
    this.qByteLen = qByteLen;
    if (typeof hashLen2 !== "number" || hashLen2 < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    this.v = new Uint8Array(hashLen2).fill(1);
    this.k = new Uint8Array(hashLen2).fill(0);
    this.counter = 0;
  }
  hmac(...values) {
    return utils.hmacSha256(this.k, ...values);
  }
  hmacSync(...values) {
    return _hmacSha256Sync(this.k, ...values);
  }
  checkSync() {
    if (typeof _hmacSha256Sync !== "function")
      throw new ShaError("hmacSha256Sync needs to be set");
  }
  incr() {
    if (this.counter >= 1e3)
      throw new Error("Tried 1,000 k values for sign(), all were invalid");
    this.counter += 1;
  }
  async reseed(seed2 = new Uint8Array()) {
    this.k = await this.hmac(this.v, Uint8Array.from([0]), seed2);
    this.v = await this.hmac(this.v);
    if (seed2.length === 0)
      return;
    this.k = await this.hmac(this.v, Uint8Array.from([1]), seed2);
    this.v = await this.hmac(this.v);
  }
  reseedSync(seed2 = new Uint8Array()) {
    this.checkSync();
    this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed2);
    this.v = this.hmacSync(this.v);
    if (seed2.length === 0)
      return;
    this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed2);
    this.v = this.hmacSync(this.v);
  }
  async generate() {
    this.incr();
    let len = 0;
    const out = [];
    while (len < this.qByteLen) {
      this.v = await this.hmac(this.v);
      const sl = this.v.slice();
      out.push(sl);
      len += this.v.length;
    }
    return concatBytes(...out);
  }
  generateSync() {
    this.checkSync();
    this.incr();
    let len = 0;
    const out = [];
    while (len < this.qByteLen) {
      this.v = this.hmacSync(this.v);
      const sl = this.v.slice();
      out.push(sl);
      len += this.v.length;
    }
    return concatBytes(...out);
  }
};
function isWithinCurveOrder(num) {
  return _0n < num && num < CURVE.n;
}
function isValidFieldElement(num) {
  return _0n < num && num < CURVE.P;
}
function kmdToSig(kBytes, m, d, lowS = true) {
  const { n } = CURVE;
  const k = truncateHash(kBytes, true);
  if (!isWithinCurveOrder(k))
    return;
  const kinv = invert(k, n);
  const q = Point.BASE.multiply(k);
  const r = mod2(q.x, n);
  if (r === _0n)
    return;
  const s = mod2(kinv * mod2(m + d * r, n), n);
  if (s === _0n)
    return;
  let sig = new Signature(r, s);
  let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);
  if (lowS && sig.hasHighS()) {
    sig = sig.normalizeS();
    recovery ^= 1;
  }
  return { sig, recovery };
}
function normalizePrivateKey(key) {
  let num;
  if (typeof key === "bigint") {
    num = key;
  } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
    num = BigInt(key);
  } else if (typeof key === "string") {
    if (key.length !== 2 * groupLen)
      throw new Error("Expected 32 bytes of private key");
    num = hexToNumber(key);
  } else if (key instanceof Uint8Array) {
    if (key.length !== groupLen)
      throw new Error("Expected 32 bytes of private key");
    num = bytesToNumber(key);
  } else {
    throw new TypeError("Expected valid private key");
  }
  if (!isWithinCurveOrder(num))
    throw new Error("Expected private key: 0 < key < n");
  return num;
}
function normalizePublicKey(publicKey) {
  if (publicKey instanceof Point) {
    publicKey.assertValidity();
    return publicKey;
  } else {
    return Point.fromHex(publicKey);
  }
}
function normalizeSignature(signature) {
  if (signature instanceof Signature) {
    signature.assertValidity();
    return signature;
  }
  try {
    return Signature.fromDER(signature);
  } catch (error) {
    return Signature.fromCompact(signature);
  }
}
function getPublicKey(privateKey, isCompressed = false) {
  return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
}
function bits2int(bytes2) {
  const slice2 = bytes2.length > fieldLen ? bytes2.slice(0, fieldLen) : bytes2;
  return bytesToNumber(slice2);
}
function bits2octets(bytes2) {
  const z1 = bits2int(bytes2);
  const z2 = mod2(z1, CURVE.n);
  return int2octets(z2 < _0n ? z1 : z2);
}
function int2octets(num) {
  return numTo32b(num);
}
function initSigArgs(msgHash, privateKey, extraEntropy) {
  if (msgHash == null)
    throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
  const h1 = ensureBytes(msgHash);
  const d = normalizePrivateKey(privateKey);
  const seedArgs = [int2octets(d), bits2octets(h1)];
  if (extraEntropy != null) {
    if (extraEntropy === true)
      extraEntropy = utils.randomBytes(fieldLen);
    const e = ensureBytes(extraEntropy);
    if (e.length !== fieldLen)
      throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
    seedArgs.push(e);
  }
  const seed2 = concatBytes(...seedArgs);
  const m = bits2int(h1);
  return { seed: seed2, m, d };
}
function finalizeSig(recSig, opts) {
  const { sig, recovery } = recSig;
  const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);
  const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
  return recovered ? [hashed, recovery] : hashed;
}
async function sign2(msgHash, privKey, opts = {}) {
  const { seed: seed2, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
  const drbg = new HmacDrbg(hashLen, groupLen);
  await drbg.reseed(seed2);
  let sig;
  while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))
    await drbg.reseed();
  return finalizeSig(sig, opts);
}
var vopts = { strict: true };
function verify$1(signature, msgHash, publicKey, opts = vopts) {
  let sig;
  try {
    sig = normalizeSignature(signature);
    msgHash = ensureBytes(msgHash);
  } catch (error) {
    return false;
  }
  const { r, s } = sig;
  if (opts.strict && sig.hasHighS())
    return false;
  const h = truncateHash(msgHash);
  let P;
  try {
    P = normalizePublicKey(publicKey);
  } catch (error) {
    return false;
  }
  const { n } = CURVE;
  const sinv = invert(s, n);
  const u1 = mod2(h * sinv, n);
  const u2 = mod2(r * sinv, n);
  const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
  if (!R)
    return false;
  const v = mod2(R.x, n);
  return v === r;
}
Point.BASE._setWindowSize(8);
var crypto2 = {
  node: nodeCrypto,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};
var TAGGED_HASH_PREFIXES = {};
var utils = {
  bytesToHex,
  hexToBytes,
  concatBytes,
  mod: mod2,
  invert,
  isValidPrivateKey(privateKey) {
    try {
      normalizePrivateKey(privateKey);
      return true;
    } catch (error) {
      return false;
    }
  },
  _bigintTo32Bytes: numTo32b,
  _normalizePrivateKey: normalizePrivateKey,
  hashToPrivateKey: (hash3) => {
    hash3 = ensureBytes(hash3);
    const minLen = groupLen + 8;
    if (hash3.length < minLen || hash3.length > 1024) {
      throw new Error(`Expected valid bytes of private key as per FIPS 186`);
    }
    const num = mod2(bytesToNumber(hash3), CURVE.n - _1n) + _1n;
    return numTo32b(num);
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto2.web) {
      return crypto2.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto2.node) {
      const { randomBytes: randomBytes3 } = crypto2.node;
      return Uint8Array.from(randomBytes3(bytesLength));
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),
  precompute(windowSize = 8, point = Point.BASE) {
    const cached = point === Point.BASE ? point : new Point(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_3n);
    return cached;
  },
  sha256: async (...messages3) => {
    if (crypto2.web) {
      const buffer2 = await crypto2.web.subtle.digest("SHA-256", concatBytes(...messages3));
      return new Uint8Array(buffer2);
    } else if (crypto2.node) {
      const { createHash } = crypto2.node;
      const hash3 = createHash("sha256");
      messages3.forEach((m) => hash3.update(m));
      return Uint8Array.from(hash3.digest());
    } else {
      throw new Error("The environment doesn't have sha256 function");
    }
  },
  hmacSha256: async (key, ...messages3) => {
    if (crypto2.web) {
      const ckey = await crypto2.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
      const message2 = concatBytes(...messages3);
      const buffer2 = await crypto2.web.subtle.sign("HMAC", ckey, message2);
      return new Uint8Array(buffer2);
    } else if (crypto2.node) {
      const { createHmac } = crypto2.node;
      const hash3 = createHmac("sha256", key);
      messages3.forEach((m) => hash3.update(m));
      return Uint8Array.from(hash3.digest());
    } else {
      throw new Error("The environment doesn't have hmac-sha256 function");
    }
  },
  sha256Sync: void 0,
  hmacSha256Sync: void 0,
  taggedHash: async (tag, ...messages3) => {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = concatBytes(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return utils.sha256(tagP, ...messages3);
  },
  taggedHashSync: (tag, ...messages3) => {
    if (typeof _sha256Sync !== "function")
      throw new ShaError("sha256Sync is undefined, you need to set it");
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = concatBytes(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return _sha256Sync(tagP, ...messages3);
  },
  _JacobianPoint: JacobianPoint
};
Object.defineProperties(utils, {
  sha256Sync: {
    configurable: false,
    get() {
      return _sha256Sync;
    },
    set(val) {
      if (!_sha256Sync)
        _sha256Sync = val;
    }
  },
  hmacSha256Sync: {
    configurable: false,
    get() {
      return _hmacSha256Sync;
    },
    set(val) {
      if (!_hmacSha256Sync)
        _hmacSha256Sync = val;
    }
  }
});
var import_err_code10 = __toESM(require_err_code(), 1);
function randomBytes$1(length3) {
  if (isNaN(length3) || length3 <= 0) {
    throw (0, import_err_code10.default)(new Error("random bytes length must be a Number bigger than 0"), "ERR_INVALID_LENGTH");
  }
  return utils.randomBytes(length3);
}
var rsa_utils_exports = {};
__export(rsa_utils_exports, {
  jwkToPkcs1: () => jwkToPkcs1,
  jwkToPkix: () => jwkToPkix,
  pkcs1ToJwk: () => pkcs1ToJwk,
  pkixToJwk: () => pkixToJwk
});
__toESM(require_asn1(), 1);
__toESM(require_rsa(), 1);
var import_forge2 = __toESM(require_forge(), 1);
var import_err_code11 = __toESM(require_err_code(), 1);
function pkcs1ToJwk(bytes2) {
  const asn1 = import_forge2.default.asn1.fromDer(toString3(bytes2, "ascii"));
  const privateKey = import_forge2.default.pki.privateKeyFromAsn1(asn1);
  return {
    kty: "RSA",
    n: bigIntegerToUintBase64url(privateKey.n),
    e: bigIntegerToUintBase64url(privateKey.e),
    d: bigIntegerToUintBase64url(privateKey.d),
    p: bigIntegerToUintBase64url(privateKey.p),
    q: bigIntegerToUintBase64url(privateKey.q),
    dp: bigIntegerToUintBase64url(privateKey.dP),
    dq: bigIntegerToUintBase64url(privateKey.dQ),
    qi: bigIntegerToUintBase64url(privateKey.qInv),
    alg: "RS256"
  };
}
function jwkToPkcs1(jwk) {
  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
    throw (0, import_err_code11.default)(new Error("JWK was missing components"), "ERR_INVALID_PARAMETERS");
  }
  const asn1 = import_forge2.default.pki.privateKeyToAsn1({
    n: base64urlToBigInteger(jwk.n),
    e: base64urlToBigInteger(jwk.e),
    d: base64urlToBigInteger(jwk.d),
    p: base64urlToBigInteger(jwk.p),
    q: base64urlToBigInteger(jwk.q),
    dP: base64urlToBigInteger(jwk.dp),
    dQ: base64urlToBigInteger(jwk.dq),
    qInv: base64urlToBigInteger(jwk.qi)
  });
  return fromString3(import_forge2.default.asn1.toDer(asn1).getBytes(), "ascii");
}
function pkixToJwk(bytes2) {
  const asn1 = import_forge2.default.asn1.fromDer(toString3(bytes2, "ascii"));
  const publicKey = import_forge2.default.pki.publicKeyFromAsn1(asn1);
  return {
    kty: "RSA",
    n: bigIntegerToUintBase64url(publicKey.n),
    e: bigIntegerToUintBase64url(publicKey.e)
  };
}
function jwkToPkix(jwk) {
  if (jwk.n == null || jwk.e == null) {
    throw (0, import_err_code11.default)(new Error("JWK was missing components"), "ERR_INVALID_PARAMETERS");
  }
  const asn1 = import_forge2.default.pki.publicKeyToAsn1({
    n: base64urlToBigInteger(jwk.n),
    e: base64urlToBigInteger(jwk.e)
  });
  return fromString3(import_forge2.default.asn1.toDer(asn1).getBytes(), "ascii");
}
__toESM(require_rsa(), 1);
var import_forge3 = __toESM(require_forge(), 1);
function convert(key, types2) {
  return types2.map((t) => base64urlToBigInteger(key[t]));
}
function jwk2priv(key) {
  return import_forge3.default.pki.setRsaPrivateKey(...convert(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
}
function jwk2pub(key) {
  return import_forge3.default.pki.setRsaPublicKey(...convert(key, ["n", "e"]));
}
var import_err_code12 = __toESM(require_err_code(), 1);
async function generateKey(bits2) {
  const pair2 = await webcrypto_default.get().subtle.generateKey({
    name: "RSASSA-PKCS1-v1_5",
    modulusLength: bits2,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: { name: "SHA-256" }
  }, true, ["sign", "verify"]);
  const keys = await exportKey(pair2);
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
async function unmarshalPrivateKey2(key) {
  const privateKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, true, ["sign"]);
  const pair2 = [
    privateKey,
    await derivePublicFromPrivate(key)
  ];
  const keys = await exportKey({
    privateKey: pair2[0],
    publicKey: pair2[1]
  });
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
async function hashAndSign(key, msg) {
  const privateKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["sign"]);
  const sig = await webcrypto_default.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, Uint8Array.from(msg));
  return new Uint8Array(sig, 0, sig.byteLength);
}
async function hashAndVerify(key, sig, msg) {
  const publicKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["verify"]);
  return await webcrypto_default.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg);
}
async function exportKey(pair2) {
  if (pair2.privateKey == null || pair2.publicKey == null) {
    throw (0, import_err_code12.default)(new Error("Private and public key are required"), "ERR_INVALID_PARAMETERS");
  }
  return await Promise.all([
    webcrypto_default.get().subtle.exportKey("jwk", pair2.privateKey),
    webcrypto_default.get().subtle.exportKey("jwk", pair2.publicKey)
  ]);
}
async function derivePublicFromPrivate(jwKey) {
  return await webcrypto_default.get().subtle.importKey("jwk", {
    kty: jwKey.kty,
    n: jwKey.n,
    e: jwKey.e
  }, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, true, ["verify"]);
}
function convertKey(key, pub, msg, handle2) {
  const fkey = pub ? jwk2pub(key) : jwk2priv(key);
  const fmsg = toString3(Uint8Array.from(msg), "ascii");
  const fomsg = handle2(fmsg, fkey);
  return fromString3(fomsg, "ascii");
}
function encrypt(key, msg) {
  return convertKey(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
}
function decrypt(key, msg) {
  return convertKey(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
}
async function exporter(privateKey, password) {
  const cipher = create3();
  const encryptedKey = await cipher.encrypt(privateKey, password);
  return base64.encode(encryptedKey);
}
var RsaPublicKey = class {
  constructor(key) {
    this._key = key;
  }
  async verify(data, sig) {
    return await hashAndVerify(this._key, sig, data);
  }
  marshal() {
    return rsa_utils_exports.jwkToPkix(this._key);
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.RSA,
      Data: this.marshal()
    }).subarray();
  }
  encrypt(bytes2) {
    return encrypt(this._key, bytes2);
  }
  equals(key) {
    return equals(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha256.digest(this.bytes);
    return bytes2;
  }
};
var RsaPrivateKey = class {
  constructor(key, publicKey) {
    this._key = key;
    this._publicKey = publicKey;
  }
  genSecret() {
    return randomBytes$1(16);
  }
  async sign(message2) {
    return await hashAndSign(this._key, message2);
  }
  get public() {
    if (this._publicKey == null) {
      throw (0, import_err_code13.default)(new Error("public key not provided"), "ERR_PUBKEY_NOT_PROVIDED");
    }
    return new RsaPublicKey(this._publicKey);
  }
  decrypt(bytes2) {
    return decrypt(this._key, bytes2);
  }
  marshal() {
    return rsa_utils_exports.jwkToPkcs1(this._key);
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.RSA,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha256.digest(this.bytes);
    return bytes2;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the SHA-256 multihash of its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   */
  async id() {
    const hash3 = await this.public.hash();
    return toString3(hash3, "base58btc");
  }
  /**
   * Exports the key into a password protected PEM format
   */
  async export(password, format2 = "pkcs-8") {
    if (format2 === "pkcs-8") {
      const buffer2 = new import_forge4.default.util.ByteBuffer(this.marshal());
      const asn1 = import_forge4.default.asn1.fromDer(buffer2);
      const privateKey = import_forge4.default.pki.privateKeyFromAsn1(asn1);
      const options = {
        algorithm: "aes256",
        count: 1e4,
        saltSize: 128 / 8,
        prfAlgorithm: "sha512"
      };
      return import_forge4.default.pki.encryptRsaPrivateKey(privateKey, password, options);
    } else if (format2 === "libp2p-key") {
      return await exporter(this.bytes, password);
    } else {
      throw (0, import_err_code13.default)(new Error(`export format '${format2}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
    }
  }
};
async function unmarshalRsaPrivateKey(bytes2) {
  const jwk = rsa_utils_exports.pkcs1ToJwk(bytes2);
  const keys = await unmarshalPrivateKey2(jwk);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
function unmarshalRsaPublicKey(bytes2) {
  const jwk = rsa_utils_exports.pkixToJwk(bytes2);
  return new RsaPublicKey(jwk);
}
async function fromJwk(jwk) {
  const keys = await unmarshalPrivateKey2(jwk);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
async function generateKeyPair(bits2) {
  const keys = await generateKey(bits2);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
var ed25519_class_exports = {};
__export(ed25519_class_exports, {
  Ed25519PrivateKey: () => Ed25519PrivateKey,
  Ed25519PublicKey: () => Ed25519PublicKey,
  generateKeyPair: () => generateKeyPair2,
  generateKeyPairFromSeed: () => generateKeyPairFromSeed,
  unmarshalEd25519PrivateKey: () => unmarshalEd25519PrivateKey,
  unmarshalEd25519PublicKey: () => unmarshalEd25519PublicKey
});
var import_err_code14 = __toESM(require_err_code(), 1);
var nodeCrypto2 = __toESM(require_crypto());
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var CU_O = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989");
var CURVE2 = Object.freeze({
  a: BigInt(-1),
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
  l: CU_O,
  n: CU_O,
  h: BigInt(8),
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
});
var POW_2_2562 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
var SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var ExtendedPoint = class {
  constructor(x, y, z, t) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.t = t;
  }
  static fromAffine(p) {
    if (!(p instanceof Point2)) {
      throw new TypeError("ExtendedPoint#fromAffine: expected Point");
    }
    if (p.equals(Point2.ZERO))
      return ExtendedPoint.ZERO;
    return new ExtendedPoint(p.x, p.y, _1n2, mod3(p.x * p.y));
  }
  static toAffineBatch(points) {
    const toInv = invertBatch2(points.map((p) => p.z));
    return points.map((p, i2) => p.toAffine(toInv[i2]));
  }
  static normalizeZ(points) {
    return this.toAffineBatch(points).map(this.fromAffine);
  }
  equals(other) {
    assertExtPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    const X1Z2 = mod3(X1 * Z2);
    const X2Z1 = mod3(X2 * Z1);
    const Y1Z2 = mod3(Y1 * Z2);
    const Y2Z1 = mod3(Y2 * Z1);
    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
  }
  negate() {
    return new ExtendedPoint(mod3(-this.x), this.y, this.z, mod3(-this.t));
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const { a } = CURVE2;
    const A = mod3(X1 * X1);
    const B = mod3(Y1 * Y1);
    const C = mod3(_2n2 * mod3(Z1 * Z1));
    const D = mod3(a * A);
    const x1y1 = X1 + Y1;
    const E = mod3(mod3(x1y1 * x1y1) - A - B);
    const G = D + B;
    const F = G - C;
    const H = D - B;
    const X3 = mod3(E * F);
    const Y3 = mod3(G * H);
    const T3 = mod3(E * H);
    const Z3 = mod3(F * G);
    return new ExtendedPoint(X3, Y3, Z3, T3);
  }
  add(other) {
    assertExtPoint(other);
    const { x: X1, y: Y1, z: Z1, t: T1 } = this;
    const { x: X2, y: Y2, z: Z2, t: T2 } = other;
    const A = mod3((Y1 - X1) * (Y2 + X2));
    const B = mod3((Y1 + X1) * (Y2 - X2));
    const F = mod3(B - A);
    if (F === _0n2)
      return this.double();
    const C = mod3(Z1 * _2n2 * T2);
    const D = mod3(T1 * _2n2 * Z2);
    const E = D + C;
    const G = B + A;
    const H = D - C;
    const X3 = mod3(E * F);
    const Y3 = mod3(G * H);
    const T3 = mod3(E * H);
    const Z3 = mod3(F * G);
    return new ExtendedPoint(X3, Y3, Z3, T3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  precomputeWindow(W) {
    const windows = 1 + 256 / W;
    const points = [];
    let p = this;
    let base3 = p;
    for (let window2 = 0; window2 < windows; window2++) {
      base3 = p;
      points.push(base3);
      for (let i2 = 1; i2 < 2 ** (W - 1); i2++) {
        base3 = base3.add(p);
        points.push(base3);
      }
      p = base3.double();
    }
    return points;
  }
  wNAF(n, affinePoint) {
    if (!affinePoint && this.equals(ExtendedPoint.BASE))
      affinePoint = Point2.BASE;
    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes2.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W);
      if (affinePoint && W !== 1) {
        precomputes = ExtendedPoint.normalizeZ(precomputes);
        pointPrecomputes2.set(affinePoint, precomputes);
      }
    }
    let p = ExtendedPoint.ZERO;
    let f = ExtendedPoint.ZERO;
    const windows = 1 + 256 / W;
    const windowSize = 2 ** (W - 1);
    const mask = BigInt(2 ** W - 1);
    const maxNumber = 2 ** W;
    const shiftBy = BigInt(W);
    for (let window2 = 0; window2 < windows; window2++) {
      const offset = window2 * windowSize;
      let wbits = Number(n & mask);
      n >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n += _1n2;
      }
      if (wbits === 0) {
        let pr = precomputes[offset];
        if (window2 % 2)
          pr = pr.negate();
        f = f.add(pr);
      } else {
        let cached = precomputes[offset + Math.abs(wbits) - 1];
        if (wbits < 0)
          cached = cached.negate();
        p = p.add(cached);
      }
    }
    return ExtendedPoint.normalizeZ([p, f])[0];
  }
  multiply(scalar, affinePoint) {
    return this.wNAF(normalizeScalar2(scalar, CURVE2.l), affinePoint);
  }
  multiplyUnsafe(scalar) {
    let n = normalizeScalar2(scalar, CURVE2.l, false);
    const G = ExtendedPoint.BASE;
    const P0 = ExtendedPoint.ZERO;
    if (n === _0n2)
      return P0;
    if (this.equals(P0) || n === _1n2)
      return this;
    if (this.equals(G))
      return this.wNAF(n);
    let p = P0;
    let d = this;
    while (n > _0n2) {
      if (n & _1n2)
        p = p.add(d);
      d = d.double();
      n >>= _1n2;
    }
    return p;
  }
  isSmallOrder() {
    return this.multiplyUnsafe(CURVE2.h).equals(ExtendedPoint.ZERO);
  }
  isTorsionFree() {
    return this.multiplyUnsafe(CURVE2.l).equals(ExtendedPoint.ZERO);
  }
  toAffine(invZ = invert2(this.z)) {
    const { x, y, z } = this;
    const ax = mod3(x * invZ);
    const ay = mod3(y * invZ);
    const zz = mod3(z * invZ);
    if (zz !== _1n2)
      throw new Error("invZ was invalid");
    return new Point2(ax, ay);
  }
  fromRistrettoBytes() {
    legacyRist();
  }
  toRistrettoBytes() {
    legacyRist();
  }
  fromRistrettoHash() {
    legacyRist();
  }
};
ExtendedPoint.BASE = new ExtendedPoint(CURVE2.Gx, CURVE2.Gy, _1n2, mod3(CURVE2.Gx * CURVE2.Gy));
ExtendedPoint.ZERO = new ExtendedPoint(_0n2, _1n2, _1n2, _0n2);
function assertExtPoint(other) {
  if (!(other instanceof ExtendedPoint))
    throw new TypeError("ExtendedPoint expected");
}
function assertRstPoint(other) {
  if (!(other instanceof RistrettoPoint))
    throw new TypeError("RistrettoPoint expected");
}
function legacyRist() {
  throw new Error("Legacy method: switch to RistrettoPoint");
}
var RistrettoPoint = class {
  constructor(ep) {
    this.ep = ep;
  }
  static calcElligatorRistrettoMap(r0) {
    const { d } = CURVE2;
    const r = mod3(SQRT_M1 * r0 * r0);
    const Ns = mod3((r + _1n2) * ONE_MINUS_D_SQ);
    let c = BigInt(-1);
    const D = mod3((c - d * r) * mod3(r + d));
    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
    let s_ = mod3(s * r0);
    if (!edIsNegative(s_))
      s_ = mod3(-s_);
    if (!Ns_D_is_sq)
      s = s_;
    if (!Ns_D_is_sq)
      c = r;
    const Nt = mod3(c * (r - _1n2) * D_MINUS_ONE_SQ - D);
    const s2 = s * s;
    const W0 = mod3((s + s) * D);
    const W1 = mod3(Nt * SQRT_AD_MINUS_ONE);
    const W2 = mod3(_1n2 - s2);
    const W3 = mod3(_1n2 + s2);
    return new ExtendedPoint(mod3(W0 * W3), mod3(W2 * W1), mod3(W1 * W3), mod3(W0 * W2));
  }
  static hashToCurve(hex) {
    hex = ensureBytes2(hex, 64);
    const r1 = bytes255ToNumberLE(hex.slice(0, 32));
    const R1 = this.calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(hex.slice(32, 64));
    const R2 = this.calcElligatorRistrettoMap(r2);
    return new RistrettoPoint(R1.add(R2));
  }
  static fromHex(hex) {
    hex = ensureBytes2(hex, 32);
    const { a, d } = CURVE2;
    const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
    const s = bytes255ToNumberLE(hex);
    if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))
      throw new Error(emsg);
    const s2 = mod3(s * s);
    const u1 = mod3(_1n2 + a * s2);
    const u2 = mod3(_1n2 - a * s2);
    const u1_2 = mod3(u1 * u1);
    const u2_2 = mod3(u2 * u2);
    const v = mod3(a * d * u1_2 - u2_2);
    const { isValid, value: I } = invertSqrt(mod3(v * u2_2));
    const Dx = mod3(I * u2);
    const Dy = mod3(I * Dx * v);
    let x = mod3((s + s) * Dx);
    if (edIsNegative(x))
      x = mod3(-x);
    const y = mod3(u1 * Dy);
    const t = mod3(x * y);
    if (!isValid || edIsNegative(t) || y === _0n2)
      throw new Error(emsg);
    return new RistrettoPoint(new ExtendedPoint(x, y, _1n2, t));
  }
  toRawBytes() {
    let { x, y, z, t } = this.ep;
    const u1 = mod3(mod3(z + y) * mod3(z - y));
    const u2 = mod3(x * y);
    const u2sq = mod3(u2 * u2);
    const { value: invsqrt } = invertSqrt(mod3(u1 * u2sq));
    const D1 = mod3(invsqrt * u1);
    const D2 = mod3(invsqrt * u2);
    const zInv = mod3(D1 * D2 * t);
    let D;
    if (edIsNegative(t * zInv)) {
      let _x = mod3(y * SQRT_M1);
      let _y = mod3(x * SQRT_M1);
      x = _x;
      y = _y;
      D = mod3(D1 * INVSQRT_A_MINUS_D);
    } else {
      D = D2;
    }
    if (edIsNegative(x * zInv))
      y = mod3(-y);
    let s = mod3((z - y) * D);
    if (edIsNegative(s))
      s = mod3(-s);
    return numberTo32BytesLE(s);
  }
  toHex() {
    return bytesToHex2(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  equals(other) {
    assertRstPoint(other);
    const a = this.ep;
    const b = other.ep;
    const one = mod3(a.x * b.y) === mod3(a.y * b.x);
    const two = mod3(a.y * b.y) === mod3(a.x * b.x);
    return one || two;
  }
  add(other) {
    assertRstPoint(other);
    return new RistrettoPoint(this.ep.add(other.ep));
  }
  subtract(other) {
    assertRstPoint(other);
    return new RistrettoPoint(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return new RistrettoPoint(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));
  }
};
RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
var pointPrecomputes2 = /* @__PURE__ */ new WeakMap();
var Point2 = class {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes2.delete(this);
  }
  static fromHex(hex, strict = true) {
    const { d, P } = CURVE2;
    hex = ensureBytes2(hex, 32);
    const normed = hex.slice();
    normed[31] = hex[31] & ~128;
    const y = bytesToNumberLE(normed);
    if (strict && y >= P)
      throw new Error("Expected 0 < hex < P");
    if (!strict && y >= POW_2_2562)
      throw new Error("Expected 0 < hex < 2**256");
    const y2 = mod3(y * y);
    const u = mod3(y2 - _1n2);
    const v = mod3(d * y2 + _1n2);
    let { isValid, value: x } = uvRatio(u, v);
    if (!isValid)
      throw new Error("Point.fromHex: invalid y coordinate");
    const isXOdd = (x & _1n2) === _1n2;
    const isLastByteOdd = (hex[31] & 128) !== 0;
    if (isLastByteOdd !== isXOdd) {
      x = mod3(-x);
    }
    return new Point2(x, y);
  }
  static async fromPrivateKey(privateKey) {
    return (await getExtendedPublicKey(privateKey)).point;
  }
  toRawBytes() {
    const bytes2 = numberTo32BytesLE(this.y);
    bytes2[31] |= this.x & _1n2 ? 128 : 0;
    return bytes2;
  }
  toHex() {
    return bytesToHex2(this.toRawBytes());
  }
  toX25519() {
    const { y } = this;
    const u = mod3((_1n2 + y) * invert2(_1n2 - y));
    return numberTo32BytesLE(u);
  }
  isTorsionFree() {
    return ExtendedPoint.fromAffine(this).isTorsionFree();
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new Point2(mod3(-this.x), this.y);
  }
  add(other) {
    return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
};
Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy);
Point2.ZERO = new Point2(_0n2, _1n2);
var Signature2 = class {
  constructor(r, s) {
    this.r = r;
    this.s = s;
    this.assertValidity();
  }
  static fromHex(hex) {
    const bytes2 = ensureBytes2(hex, 64);
    const r = Point2.fromHex(bytes2.slice(0, 32), false);
    const s = bytesToNumberLE(bytes2.slice(32, 64));
    return new Signature2(r, s);
  }
  assertValidity() {
    const { r, s } = this;
    if (!(r instanceof Point2))
      throw new Error("Expected Point instance");
    normalizeScalar2(s, CURVE2.l, false);
    return this;
  }
  toRawBytes() {
    const u8 = new Uint8Array(64);
    u8.set(this.r.toRawBytes());
    u8.set(numberTo32BytesLE(this.s), 32);
    return u8;
  }
  toHex() {
    return bytesToHex2(this.toRawBytes());
  }
};
function concatBytes2(...arrays) {
  if (!arrays.every((a) => a instanceof Uint8Array))
    throw new Error("Expected Uint8Array list");
  if (arrays.length === 1)
    return arrays[0];
  const length3 = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length3);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const arr = arrays[i2];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
var hexes2 = Array.from({ length: 256 }, (v, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex2(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i2 = 0; i2 < uint8a.length; i2++) {
    hex += hexes2[uint8a[i2]];
  }
  return hex;
}
function hexToBytes2(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array = new Uint8Array(hex.length / 2);
  for (let i2 = 0; i2 < array.length; i2++) {
    const j = i2 * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i2] = byte;
  }
  return array;
}
function numberTo32BytesBE(num) {
  const length3 = 32;
  const hex = num.toString(16).padStart(length3 * 2, "0");
  return hexToBytes2(hex);
}
function numberTo32BytesLE(num) {
  return numberTo32BytesBE(num).reverse();
}
function edIsNegative(num) {
  return (mod3(num) & _1n2) === _1n2;
}
function bytesToNumberLE(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  return BigInt("0x" + bytesToHex2(Uint8Array.from(uint8a).reverse()));
}
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function bytes255ToNumberLE(bytes2) {
  return mod3(bytesToNumberLE(bytes2) & MAX_255B);
}
function mod3(a, b = CURVE2.P) {
  const res = a % b;
  return res >= _0n2 ? res : b + res;
}
function invert2(number, modulo = CURVE2.P) {
  if (number === _0n2 || modulo <= _0n2) {
    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
  }
  let a = mod3(number, modulo);
  let b = modulo;
  let x = _0n2, u = _1n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    b = a, a = r, x = u, u = m;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod3(x, modulo);
}
function invertBatch2(nums, p = CURVE2.P) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i2) => {
    if (num === _0n2)
      return acc;
    tmp[i2] = acc;
    return mod3(acc * num, p);
  }, _1n2);
  const inverted = invert2(lastMultiplied, p);
  nums.reduceRight((acc, num, i2) => {
    if (num === _0n2)
      return acc;
    tmp[i2] = mod3(acc * tmp[i2], p);
    return mod3(acc * num, p);
  }, inverted);
  return tmp;
}
function pow22(x, power) {
  const { P } = CURVE2;
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= P;
  }
  return res;
}
function pow_2_252_3(x) {
  const { P } = CURVE2;
  const _5n = BigInt(5);
  const _10n = BigInt(10);
  const _20n = BigInt(20);
  const _40n = BigInt(40);
  const _80n = BigInt(80);
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow22(b2, _2n2) * b2 % P;
  const b5 = pow22(b4, _1n2) * x % P;
  const b10 = pow22(b5, _5n) * b5 % P;
  const b20 = pow22(b10, _10n) * b10 % P;
  const b40 = pow22(b20, _20n) * b20 % P;
  const b80 = pow22(b40, _40n) * b40 % P;
  const b160 = pow22(b80, _80n) * b80 % P;
  const b240 = pow22(b160, _80n) * b80 % P;
  const b250 = pow22(b240, _10n) * b10 % P;
  const pow_p_5_8 = pow22(b250, _2n2) * x % P;
  return { pow_p_5_8, b2 };
}
function uvRatio(u, v) {
  const v3 = mod3(v * v * v);
  const v7 = mod3(v3 * v3 * v);
  const pow = pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod3(u * v3 * pow);
  const vx2 = mod3(v * x * x);
  const root1 = x;
  const root2 = mod3(x * SQRT_M1);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod3(-u);
  const noRoot = vx2 === mod3(-u * SQRT_M1);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (edIsNegative(x))
    x = mod3(-x);
  return { isValid: useRoot1 || useRoot2, value: x };
}
function invertSqrt(number) {
  return uvRatio(_1n2, number);
}
function modlLE(hash3) {
  return mod3(bytesToNumberLE(hash3), CURVE2.l);
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length) {
    return false;
  }
  for (let i2 = 0; i2 < b1.length; i2++) {
    if (b1[i2] !== b2[i2]) {
      return false;
    }
  }
  return true;
}
function ensureBytes2(hex, expectedLength) {
  const bytes2 = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes2(hex);
  if (typeof expectedLength === "number" && bytes2.length !== expectedLength)
    throw new Error(`Expected ${expectedLength} bytes`);
  return bytes2;
}
function normalizeScalar2(num, max, strict = true) {
  if (!max)
    throw new TypeError("Specify max value");
  if (typeof num === "number" && Number.isSafeInteger(num))
    num = BigInt(num);
  if (typeof num === "bigint" && num < max) {
    if (strict) {
      if (_0n2 < num)
        return num;
    } else {
      if (_0n2 <= num)
        return num;
    }
  }
  throw new TypeError("Expected valid scalar: 0 < scalar < max");
}
function adjustBytes25519(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
function checkPrivateKey(key) {
  key = typeof key === "bigint" || typeof key === "number" ? numberTo32BytesBE(normalizeScalar2(key, POW_2_2562)) : ensureBytes2(key);
  if (key.length !== 32)
    throw new Error(`Expected 32 bytes`);
  return key;
}
function getKeyFromHash(hashed) {
  const head = adjustBytes25519(hashed.slice(0, 32));
  const prefix = hashed.slice(32, 64);
  const scalar = modlLE(head);
  const point = Point2.BASE.multiply(scalar);
  const pointBytes = point.toRawBytes();
  return { head, prefix, scalar, point, pointBytes };
}
var _sha512Sync;
async function getExtendedPublicKey(key) {
  return getKeyFromHash(await utils2.sha512(checkPrivateKey(key)));
}
async function getPublicKey2(privateKey) {
  return (await getExtendedPublicKey(privateKey)).pointBytes;
}
async function sign3(message2, privateKey) {
  message2 = ensureBytes2(message2);
  const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);
  const r = modlLE(await utils2.sha512(prefix, message2));
  const R = Point2.BASE.multiply(r);
  const k = modlLE(await utils2.sha512(R.toRawBytes(), pointBytes, message2));
  const s = mod3(r + k * scalar, CURVE2.l);
  return new Signature2(R, s).toRawBytes();
}
function prepareVerification(sig, message2, publicKey) {
  message2 = ensureBytes2(message2);
  if (!(publicKey instanceof Point2))
    publicKey = Point2.fromHex(publicKey, false);
  const { r, s } = sig instanceof Signature2 ? sig.assertValidity() : Signature2.fromHex(sig);
  const SB = ExtendedPoint.BASE.multiplyUnsafe(s);
  return { r, s, SB, pub: publicKey, msg: message2 };
}
function finishVerification(publicKey, r, SB, hashed) {
  const k = modlLE(hashed);
  const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);
  const RkA = ExtendedPoint.fromAffine(r).add(kA);
  return RkA.subtract(SB).multiplyUnsafe(CURVE2.h).equals(ExtendedPoint.ZERO);
}
async function verify2(sig, message2, publicKey) {
  const { r, SB, msg, pub } = prepareVerification(sig, message2, publicKey);
  const hashed = await utils2.sha512(r.toRawBytes(), pub.toRawBytes(), msg);
  return finishVerification(pub, r, SB, hashed);
}
Point2.BASE._setWindowSize(8);
var crypto3 = {
  node: nodeCrypto2,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};
var utils2 = {
  bytesToHex: bytesToHex2,
  hexToBytes: hexToBytes2,
  concatBytes: concatBytes2,
  getExtendedPublicKey,
  mod: mod3,
  invert: invert2,
  TORSION_SUBGROUP: [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ],
  hashToPrivateScalar: (hash3) => {
    hash3 = ensureBytes2(hash3);
    if (hash3.length < 40 || hash3.length > 1024)
      throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
    return mod3(bytesToNumberLE(hash3), CURVE2.l - _1n2) + _1n2;
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto3.web) {
      return crypto3.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto3.node) {
      const { randomBytes: randomBytes3 } = crypto3.node;
      return new Uint8Array(randomBytes3(bytesLength).buffer);
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => {
    return utils2.randomBytes(32);
  },
  sha512: async (...messages3) => {
    const message2 = concatBytes2(...messages3);
    if (crypto3.web) {
      const buffer2 = await crypto3.web.subtle.digest("SHA-512", message2.buffer);
      return new Uint8Array(buffer2);
    } else if (crypto3.node) {
      return Uint8Array.from(crypto3.node.createHash("sha512").update(message2).digest());
    } else {
      throw new Error("The environment doesn't have sha512 function");
    }
  },
  precompute(windowSize = 8, point = Point2.BASE) {
    const cached = point.equals(Point2.BASE) ? point : new Point2(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_2n2);
    return cached;
  },
  sha512Sync: void 0
};
Object.defineProperties(utils2, {
  sha512Sync: {
    configurable: false,
    get() {
      return _sha512Sync;
    },
    set(val) {
      if (!_sha512Sync)
        _sha512Sync = val;
    }
  }
});
var PUBLIC_KEY_BYTE_LENGTH = 32;
var PRIVATE_KEY_BYTE_LENGTH = 64;
var KEYS_BYTE_LENGTH = 32;
async function generateKey2() {
  const privateKeyRaw = utils2.randomPrivateKey();
  const publicKey = await getPublicKey2(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
async function generateKeyFromSeed(seed2) {
  if (seed2.length !== KEYS_BYTE_LENGTH) {
    throw new TypeError('"seed" must be 32 bytes in length.');
  } else if (!(seed2 instanceof Uint8Array)) {
    throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
  }
  const privateKeyRaw = seed2;
  const publicKey = await getPublicKey2(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
async function hashAndSign2(privateKey, msg) {
  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);
  return await sign3(msg, privateKeyRaw);
}
async function hashAndVerify2(publicKey, sig, msg) {
  return await verify2(sig, msg, publicKey);
}
function concatKeys(privateKeyRaw, publicKey) {
  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
  for (let i2 = 0; i2 < KEYS_BYTE_LENGTH; i2++) {
    privateKey[i2] = privateKeyRaw[i2];
    privateKey[KEYS_BYTE_LENGTH + i2] = publicKey[i2];
  }
  return privateKey;
}
var Ed25519PublicKey = class {
  constructor(key) {
    this._key = ensureKey(key, PUBLIC_KEY_BYTE_LENGTH);
  }
  async verify(data, sig) {
    return await hashAndVerify2(this._key, sig, data);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.Ed25519,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha256.digest(this.bytes);
    return bytes2;
  }
};
var Ed25519PrivateKey = class {
  // key       - 64 byte Uint8Array containing private key
  // publicKey - 32 byte Uint8Array containing public key
  constructor(key, publicKey) {
    this._key = ensureKey(key, PRIVATE_KEY_BYTE_LENGTH);
    this._publicKey = ensureKey(publicKey, PUBLIC_KEY_BYTE_LENGTH);
  }
  async sign(message2) {
    return await hashAndSign2(this._key, message2);
  }
  get public() {
    return new Ed25519PublicKey(this._publicKey);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.Ed25519,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha256.digest(this.bytes);
    return bytes2;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the identity multihash containing its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   *
   * @returns {Promise<string>}
   */
  async id() {
    const encoding = await identity.digest(this.public.bytes);
    return base58btc.encode(encoding.bytes).substring(1);
  }
  /**
   * Exports the key into a password protected `format`
   */
  async export(password, format2 = "libp2p-key") {
    if (format2 === "libp2p-key") {
      return await exporter(this.bytes, password);
    } else {
      throw (0, import_err_code14.default)(new Error(`export format '${format2}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
    }
  }
};
function unmarshalEd25519PrivateKey(bytes2) {
  if (bytes2.length > PRIVATE_KEY_BYTE_LENGTH) {
    bytes2 = ensureKey(bytes2, PRIVATE_KEY_BYTE_LENGTH + PUBLIC_KEY_BYTE_LENGTH);
    const privateKeyBytes2 = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
    const publicKeyBytes2 = bytes2.subarray(PRIVATE_KEY_BYTE_LENGTH, bytes2.length);
    return new Ed25519PrivateKey(privateKeyBytes2, publicKeyBytes2);
  }
  bytes2 = ensureKey(bytes2, PRIVATE_KEY_BYTE_LENGTH);
  const privateKeyBytes = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
  const publicKeyBytes = bytes2.subarray(PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
}
function unmarshalEd25519PublicKey(bytes2) {
  bytes2 = ensureKey(bytes2, PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PublicKey(bytes2);
}
async function generateKeyPair2() {
  const { privateKey, publicKey } = await generateKey2();
  return new Ed25519PrivateKey(privateKey, publicKey);
}
async function generateKeyPairFromSeed(seed2) {
  const { privateKey, publicKey } = await generateKeyFromSeed(seed2);
  return new Ed25519PrivateKey(privateKey, publicKey);
}
function ensureKey(key, length3) {
  key = Uint8Array.from(key ?? []);
  if (key.length !== length3) {
    throw (0, import_err_code14.default)(new Error(`Key must be a Uint8Array of length ${length3}, got ${key.length}`), "ERR_INVALID_KEY_TYPE");
  }
  return key;
}
var secp256k1_class_exports = {};
__export(secp256k1_class_exports, {
  Secp256k1PrivateKey: () => Secp256k1PrivateKey,
  Secp256k1PublicKey: () => Secp256k1PublicKey,
  generateKeyPair: () => generateKeyPair3,
  unmarshalSecp256k1PrivateKey: () => unmarshalSecp256k1PrivateKey,
  unmarshalSecp256k1PublicKey: () => unmarshalSecp256k1PublicKey
});
var import_err_code16 = __toESM(require_err_code(), 1);
var import_err_code15 = __toESM(require_err_code(), 1);
function generateKey3() {
  return utils.randomPrivateKey();
}
async function hashAndSign3(key, msg) {
  const { digest: digest2 } = await sha256.digest(msg);
  try {
    return await sign2(digest2, key);
  } catch (err2) {
    throw (0, import_err_code15.default)(err2, "ERR_INVALID_INPUT");
  }
}
async function hashAndVerify3(key, sig, msg) {
  try {
    const { digest: digest2 } = await sha256.digest(msg);
    return verify$1(sig, digest2, key);
  } catch (err2) {
    throw (0, import_err_code15.default)(err2, "ERR_INVALID_INPUT");
  }
}
function compressPublicKey(key) {
  const point = Point.fromHex(key).toRawBytes(true);
  return point;
}
function validatePrivateKey(key) {
  try {
    getPublicKey(key, true);
  } catch (err2) {
    throw (0, import_err_code15.default)(err2, "ERR_INVALID_PRIVATE_KEY");
  }
}
function validatePublicKey(key) {
  try {
    Point.fromHex(key);
  } catch (err2) {
    throw (0, import_err_code15.default)(err2, "ERR_INVALID_PUBLIC_KEY");
  }
}
function computePublicKey(privateKey) {
  try {
    return getPublicKey(privateKey, true);
  } catch (err2) {
    throw (0, import_err_code15.default)(err2, "ERR_INVALID_PRIVATE_KEY");
  }
}
var Secp256k1PublicKey = class {
  constructor(key) {
    validatePublicKey(key);
    this._key = key;
  }
  async verify(data, sig) {
    return await hashAndVerify3(this._key, sig, data);
  }
  marshal() {
    return compressPublicKey(this._key);
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.Secp256k1,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha256.digest(this.bytes);
    return bytes2;
  }
};
var Secp256k1PrivateKey = class {
  constructor(key, publicKey) {
    this._key = key;
    this._publicKey = publicKey ?? computePublicKey(key);
    validatePrivateKey(this._key);
    validatePublicKey(this._publicKey);
  }
  async sign(message2) {
    return await hashAndSign3(this._key, message2);
  }
  get public() {
    return new Secp256k1PublicKey(this._publicKey);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.Secp256k1,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha256.digest(this.bytes);
    return bytes2;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the SHA-256 multihash of its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   */
  async id() {
    const hash3 = await this.public.hash();
    return toString3(hash3, "base58btc");
  }
  /**
   * Exports the key into a password protected `format`
   */
  async export(password, format2 = "libp2p-key") {
    if (format2 === "libp2p-key") {
      return await exporter(this.bytes, password);
    } else {
      throw (0, import_err_code16.default)(new Error(`export format '${format2}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
    }
  }
};
function unmarshalSecp256k1PrivateKey(bytes2) {
  return new Secp256k1PrivateKey(bytes2);
}
function unmarshalSecp256k1PublicKey(bytes2) {
  return new Secp256k1PublicKey(bytes2);
}
async function generateKeyPair3() {
  const privateKeyBytes = await generateKey3();
  return new Secp256k1PrivateKey(privateKeyBytes);
}
var supportedKeys = {
  rsa: rsa_class_exports,
  ed25519: ed25519_class_exports,
  secp256k1: secp256k1_class_exports
};
function unsupportedKey(type) {
  const supported = Object.keys(supportedKeys).join(" / ");
  return (0, import_err_code17.default)(new Error(`invalid or unsupported key type ${type}. Must be ${supported}`), "ERR_UNSUPPORTED_KEY_TYPE");
}
function typeToKey(type) {
  type = type.toLowerCase();
  if (type === "rsa" || type === "ed25519" || type === "secp256k1") {
    return supportedKeys[type];
  }
  throw unsupportedKey(type);
}
async function generateKeyPair4(type, bits2) {
  return await typeToKey(type).generateKeyPair(bits2 ?? 2048);
}
async function generateKeyPairFromSeed2(type, seed2, bits2) {
  if (type.toLowerCase() !== "ed25519") {
    throw (0, import_err_code17.default)(new Error("Seed key derivation is unimplemented for RSA or secp256k1"), "ERR_UNSUPPORTED_KEY_DERIVATION_TYPE");
  }
  return await generateKeyPairFromSeed(seed2);
}
function unmarshalPublicKey2(buf2) {
  const decoded = PublicKey.decode(buf2);
  const data = decoded.Data ?? new Uint8Array();
  switch (decoded.Type) {
    case KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPublicKey(data);
    case KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);
    case KeyType.Secp256k1:
      return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);
    default:
      throw unsupportedKey(decoded.Type ?? "RSA");
  }
}
function marshalPublicKey2(key, type) {
  type = (type ?? "rsa").toLowerCase();
  typeToKey(type);
  return key.bytes;
}
async function unmarshalPrivateKey3(buf2) {
  const decoded = PrivateKey.decode(buf2);
  const data = decoded.Data ?? new Uint8Array();
  switch (decoded.Type) {
    case KeyType.RSA:
      return await supportedKeys.rsa.unmarshalRsaPrivateKey(data);
    case KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);
    case KeyType.Secp256k1:
      return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);
    default:
      throw unsupportedKey(decoded.Type ?? "RSA");
  }
}
function marshalPrivateKey(key, type) {
  type = (type ?? "rsa").toLowerCase();
  typeToKey(type);
  return key.bytes;
}
async function importKey(encryptedKey, password) {
  try {
    const key2 = await importer(encryptedKey, password);
    return await unmarshalPrivateKey3(key2);
  } catch (_) {
  }
  const key = import_forge5.default.pki.decryptRsaPrivateKey(encryptedKey, password);
  if (key === null) {
    throw (0, import_err_code17.default)(new Error("Cannot read the key, most likely the password is wrong or not a RSA key"), "ERR_CANNOT_DECRYPT_PEM");
  }
  let der = import_forge5.default.asn1.toDer(import_forge5.default.pki.privateKeyToAsn1(key));
  der = fromString3(der.getBytes(), "ascii");
  return await supportedKeys.rsa.unmarshalRsaPrivateKey(der);
}
var import_err_code19 = __toESM(require_err_code());
var import_err_code18 = __toESM(require_err_code(), 1);
var ERR_IPNS_EXPIRED_RECORD = "ERR_IPNS_EXPIRED_RECORD";
var ERR_UNRECOGNIZED_VALIDITY = "ERR_UNRECOGNIZED_VALIDITY";
var ERR_SIGNATURE_CREATION = "ERR_SIGNATURE_CREATION";
var ERR_SIGNATURE_VERIFICATION = "ERR_SIGNATURE_VERIFICATION";
var ERR_UNRECOGNIZED_FORMAT = "ERR_UNRECOGNIZED_FORMAT";
var ERR_UNDEFINED_PARAMETER = "ERR_UNDEFINED_PARAMETER";
var ERR_INVALID_RECORD_DATA = "ERR_INVALID_RECORD_DATA";
var ERR_INVALID_EMBEDDED_KEY = "ERR_INVALID_EMBEDDED_KEY";
var ERR_MISSING_PRIVATE_KEY = "ERR_MISSING_PRIVATE_KEY";
var IpnsEntry;
(function(IpnsEntry2) {
  (function(ValidityType2) {
    ValidityType2["EOL"] = "EOL";
  })(IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
  let __ValidityTypeValues;
  (function(__ValidityTypeValues2) {
    __ValidityTypeValues2[__ValidityTypeValues2["EOL"] = 0] = "EOL";
  })(__ValidityTypeValues || (__ValidityTypeValues = {}));
  (function(ValidityType2) {
    ValidityType2.codec = () => {
      return enumeration(__ValidityTypeValues);
    };
  })(IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
  let _codec;
  IpnsEntry2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.value != null) {
          w.uint32(10);
          w.bytes(obj.value);
        }
        if (obj.signature != null) {
          w.uint32(18);
          w.bytes(obj.signature);
        }
        if (obj.validityType != null) {
          w.uint32(24);
          IpnsEntry2.ValidityType.codec().encode(obj.validityType, w);
        }
        if (obj.validity != null) {
          w.uint32(34);
          w.bytes(obj.validity);
        }
        if (obj.sequence != null) {
          w.uint32(40);
          w.uint64(obj.sequence);
        }
        if (obj.ttl != null) {
          w.uint32(48);
          w.uint64(obj.ttl);
        }
        if (obj.pubKey != null) {
          w.uint32(58);
          w.bytes(obj.pubKey);
        }
        if (obj.signatureV2 != null) {
          w.uint32(66);
          w.bytes(obj.signatureV2);
        }
        if (obj.data != null) {
          w.uint32(74);
          w.bytes(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {};
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.value = reader3.bytes();
              break;
            case 2:
              obj.signature = reader3.bytes();
              break;
            case 3:
              obj.validityType = IpnsEntry2.ValidityType.codec().decode(reader3);
              break;
            case 4:
              obj.validity = reader3.bytes();
              break;
            case 5:
              obj.sequence = reader3.uint64();
              break;
            case 6:
              obj.ttl = reader3.uint64();
              break;
            case 7:
              obj.pubKey = reader3.bytes();
              break;
            case 8:
              obj.signatureV2 = reader3.bytes();
              break;
            case 9:
              obj.data = reader3.bytes();
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  IpnsEntry2.encode = (obj) => {
    return encodeMessage(obj, IpnsEntry2.codec());
  };
  IpnsEntry2.decode = (buf2) => {
    return decodeMessage(buf2, IpnsEntry2.codec());
  };
})(IpnsEntry || (IpnsEntry = {}));
var log = logger("ipns:utils");
var IPNS_PREFIX = fromString3("/ipns/");
function parseRFC3339(time) {
  const rfc3339Matcher = new RegExp(
    // 2006-01-02T
    "(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"
  );
  const m = String(time).trim().match(rfc3339Matcher);
  if (m == null) {
    throw new Error("Invalid format");
  }
  const year = parseInt(m[1], 10);
  const month = parseInt(m[2], 10) - 1;
  const date = parseInt(m[3], 10);
  const hour3 = parseInt(m[4], 10);
  const minute5 = parseInt(m[5], 10);
  const second3 = parseInt(m[6], 10);
  const millisecond = parseInt(m[7].slice(0, -6), 10);
  return new Date(Date.UTC(year, month, date, hour3, minute5, second3, millisecond));
}
var extractPublicKey = async (peerId, entry) => {
  if (entry == null || peerId == null) {
    const error = new Error("one or more of the provided parameters are not defined");
    log.error(error);
    throw (0, import_err_code18.default)(error, ERR_UNDEFINED_PARAMETER);
  }
  let pubKey;
  if (entry.pubKey != null) {
    try {
      pubKey = unmarshalPublicKey2(entry.pubKey);
    } catch (err2) {
      log.error(err2);
      throw err2;
    }
    const otherId = await peerIdFromKeys(entry.pubKey);
    if (!otherId.equals(peerId)) {
      throw (0, import_err_code18.default)(new Error("Embedded public key did not match PeerID"), ERR_INVALID_EMBEDDED_KEY);
    }
  } else if (peerId.publicKey != null) {
    pubKey = unmarshalPublicKey2(peerId.publicKey);
  }
  if (pubKey != null) {
    return pubKey;
  }
  throw (0, import_err_code18.default)(new Error("no public key is available"), ERR_UNDEFINED_PARAMETER);
};
var ipnsEntryDataForV1Sig = (value2, validityType, validity) => {
  const validityTypeBuffer = fromString3(validityType);
  return concat([value2, validity, validityTypeBuffer]);
};
var ipnsEntryDataForV2Sig = (data) => {
  const entryData = fromString3("ipns-signature:");
  return concat([entryData, data]);
};
var marshal = (obj) => {
  return IpnsEntry.encode(obj);
};
var unmarshal = (buf2) => {
  const message2 = IpnsEntry.decode(buf2);
  if (message2.sequence != null) {
    message2.sequence = BigInt(message2.sequence);
  }
  if (message2.ttl != null) {
    message2.ttl = BigInt(message2.ttl);
  }
  return {
    value: message2.value ?? new Uint8Array(0),
    signature: message2.signature ?? new Uint8Array(0),
    validityType: message2.validityType ?? IpnsEntry.ValidityType.EOL,
    validity: message2.validity ?? new Uint8Array(0),
    sequence: message2.sequence ?? 0n,
    pubKey: message2.pubKey,
    ttl: message2.ttl ?? void 0,
    signatureV2: message2.signatureV2,
    data: message2.data
  };
};
var peerIdToRoutingKey = (peerId) => {
  return concat([
    IPNS_PREFIX,
    peerId.toBytes()
  ]);
};
var peerIdFromRoutingKey = (key) => {
  return peerIdFromBytes(key.slice(IPNS_PREFIX.length));
};
var createCborData = (value2, validity, validityType, sequence, ttl2) => {
  let ValidityType;
  if (validityType === IpnsEntry.ValidityType.EOL) {
    ValidityType = 0;
  } else {
    throw (0, import_err_code18.default)(new Error("Unknown validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  const data = {
    Value: value2,
    Validity: validity,
    ValidityType,
    Sequence: sequence,
    TTL: ttl2
  };
  return encode2$2(data);
};
var parseCborData = (buf2) => {
  const data = decode3$1(buf2);
  if (data.ValidityType === 0) {
    data.ValidityType = IpnsEntry.ValidityType.EOL;
  } else {
    throw (0, import_err_code18.default)(new Error("Unknown validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  if (Number.isInteger(data.Sequence)) {
    data.Sequence = BigInt(data.Sequence);
  }
  if (Number.isInteger(data.TTL)) {
    data.TTL = BigInt(data.TTL);
  }
  return data;
};
var log2 = logger("ipns");
var ID_MULTIHASH_CODE = identity.code;
var namespace = "/ipns/";
var namespaceLength = namespace.length;
var create4 = async (peerId, value2, seq, lifetime) => {
  const expirationDate = new import_timestamp_nano.default(Date.now() + Number(lifetime));
  const validityType = IpnsEntry.ValidityType.EOL;
  const [ms, ns] = lifetime.toString().split(".");
  const lifetimeNs = BigInt(ms) * BigInt(1e5) + BigInt(ns ?? "0");
  return await _create(peerId, value2, seq, validityType, expirationDate, lifetimeNs);
};
var _create = async (peerId, value2, seq, validityType, expirationDate, ttl2) => {
  seq = BigInt(seq);
  const isoValidity = fromString3(expirationDate.toString());
  if (peerId.privateKey == null) {
    throw (0, import_err_code19.default)(new Error("Missing private key"), ERR_MISSING_PRIVATE_KEY);
  }
  const privateKey = await unmarshalPrivateKey3(peerId.privateKey);
  const signatureV1 = await signLegacyV1(privateKey, value2, validityType, isoValidity);
  const data = createCborData(value2, isoValidity, validityType, seq, ttl2);
  const sigData = ipnsEntryDataForV2Sig(data);
  const signatureV2 = await privateKey.sign(sigData);
  const entry = {
    value: value2,
    signature: signatureV1,
    validityType,
    validity: isoValidity,
    sequence: seq,
    ttl: ttl2,
    signatureV2,
    data
  };
  if (peerId.publicKey != null) {
    const digest2 = decode3$3(peerId.toBytes());
    if (digest2.code !== ID_MULTIHASH_CODE || !equals(peerId.publicKey, digest2.digest)) {
      entry.pubKey = peerId.publicKey;
    }
  }
  log2("ipns entry for %b created", value2);
  return entry;
};
var rawStdEncoding = (key) => base32upper.encode(key).slice(1);
var getLocalKey = (key) => new Key(`/ipns/${rawStdEncoding(key)}`);
var signLegacyV1 = async (privateKey, value2, validityType, validity) => {
  try {
    const dataForSignature = ipnsEntryDataForV1Sig(value2, validityType, validity);
    return await privateKey.sign(dataForSignature);
  } catch (error) {
    log2.error("record signature creation failed", error);
    throw (0, import_err_code19.default)(new Error("record signature creation failed"), ERR_SIGNATURE_CREATION);
  }
};
var log3 = logger("ipfs:ipns:publisher");
var ERR_NOT_FOUND = notFoundError().code;
var defaultRecordLifetime = 60 * 60 * 1e3;
var IpnsPublisher = class {
  /**
   * @param {import('ipfs-core-types/src/utils').BufferStore} routing
   * @param {import('interface-datastore').Datastore} datastore
   */
  constructor(routing, datastore) {
    this._routing = routing;
    this._datastore = datastore;
  }
  /**
   * Publish record with a eol
   *
   * @param {PeerId} peerId
   * @param {Uint8Array} value
   * @param {number} lifetime
   * @param {AbortOptions} [options]
   */
  async publishWithEOL(peerId, value2, lifetime, options) {
    const record = await this._updateOrCreateRecord(peerId, value2, lifetime, options);
    return this._putRecordToRouting(record, peerId, options);
  }
  /**
   * Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system
   *
   * @param {PeerId} peerId
   * @param {Uint8Array} value
   * @param {AbortOptions} options
   */
  publish(peerId, value2, options) {
    return this.publishWithEOL(peerId, value2, defaultRecordLifetime, options);
  }
  /**
   * @param {Uint8Array} record
   * @param {PeerId} peerId
   * @param {AbortOptions} [options]
   */
  async _putRecordToRouting(record, peerId, options) {
    if (!isPeerId(peerId)) {
      const errMsg = "peerId received is not valid";
      log3.error(errMsg);
      throw (0, import_err_code20.default)(new Error(errMsg), "ERR_INVALID_PEER_ID");
    }
    if (peerId.publicKey == null) {
      throw (0, import_err_code20.default)(new Error("Public key was missing"), "ERR_MISSING_PUBLIC_KEY");
    }
    const routingKey = peerIdToRoutingKey(peerId);
    await this._publishEntry(routingKey, record, options);
    return record;
  }
  /**
   * @param {Uint8Array} key
   * @param {Uint8Array} entry
   * @param {AbortOptions} [options]
   */
  async _publishEntry(key, entry, options) {
    try {
      const res = await this._routing.put(key, entry, options);
      log3(`ipns record for ${toString3(key, "base32")} was stored in the routing`);
      return res;
    } catch (err2) {
      const errMsg = `ipns record for ${toString3(key, "base32")} could not be stored in the routing - ${err2.stack}`;
      log3.error(errMsg);
      log3.error(err2);
      throw (0, import_err_code20.default)(new Error(errMsg), "ERR_PUTTING_TO_ROUTING");
    }
  }
  /**
   * Returns the record this node has published corresponding to the given peer ID.
   *
   * If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.
   *
   * @param {PeerId} peerId
   * @param {object} options
   * @param {boolean} [options.checkRouting]
   */
  async _getPublished(peerId, options = {}) {
    if (!isPeerId(peerId)) {
      const errMsg = "peerId received is not valid";
      log3.error(errMsg);
      throw (0, import_err_code20.default)(new Error(errMsg), "ERR_INVALID_PEER_ID");
    }
    const checkRouting = options.checkRouting !== false;
    try {
      const dsVal = await this._datastore.get(getLocalKey(peerId.toBytes()));
      return this._unmarshalData(dsVal);
    } catch (err2) {
      if (err2.code !== ERR_NOT_FOUND) {
        const errMsg = `unexpected error getting the ipns record ${peerId.toString()} from datastore`;
        log3.error(errMsg);
        throw (0, import_err_code20.default)(new Error(errMsg), "ERR_UNEXPECTED_DATASTORE_RESPONSE");
      }
      if (!checkRouting) {
        throw (0, import_err_code20.default)(err2, "ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED");
      }
      try {
        const routingKey = peerIdToRoutingKey(peerId);
        const res = await this._routing.get(routingKey);
        return this._unmarshalData(res);
      } catch (err3) {
        log3.error(err3);
        throw err3;
      }
    }
  }
  /**
   * @param {Uint8Array} data
   */
  _unmarshalData(data) {
    try {
      return unmarshal(data);
    } catch (err2) {
      throw (0, import_err_code20.default)(err2, "ERR_INVALID_RECORD_DATA");
    }
  }
  /**
   * @param {PeerId} peerId
   * @param {Uint8Array} value
   * @param {number} lifetime
   * @param {AbortOptions} [options]
   */
  async _updateOrCreateRecord(peerId, value2, lifetime, options) {
    if (!isPeerId(peerId)) {
      const errMsg = "peerId received is not valid";
      log3.error(errMsg);
      throw (0, import_err_code20.default)(new Error(errMsg), "ERR_INVALID_PEER_ID");
    }
    const getPublishedOptions = {
      checkRouting: true
    };
    let record;
    try {
      record = await this._getPublished(peerId, getPublishedOptions);
    } catch (err2) {
      if (err2.code !== ERR_NOT_FOUND) {
        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.toString()} ${err2.stack}`;
        log3.error(errMsg);
        throw (0, import_err_code20.default)(new Error(errMsg), "ERR_DETERMINING_PUBLISHED_RECORD");
      }
    }
    let seqNumber = 0n;
    if (record && record.sequence !== void 0) {
      seqNumber = equals(record.value, value2) ? record.sequence : record.sequence + BigInt(1);
    }
    let entryData;
    try {
      entryData = await create4(peerId, value2, seqNumber, lifetime);
    } catch (err2) {
      const errMsg = `ipns record for ${value2} could not be created`;
      log3.error(err2);
      throw (0, import_err_code20.default)(new Error(errMsg), "ERR_CREATING_IPNS_RECORD");
    }
    try {
      const data = marshal(entryData);
      await this._datastore.put(getLocalKey(peerId.toBytes()), data, options);
      log3(`ipns record for ${toString3(value2, "base32")} was stored in the datastore`);
      return data;
    } catch (err2) {
      const errMsg = `ipns record for ${value2} could not be stored in the datastore`;
      log3.error(errMsg);
      throw (0, import_err_code20.default)(new Error(errMsg), "ERR_STORING_IN_DATASTORE");
    }
  }
};
IpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;
var import_err_code21 = __toESM(require_err_code(), 1);
var import_timeout_abort_controller2 = __toESM(require_timeout_abort_controller(), 1);
var log4 = logger("ipfs:ipns:republisher");
var minute = 60 * 1e3;
var hour = 60 * minute;
var defaultBroadcastInterval = 4 * hour;
var defaultRecordLifetime2 = 24 * hour;
var IpnsRepublisher = class {
  /**
   * @param {import('./publisher').IpnsPublisher} publisher
   * @param {import('interface-datastore').Datastore} datastore
   * @param {PeerId} peerId
   * @param {import('@libp2p/interface-keychain').KeyChain} keychain
   * @param {object} options
   * @param {string} options.pass
   * @param {number} [options.initialBroadcastInterval]
   * @param {number} [options.broadcastInterval]
   */
  constructor(publisher, datastore, peerId, keychain, options = { pass: "" }) {
    this._publisher = publisher;
    this._datastore = datastore;
    this._peerId = peerId;
    this._keychain = keychain;
    this._options = options;
    this._republishHandle = null;
  }
  async start() {
    if (this._republishHandle) {
      throw (0, import_err_code21.default)(new Error("republisher is already running"), "ERR_REPUBLISH_ALREADY_RUNNING");
    }
    const republishHandle = {
      /** @type {null|(() => Promise<void>)} */
      _task: null,
      /** @type {null|Promise<void>} */
      _inflightTask: null,
      /** @type {null|NodeJS.Timeout} */
      _timeoutId: null,
      /**
       * @param {function(): number} period
       */
      runPeriodically: (period) => {
        republishHandle._timeoutId = setTimeout(async () => {
          republishHandle._timeoutId = null;
          try {
            republishHandle._inflightTask = republishHandle._task();
            await republishHandle._inflightTask;
            if (republishHandle._task) {
              republishHandle.runPeriodically(period);
            }
          } catch (err2) {
            log4.error(err2);
          }
        }, period());
      },
      cancel: async () => {
        if (republishHandle._timeoutId != null) {
          clearTimeout(republishHandle._timeoutId);
        }
        republishHandle._task = null;
        await republishHandle._inflightTask;
      }
    };
    const { pass } = this._options;
    let firstRun = true;
    republishHandle._task = async () => {
      const timeoutController = new import_timeout_abort_controller2.TimeoutController(3e4);
      try {
        await this._republishEntries(this._peerId, pass, {
          signal: timeoutController.signal
        });
      } finally {
        timeoutController.clear();
      }
    };
    republishHandle.runPeriodically(() => {
      if (firstRun) {
        firstRun = false;
        return this._options.initialBroadcastInterval || minute;
      }
      return this._options.broadcastInterval || defaultBroadcastInterval;
    });
    this._republishHandle = republishHandle;
  }
  async stop() {
    const republishHandle = this._republishHandle;
    if (!republishHandle) {
      throw (0, import_err_code21.default)(new Error("republisher is not running"), "ERR_REPUBLISH_NOT_RUNNING");
    }
    this._republishHandle = null;
    await republishHandle.cancel();
  }
  /**
   * @param {PeerId} peerId
   * @param {string} pass
   * @param {AbortOptions} options
   */
  async _republishEntries(peerId, pass, options) {
    try {
      await this._republishEntry(peerId, options);
    } catch (err2) {
      const errMsg = "cannot republish entry for the node's private key";
      log4.error(errMsg);
      return;
    }
    if (pass) {
      try {
        const keys = await this._keychain.listKeys();
        for (const key of keys) {
          if (key.name === "self") {
            continue;
          }
          const pem = await this._keychain.exportKey(key.name, pass);
          const privKey = await importKey(pem, pass);
          const peerIdKey = await peerIdFromKeys(privKey.public.bytes, privKey.bytes);
          await this._republishEntry(peerIdKey, options);
        }
      } catch (err2) {
        log4.error(err2);
      }
    }
  }
  /**
   * @param {PeerId} peerId
   * @param {AbortOptions} options
   */
  async _republishEntry(peerId, options) {
    try {
      const value2 = await this._getPreviousValue(peerId);
      await this._publisher.publishWithEOL(peerId, value2, defaultRecordLifetime2, options);
    } catch (err2) {
      if (err2.code === "ERR_NO_ENTRY_FOUND") {
        return;
      }
      throw err2;
    }
  }
  /**
   * @param {PeerId} peerId
   */
  async _getPreviousValue(peerId) {
    if (!isPeerId(peerId)) {
      throw (0, import_err_code21.default)(new Error("invalid peer ID"), "ERR_INVALID_PEER_ID");
    }
    try {
      const dsVal = await this._datastore.get(getLocalKey(peerId.toBytes()));
      if (!(dsVal instanceof Uint8Array)) {
        throw (0, import_err_code21.default)(new Error("found ipns record that we couldn't process"), "ERR_INVALID_IPNS_RECORD");
      }
      try {
        const record = unmarshal(dsVal);
        return record.value;
      } catch (err2) {
        log4.error(err2);
        throw (0, import_err_code21.default)(new Error("found ipns record that we couldn't convert to a value"), "ERR_INVALID_IPNS_RECORD");
      }
    } catch (err2) {
      if (err2 && err2.notFound) {
        throw (0, import_err_code21.default)(new Error(`no previous entry for record with id: ${peerId.toString()}`), "ERR_NO_ENTRY_FOUND");
      }
      throw err2;
    }
  }
};
var import_err_code23 = __toESM(require_err_code(), 1);
var import_err_code22 = __toESM(require_err_code());
var log5 = logger("ipns:validator");
var validate2 = async (publicKey, entry) => {
  const { value: value2, validityType, validity } = entry;
  let dataForSignature;
  let signature;
  if (entry.signatureV2 != null && entry.data != null) {
    signature = entry.signatureV2;
    dataForSignature = ipnsEntryDataForV2Sig(entry.data);
    validateCborDataMatchesPbData(entry);
  } else {
    throw (0, import_err_code22.default)(new Error("missing data or signatureV2"), ERR_SIGNATURE_VERIFICATION);
  }
  let isValid;
  try {
    isValid = await publicKey.verify(dataForSignature, signature);
  } catch (err2) {
    isValid = false;
  }
  if (!isValid) {
    log5.error("record signature verification failed");
    throw (0, import_err_code22.default)(new Error("record signature verification failed"), ERR_SIGNATURE_VERIFICATION);
  }
  if (validity != null && validityType === IpnsEntry.ValidityType.EOL) {
    let validityDate;
    try {
      validityDate = parseRFC3339(toString3(validity));
    } catch (e) {
      log5.error("unrecognized validity format (not an rfc3339 format)");
      throw (0, import_err_code22.default)(new Error("unrecognized validity format (not an rfc3339 format)"), ERR_UNRECOGNIZED_FORMAT);
    }
    if (validityDate.getTime() < Date.now()) {
      log5.error("record has expired");
      throw (0, import_err_code22.default)(new Error("record has expired"), ERR_IPNS_EXPIRED_RECORD);
    }
  } else if (validityType != null) {
    log5.error("unrecognized validity type");
    throw (0, import_err_code22.default)(new Error("unrecognized validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  log5("ipns entry for %b is valid", value2);
};
var validateCborDataMatchesPbData = (entry) => {
  if (entry.data == null) {
    throw (0, import_err_code22.default)(new Error("Record data is missing"), ERR_INVALID_RECORD_DATA);
  }
  const data = parseCborData(entry.data);
  if (!equals(data.Value, entry.value)) {
    throw (0, import_err_code22.default)(new Error('Field "value" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (!equals(data.Validity, entry.validity)) {
    throw (0, import_err_code22.default)(new Error('Field "validity" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.ValidityType !== entry.validityType) {
    throw (0, import_err_code22.default)(new Error('Field "validityType" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.Sequence !== entry.sequence) {
    throw (0, import_err_code22.default)(new Error('Field "sequence" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.TTL !== entry.ttl) {
    throw (0, import_err_code22.default)(new Error('Field "ttl" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
};
var ipnsValidator = async (key, marshalledData) => {
  const peerId = peerIdFromRoutingKey(key);
  const receivedEntry = unmarshal(marshalledData);
  const pubKey = await extractPublicKey(peerId, receivedEntry);
  await validate2(pubKey, receivedEntry);
};
var log6 = logger("ipfs:ipns:resolver");
var ERR_NOT_FOUND2 = notFoundError().code;
var defaultMaximumRecursiveDepth = 32;
var IpnsResolver = class {
  /**
   * @param {import('ipfs-core-types/src/utils').BufferStore} routing
   */
  constructor(routing) {
    this._routing = routing;
  }
  /**
   * @param {string} name
   * @param {object} [options]
   * @param {boolean} [options.recursive]
   * @param {AbortSignal} [options.signal]
   */
  async resolve(name9, options = {}) {
    if (typeof name9 !== "string") {
      throw (0, import_err_code23.default)(new Error("invalid name"), "ERR_INVALID_NAME");
    }
    const recursive2 = options.recursive && options.recursive.toString() === "true";
    const nameSegments = name9.split("/");
    if (nameSegments.length !== 3 || nameSegments[0] !== "") {
      throw (0, import_err_code23.default)(new Error("invalid name"), "ERR_INVALID_NAME");
    }
    const key = nameSegments[2];
    let depth = Infinity;
    if (recursive2) {
      depth = defaultMaximumRecursiveDepth;
    }
    const res = await this.resolver(key, depth, options);
    log6(`${name9} was locally resolved correctly`);
    return res;
  }
  /**
   * Recursive resolver according to the specified depth
   *
   * @param {string} name
   * @param {number} depth
   * @param {AbortOptions} options
   * @returns {Promise<string>}
   */
  async resolver(name9, depth, options) {
    if (depth === 0) {
      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`;
      log6.error(errMsg);
      throw (0, import_err_code23.default)(new Error(errMsg), "ERR_RESOLVE_RECURSION_LIMIT");
    }
    const res = await this._resolveName(name9, options);
    const nameSegments = res.split("/");
    if (nameSegments[1] === "ipfs" || !depth) {
      return res;
    }
    return this.resolver(nameSegments[2], depth - 1, options);
  }
  /**
   * Resolve ipns entries from the provided routing
   *
   * @param {string} name
   * @param {AbortOptions} options
   */
  async _resolveName(name9, options) {
    const peerId = peerIdFromString(name9);
    const routingKey = peerIdToRoutingKey(peerId);
    let record;
    try {
      record = await this._routing.get(routingKey, options);
    } catch (err2) {
      log6.error("could not get record from routing", err2);
      if (err2.code === ERR_NOT_FOUND2) {
        throw (0, import_err_code23.default)(new Error(`record requested for ${name9} was not found in the network`), "ERR_NO_RECORD_FOUND");
      }
      throw (0, import_err_code23.default)(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), "ERR_UNEXPECTED_ERROR_GETTING_RECORD");
    }
    return this._validateRecord(peerId, record);
  }
  /**
   * Validate a resolved record
   *
   * @param {PeerId} peerId
   * @param {Uint8Array} record
   */
  async _validateRecord(peerId, record) {
    await ipnsValidator(concat([
      fromString3("/ipns/"),
      peerId.toBytes()
    ]), record);
    const ipnsEntry = unmarshal(record);
    return toString3(ipnsEntry.value);
  }
};
var import_hashlru2 = __toESM(require_hashlru(), 1);
var TLRU2 = class {
  /**
   * Creates an instance of TLRU.
   *
   * @param {number} maxSize
   */
  constructor(maxSize) {
    this.lru = (0, import_hashlru2.default)(maxSize);
  }
  /**
   * Get the value from the a key
   *
   * @param {string} key
   * @returns {T|undefined}
   * @memberof TLoRU
   */
  get(key) {
    const value2 = this.lru.get(key);
    if (value2) {
      if (value2.expire && value2.expire < Date.now()) {
        this.lru.remove(key);
        return void 0;
      }
      return value2.value;
    }
    return void 0;
  }
  /**
   * Set a key value pair
   *
   * @param {string} key
   * @param {T} value
   * @param {number} ttl - in miliseconds
   * @returns {void}
   */
  set(key, value2, ttl2) {
    this.lru.set(key, { value: value2, expire: Date.now() + ttl2 });
  }
  /**
   * Find if the cache has the key
   *
   * @param {string} key
   * @returns {boolean}
   */
  has(key) {
    const value2 = this.get(key);
    if (value2) {
      return true;
    }
    return false;
  }
  /**
   * Remove key
   *
   * @param {string} key
   */
  remove(key) {
    this.lru.remove(key);
  }
  /**
   * Clears the cache
   *
   * @memberof TLRU
   */
  clear() {
    this.lru.clear();
  }
};
var log7 = logger("ipfs:ipns");
var defaultRecordTtl = 60 * 1e3;
var IPNS = class {
  /**
   * @param {import('ipfs-core-types/src/utils').BufferStore} routing
   * @param {import('interface-datastore').Datastore} datastore
   * @param {PeerId} peerId
   * @param {import('@libp2p/interface-keychain').KeyChain} keychain
   * @param {object} options
   * @param {string} options.pass
   * @param {number} [options.initialBroadcastInterval]
   * @param {number} [options.broadcastInterval]
   */
  constructor(routing, datastore, peerId, keychain, options) {
    this.publisher = new IpnsPublisher(routing, datastore);
    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options);
    this.resolver = new IpnsResolver(routing);
    this.cache = new TLRU2(1e3);
    this.routing = routing;
  }
  /**
   * Publish
   *
   * @param {PeerId} peerId
   * @param {Uint8Array} value
   * @param {number} lifetime
   * @param {AbortOptions} [options]
   */
  async publish(peerId, value2, lifetime = IpnsPublisher.defaultRecordLifetime, options) {
    try {
      await this.publisher.publishWithEOL(peerId, value2, lifetime, options);
      log7(`IPNS value ${toString3(value2, "base32")} was published correctly`);
      const id = peerId.toString();
      const ttEol = parseFloat(lifetime);
      const ttl2 = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;
      this.cache.set(id, value2, ttl2);
      log7(`IPNS value ${toString3(value2, "base32")} was cached correctly`);
      return {
        name: id,
        value: value2
      };
    } catch (err2) {
      log7.error(err2);
      throw err2;
    }
  }
  /**
   * Resolve
   *
   * @param {string} name
   * @param {object} options
   * @param {boolean} [options.nocache]
   * @param {boolean} [options.recursive]
   * @param {AbortSignal} [options.signal]
   */
  async resolve(name9, options = {}) {
    if (typeof name9 !== "string") {
      throw (0, import_err_code24.default)(new Error("name received is not valid"), "ERR_INVALID_NAME");
    }
    if (!options.nocache && !options.recursive) {
      const id = name9.split("/")[2];
      const result = this.cache.get(id);
      if (result) {
        return result;
      }
    }
    try {
      const result = await this.resolver.resolve(name9, options);
      log7(`IPNS record from ${name9} was resolved correctly`);
      return result;
    } catch (err2) {
      log7.error(err2);
      throw err2;
    }
  }
  /**
   * Initialize keyspace
   *
   * Sets the ipns record for the given key to point to an empty directory
   *
   * @param {PeerId} peerId
   * @param {Uint8Array} value
   * @param {AbortOptions} [options]
   */
  async initializeKeyspace(peerId, value2, options) {
    return this.publish(peerId, value2, IpnsPublisher.defaultRecordLifetime, options);
  }
};
async function all(source) {
  const arr = [];
  for await (const entry of source) {
    arr.push(entry);
  }
  return arr;
}
var sortAll = (iterable, sorter) => {
  return async function* () {
    const values = await all(iterable);
    yield* values.sort(sorter);
  }();
};
async function drain(source) {
  for await (const _ of source) {
  }
}
async function* filter(source, fn) {
  for await (const entry of source) {
    if (await fn(entry)) {
      yield entry;
    }
  }
}
async function* take(source, limit) {
  let items = 0;
  if (limit < 1) {
    return;
  }
  for await (const entry of source) {
    yield entry;
    items++;
    if (items === limit) {
      return;
    }
  }
}
var BaseDatastore = class {
  /**
   * @returns {Promise<void>}
   */
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  /**
   * @returns {Promise<void>}
   */
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  /**
   * @param {Key} key
   * @param {Uint8Array} val
   * @param {Options} [options]
   * @returns {Promise<void>}
   */
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  /**
   * @param {Key} key
   * @param {Options} [options]
   * @returns {Promise<Uint8Array>}
   */
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  /**
   * @param {Key} key
   * @param {Options} [options]
   * @returns {Promise<boolean>}
   */
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  /**
   * @param {Key} key
   * @param {Options} [options]
   * @returns {Promise<void>}
   */
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  /**
   * @param {AwaitIterable<Pair>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<Pair>}
   */
  async *putMany(source, options = {}) {
    for await (const { key, value: value2 } of source) {
      await this.put(key, value2, options);
      yield { key, value: value2 };
    }
  }
  /**
   * @param {AwaitIterable<Key>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<Uint8Array>}
   */
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield this.get(key, options);
    }
  }
  /**
   * @param {AwaitIterable<Key>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<Key>}
   */
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  /**
   * @returns {Batch}
   */
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value2) {
        puts.push({ key, value: value2 });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await drain(this.putMany(puts, options));
        puts = [];
        await drain(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  /**
   * Extending classes should override `query` or implement this method
   *
   * @param {Query} q
   * @param {Options} [options]
   * @returns {AsyncIterable<Pair>}
   */
  // eslint-disable-next-line require-yield
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  /**
   * Extending classes should override `queryKeys` or implement this method
   *
   * @param {KeyQuery} q
   * @param {Options} [options]
   * @returns {AsyncIterable<Key>}
   */
  // eslint-disable-next-line require-yield
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  /**
   * @param {Query} q
   * @param {Options} [options]
   */
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      it = filter(
        it,
        (e) => e.key.toString().startsWith(
          /** @type {string} */
          q.prefix
        )
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => filter(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      it = filter(it, () => i2++ >= /** @type {number} */
      q.offset);
    }
    if (q.limit != null) {
      it = take(it, q.limit);
    }
    return it;
  }
  /**
   * @param {KeyQuery} q
   * @param {Options} [options]
   */
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      it = filter(
        it,
        (key) => key.toString().startsWith(
          /** @type {string} */
          q.prefix
        )
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => filter(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      it = filter(it, () => i2++ >= /** @type {number} */
      q.offset);
    }
    if (q.limit != null) {
      it = take(it, q.limit);
    }
    return it;
  }
};
var FixedFIFO = class {
  constructor(hwm) {
    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
      throw new Error("Max size for a FixedFIFO should be a power of two");
    }
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }
  push(data) {
    if (this.buffer[this.top] !== void 0) {
      return false;
    }
    this.buffer[this.top] = data;
    this.top = this.top + 1 & this.mask;
    return true;
  }
  shift() {
    const last2 = this.buffer[this.btm];
    if (last2 === void 0) {
      return void 0;
    }
    this.buffer[this.btm] = void 0;
    this.btm = this.btm + 1 & this.mask;
    return last2;
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
};
var FIFO = class {
  constructor(options = {}) {
    this.hwm = options.splitLimit ?? 16;
    this.head = new FixedFIFO(this.hwm);
    this.tail = this.head;
    this.size = 0;
  }
  calculateSize(obj) {
    if (obj?.byteLength != null) {
      return obj.byteLength;
    }
    return 1;
  }
  push(val) {
    if (val?.value != null) {
      this.size += this.calculateSize(val.value);
    }
    if (!this.head.push(val)) {
      const prev2 = this.head;
      this.head = prev2.next = new FixedFIFO(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }
  shift() {
    let val = this.tail.shift();
    if (val === void 0 && this.tail.next != null) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      val = this.tail.shift();
    }
    if (val?.value != null) {
      this.size -= this.calculateSize(val.value);
    }
    return val;
  }
  isEmpty() {
    return this.head.isEmpty();
  }
};
function pushable(options = {}) {
  const getNext = (buffer2) => {
    const next = buffer2.shift();
    if (next == null) {
      return { done: true };
    }
    if (next.error != null) {
      throw next.error;
    }
    return {
      done: next.done === true,
      // @ts-expect-error
      value: next.value
    };
  };
  return _pushable(getNext, options);
}
function pushableV(options = {}) {
  const getNext = (buffer2) => {
    let next;
    const values = [];
    while (!buffer2.isEmpty()) {
      next = buffer2.shift();
      if (next == null) {
        break;
      }
      if (next.error != null) {
        throw next.error;
      }
      if (next.done === false) {
        values.push(next.value);
      }
    }
    if (next == null) {
      return { done: true };
    }
    return {
      done: next.done === true,
      value: values
    };
  };
  return _pushable(getNext, options);
}
function _pushable(getNext, options) {
  options = options ?? {};
  let onEnd = options.onEnd;
  let buffer2 = new FIFO();
  let pushable2;
  let onNext;
  let ended;
  const waitNext = async () => {
    if (!buffer2.isEmpty()) {
      return getNext(buffer2);
    }
    if (ended) {
      return { done: true };
    }
    return await new Promise((resolve7, reject) => {
      onNext = (next) => {
        onNext = null;
        buffer2.push(next);
        try {
          resolve7(getNext(buffer2));
        } catch (err2) {
          reject(err2);
        }
        return pushable2;
      };
    });
  };
  const bufferNext = (next) => {
    if (onNext != null) {
      return onNext(next);
    }
    buffer2.push(next);
    return pushable2;
  };
  const bufferError = (err2) => {
    buffer2 = new FIFO();
    if (onNext != null) {
      return onNext({ error: err2 });
    }
    buffer2.push({ error: err2 });
    return pushable2;
  };
  const push = (value2) => {
    if (ended) {
      return pushable2;
    }
    if (options?.objectMode !== true && value2?.byteLength == null) {
      throw new Error("objectMode was not true but tried to push non-Uint8Array value");
    }
    return bufferNext({ done: false, value: value2 });
  };
  const end = (err2) => {
    if (ended)
      return pushable2;
    ended = true;
    return err2 != null ? bufferError(err2) : bufferNext({ done: true });
  };
  const _return = () => {
    buffer2 = new FIFO();
    end();
    return { done: true };
  };
  const _throw = (err2) => {
    end(err2);
    return { done: true };
  };
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: waitNext,
    return: _return,
    throw: _throw,
    push,
    end,
    get readableLength() {
      return buffer2.size;
    }
  };
  if (onEnd == null) {
    return pushable2;
  }
  const _pushable2 = pushable2;
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return _pushable2.next();
    },
    throw(err2) {
      _pushable2.throw(err2);
      if (onEnd != null) {
        onEnd(err2);
        onEnd = void 0;
      }
      return { done: true };
    },
    return() {
      _pushable2.return();
      if (onEnd != null) {
        onEnd();
        onEnd = void 0;
      }
      return { done: true };
    },
    push,
    end(err2) {
      _pushable2.end(err2);
      if (onEnd != null) {
        onEnd(err2);
        onEnd = void 0;
      }
      return pushable2;
    },
    get readableLength() {
      return _pushable2.readableLength;
    }
  };
  return pushable2;
}
var log8 = logger("datastore:core:tiered");
var TieredDatastore = class extends BaseDatastore {
  /**
   * @param {Datastore[]} stores
   */
  constructor(stores) {
    super();
    this.stores = stores.slice();
  }
  async open() {
    try {
      await Promise.all(this.stores.map((store) => store.open()));
    } catch (err2) {
      throw dbOpenFailedError(err2);
    }
  }
  /**
   * @param {Key} key
   * @param {Uint8Array} value
   * @param {Options} [options]
   */
  async put(key, value2, options) {
    try {
      await Promise.all(this.stores.map((store) => store.put(key, value2, options)));
    } catch (err2) {
      throw dbWriteFailedError(err2);
    }
  }
  /**
   * @param {Key} key
   * @param {Options} [options]
   */
  async get(key, options) {
    for (const store of this.stores) {
      try {
        const res = await store.get(key, options);
        if (res)
          return res;
      } catch (err2) {
        log8.error(err2);
      }
    }
    throw notFoundError();
  }
  /**
   * @param {Key} key
   * @param {Options} [options]
   */
  async has(key, options) {
    for (const s of this.stores) {
      if (await s.has(key, options)) {
        return true;
      }
    }
    return false;
  }
  /**
   * @param {Key} key
   * @param {Options} [options]
   */
  async delete(key, options) {
    try {
      await Promise.all(this.stores.map((store) => store.delete(key, options)));
    } catch (err2) {
      throw dbDeleteFailedError(err2);
    }
  }
  /**
   * @param {AwaitIterable<Pair>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<Pair>}
   */
  async *putMany(source, options = {}) {
    let error;
    const pushables = this.stores.map((store) => {
      const source2 = pushable({
        objectMode: true
      });
      drain(store.putMany(source2, options)).catch((err2) => {
        error = err2;
      });
      return source2;
    });
    try {
      for await (const pair2 of source) {
        if (error) {
          throw error;
        }
        pushables.forEach((p) => p.push(pair2));
        yield pair2;
      }
    } finally {
      pushables.forEach((p) => p.end());
    }
  }
  /**
   * @param {AwaitIterable<Key>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<Key>}
   */
  async *deleteMany(source, options = {}) {
    let error;
    const pushables = this.stores.map((store) => {
      const source2 = pushable({
        objectMode: true
      });
      drain(store.deleteMany(source2, options)).catch((err2) => {
        error = err2;
      });
      return source2;
    });
    try {
      for await (const key of source) {
        if (error) {
          throw error;
        }
        pushables.forEach((p) => p.push(key));
        yield key;
      }
    } finally {
      pushables.forEach((p) => p.end());
    }
  }
  async close() {
    await Promise.all(this.stores.map((store) => store.close()));
  }
  /**
   * @returns {Batch}
   */
  batch() {
    const batches = this.stores.map((store) => store.batch());
    return {
      put: (key, value2) => {
        batches.forEach((b) => b.put(key, value2));
      },
      delete: (key) => {
        batches.forEach((b) => b.delete(key));
      },
      commit: async (options) => {
        for (const batch2 of batches) {
          await batch2.commit(options);
        }
      }
    };
  }
  /**
   * @param {Query} q
   * @param {Options} [options]
   */
  query(q, options) {
    return this.stores[this.stores.length - 1].query(q, options);
  }
  /**
   * @param {KeyQuery} q
   * @param {Options} [options]
   */
  queryKeys(q, options) {
    return this.stores[this.stores.length - 1].queryKeys(q, options);
  }
};
function dlv_es_default(t, e, l, n, r) {
  for (e = e.split ? e.split(".") : e, n = 0; n < e.length; n++)
    t = t ? t[e[n]] : r;
  return t === r ? l : t;
}
var ipnsSelector = (key, data) => {
  const entries = data.map((buf2, index2) => ({
    entry: IpnsEntry.decode(buf2),
    index: index2
  }));
  entries.sort((a, b) => {
    if (a.entry.signatureV2 != null && b.entry.signatureV2 == null) {
      return -1;
    } else if (a.entry.signatureV2 == null && b.entry.signatureV2 != null) {
      return 1;
    }
    const aSeq = a.entry.sequence ?? 0n;
    const bSeq = b.entry.sequence ?? 0n;
    if (aSeq > bSeq) {
      return -1;
    } else if (aSeq < bSeq) {
      return 1;
    }
    const aValidty = a.entry.validity ?? new Uint8Array(0);
    const bValidty = b.entry.validity ?? new Uint8Array(0);
    const entryAValidityDate = parseRFC3339(toString3(aValidty));
    const entryBValidityDate = parseRFC3339(toString3(bValidty));
    if (entryAValidityDate.getTime() > entryBValidityDate.getTime()) {
      return -1;
    }
    if (entryAValidityDate.getTime() < entryBValidityDate.getTime()) {
      return 1;
    }
    return 0;
  });
  return entries[0].index;
};
var SHARDING_FN = "SHARDING";
var README_FN = "_README";
var MemoryDatastore = class extends BaseDatastore {
  constructor() {
    super();
    this.data = {};
  }
  open() {
    return Promise.resolve();
  }
  close() {
    return Promise.resolve();
  }
  /**
   * @param {Key} key
   * @param {Uint8Array} val
   */
  async put(key, val) {
    this.data[key.toString()] = val;
  }
  /**
   * @param {Key} key
   */
  async get(key) {
    const exists2 = await this.has(key);
    if (!exists2)
      throw notFoundError();
    return this.data[key.toString()];
  }
  /**
   * @param {Key} key
   */
  async has(key) {
    return this.data[key.toString()] !== void 0;
  }
  /**
   * @param {Key} key
   */
  async delete(key) {
    delete this.data[key.toString()];
  }
  async *_all() {
    yield* Object.entries(this.data).map(([key, value2]) => ({ key: new Key(key), value: value2 }));
  }
  async *_allKeys() {
    yield* Object.entries(this.data).map(([key]) => new Key(key));
  }
};
async function* map(source, func) {
  for await (const val of source) {
    yield func(val);
  }
}
async function* merge$1(...sources) {
  const output = pushable({
    objectMode: true
  });
  void Promise.resolve().then(async () => {
    try {
      await Promise.all(sources.map(async (source) => {
        for await (const item of source) {
          output.push(item);
        }
      }));
      output.end();
    } catch (err2) {
      output.end(err2);
    }
  });
  yield* output;
}
var rawPipe = (...fns) => {
  let res;
  while (fns.length > 0) {
    res = fns.shift()(res);
  }
  return res;
};
var isIterable2 = (obj) => {
  return obj != null && (typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function" || typeof obj.next === "function");
};
var isDuplex = (obj) => {
  return obj != null && typeof obj.sink === "function" && isIterable2(obj.source);
};
var duplexPipelineFn = (duplex) => {
  return (source) => {
    const p = duplex.sink(source);
    if (p.then != null) {
      const stream = pushable({
        objectMode: true
      });
      p.then(() => {
        stream.end();
      }, (err2) => {
        stream.end(err2);
      });
      const sourceWrap = async function* () {
        yield* duplex.source;
        stream.end();
      };
      return merge$1(stream, sourceWrap());
    }
    return duplex.source;
  };
};
function pipe(first2, ...rest) {
  if (isDuplex(first2)) {
    const duplex = first2;
    first2 = () => duplex.source;
  } else if (isIterable2(first2)) {
    const source = first2;
    first2 = () => source;
  }
  const fns = [first2, ...rest];
  if (fns.length > 1) {
    if (isDuplex(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i2 = 1; i2 < fns.length - 1; i2++) {
      if (isDuplex(fns[i2])) {
        fns[i2] = duplexPipelineFn(fns[i2]);
      }
    }
  }
  return rawPipe(...fns);
}
new Key(SHARDING_FN);
new Key(README_FN);
var namespace2 = "/record/";
function encodeBase32(buf2) {
  return toString3(buf2, "base32");
}
function keyToTopic(key) {
  if (typeof key === "string" || key instanceof String) {
    key = fromString3(key.toString());
  }
  const b64url = toString3(key, "base64url");
  return `${namespace2}${b64url}`;
}
function topicToKey(topic) {
  if (topic.substring(0, namespace2.length) !== namespace2) {
    throw new CodeError("topic received is not from a record", "ERR_TOPIC_IS_NOT_FROM_RECORD_NAMESPACE");
  }
  const key = topic.substring(namespace2.length);
  return fromString3(key, "base64url");
}
var log9 = logger("datastore-pubsub:publisher");
var PubSubDatastore = class extends BaseDatastore {
  /**
   * Creates an instance of DatastorePubsub.
   *
   * @param {import('@libp2p/interface-pubsub').PubSub} pubsub - pubsub implementation
   * @param {import('interface-datastore').Datastore} datastore - datastore instance
   * @param {PeerId} peerId - peer-id instance
   * @param {import('@libp2p/interface-dht').ValidateFn} validator - validator function
   * @param {import('@libp2p/interface-dht').SelectFn} selector - selector function
   * @param {SubscriptionKeyFn} [subscriptionKeyFn] - function to manipulate the key topic received before processing it
   * @memberof DatastorePubsub
   */
  constructor(pubsub, datastore, peerId, validator, selector, subscriptionKeyFn) {
    super();
    if (!validator) {
      throw new CodeError("missing validator", "ERR_INVALID_PARAMETERS");
    }
    if (typeof validator !== "function") {
      throw new CodeError("missing validate function", "ERR_INVALID_PARAMETERS");
    }
    if (typeof selector !== "function") {
      throw new CodeError("missing select function", "ERR_INVALID_PARAMETERS");
    }
    if (subscriptionKeyFn && typeof subscriptionKeyFn !== "function") {
      throw new CodeError("invalid subscriptionKeyFn received", "ERR_INVALID_PARAMETERS");
    }
    this._pubsub = pubsub;
    this._datastore = datastore;
    this._peerId = peerId;
    this._validator = validator;
    this._selector = selector;
    this._handleSubscriptionKeyFn = subscriptionKeyFn;
    this._onMessage = this._onMessage.bind(this);
    this._pubsub.addEventListener("message", this._onMessage);
  }
  /**
   * Publishes a value through pubsub.
   *
   * @param {Uint8Array} key - identifier of the value to be published.
   * @param {Uint8Array} val - value to be propagated.
   * @param {AbortOptions} [options]
   */
  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays
  async put(key, val, options) {
    if (!(key instanceof Uint8Array)) {
      const errMsg = "datastore key does not have a valid format";
      log9.error(errMsg);
      throw new CodeError(errMsg, "ERR_INVALID_DATASTORE_KEY");
    }
    if (!(val instanceof Uint8Array)) {
      const errMsg = "received value is not a Uint8Array";
      log9.error(errMsg);
      throw new CodeError(errMsg, "ERR_INVALID_VALUE_RECEIVED");
    }
    const stringifiedTopic = keyToTopic(key);
    log9(`publish value for topic ${stringifiedTopic}`);
    await this._pubsub.publish(stringifiedTopic, val);
  }
  /**
   * Try to subscribe a topic with Pubsub and returns the local value if available.
   *
   * @param {Uint8Array} key - identifier of the value to be subscribed.
   * @param {AbortOptions} [options]
   */
  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays
  async get(key, options) {
    if (!(key instanceof Uint8Array)) {
      const errMsg = "datastore key does not have a valid format";
      log9.error(errMsg);
      throw new CodeError(errMsg, "ERR_INVALID_DATASTORE_KEY");
    }
    const stringifiedTopic = keyToTopic(key);
    const subscriptions = await this._pubsub.getTopics();
    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {
      return this._getLocal(key, options);
    }
    try {
      await this._pubsub.subscribe(stringifiedTopic);
    } catch (err2) {
      const errMsg = `cannot subscribe topic ${stringifiedTopic}`;
      log9.error(errMsg);
      throw new CodeError(errMsg, "ERR_SUBSCRIBING_TOPIC");
    }
    log9(`subscribed values for key ${stringifiedTopic}`);
    return this._getLocal(key);
  }
  /**
   * Unsubscribe topic.
   *
   * @param {Uint8Array} key - identifier of the value to unsubscribe.
   * @returns {void}
   */
  unsubscribe(key) {
    const stringifiedTopic = keyToTopic(key);
    return this._pubsub.unsubscribe(stringifiedTopic);
  }
  /**
   * Get record from local datastore
   *
   * @private
   * @param {Uint8Array} key
   * @param {AbortOptions} [options]
   */
  async _getLocal(key, options) {
    const routingKey = new Key("/" + encodeBase32(key), false);
    let dsVal;
    try {
      dsVal = await this._datastore.get(routingKey, options);
    } catch (err2) {
      if (err2.code !== "ERR_NOT_FOUND") {
        const errMsg2 = `unexpected error getting the ipns record for ${routingKey.toString()}`;
        log9.error(errMsg2);
        throw new CodeError(errMsg2, "ERR_UNEXPECTED_ERROR_GETTING_RECORD");
      }
      const errMsg = `local record requested was not found for ${routingKey.toString()}`;
      log9.error(errMsg);
      throw new CodeError(errMsg, "ERR_NOT_FOUND");
    }
    if (!(dsVal instanceof Uint8Array)) {
      const errMsg = "found record that we couldn't convert to a value";
      log9.error(errMsg);
      throw new CodeError(errMsg, "ERR_INVALID_RECORD_RECEIVED");
    }
    return dsVal;
  }
  /**
   * handles pubsub subscription messages
   *
   * @param {CustomEvent<PubSubMessage>} evt
   */
  async _onMessage(evt) {
    const msg = evt.detail;
    if (msg.type !== "signed") {
      log9.error("unsigned message received, this module can only work with signed messages");
      return;
    }
    const { data, from: from3, topic } = msg;
    let key;
    try {
      key = topicToKey(topic);
    } catch (err2) {
      log9.error(err2);
      return;
    }
    log9(`message received for topic ${topic}`);
    if (this._peerId.equals(from3)) {
      log9("message discarded as it is from the same peer");
      return;
    }
    if (this._handleSubscriptionKeyFn) {
      let res;
      try {
        res = await this._handleSubscriptionKeyFn(key);
      } catch (err2) {
        log9.error("message discarded by the subscriptionKeyFn");
        return;
      }
      key = res;
    }
    try {
      await this._storeIfSubscriptionIsBetter(key, data);
    } catch (err2) {
      log9.error(err2);
    }
  }
  /**
   * Store the received record if it is better than the current stored
   *
   * @param {Uint8Array} key
   * @param {Uint8Array} data
   * @param {AbortOptions} [options]
   */
  async _storeIfSubscriptionIsBetter(key, data, options) {
    let isBetter = false;
    try {
      isBetter = await this._isBetter(key, data);
    } catch (err2) {
      if (err2.code !== "ERR_NOT_VALID_RECORD") {
        throw err2;
      }
    }
    if (isBetter) {
      await this._storeRecord(key, data, options);
    }
  }
  /**
   * Validate record according to the received validation function
   *
   * @param {Uint8Array} key
   * @param {Uint8Array} value
   */
  async _validateRecord(key, value2) {
    return this._validator(key, value2);
  }
  /**
   * Select the best record according to the received select function
   *
   * @param {Uint8Array} key
   * @param {Uint8Array[]} records
   */
  async _selectRecord(key, records) {
    const res = await this._selector(key, records);
    return res === 0;
  }
  /**
   * Verify if the record received through pubsub is valid and better than the one currently stored
   *
   * @param {Uint8Array} key
   * @param {Uint8Array} val
   */
  async _isBetter(key, val) {
    try {
      await this._validateRecord(key, val);
    } catch (err2) {
      const errMsg = "record received through pubsub is not valid";
      log9.error(errMsg);
      throw new CodeError(errMsg, "ERR_NOT_VALID_RECORD");
    }
    const dsKey = new Key(key);
    let currentRecord;
    try {
      currentRecord = await this._getLocal(dsKey.uint8Array());
    } catch (err2) {
      return true;
    }
    if (equals(currentRecord, val)) {
      return false;
    }
    return this._selectRecord(key, [currentRecord, val]);
  }
  /**
   * add record to datastore
   *
   * @param {Uint8Array} key
   * @param {Uint8Array} data
   * @param {AbortOptions} [options]
   */
  async _storeRecord(key, data, options) {
    const routingKey = new Key("/" + encodeBase32(key), false);
    await this._datastore.put(routingKey, data, options);
    log9(`record for ${keyToTopic(key)} was stored in the datastore`);
  }
};
var import_err_code25 = __toESM(require_err_code(), 1);
var log10 = logger("ipfs:ipns:pubsub");
var IpnsPubsubDatastore = class {
  /**
   * @param {import('@libp2p/interface-pubsub').PubSub} pubsub
   * @param {import('interface-datastore').Datastore} localDatastore
   * @param {import('@libp2p/interface-peer-id').PeerId} peerId
   */
  constructor(pubsub, localDatastore, peerId) {
    this._subscriptions = {};
    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this);
    this._pubsubDs = new PubSubDatastore(pubsub, localDatastore, peerId, ipnsValidator, ipnsSelector, this._handleSubscriptionKey);
  }
  /**
   * Put a value to the pubsub datastore indexed by the received key properly encoded.
   *
   * @param {Uint8Array} key - identifier of the value.
   * @param {Uint8Array} value - value to be stored.
   * @param {AbortOptions} [options]
   */
  async put(key, value2, options) {
    try {
      await this._pubsubDs.put(key, value2, options);
    } catch (err2) {
      log10.error(err2);
      throw err2;
    }
  }
  /**
   * Get a value from the pubsub datastore indexed by the received key properly encoded.
   * Also, the identifier topic is subscribed to and the pubsub datastore records will be
   * updated once new publishes occur.
   *
   * @param {Uint8Array} key - identifier of the value to be obtained.
   * @param {AbortOptions} [options]
   */
  async get(key, options) {
    let res;
    let err2;
    try {
      res = await this._pubsubDs.get(key, options);
    } catch (e) {
      err2 = e;
    }
    const ns = key.slice(0, namespaceLength);
    if (toString3(ns) === namespace) {
      const stringifiedTopic = base58btc.encode(key).substring(1);
      const id = base58btc.encode(key.slice(namespaceLength)).substring(1);
      this._subscriptions[stringifiedTopic] = id;
      log10(`subscribed to pubsub topic ${stringifiedTopic}, id ${id}`);
    }
    if (err2) {
      throw err2;
    }
    return res;
  }
  /**
   * Modify subscription key to have a proper encoding
   *
   * @param {Uint8Array | string} key
   */
  _handleSubscriptionKey(key) {
    if (key instanceof Uint8Array) {
      key = toString3(key, "base58btc");
    }
    const subscriber = this._subscriptions[key];
    if (!subscriber) {
      throw (0, import_err_code25.default)(new Error(`key ${key} does not correspond to a subscription`), "ERR_INVALID_KEY");
    }
    try {
      const k = peerIdToRoutingKey(peerIdFromString(subscriber));
      return k;
    } catch (err2) {
      log10.error(err2);
      throw err2;
    }
  }
  /**
   * Get pubsub subscriptions related to ipns.
   */
  getSubscriptions() {
    const subscriptions = Object.values(this._subscriptions).filter(Boolean);
    return subscriptions.map((sub) => `${namespace}${sub}`);
  }
  /**
   * Cancel pubsub subscriptions related to ipns.
   *
   * @param {string} name - ipns path to cancel the pubsub subscription.
   */
  async cancel(name9) {
    if (typeof name9 !== "string") {
      throw (0, import_err_code25.default)(new Error("invalid subscription name"), "ERR_INVALID_SUBSCRIPTION_NAME");
    }
    if (name9.startsWith(namespace)) {
      name9 = name9.substring(namespaceLength);
    }
    const stringifiedTopic = Object.keys(this._subscriptions).find((key) => this._subscriptions[key] === name9);
    if (!stringifiedTopic) {
      return {
        canceled: false
      };
    }
    const bufTopic = fromString3(stringifiedTopic);
    this._pubsubDs.unsubscribe(bufTopic);
    delete this._subscriptions[stringifiedTopic];
    log10(`unsubscribed pubsub ${stringifiedTopic}: ${name9}`);
    return {
      canceled: true
    };
  }
};
var Record;
(function(Record3) {
  let _codec;
  Record3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.key != null && obj.key.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.key);
        }
        if (opts.writeDefaults === true || obj.value != null && obj.value.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.value);
        }
        if (opts.writeDefaults === true || obj.timeReceived !== "") {
          w.uint32(42);
          w.string(obj.timeReceived);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {
          key: new Uint8Array(0),
          value: new Uint8Array(0),
          timeReceived: ""
        };
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.key = reader3.bytes();
              break;
            case 2:
              obj.value = reader3.bytes();
              break;
            case 5:
              obj.timeReceived = reader3.string();
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Record3.encode = (obj) => {
    return encodeMessage(obj, Record3.codec());
  };
  Record3.decode = (buf2) => {
    return decodeMessage(buf2, Record3.codec());
  };
})(Record || (Record = {}));
function toRFC3339(time) {
  const year = time.getUTCFullYear();
  const month = String(time.getUTCMonth() + 1).padStart(2, "0");
  const day = String(time.getUTCDate()).padStart(2, "0");
  const hour3 = String(time.getUTCHours()).padStart(2, "0");
  const minute5 = String(time.getUTCMinutes()).padStart(2, "0");
  const seconds = String(time.getUTCSeconds()).padStart(2, "0");
  const milliseconds = time.getUTCMilliseconds();
  const nanoseconds = String(milliseconds * 1e3 * 1e3).padStart(9, "0");
  return `${year}-${month}-${day}T${hour3}:${minute5}:${seconds}.${nanoseconds}Z`;
}
function parseRFC33392(time) {
  const rfc3339Matcher = new RegExp(
    // 2006-01-02T
    "(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"
  );
  const m = String(time).trim().match(rfc3339Matcher);
  if (m == null) {
    throw new Error("Invalid format");
  }
  const year = parseInt(m[1], 10);
  const month = parseInt(m[2], 10) - 1;
  const date = parseInt(m[3], 10);
  const hour3 = parseInt(m[4], 10);
  const minute5 = parseInt(m[5], 10);
  const second3 = parseInt(m[6], 10);
  const millisecond = parseInt(m[7].slice(0, -6), 10);
  return new Date(Date.UTC(year, month, date, hour3, minute5, second3, millisecond));
}
var Libp2pRecord = class {
  constructor(key, value2, timeReceived) {
    if (!(key instanceof Uint8Array)) {
      throw new Error("key must be a Uint8Array");
    }
    if (!(value2 instanceof Uint8Array)) {
      throw new Error("value must be a Uint8Array");
    }
    this.key = key;
    this.value = value2;
    this.timeReceived = timeReceived;
  }
  serialize() {
    return Record.encode(this.prepareSerialize());
  }
  /**
   * Return the object format ready to be given to the protobuf library.
   */
  prepareSerialize() {
    return {
      key: this.key,
      value: this.value,
      timeReceived: toRFC3339(this.timeReceived)
    };
  }
  /**
   * Decode a protobuf encoded record
   */
  static deserialize(raw) {
    const rec = Record.decode(raw);
    return new Libp2pRecord(rec.key, rec.value, new Date(rec.timeReceived));
  }
  /**
   * Create a record from the raw object returned from the protobuf library
   */
  static fromDeserialized(obj) {
    const recvtime = parseRFC33392(obj.timeReceived);
    if (obj.key == null) {
      throw new Error("key missing from deserialized object");
    }
    if (obj.value == null) {
      throw new Error("value missing from deserialized object");
    }
    const rec = new Libp2pRecord(obj.key, obj.value, recvtime);
    return rec;
  }
};
var import_err_code26 = __toESM(require_err_code(), 1);
var log11 = logger("ipfs:ipns:offline-datastore");
var OfflineDatastore = class {
  /**
   * @param {import('interface-datastore').Datastore} datastore
   */
  constructor(datastore) {
    this._datastore = datastore;
    this.stores = [];
  }
  /**
   * Put a value to the local datastore indexed by the received key properly encoded.
   *
   * @param {Uint8Array} key - identifier of the value.
   * @param {Uint8Array} value - value to be stored.
   * @param {AbortOptions} [options]
   */
  async put(key, value2, options) {
    if (!(key instanceof Uint8Array)) {
      throw (0, import_err_code26.default)(new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY");
    }
    if (!(value2 instanceof Uint8Array)) {
      throw (0, import_err_code26.default)(new Error("Offline datastore value must be a Uint8Array"), "ERR_INVALID_VALUE");
    }
    let routingKey;
    try {
      routingKey = this._routingKey(key);
    } catch (err2) {
      log11.error(err2);
      throw (0, import_err_code26.default)(new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY");
    }
    const record = new Libp2pRecord(key, value2, new Date());
    await this._datastore.put(routingKey, record.serialize(), options);
  }
  /**
   * Get a value from the local datastore indexed by the received key properly encoded.
   *
   * @param {Uint8Array} key - identifier of the value to be obtained.
   * @param {AbortOptions} [options]
   */
  async get(key, options) {
    if (!(key instanceof Uint8Array)) {
      throw (0, import_err_code26.default)(new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY");
    }
    let routingKey;
    try {
      routingKey = this._routingKey(key);
    } catch (err2) {
      log11.error(err2);
      throw (0, import_err_code26.default)(new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY");
    }
    const res = await this._datastore.get(routingKey, options);
    let record;
    try {
      record = Libp2pRecord.deserialize(res);
    } catch (err2) {
      log11.error(err2);
      throw err2;
    }
    return record.value;
  }
  /**
   * encode key properly - base32(/ipns/{cid})
   *
   * @param {Uint8Array} key
   */
  _routingKey(key) {
    return new Key("/dht/record/" + toString3(key, "base32"), false);
  }
};
var log12 = logger("ipfs:ipns:dht-datastore");
var DHTDatastore = class {
  /**
   *
   * @param {import('@libp2p/interface-dht').DHT} dht
   */
  constructor(dht) {
    this._dht = dht;
  }
  /**
   * @param {Uint8Array} key - identifier of the value.
   * @param {Uint8Array} value - value to be stored.
   * @param {AbortOptions} [options]
   */
  async put(key, value2, options) {
    try {
      await drain(this._dht.put(key, value2, options));
    } catch (err2) {
      log12.error(err2);
      throw err2;
    }
  }
  /**
   * @param {Uint8Array} key - identifier of the value to be obtained.
   * @param {AbortOptions} [options]
   */
  async get(key, options) {
    for await (const event of this._dht.get(key, options)) {
      if (event.name === "VALUE") {
        return event.value;
      }
    }
    throw notFoundError();
  }
};
function createRouting({ libp2p, repo, peerId, options }) {
  const ipnsStores = [];
  let pubsubDs;
  if (dlv_es_default(options, "EXPERIMENTAL.ipnsPubsub", false)) {
    pubsubDs = new IpnsPubsubDatastore(libp2p.pubsub, repo.datastore, peerId);
    ipnsStores.push(pubsubDs);
  }
  if (dlv_es_default(options, "offline", false) !== true && ["dht", "dhtclient", "dhtserver"].includes(dlv_es_default(options, "config.Routing.Type", "none"))) {
    ipnsStores.push(new DHTDatastore(libp2p.dht));
  }
  if (dlv_es_default(options, "offline", false) || ipnsStores.length === 0) {
    const offlineDatastore = new OfflineDatastore(repo.datastore);
    ipnsStores.push(offlineDatastore);
  }
  return new TieredDatastore(ipnsStores);
}
var log13 = logger("ipfs:components:ipns");
var IPNSAPI = class {
  /**
   * @param {object} options
   * @param {string} options.pass
   * @param {boolean} [options.offline]
   * @param {LibP2POptions} [options.libp2p]
   * @param {ExperimentalOptions} [options.EXPERIMENTAL]
   */
  constructor(options = { pass: "" }) {
    this.options = options;
    this.offline = null;
    this.online = null;
  }
  getIPNS() {
    const ipns = this.online || this.offline;
    if (ipns) {
      return ipns;
    } else {
      throw new NotInitializedError();
    }
  }
  get routing() {
    return this.getIPNS().routing;
  }
  /**
   * Activates IPNS subsystem in an ofline mode. If it was started once already
   * it will throw an exception.
   *
   * This is primarily used for offline ipns modifications, such as the
   * initializeKeyspace feature.
   *
   * @param {object} config
   * @param {import('ipfs-repo').IPFSRepo} config.repo
   * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId
   * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain
   */
  startOffline({ repo, peerId, keychain }) {
    if (this.offline != null) {
      throw new AlreadyInitializedError();
    }
    log13("initializing IPNS keyspace (offline)");
    const routing = new OfflineDatastore(repo.datastore);
    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);
    this.offline = ipns;
  }
  /**
   * @param {object} config
   * @param {import('libp2p').Libp2p} config.libp2p
   * @param {import('ipfs-repo').IPFSRepo} config.repo
   * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId
   * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain
   */
  async startOnline({ libp2p, repo, peerId, keychain }) {
    if (this.online != null) {
      throw new AlreadyInitializedError();
    }
    const routing = createRouting({ libp2p, repo, peerId, options: this.options });
    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);
    await ipns.republisher.start();
    this.online = ipns;
  }
  async stop() {
    const ipns = this.online;
    if (ipns) {
      await ipns.republisher.stop();
      this.online = null;
    }
  }
  /**
   * @param {PeerId} peerId
   * @param {Uint8Array} value
   * @param {number} lifetime
   * @param {AbortOptions} [options]
   */
  publish(peerId, value2, lifetime, options) {
    return this.getIPNS().publish(peerId, value2, lifetime, options);
  }
  /**
   *
   * @param {string} name
   * @param {object} [options]
   * @param {boolean} [options.nocache]
   * @param {boolean} [options.recursive]
   * @param {AbortSignal} [options.signal]
   */
  resolve(name9, options) {
    return this.getIPNS().resolve(name9, options);
  }
  /**
   * @param {PeerId} peerId
   * @param {Uint8Array} value
   * @param {AbortOptions} [options]
   */
  initializeKeyspace(peerId, value2, options) {
    return this.getIPNS().initializeKeyspace(peerId, value2, options);
  }
};
var import_err_code27 = __toESM(require_err_code(), 1);
async function resolvePath2({ ipns, repo, codecs: codecs2 }, name9, options) {
  if (ipnsPath(name9)) {
    return ipns.resolve(name9);
  }
  const {
    cid,
    path: path2
  } = toCidAndPath(name9);
  await drain(resolve(cid, path2 || "", codecs2, repo, options));
}
var log14 = logger("ipfs:name:publish");
function createPublish({ ipns, repo, codecs: codecs2, peerId, isOnline, keychain }) {
  const lookupKey = async (keyName) => {
    let privateKey;
    if (keyName === "self" && peerId.privateKey != null) {
      privateKey = await unmarshalPrivateKey3(peerId.privateKey);
    } else {
      try {
        const pem = await keychain.exportKey(keyName, "temp");
        privateKey = await importKey(pem, "temp");
      } catch (err2) {
        log14.error(err2);
        throw (0, import_err_code27.default)(err2, "ERR_CANNOT_GET_KEY");
      }
    }
    return peerIdFromKeys(privateKey.public.bytes, privateKey.bytes);
  };
  async function publish(value2, options = {}) {
    const resolve7 = !(options.resolve === false);
    const lifetime = options.lifetime || "24h";
    const key = options.key || "self";
    if (!isOnline()) {
      throw (0, import_err_code27.default)(new Error(OFFLINE_ERROR), "OFFLINE_ERROR");
    }
    try {
      value2 = normalizePath(value2);
    } catch (err2) {
      log14.error(err2);
      throw err2;
    }
    let pubLifetime = 0;
    try {
      pubLifetime = parse_duration_default(lifetime) || 0;
      pubLifetime = parseFloat(pubLifetime.toFixed(6));
    } catch (err2) {
      log14.error(err2);
      throw err2;
    }
    const results = await Promise.all([
      // verify if the path exists, if not, an error will stop the execution
      lookupKey(key),
      // if resolving, do a get so we make sure we have the blocks
      resolve7 ? resolvePath2({ ipns, repo, codecs: codecs2 }, value2) : Promise.resolve()
    ]);
    const bytes2 = fromString3(value2);
    const result = await ipns.publish(results[0], bytes2, pubLifetime, options);
    return {
      name: result.name,
      value: toString3(result.value)
    };
  }
  return withTimeoutOption(publish);
}
var import_err_code28 = __toESM(require_err_code(), 1);
var import_is_domain_name = __toESM(require_is_domain_name(), 1);
var mergeOptions2 = merge_options_default.bind({ ignoreUndefined: true });
var log15 = logger("ipfs:name:resolve");
var appendRemainder = (result, remainder) => remainder.length > 0 ? result + "/" + remainder.join("/") : result;
function createResolve2({ dns, ipns, isOnline, options: { offline } }) {
  async function* resolve7(name9, options = {}) {
    options = mergeOptions2({
      nocache: false,
      recursive: true
    }, options);
    if (offline && options && options.nocache) {
      throw (0, import_err_code28.default)(new Error("cannot specify both offline and nocache"), "ERR_NOCACHE_AND_OFFLINE");
    }
    if (!isOnline() && !offline) {
      throw (0, import_err_code28.default)(new Error(OFFLINE_ERROR), "OFFLINE_ERROR");
    }
    let ipnsName = name9.toString();
    if (!ipnsName.startsWith("/ipns/")) {
      ipnsName = `/ipns/${ipnsName}`;
    }
    let [namespace3, hash3, ...remainder] = ipnsName.slice(1).split("/");
    try {
      if (hash3.substring(0, 1) === "1") {
        const id = peerIdFromString(hash3);
        const digest2 = decode3$3(id.toBytes());
        const libp2pKey = CID.createV1(114, digest2);
        hash3 = libp2pKey.toString(base36);
      } else {
        const cid = CID.parse(hash3);
        if (cid.version === 1) {
          hash3 = cid.toString(base36);
        }
      }
    } catch (err2) {
      if ((0, import_is_domain_name.default)(hash3)) {
        yield appendRemainder(await dns(hash3, options), remainder);
        return;
      }
      log15.error(err2);
      throw (0, import_err_code28.default)(new Error("Invalid IPNS name"), "ERR_IPNS_INVALID_NAME");
    }
    const value2 = await ipns.resolve(`/${namespace3}/${hash3}`, options);
    yield appendRemainder(value2 instanceof Uint8Array ? toString3(value2) : value2, remainder);
  }
  return withTimeoutOption(resolve7);
}
var import_err_code29 = __toESM(require_err_code(), 1);
function getPubsubRouting(ipns, options) {
  if (!ipns || !(options && options.ipnsPubsub)) {
    throw (0, import_err_code29.default)(new Error("IPNS pubsub subsystem is not enabled"), "ERR_IPNS_PUBSUB_NOT_ENABLED");
  }
  if (ipns.routing instanceof IpnsPubsubDatastore) {
    return ipns.routing;
  }
  const pubsub = (ipns.routing.stores || []).find((s) => s instanceof IpnsPubsubDatastore);
  if (!pubsub) {
    throw (0, import_err_code29.default)(new Error("IPNS pubsub datastore not found"), "ERR_PUBSUB_DATASTORE_NOT_FOUND");
  }
  return pubsub;
}
function createCancel({ ipns, options }) {
  const experimental = options.EXPERIMENTAL;
  async function cancel(name9, options2 = {}) {
    const pubsub = getPubsubRouting(ipns, experimental);
    return pubsub.cancel(name9, options2);
  }
  return withTimeoutOption(cancel);
}
function createState({ ipns, options }) {
  const experimental = options.EXPERIMENTAL;
  async function state(_options = {}) {
    try {
      return { enabled: Boolean(getPubsubRouting(ipns, experimental)) };
    } catch (err2) {
      return { enabled: false };
    }
  }
  return withTimeoutOption(state);
}
function createSubs({ ipns, options }) {
  const experimental = options.EXPERIMENTAL;
  async function subs(options2 = {}) {
    const pubsub = getPubsubRouting(ipns, experimental);
    return pubsub.getSubscriptions(options2);
  }
  return withTimeoutOption(subs);
}
var PubSubAPI = class {
  /**
   * @param {object} config
   * @param {import('../../ipns').IPNSAPI} config.ipns
   * @param {import('../../../types').Options} config.options
   */
  constructor({ ipns, options }) {
    this.cancel = createCancel({ ipns, options });
    this.state = createState({ ipns, options });
    this.subs = createSubs({ ipns, options });
  }
};
var NameAPI = class {
  /**
   * @param {object} config
   * @param {import('../ipns').IPNSAPI} config.ipns
   * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId
   * @param {import('../../types').Options} config.options
   * @param {import('ipfs-repo').IPFSRepo} config.repo
   * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs
   * @param {import('ipfs-core-types/src/root').API<{}>["isOnline"]} config.isOnline
   * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain
   * @param {import('ipfs-core-types/src/root').API<{}>["dns"]} config.dns
   */
  constructor({ dns, ipns, repo, codecs: codecs2, peerId, isOnline, keychain, options }) {
    this.publish = createPublish({ ipns, repo, codecs: codecs2, peerId, isOnline, keychain });
    this.resolve = createResolve2({ dns, ipns, isOnline, options });
    this.pubsub = new PubSubAPI({ ipns, options });
  }
};
var import_timeout_abort_controller3 = __toESM(require_timeout_abort_controller(), 1);
var import_any_signal2 = __toESM(require_any_signal(), 1);
var ERR_NOT_FOUND3 = notFoundError().code;
var Format = {
  default: "<dst>",
  edges: "<src> -> <dst>"
};
function createRefs({ repo, codecs: codecs2, resolve: resolve7, preload: preload2 }) {
  async function* refs(ipfsPath3, options = {}) {
    if (options.maxDepth === 0) {
      return;
    }
    if (options.edges && options.format && options.format !== Format.default) {
      throw new Error("Cannot set edges to true and also specify format");
    }
    options.format = options.edges ? Format.edges : options.format;
    if (typeof options.maxDepth !== "number") {
      options.maxDepth = options.recursive ? Infinity : 1;
    }
    if (options.timeout) {
      const controller = new import_timeout_abort_controller3.TimeoutController(options.timeout);
      const signals = [controller.signal];
      if (options.signal) {
        signals.push(options.signal);
      }
      options.signal = (0, import_any_signal2.anySignal)(signals);
    }
    const rawPaths = Array.isArray(ipfsPath3) ? ipfsPath3 : [ipfsPath3];
    const paths = rawPaths.map((p) => getFullPath(preload2, p, options));
    for (const path2 of paths) {
      try {
        yield* refsStream(resolve7, repo, codecs2, path2, options);
      } catch (err2) {
        yield {
          ref: "",
          err: err2.message
        };
      }
    }
  }
  return refs;
}
function getFullPath(preload2, ipfsPath3, options) {
  const {
    cid,
    path: path2
  } = toCidAndPath(ipfsPath3);
  if (options.preload !== false) {
    preload2(cid);
  }
  return `/ipfs/${cid}${path2 || ""}`;
}
async function* refsStream(resolve7, repo, codecs2, path2, options) {
  const resPath = await resolve7(path2, options);
  const {
    cid
  } = toCidAndPath(resPath);
  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity;
  const unique = options.unique || false;
  for await (const obj of objectStream(repo, codecs2, cid, maxDepth, unique, options)) {
    if (!obj.parent) {
      continue;
    }
    if (obj.isDuplicate) {
      continue;
    }
    yield {
      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)
    };
  }
}
function formatLink(srcCid, dstCid, linkName = "", format2 = Format.default) {
  let out = format2.replace(/<src>/g, srcCid.toString());
  out = out.replace(/<dst>/g, dstCid.toString());
  out = out.replace(/<linkname>/g, linkName);
  return out;
}
async function* objectStream(repo, codecs2, rootCid, maxDepth, uniqueOnly, options) {
  const seen = /* @__PURE__ */ new Set();
  async function* traverseLevel(parent2, depth) {
    const nextLevelDepth = depth + 1;
    if (nextLevelDepth > maxDepth) {
      return;
    }
    try {
      for await (const link of getLinks(repo, codecs2, parent2.cid, options)) {
        yield {
          parent: parent2,
          node: link,
          isDuplicate: uniqueOnly && seen.has(link.cid.toString())
        };
        if (uniqueOnly) {
          seen.add(link.cid.toString());
        }
        yield* traverseLevel(link, nextLevelDepth);
      }
    } catch (err2) {
      if (err2.code === ERR_NOT_FOUND3) {
        err2.message = `Could not find object with CID: ${parent2.cid}`;
      }
      throw err2;
    }
  }
  yield* traverseLevel({ cid: rootCid }, 0);
}
async function* getLinks(repo, codecs2, cid, options) {
  const block = await repo.blocks.get(cid, options);
  const codec = await codecs2.getCodec(cid.code);
  const value2 = codec.decode(block);
  const isDagPb = cid.code === code;
  const base3 = [];
  for (const [name9, cid2] of links(value2, base3)) {
    if (isDagPb) {
      const match = name9.match(/^Links\/(\d+)\/Hash$/);
      if (match) {
        const index2 = Number(match[1]);
        if (index2 < value2.Links.length) {
          yield {
            name: value2.Links[index2].Name,
            cid: cid2
          };
          continue;
        }
      }
    }
    yield {
      name: name9,
      cid: cid2
    };
  }
}
var links = function* (source, base3) {
  if (source == null) {
    return;
  }
  if (source instanceof Uint8Array) {
    return;
  }
  for (const [key, value2] of Object.entries(source)) {
    const path2 = [...base3, key];
    if (value2 != null && typeof value2 === "object") {
      if (Array.isArray(value2)) {
        for (const [index2, element] of value2.entries()) {
          const elementPath = [...path2, index2];
          const cid = CID.asCID(element);
          if (cid) {
            yield [elementPath.join("/"), cid];
          } else if (typeof element === "object") {
            yield* links(element, elementPath);
          }
        }
      } else {
        const cid = CID.asCID(value2);
        if (cid) {
          yield [path2.join("/"), cid];
        } else {
          yield* links(value2, path2);
        }
      }
    }
  }
  return [];
};
function createLocal({ repo }) {
  async function* refsLocal(options = {}) {
    for await (const cid of repo.blocks.queryKeys({}, { signal: options.signal })) {
      yield { ref: cid.toString() };
    }
  }
  return withTimeoutOption(refsLocal);
}
function createWantlist({ network }) {
  async function wantlist(options = {}) {
    const { bitswap } = await network.use(options);
    const list = bitswap.getWantlist();
    return Array.from(list).map((e) => e[1].cid);
  }
  return withTimeoutOption(wantlist);
}
function createWantlistForPeer({ network }) {
  async function wantlistForPeer(peerId, options = {}) {
    const { bitswap } = await network.use(options);
    const list = bitswap.wantlistForPeer(peerId);
    return Array.from(list).map((e) => e[1].cid);
  }
  return withTimeoutOption(wantlistForPeer);
}
function createUnwant({ network }) {
  async function unwant(cids, options = {}) {
    const { bitswap } = await network.use(options);
    if (!Array.isArray(cids)) {
      cids = [cids];
    }
    return bitswap.unwant(cids);
  }
  return withTimeoutOption(unwant);
}
function createStat({ network }) {
  async function stat(options = {}) {
    const bitswap = (await network.use(options)).bitswap;
    const snapshot = bitswap.stat().snapshot;
    return {
      provideBufLen: parseInt(snapshot.providesBufferLength.toString()),
      blocksReceived: BigInt(snapshot.blocksReceived.toString()),
      wantlist: Array.from(bitswap.getWantlist()).map((e) => e[1].cid),
      peers: bitswap.peers(),
      dupBlksReceived: BigInt(snapshot.dupBlksReceived.toString()),
      dupDataReceived: BigInt(snapshot.dupDataReceived.toString()),
      dataReceived: BigInt(snapshot.dataReceived.toString()),
      blocksSent: BigInt(snapshot.blocksSent.toString()),
      dataSent: BigInt(snapshot.dataSent.toString())
    };
  }
  return withTimeoutOption(stat);
}
var BitswapAPI = class {
  /**
   * @param {object} config
   * @param {NetworkService} config.network
   */
  constructor({ network }) {
    this.wantlist = createWantlist({ network });
    this.wantlistForPeer = createWantlistForPeer({ network });
    this.unwant = createUnwant({ network });
    this.stat = createStat({ network });
  }
};
function isValidMultiaddr(ma) {
  try {
    return IPFS.matches(ma);
  } catch (err2) {
    return false;
  }
}
function createAdd2({ repo }) {
  async function add(multiaddr2, options = {}) {
    if (!isValidMultiaddr(multiaddr2)) {
      throw new Error(`${multiaddr2} is not a valid Multiaddr`);
    }
    const config2 = await repo.config.getAll(options);
    const boostrappers = config2.Bootstrap || [];
    boostrappers.push(multiaddr2.toString());
    config2.Bootstrap = Array.from(
      new Set(boostrappers)
    ).sort((a, b) => a.localeCompare(b));
    await repo.config.replace(config2);
    return {
      Peers: [multiaddr2]
    };
  }
  return withTimeoutOption(add);
}
function createClear({ repo }) {
  async function clear(options = {}) {
    const config2 = await repo.config.getAll(options);
    const removed = config2.Bootstrap || [];
    config2.Bootstrap = [];
    await repo.config.replace(config2);
    return { Peers: removed.map((ma) => multiaddr(ma)) };
  }
  return withTimeoutOption(clear);
}
function createList({ repo }) {
  async function list(options = {}) {
    const peers = await repo.config.get("Bootstrap", options);
    return { Peers: (peers || []).map((ma) => multiaddr(ma)) };
  }
  return withTimeoutOption(list);
}
var config_browser_default = () => ({
  Addresses: {
    Swarm: [],
    Announce: [],
    NoAnnounce: [],
    API: "",
    Gateway: "",
    RPC: "",
    Delegates: [
      "/dns4/node0.delegate.ipfs.io/tcp/443/https",
      "/dns4/node1.delegate.ipfs.io/tcp/443/https",
      "/dns4/node2.delegate.ipfs.io/tcp/443/https",
      "/dns4/node3.delegate.ipfs.io/tcp/443/https"
    ]
  },
  Discovery: {
    MDNS: {
      Enabled: false,
      Interval: 10
    },
    webRTCStar: {
      Enabled: true
    }
  },
  Bootstrap: [
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt",
    "/dns4/node0.preload.ipfs.io/tcp/443/wss/p2p/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic",
    "/dns4/node1.preload.ipfs.io/tcp/443/wss/p2p/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6",
    "/dns4/node2.preload.ipfs.io/tcp/443/wss/p2p/QmV7gnbW5VTcJ3oyM2Xk1rdFBJ3kTkvxc87UFGsun29STS",
    "/dns4/node3.preload.ipfs.io/tcp/443/wss/p2p/QmY7JB6MQXhxHvq7dBDh4HpbH29v4yE9JRadAVpndvzySN"
  ],
  Pubsub: {
    Enabled: true
  },
  Swarm: {
    ConnMgr: {
      LowWater: 5,
      HighWater: 20
    },
    DisableNatPortMap: true
  },
  Routing: {
    Type: "dhtclient"
  }
});
function createReset({ repo }) {
  async function reset(options = {}) {
    const config2 = await repo.config.getAll(options);
    config2.Bootstrap = config_browser_default().Bootstrap;
    await repo.config.replace(config2);
    return {
      Peers: config_browser_default().Bootstrap.map((ma) => multiaddr(ma))
    };
  }
  return withTimeoutOption(reset);
}
function createRm2({ repo }) {
  async function rm(multiaddr2, options = {}) {
    if (!isValidMultiaddr(multiaddr2)) {
      throw new Error(`${multiaddr2} is not a valid Multiaddr`);
    }
    const config2 = await repo.config.getAll(options);
    config2.Bootstrap = (config2.Bootstrap || []).filter((ma) => ma.toString() !== multiaddr2.toString());
    await repo.config.replace(config2);
    return { Peers: [multiaddr2] };
  }
  return withTimeoutOption(rm);
}
var BootstrapAPI = class {
  /**
   * @param {object} config
   * @param {import('ipfs-repo').IPFSRepo} config.repo
   */
  constructor({ repo }) {
    this.add = createAdd2({ repo });
    this.list = createList({ repo });
    this.rm = createRm2({ repo });
    this.clear = createClear({ repo });
    this.reset = createReset({ repo });
  }
};
function createGet({ preload: preload2, repo }) {
  async function get3(cid, options = {}) {
    if (options.preload !== false) {
      preload2(cid);
    }
    return repo.blocks.get(cid, options);
  }
  return withTimeoutOption(get3);
}
function createPut({ codecs: codecs2, hashers, repo, preload: preload2 }) {
  async function put(block, options = {}) {
    const release = options.pin ? await repo.gcLock.readLock() : null;
    try {
      const cidVersion = options.version != null ? options.version : 0;
      const codecName = options.format || (cidVersion === 0 ? "dag-pb" : "raw");
      const hasher = await hashers.getHasher(options.mhtype || "sha2-256");
      const hash3 = await hasher.digest(block);
      const codec = await codecs2.getCodec(codecName);
      const cid = CID.create(cidVersion, codec.code, hash3);
      await repo.blocks.put(cid, block, {
        signal: options.signal
      });
      if (options.preload !== false) {
        preload2(cid);
      }
      if (options.pin === true) {
        await repo.pins.pinRecursively(cid, {
          signal: options.signal
        });
      }
      return cid;
    } finally {
      if (release) {
        release();
      }
    }
  }
  return withTimeoutOption(put);
}
var import_err_code30 = __toESM(require_err_code(), 1);
function pDefer() {
  const deferred = {};
  deferred.promise = new Promise((resolve7, reject) => {
    deferred.resolve = resolve7;
    deferred.reject = reject;
  });
  return deferred;
}
var CustomEvent = globalThis.CustomEvent ?? Event;
async function* parallel(source, options = {}) {
  let concurrency = options.concurrency ?? Infinity;
  if (concurrency < 1) {
    concurrency = Infinity;
  }
  const ordered = options.ordered == null ? false : options.ordered;
  const emitter = new EventTarget();
  const ops = [];
  let slotAvailable = pDefer();
  let resultAvailable = pDefer();
  let sourceFinished = false;
  let sourceErr;
  let opErred = false;
  emitter.addEventListener("task-complete", () => {
    resultAvailable.resolve();
  });
  void Promise.resolve().then(async () => {
    try {
      for await (const task of source) {
        if (ops.length === concurrency) {
          slotAvailable = pDefer();
          await slotAvailable.promise;
        }
        if (opErred) {
          break;
        }
        const op = {
          done: false
        };
        ops.push(op);
        task().then((result) => {
          op.done = true;
          op.ok = true;
          op.value = result;
          emitter.dispatchEvent(new CustomEvent("task-complete"));
        }, (err2) => {
          op.done = true;
          op.err = err2;
          emitter.dispatchEvent(new CustomEvent("task-complete"));
        });
      }
      sourceFinished = true;
      emitter.dispatchEvent(new CustomEvent("task-complete"));
    } catch (err2) {
      sourceErr = err2;
      emitter.dispatchEvent(new CustomEvent("task-complete"));
    }
  });
  function valuesAvailable() {
    if (ordered) {
      return ops[0]?.done;
    }
    return Boolean(ops.find((op) => op.done));
  }
  function* yieldOrderedValues() {
    while (ops.length > 0 && ops[0].done) {
      const op = ops[0];
      ops.shift();
      if (op.ok) {
        yield op.value;
      } else {
        opErred = true;
        slotAvailable.resolve();
        throw op.err;
      }
      slotAvailable.resolve();
    }
  }
  function* yieldUnOrderedValues() {
    while (valuesAvailable()) {
      for (let i2 = 0; i2 < ops.length; i2++) {
        if (ops[i2].done) {
          const op = ops[i2];
          ops.splice(i2, 1);
          i2--;
          if (op.ok) {
            yield op.value;
          } else {
            opErred = true;
            slotAvailable.resolve();
            throw op.err;
          }
          slotAvailable.resolve();
        }
      }
    }
  }
  while (true) {
    if (!valuesAvailable()) {
      resultAvailable = pDefer();
      await resultAvailable.promise;
    }
    if (sourceErr != null) {
      throw sourceErr;
    }
    if (ordered) {
      yield* yieldOrderedValues();
    } else {
      yield* yieldUnOrderedValues();
    }
    if (sourceFinished && ops.length === 0) {
      break;
    }
  }
}
function cleanCid(cid) {
  if (cid instanceof Uint8Array) {
    return CID.decode(cid);
  }
  return CID.parse(cid.toString());
}
var BLOCK_RM_CONCURRENCY = 8;
function createRm3({ repo }) {
  async function* rm(cids, options = {}) {
    if (!Array.isArray(cids)) {
      cids = [cids];
    }
    const release = await repo.gcLock.writeLock();
    try {
      yield* pipe(
        cids,
        (source) => map(source, (cid) => {
          return async () => {
            cid = cleanCid(cid);
            const result = { cid };
            try {
              const has = await repo.blocks.has(cid);
              if (!has) {
                throw (0, import_err_code30.default)(new Error("block not found"), "ERR_BLOCK_NOT_FOUND");
              }
              await repo.blocks.delete(cid);
            } catch (err2) {
              if (!options.force) {
                err2.message = `cannot remove ${cid}: ${err2.message}`;
                result.error = err2;
              }
            }
            return result;
          };
        }),
        (source) => parallel(source, { concurrency: BLOCK_RM_CONCURRENCY }),
        (source) => filter(source, () => !options.quiet)
      );
    } finally {
      release();
    }
  }
  return withTimeoutOption(rm);
}
function createStat2({ repo, preload: preload2 }) {
  async function stat(cid, options = {}) {
    cid = cleanCid(cid);
    if (options.preload !== false) {
      preload2(cid);
    }
    const block = await repo.blocks.get(cid);
    return { cid, size: block.length };
  }
  return withTimeoutOption(stat);
}
var BlockAPI = class {
  /**
   * @param {object} config
   * @param {import('ipfs-core-utils/src/multihashes').Multihashes} config.hashers
   * @param {import('ipfs-core-utils/src/multicodecs').Multicodecs} config.codecs
   * @param {Preload} config.preload
   * @param {import('ipfs-repo').IPFSRepo} config.repo
   */
  constructor({ codecs: codecs2, hashers, preload: preload2, repo }) {
    this.get = createGet({ preload: preload2, repo });
    this.put = createPut({ codecs: codecs2, hashers, preload: preload2, repo });
    this.rm = createRm3({ repo });
    this.stat = createStat2({ preload: preload2, repo });
  }
};
var import_err_code31 = __toESM(require_err_code(), 1);
async function* browserReadableStreamToIt(stream, options = {}) {
  const reader3 = stream.getReader();
  try {
    while (true) {
      const result = await reader3.read();
      if (result.done) {
        return;
      }
      yield result.value;
    }
  } finally {
    if (options.preventCancel !== true) {
      await reader3.cancel();
    }
    reader3.releaseLock();
  }
}
function blobToIt(blob) {
  if (typeof blob.stream === "function") {
    return browserReadableStreamToIt(blob.stream());
  }
  return browserReadableStreamToIt(new Response(blob).body);
}
function peekableIterator(iterable) {
  const [iterator, symbol7] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator.next();
    },
    push: (value2) => {
      queue.push(value2);
    },
    next: () => {
      if (queue.length > 0) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator.next();
    },
    [symbol7]() {
      return this;
    }
  };
}
function isBytes(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob$1(obj) {
  return obj.constructor && (obj.constructor.name === "Blob" || obj.constructor.name === "File") && typeof obj.stream === "function";
}
function isFileObject(obj) {
  return typeof obj === "object" && (obj.path || obj.content);
}
var isReadableStream = (value2) => value2 && typeof value2.getReader === "function";
async function* toAsyncIterable(thing) {
  yield thing;
}
async function normaliseContent(input) {
  if (isBytes(input)) {
    return toAsyncIterable(toBytes2(input));
  }
  if (typeof input === "string" || input instanceof String) {
    return toAsyncIterable(toBytes2(input.toString()));
  }
  if (isBlob$1(input)) {
    return blobToIt(input);
  }
  if (isReadableStream(input)) {
    input = browserReadableStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = peekableIterator(input);
    const { value: value2, done } = await peekable.peek();
    if (done) {
      return toAsyncIterable(new Uint8Array(0));
    }
    peekable.push(value2);
    if (Number.isInteger(value2)) {
      return toAsyncIterable(Uint8Array.from(await all(peekable)));
    }
    if (isBytes(value2) || typeof value2 === "string" || value2 instanceof String) {
      return map(peekable, toBytes2);
    }
  }
  throw (0, import_err_code31.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
}
function toBytes2(chunk) {
  if (chunk instanceof Uint8Array) {
    return chunk;
  }
  if (ArrayBuffer.isView(chunk)) {
    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  }
  if (chunk instanceof ArrayBuffer) {
    return new Uint8Array(chunk);
  }
  if (Array.isArray(chunk)) {
    return Uint8Array.from(chunk);
  }
  return fromString3(chunk.toString());
}
var import_err_code32 = __toESM(require_err_code(), 1);
async function* normaliseCandidateSingle(input, normaliseContent3) {
  if (input === null || input === void 0) {
    throw (0, import_err_code32.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  if (typeof input === "string" || input instanceof String) {
    yield toFileObject(input.toString(), normaliseContent3);
    return;
  }
  if (isBytes(input) || isBlob$1(input)) {
    yield toFileObject(input, normaliseContent3);
    return;
  }
  if (isReadableStream(input)) {
    input = browserReadableStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = peekableIterator(input);
    const { value: value2, done } = await peekable.peek();
    if (done) {
      yield { content: [] };
      return;
    }
    peekable.push(value2);
    if (Number.isInteger(value2) || isBytes(value2) || typeof value2 === "string" || value2 instanceof String) {
      yield toFileObject(peekable, normaliseContent3);
      return;
    }
    throw (0, import_err_code32.default)(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isFileObject(input)) {
    yield toFileObject(input, normaliseContent3);
    return;
  }
  throw (0, import_err_code32.default)(new Error('Unexpected input: cannot convert "' + typeof input + '" into ImportCandidate'), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject(input, normaliseContent3) {
  const { path: path2, mode, mtime, content } = input;
  const file = {
    path: path2 || "",
    mode: parseMode(mode),
    mtime: parseMtime(mtime)
  };
  if (content) {
    file.content = await normaliseContent3(content);
  } else if (!path2) {
    file.content = await normaliseContent3(input);
  }
  return file;
}
function normaliseInput2(input) {
  return normaliseCandidateSingle(input, normaliseContent);
}
function createAdd3({ addAll }) {
  async function add(entry, options = {}) {
    const result = await last(addAll(normaliseInput2(entry), options));
    if (result == null) {
      throw Error("Failed to add a file, if you see this please report a bug");
    }
    return result;
  }
  return add;
}
async function* batch(source, size = 1) {
  let things = [];
  if (size < 1) {
    size = 1;
  }
  for await (const thing of source) {
    things.push(thing);
    while (things.length >= size) {
      yield things.slice(0, size);
      things = things.slice(size);
    }
  }
  while (things.length > 0) {
    yield things.slice(0, size);
    things = things.slice(size);
  }
}
async function* parallelBatch(source, size = 1) {
  for await (const tasks of batch(source, size)) {
    const things = tasks.map(async (p) => {
      return await p().then((value2) => ({ ok: true, value: value2 }), (err2) => ({ ok: false, err: err2 }));
    });
    for (let i2 = 0; i2 < things.length; i2++) {
      const result = await things[i2];
      if (result.ok) {
        yield result.value;
      } else {
        throw result.err;
      }
    }
  }
}
var import_murmurhash3js_revisited = __toESM(require_murmurhash3js_revisited());
function fromNumberTo32BitBuf(number) {
  const bytes2 = new Array(4);
  for (let i2 = 0; i2 < 4; i2++) {
    bytes2[i2] = number & 255;
    number = number >> 8;
  }
  return new Uint8Array(bytes2);
}
from$1({
  name: "murmur3-32",
  code: 35,
  encode: (input) => fromNumberTo32BitBuf(import_murmurhash3js_revisited.default.x86.hash32(input))
});
var murmur3128 = from$1({
  name: "murmur3-128",
  code: 34,
  encode: (input) => bytes_exports.fromHex(import_murmurhash3js_revisited.default.x64.hash128(input))
});
from$1({
  name: "murmur3-x64-64",
  code: 34,
  encode: (input) => bytes_exports.fromHex(import_murmurhash3js_revisited.default.x64.hash128(input)).subarray(0, 8)
});
async function hamtHashFn(buf2) {
  return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
}
var defaultOptions = {
  chunker: "fixed",
  strategy: "balanced",
  // 'flat', 'trickle'
  rawLeaves: false,
  onlyHash: false,
  reduceSingleLeafToSelf: true,
  hasher: sha256,
  leafType: "file",
  // 'raw'
  cidVersion: 0,
  progress: () => () => {
  },
  shardSplitThreshold: 1e3,
  fileImportConcurrency: 50,
  blockWriteConcurrency: 10,
  minChunkSize: 262144,
  maxChunkSize: 262144,
  avgChunkSize: 262144,
  window: 16,
  // FIXME: This number is too big for JavaScript
  // https://github.com/ipfs/go-ipfs-chunker/blob/d0125832512163708c0804a3cda060e21acddae4/rabin.go#L11
  polynomial: 17437180132763652,
  // eslint-disable-line no-loss-of-precision
  maxChildrenPerNode: 174,
  layerRepeat: 4,
  wrapWithDirectory: false,
  recursive: false,
  hidden: false,
  timeout: void 0,
  hamtHashFn,
  hamtHashCode: 34,
  hamtBucketBits: 8
};
var options_default = (options = {}) => {
  const defaults2 = merge_options_default.bind({ ignoreUndefined: true });
  return defaults2(defaultOptions, options);
};
var persist = async (buffer2, blockstore, options) => {
  if (!options.codec) {
    options.codec = src_exports;
  }
  if (!options.hasher) {
    options.hasher = sha256;
  }
  if (options.cidVersion === void 0) {
    options.cidVersion = 1;
  }
  if (options.codec === src_exports && options.hasher !== sha256) {
    options.cidVersion = 1;
  }
  const multihash = await options.hasher.digest(buffer2);
  const cid = CID.create(options.cidVersion, options.codec.code, multihash);
  if (!options.onlyHash) {
    await blockstore.put(cid, buffer2, {
      signal: options.signal
    });
  }
  return cid;
};
var persist_default = persist;
var dirBuilder = async (item, blockstore, options) => {
  const unixfs = new UnixFS({
    type: "directory",
    mtime: item.mtime,
    mode: item.mode
  });
  const buffer2 = encode$1(prepare({ Data: unixfs.marshal() }));
  const cid = await persist_default(buffer2, blockstore, options);
  const path2 = item.path;
  return {
    cid,
    path: path2,
    unixfs,
    size: buffer2.length
  };
};
var dir_default = dirBuilder;
var import_err_code33 = __toESM(require_err_code(), 1);
async function flat(source, reduce2) {
  return reduce2(await all(source));
}
var flat_default = flat;
function balanced(source, reduce2, options) {
  return reduceToParents(source, reduce2, options);
}
async function reduceToParents(source, reduce2, options) {
  const roots = [];
  for await (const chunked of batch(source, options.maxChildrenPerNode)) {
    roots.push(await reduce2(chunked));
  }
  if (roots.length > 1) {
    return reduceToParents(roots, reduce2, options);
  }
  return roots[0];
}
var balanced_default = balanced;
async function trickleStream(source, reduce2, options) {
  const root2 = new Root(options.layerRepeat);
  let iteration = 0;
  let maxDepth = 1;
  let subTree = root2;
  for await (const layer of batch(source, options.maxChildrenPerNode)) {
    if (subTree.isFull()) {
      if (subTree !== root2) {
        root2.addChild(await subTree.reduce(reduce2));
      }
      if (iteration && iteration % options.layerRepeat === 0) {
        maxDepth++;
      }
      subTree = new SubTree(maxDepth, options.layerRepeat, iteration);
      iteration++;
    }
    subTree.append(layer);
  }
  if (subTree && subTree !== root2) {
    root2.addChild(await subTree.reduce(reduce2));
  }
  return root2.reduce(reduce2);
}
var trickle_default = trickleStream;
var SubTree = class {
  /**
   * @param {number} maxDepth
   * @param {number} layerRepeat
   * @param {number} [iteration=0]
   */
  constructor(maxDepth, layerRepeat, iteration = 0) {
    this.maxDepth = maxDepth;
    this.layerRepeat = layerRepeat;
    this.currentDepth = 1;
    this.iteration = iteration;
    this.root = this.node = this.parent = {
      children: [],
      depth: this.currentDepth,
      maxDepth,
      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat
    };
  }
  isFull() {
    if (!this.root.data) {
      return false;
    }
    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {
      this._addNextNodeToParent(this.node);
      return false;
    }
    const distantRelative = this._findParent(this.node, this.currentDepth);
    if (distantRelative) {
      this._addNextNodeToParent(distantRelative);
      return false;
    }
    return true;
  }
  /**
   * @param {TrickleDagNode} parent
   */
  _addNextNodeToParent(parent2) {
    this.parent = parent2;
    const nextNode = {
      children: [],
      depth: parent2.depth + 1,
      parent: parent2,
      maxDepth: this.maxDepth,
      maxChildren: Math.floor(parent2.children.length / this.layerRepeat) * this.layerRepeat
    };
    parent2.children.push(nextNode);
    this.currentDepth = nextNode.depth;
    this.node = nextNode;
  }
  /**
   *
   * @param {InProgressImportResult[]} layer
   */
  append(layer) {
    this.node.data = layer;
  }
  /**
   * @param {Reducer} reduce
   */
  reduce(reduce2) {
    return this._reduce(this.root, reduce2);
  }
  /**
   * @param {TrickleDagNode} node
   * @param {Reducer} reduce
   * @returns {Promise<InProgressImportResult>}
   */
  async _reduce(node, reduce2) {
    let children = [];
    if (node.children.length) {
      children = await Promise.all(
        node.children.filter((child) => child.data).map((child) => this._reduce(child, reduce2))
      );
    }
    return reduce2((node.data || []).concat(children));
  }
  /**
   * @param {TrickleDagNode} node
   * @param {number} depth
   * @returns {TrickleDagNode | undefined}
   */
  _findParent(node, depth) {
    const parent2 = node.parent;
    if (!parent2 || parent2.depth === 0) {
      return;
    }
    if (parent2.children.length === parent2.maxChildren || !parent2.maxChildren) {
      return this._findParent(parent2, depth);
    }
    return parent2;
  }
};
var Root = class extends SubTree {
  /**
   * @param {number} layerRepeat
   */
  constructor(layerRepeat) {
    super(0, layerRepeat);
    this.root.depth = 0;
    this.currentDepth = 1;
  }
  /**
   * @param {InProgressImportResult} child
   */
  addChild(child) {
    this.root.children.push(child);
  }
  /**
   * @param {Reducer} reduce
   */
  reduce(reduce2) {
    return reduce2((this.root.data || []).concat(this.root.children));
  }
};
async function* bufferImporter(file, block, options) {
  for await (let buffer2 of file.content) {
    yield async () => {
      options.progress(buffer2.length, file.path);
      let unixfs;
      const opts = {
        codec: src_exports,
        cidVersion: options.cidVersion,
        hasher: options.hasher,
        onlyHash: options.onlyHash
      };
      if (options.rawLeaves) {
        opts.codec = raw_exports;
        opts.cidVersion = 1;
      } else {
        unixfs = new UnixFS({
          type: options.leafType,
          data: buffer2
        });
        buffer2 = encode$1({
          Data: unixfs.marshal(),
          Links: []
        });
      }
      return {
        cid: await persist_default(buffer2, block, opts),
        unixfs,
        size: buffer2.length
      };
    };
  }
}
var buffer_importer_default = bufferImporter;
var dagBuilders = {
  flat: flat_default,
  balanced: balanced_default,
  trickle: trickle_default
};
async function* buildFileBatch(file, blockstore, options) {
  let count = -1;
  let previous;
  let bufferImporter2;
  if (typeof options.bufferImporter === "function") {
    bufferImporter2 = options.bufferImporter;
  } else {
    bufferImporter2 = buffer_importer_default;
  }
  for await (const entry of parallelBatch(bufferImporter2(file, blockstore, options), options.blockWriteConcurrency)) {
    count++;
    if (count === 0) {
      previous = entry;
      continue;
    } else if (count === 1 && previous) {
      yield previous;
      previous = null;
    }
    yield entry;
  }
  if (previous) {
    previous.single = true;
    yield previous;
  }
}
var reduce = (file, blockstore, options) => {
  async function reducer(leaves) {
    if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {
      const leaf = leaves[0];
      if (file.mtime !== void 0 || file.mode !== void 0) {
        let buffer3 = await blockstore.get(leaf.cid);
        leaf.unixfs = new UnixFS({
          type: "file",
          mtime: file.mtime,
          mode: file.mode,
          data: buffer3
        });
        buffer3 = encode$1(prepare({ Data: leaf.unixfs.marshal() }));
        leaf.cid = await persist_default(buffer3, blockstore, {
          ...options,
          codec: src_exports,
          hasher: options.hasher,
          cidVersion: options.cidVersion
        });
        leaf.size = buffer3.length;
      }
      return {
        cid: leaf.cid,
        path: file.path,
        unixfs: leaf.unixfs,
        size: leaf.size
      };
    }
    const f = new UnixFS({
      type: "file",
      mtime: file.mtime,
      mode: file.mode
    });
    const links3 = leaves.filter((leaf) => {
      if (leaf.cid.code === code6 && leaf.size) {
        return true;
      }
      if (leaf.unixfs && !leaf.unixfs.data && leaf.unixfs.fileSize()) {
        return true;
      }
      return Boolean(leaf.unixfs && leaf.unixfs.data && leaf.unixfs.data.length);
    }).map((leaf) => {
      if (leaf.cid.code === code6) {
        f.addBlockSize(leaf.size);
        return {
          Name: "",
          Tsize: leaf.size,
          Hash: leaf.cid
        };
      }
      if (!leaf.unixfs || !leaf.unixfs.data) {
        f.addBlockSize(leaf.unixfs && leaf.unixfs.fileSize() || 0);
      } else {
        f.addBlockSize(leaf.unixfs.data.length);
      }
      return {
        Name: "",
        Tsize: leaf.size,
        Hash: leaf.cid
      };
    });
    const node = {
      Data: f.marshal(),
      Links: links3
    };
    const buffer2 = encode$1(prepare(node));
    const cid = await persist_default(buffer2, blockstore, options);
    return {
      cid,
      path: file.path,
      unixfs: f,
      size: buffer2.length + node.Links.reduce((acc, curr) => acc + curr.Tsize, 0)
    };
  }
  return reducer;
};
function fileBuilder(file, block, options) {
  const dagBuilder2 = dagBuilders[options.strategy];
  if (!dagBuilder2) {
    throw (0, import_err_code33.default)(new Error(`Unknown importer build strategy name: ${options.strategy}`), "ERR_BAD_STRATEGY");
  }
  return dagBuilder2(buildFileBatch(file, block, options), reduce(file, block, options), options);
}
var file_default = fileBuilder;
var import_err_code36 = __toESM(require_err_code(), 1);
var symbol3 = Symbol.for("@achingbrain/uint8arraylist");
function findBufAndOffset(bufs, index2) {
  if (index2 == null || index2 < 0) {
    throw new RangeError("index is out of bounds");
  }
  let offset = 0;
  for (const buf2 of bufs) {
    const bufEnd = offset + buf2.byteLength;
    if (index2 < bufEnd) {
      return {
        buf: buf2,
        index: index2 - offset
      };
    }
    offset = bufEnd;
  }
  throw new RangeError("index is out of bounds");
}
function isUint8ArrayList(value2) {
  return Boolean(value2?.[symbol3]);
}
var Uint8ArrayList = class {
  constructor(...data) {
    Object.defineProperty(this, symbol3, { value: true });
    this.bufs = [];
    this.length = 0;
    if (data.length > 0) {
      this.appendAll(data);
    }
  }
  *[Symbol.iterator]() {
    yield* this.bufs;
  }
  get byteLength() {
    return this.length;
  }
  /**
   * Add one or more `bufs` to the end of this Uint8ArrayList
   */
  append(...bufs) {
    this.appendAll(bufs);
  }
  /**
   * Add all `bufs` to the end of this Uint8ArrayList
   */
  appendAll(bufs) {
    let length3 = 0;
    for (const buf2 of bufs) {
      if (buf2 instanceof Uint8Array) {
        length3 += buf2.byteLength;
        this.bufs.push(buf2);
      } else if (isUint8ArrayList(buf2)) {
        length3 += buf2.byteLength;
        this.bufs.push(...buf2.bufs);
      } else {
        throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length3;
  }
  /**
   * Add one or more `bufs` to the start of this Uint8ArrayList
   */
  prepend(...bufs) {
    this.prependAll(bufs);
  }
  /**
   * Add all `bufs` to the start of this Uint8ArrayList
   */
  prependAll(bufs) {
    let length3 = 0;
    for (const buf2 of bufs.reverse()) {
      if (buf2 instanceof Uint8Array) {
        length3 += buf2.byteLength;
        this.bufs.unshift(buf2);
      } else if (isUint8ArrayList(buf2)) {
        length3 += buf2.byteLength;
        this.bufs.unshift(...buf2.bufs);
      } else {
        throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length3;
  }
  /**
   * Read the value at `index`
   */
  get(index2) {
    const res = findBufAndOffset(this.bufs, index2);
    return res.buf[res.index];
  }
  /**
   * Set the value at `index` to `value`
   */
  set(index2, value2) {
    const res = findBufAndOffset(this.bufs, index2);
    res.buf[res.index] = value2;
  }
  /**
   * Copy bytes from `buf` to the index specified by `offset`
   */
  write(buf2, offset = 0) {
    if (buf2 instanceof Uint8Array) {
      for (let i2 = 0; i2 < buf2.length; i2++) {
        this.set(offset + i2, buf2[i2]);
      }
    } else if (isUint8ArrayList(buf2)) {
      for (let i2 = 0; i2 < buf2.length; i2++) {
        this.set(offset + i2, buf2.get(i2));
      }
    } else {
      throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
    }
  }
  /**
   * Remove bytes from the front of the pool
   */
  consume(bytes2) {
    bytes2 = Math.trunc(bytes2);
    if (Number.isNaN(bytes2) || bytes2 <= 0) {
      return;
    }
    if (bytes2 === this.byteLength) {
      this.bufs = [];
      this.length = 0;
      return;
    }
    while (this.bufs.length > 0) {
      if (bytes2 >= this.bufs[0].byteLength) {
        bytes2 -= this.bufs[0].byteLength;
        this.length -= this.bufs[0].byteLength;
        this.bufs.shift();
      } else {
        this.bufs[0] = this.bufs[0].subarray(bytes2);
        this.length -= bytes2;
        break;
      }
    }
  }
  /**
   * Extracts a section of an array and returns a new array.
   *
   * This is a copy operation as it is with Uint8Arrays and Arrays
   * - note this is different to the behaviour of Node Buffers.
   */
  slice(beginInclusive, endExclusive) {
    const { bufs, length: length3 } = this._subList(beginInclusive, endExclusive);
    return concat(bufs, length3);
  }
  /**
   * Returns a alloc from the given start and end element index.
   *
   * In the best case where the data extracted comes from a single Uint8Array
   * internally this is a no-copy operation otherwise it is a copy operation.
   */
  subarray(beginInclusive, endExclusive) {
    const { bufs, length: length3 } = this._subList(beginInclusive, endExclusive);
    if (bufs.length === 1) {
      return bufs[0];
    }
    return concat(bufs, length3);
  }
  /**
   * Returns a allocList from the given start and end element index.
   *
   * This is a no-copy operation.
   */
  sublist(beginInclusive, endExclusive) {
    const { bufs, length: length3 } = this._subList(beginInclusive, endExclusive);
    const list = new Uint8ArrayList();
    list.length = length3;
    list.bufs = bufs;
    return list;
  }
  _subList(beginInclusive, endExclusive) {
    beginInclusive = beginInclusive ?? 0;
    endExclusive = endExclusive ?? this.length;
    if (beginInclusive < 0) {
      beginInclusive = this.length + beginInclusive;
    }
    if (endExclusive < 0) {
      endExclusive = this.length + endExclusive;
    }
    if (beginInclusive < 0 || endExclusive > this.length) {
      throw new RangeError("index is out of bounds");
    }
    if (beginInclusive === endExclusive) {
      return { bufs: [], length: 0 };
    }
    if (beginInclusive === 0 && endExclusive === this.length) {
      return { bufs: [...this.bufs], length: this.length };
    }
    const bufs = [];
    let offset = 0;
    for (let i2 = 0; i2 < this.bufs.length; i2++) {
      const buf2 = this.bufs[i2];
      const bufStart = offset;
      const bufEnd = bufStart + buf2.byteLength;
      offset = bufEnd;
      if (beginInclusive >= bufEnd) {
        continue;
      }
      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
      if (sliceStartInBuf && sliceEndsInBuf) {
        if (beginInclusive === bufStart && endExclusive === bufEnd) {
          bufs.push(buf2);
          break;
        }
        const start = beginInclusive - bufStart;
        bufs.push(buf2.subarray(start, start + (endExclusive - beginInclusive)));
        break;
      }
      if (sliceStartInBuf) {
        if (beginInclusive === 0) {
          bufs.push(buf2);
          continue;
        }
        bufs.push(buf2.subarray(beginInclusive - bufStart));
        continue;
      }
      if (sliceEndsInBuf) {
        if (endExclusive === bufEnd) {
          bufs.push(buf2);
          break;
        }
        bufs.push(buf2.subarray(0, endExclusive - bufStart));
        break;
      }
      bufs.push(buf2);
    }
    return { bufs, length: endExclusive - beginInclusive };
  }
  indexOf(search, offset = 0) {
    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
      throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
    }
    const needle = search instanceof Uint8Array ? search : search.subarray();
    offset = Number(offset ?? 0);
    if (isNaN(offset)) {
      offset = 0;
    }
    if (offset < 0) {
      offset = this.length + offset;
    }
    if (offset < 0) {
      offset = 0;
    }
    if (search.length === 0) {
      return offset > this.length ? this.length : offset;
    }
    const M = needle.byteLength;
    if (M === 0) {
      throw new TypeError("search must be at least 1 byte long");
    }
    const radix = 256;
    const rightmostPositions = new Int32Array(radix);
    for (let c = 0; c < radix; c++) {
      rightmostPositions[c] = -1;
    }
    for (let j = 0; j < M; j++) {
      rightmostPositions[needle[j]] = j;
    }
    const right = rightmostPositions;
    const lastIndex = this.byteLength - needle.byteLength;
    const lastPatIndex = needle.byteLength - 1;
    let skip;
    for (let i2 = offset; i2 <= lastIndex; i2 += skip) {
      skip = 0;
      for (let j = lastPatIndex; j >= 0; j--) {
        const char = this.get(i2 + j);
        if (needle[j] !== char) {
          skip = Math.max(1, j - right[char]);
          break;
        }
      }
      if (skip === 0) {
        return i2;
      }
    }
    return -1;
  }
  getInt8(byteOffset) {
    const buf2 = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getInt8(0);
  }
  setInt8(byteOffset, value2) {
    const buf2 = allocUnsafe(1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setInt8(0, value2);
    this.write(buf2, byteOffset);
  }
  getInt16(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getInt16(0, littleEndian);
  }
  setInt16(byteOffset, value2, littleEndian) {
    const buf2 = alloc(2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setInt16(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getInt32(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getInt32(0, littleEndian);
  }
  setInt32(byteOffset, value2, littleEndian) {
    const buf2 = alloc(4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setInt32(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getBigInt64(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getBigInt64(0, littleEndian);
  }
  setBigInt64(byteOffset, value2, littleEndian) {
    const buf2 = alloc(8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setBigInt64(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getUint8(byteOffset) {
    const buf2 = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getUint8(0);
  }
  setUint8(byteOffset, value2) {
    const buf2 = allocUnsafe(1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setUint8(0, value2);
    this.write(buf2, byteOffset);
  }
  getUint16(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getUint16(0, littleEndian);
  }
  setUint16(byteOffset, value2, littleEndian) {
    const buf2 = alloc(2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setUint16(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getUint32(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getUint32(0, littleEndian);
  }
  setUint32(byteOffset, value2, littleEndian) {
    const buf2 = alloc(4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setUint32(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getBigUint64(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getBigUint64(0, littleEndian);
  }
  setBigUint64(byteOffset, value2, littleEndian) {
    const buf2 = alloc(8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setBigUint64(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getFloat32(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getFloat32(0, littleEndian);
  }
  setFloat32(byteOffset, value2, littleEndian) {
    const buf2 = alloc(4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setFloat32(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getFloat64(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getFloat64(0, littleEndian);
  }
  setFloat64(byteOffset, value2, littleEndian) {
    const buf2 = alloc(8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setFloat64(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (!(other instanceof Uint8ArrayList)) {
      return false;
    }
    if (other.bufs.length !== this.bufs.length) {
      return false;
    }
    for (let i2 = 0; i2 < this.bufs.length; i2++) {
      if (!equals(this.bufs[i2], other.bufs[i2])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this
   * method if you know the total size of all the Uint8Arrays ahead of time.
   */
  static fromUint8Arrays(bufs, length3) {
    const list = new Uint8ArrayList();
    list.bufs = bufs;
    if (length3 == null) {
      length3 = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);
    }
    list.length = length3;
    return list;
  }
};
var import_rabin_wasm = __toESM(require_src2(), 1);
var import_err_code34 = __toESM(require_err_code(), 1);
async function* rabinChunker(source, options) {
  let min, max, avg;
  if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {
    avg = options.avgChunkSize;
    min = options.minChunkSize;
    max = options.maxChunkSize;
  } else if (!options.avgChunkSize) {
    throw (0, import_err_code34.default)(new Error("please specify an average chunk size"), "ERR_INVALID_AVG_CHUNK_SIZE");
  } else {
    avg = options.avgChunkSize;
    min = avg / 3;
    max = avg + avg / 2;
  }
  if (min < 16) {
    throw (0, import_err_code34.default)(new Error("rabin min must be greater than 16"), "ERR_INVALID_MIN_CHUNK_SIZE");
  }
  if (max < min) {
    max = min;
  }
  if (avg < min) {
    avg = min;
  }
  const sizepow = Math.floor(Math.log2(avg));
  for await (const chunk of rabin(source, {
    min,
    max,
    bits: sizepow,
    window: options.window,
    polynomial: options.polynomial
  })) {
    yield chunk;
  }
}
var rabin_default = rabinChunker;
async function* rabin(source, options) {
  const r = await (0, import_rabin_wasm.create)(options.bits, options.min, options.max, options.window);
  const buffers = new Uint8ArrayList();
  for await (const chunk of source) {
    buffers.append(chunk);
    const sizes = r.fingerprint(chunk);
    for (let i2 = 0; i2 < sizes.length; i2++) {
      const size = sizes[i2];
      const buf2 = buffers.slice(0, size);
      buffers.consume(size);
      yield buf2;
    }
  }
  if (buffers.length) {
    yield buffers.subarray(0);
  }
}
async function* fixedSizeChunker(source, options) {
  let list = new Uint8ArrayList();
  let currentLength = 0;
  let emitted = false;
  const maxChunkSize = options.maxChunkSize;
  for await (const buffer2 of source) {
    list.append(buffer2);
    currentLength += buffer2.length;
    while (currentLength >= maxChunkSize) {
      yield list.slice(0, maxChunkSize);
      emitted = true;
      if (maxChunkSize === list.length) {
        list = new Uint8ArrayList();
        currentLength = 0;
      } else {
        const newBl = new Uint8ArrayList();
        newBl.append(list.sublist(maxChunkSize));
        list = newBl;
        currentLength -= maxChunkSize;
      }
    }
  }
  if (!emitted || currentLength) {
    yield list.subarray(0, currentLength);
  }
}
var fixed_size_default = fixedSizeChunker;
var import_err_code35 = __toESM(require_err_code(), 1);
async function* validateChunks(source) {
  for await (const content of source) {
    if (content.length === void 0) {
      throw (0, import_err_code35.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
    }
    if (typeof content === "string" || content instanceof String) {
      yield fromString3(content.toString());
    } else if (Array.isArray(content)) {
      yield Uint8Array.from(content);
    } else if (content instanceof Uint8Array) {
      yield content;
    } else {
      throw (0, import_err_code35.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
    }
  }
}
var validate_chunks_default = validateChunks;
function isIterable3(thing) {
  return Symbol.iterator in thing;
}
function isAsyncIterable2(thing) {
  return Symbol.asyncIterator in thing;
}
function contentAsAsyncIterable(content) {
  try {
    if (content instanceof Uint8Array) {
      return async function* () {
        yield content;
      }();
    } else if (isIterable3(content)) {
      return async function* () {
        yield* content;
      }();
    } else if (isAsyncIterable2(content)) {
      return content;
    }
  } catch {
    throw (0, import_err_code36.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
  }
  throw (0, import_err_code36.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
}
async function* dagBuilder(source, blockstore, options) {
  for await (const entry of source) {
    if (entry.path) {
      if (entry.path.substring(0, 2) === "./") {
        options.wrapWithDirectory = true;
      }
      entry.path = entry.path.split("/").filter((path2) => path2 && path2 !== ".").join("/");
    }
    if (entry.content) {
      let chunker;
      if (typeof options.chunker === "function") {
        chunker = options.chunker;
      } else if (options.chunker === "rabin") {
        chunker = rabin_default;
      } else {
        chunker = fixed_size_default;
      }
      let chunkValidator;
      if (typeof options.chunkValidator === "function") {
        chunkValidator = options.chunkValidator;
      } else {
        chunkValidator = validate_chunks_default;
      }
      const file = {
        path: entry.path,
        mtime: entry.mtime,
        mode: entry.mode,
        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)
      };
      yield () => file_default(file, blockstore, options);
    } else if (entry.path) {
      const dir = {
        path: entry.path,
        mtime: entry.mtime,
        mode: entry.mode
      };
      yield () => dir_default(dir, blockstore, options);
    } else {
      throw new Error("Import candidate must have content or path or both");
    }
  }
}
var dag_builder_default = dagBuilder;
var Dir = class {
  /**
   * @param {DirProps} props
   * @param {ImporterOptions} options
   */
  constructor(props, options) {
    this.options = options || {};
    this.root = props.root;
    this.dir = props.dir;
    this.path = props.path;
    this.dirty = props.dirty;
    this.flat = props.flat;
    this.parent = props.parent;
    this.parentKey = props.parentKey;
    this.unixfs = props.unixfs;
    this.mode = props.mode;
    this.mtime = props.mtime;
    this.cid = void 0;
    this.size = void 0;
  }
  /**
   * @param {string} name
   * @param {InProgressImportResult | Dir} value
   */
  async put(name9, value2) {
  }
  /**
   * @param {string} name
   * @returns {Promise<InProgressImportResult | Dir | undefined>}
   */
  get(name9) {
    return Promise.resolve(this);
  }
  /**
   * @returns {AsyncIterable<{ key: string, child: InProgressImportResult | Dir}>}
   */
  async *eachChildSeries() {
  }
  /**
   * @param {Blockstore} blockstore
   * @returns {AsyncIterable<ImportResult>}
   */
  async *flush(blockstore) {
  }
};
var dir_default2 = Dir;
var DirFlat = class extends dir_default2 {
  /**
   * @param {DirProps} props
   * @param {ImporterOptions} options
   */
  constructor(props, options) {
    super(props, options);
    this._children = {};
  }
  /**
   * @param {string} name
   * @param {InProgressImportResult | Dir} value
   */
  async put(name9, value2) {
    this.cid = void 0;
    this.size = void 0;
    this._children[name9] = value2;
  }
  /**
   * @param {string} name
   */
  get(name9) {
    return Promise.resolve(this._children[name9]);
  }
  childCount() {
    return Object.keys(this._children).length;
  }
  directChildrenCount() {
    return this.childCount();
  }
  onlyChild() {
    return this._children[Object.keys(this._children)[0]];
  }
  async *eachChildSeries() {
    const keys = Object.keys(this._children);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const key = keys[i2];
      yield {
        key,
        child: this._children[key]
      };
    }
  }
  /**
   * @param {Blockstore} block
   * @returns {AsyncIterable<ImportResult>}
   */
  async *flush(block) {
    const children = Object.keys(this._children);
    const links3 = [];
    for (let i2 = 0; i2 < children.length; i2++) {
      let child = this._children[children[i2]];
      if (child instanceof dir_default2) {
        for await (const entry of child.flush(block)) {
          child = entry;
          yield child;
        }
      }
      if (child.size != null && child.cid) {
        links3.push({
          Name: children[i2],
          Tsize: child.size,
          Hash: child.cid
        });
      }
    }
    const unixfs = new UnixFS({
      type: "directory",
      mtime: this.mtime,
      mode: this.mode
    });
    const node = { Data: unixfs.marshal(), Links: links3 };
    const buffer2 = encode$1(prepare(node));
    const cid = await persist_default(buffer2, block, this.options);
    const size = buffer2.length + node.Links.reduce(
      /**
       * @param {number} acc
       * @param {PBLink} curr
       */
      (acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize),
      0
    );
    this.cid = cid;
    this.size = size;
    yield {
      cid,
      unixfs,
      path: this.path,
      size
    };
  }
};
var dir_flat_default = DirFlat;
var import_sparse_array = __toESM(require_sparse_array(), 1);
var Bucket = class {
  constructor(options, parent2, posAtParent = 0) {
    this._options = options;
    this._popCount = 0;
    this._parent = parent2;
    this._posAtParent = posAtParent;
    this._children = new import_sparse_array.default();
    this.key = null;
  }
  async put(key, value2) {
    const place = await this._findNewBucketAndPos(key);
    await place.bucket._putAt(place, key, value2);
  }
  async get(key) {
    const child = await this._findChild(key);
    if (child != null) {
      return child.value;
    }
  }
  async del(key) {
    const place = await this._findPlace(key);
    const child = place.bucket._at(place.pos);
    if (child != null && child.key === key) {
      place.bucket._delAt(place.pos);
    }
  }
  leafCount() {
    const children = this._children.compactArray();
    return children.reduce((acc, child) => {
      if (child instanceof Bucket) {
        return acc + child.leafCount();
      }
      return acc + 1;
    }, 0);
  }
  childrenCount() {
    return this._children.length;
  }
  onlyChild() {
    return this._children.get(0);
  }
  *eachLeafSeries() {
    const children = this._children.compactArray();
    for (const child of children) {
      if (child instanceof Bucket) {
        yield* child.eachLeafSeries();
      } else {
        yield child;
      }
    }
  }
  serialize(map4, reduce2) {
    const acc = [];
    return reduce2(this._children.reduce((acc2, child, index2) => {
      if (child != null) {
        if (child instanceof Bucket) {
          acc2.push(child.serialize(map4, reduce2));
        } else {
          acc2.push(map4(child, index2));
        }
      }
      return acc2;
    }, acc));
  }
  async asyncTransform(asyncMap, asyncReduce) {
    return await asyncTransformBucket(this, asyncMap, asyncReduce);
  }
  toJSON() {
    return this.serialize(mapNode, reduceNodes);
  }
  prettyPrint() {
    return JSON.stringify(this.toJSON(), null, "  ");
  }
  tableSize() {
    return Math.pow(2, this._options.bits);
  }
  async _findChild(key) {
    const result = await this._findPlace(key);
    const child = result.bucket._at(result.pos);
    if (child instanceof Bucket) {
      return void 0;
    }
    if (child != null && child.key === key) {
      return child;
    }
  }
  async _findPlace(key) {
    const hashValue = this._options.hash(typeof key === "string" ? fromString3(key) : key);
    const index2 = await hashValue.take(this._options.bits);
    const child = this._children.get(index2);
    if (child instanceof Bucket) {
      return await child._findPlace(hashValue);
    }
    return {
      bucket: this,
      pos: index2,
      hash: hashValue,
      existingChild: child
    };
  }
  async _findNewBucketAndPos(key) {
    const place = await this._findPlace(key);
    if (place.existingChild != null && place.existingChild.key !== key) {
      const bucket = new Bucket(this._options, place.bucket, place.pos);
      place.bucket._putObjectAt(place.pos, bucket);
      const newPlace = await bucket._findPlace(place.existingChild.hash);
      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
      return await bucket._findNewBucketAndPos(place.hash);
    }
    return place;
  }
  _putAt(place, key, value2) {
    this._putObjectAt(place.pos, {
      key,
      value: value2,
      hash: place.hash
    });
  }
  _putObjectAt(pos, object) {
    if (this._children.get(pos) == null) {
      this._popCount++;
    }
    this._children.set(pos, object);
  }
  _delAt(pos) {
    if (pos === -1) {
      throw new Error("Invalid position");
    }
    if (this._children.get(pos) != null) {
      this._popCount--;
    }
    this._children.unset(pos);
    this._level();
  }
  _level() {
    if (this._parent != null && this._popCount <= 1) {
      if (this._popCount === 1) {
        const onlyChild = this._children.find(exists);
        if (onlyChild != null && !(onlyChild instanceof Bucket)) {
          const hash3 = onlyChild.hash;
          hash3.untake(this._options.bits);
          const place = {
            pos: this._posAtParent,
            hash: hash3,
            bucket: this._parent
          };
          this._parent._putAt(place, onlyChild.key, onlyChild.value);
        }
      } else {
        this._parent._delAt(this._posAtParent);
      }
    }
  }
  _at(index2) {
    return this._children.get(index2);
  }
};
function exists(o) {
  return Boolean(o);
}
function mapNode(node, _) {
  return node.key;
}
function reduceNodes(nodes) {
  return nodes;
}
async function asyncTransformBucket(bucket, asyncMap, asyncReduce) {
  const output = [];
  for (const child of bucket._children.compactArray()) {
    if (child instanceof Bucket) {
      await asyncTransformBucket(child, asyncMap, asyncReduce);
    } else {
      const mappedChildren = await asyncMap(child);
      output.push({
        bitField: bucket._children.bitField(),
        children: mappedChildren
      });
    }
  }
  return await asyncReduce(output);
}
var START_MASKS = [
  255,
  254,
  252,
  248,
  240,
  224,
  192,
  128
];
var STOP_MASKS = [
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255
];
var ConsumableBuffer = class {
  constructor(value2) {
    this._value = value2;
    this._currentBytePos = value2.length - 1;
    this._currentBitPos = 7;
  }
  availableBits() {
    return this._currentBitPos + 1 + this._currentBytePos * 8;
  }
  totalBits() {
    return this._value.length * 8;
  }
  take(bits2) {
    let pendingBits = bits2;
    let result = 0;
    while (pendingBits > 0 && this._haveBits()) {
      const byte = this._value[this._currentBytePos];
      const availableBits = this._currentBitPos + 1;
      const taking = Math.min(availableBits, pendingBits);
      const value2 = byteBitsToInt(byte, availableBits - taking, taking);
      result = (result << taking) + value2;
      pendingBits -= taking;
      this._currentBitPos -= taking;
      if (this._currentBitPos < 0) {
        this._currentBitPos = 7;
        this._currentBytePos--;
      }
    }
    return result;
  }
  untake(bits2) {
    this._currentBitPos += bits2;
    while (this._currentBitPos > 7) {
      this._currentBitPos -= 8;
      this._currentBytePos += 1;
    }
  }
  _haveBits() {
    return this._currentBytePos >= 0;
  }
};
function byteBitsToInt(byte, start, length3) {
  const mask = maskFor(start, length3);
  return (byte & mask) >>> start;
}
function maskFor(start, length3) {
  return START_MASKS[start] & STOP_MASKS[Math.min(length3 + start - 1, 7)];
}
function wrapHash(hashFn2) {
  function hashing(value2) {
    if (value2 instanceof InfiniteHash) {
      return value2;
    } else {
      return new InfiniteHash(value2, hashFn2);
    }
  }
  return hashing;
}
var InfiniteHash = class {
  constructor(value2, hashFn2) {
    if (!(value2 instanceof Uint8Array)) {
      throw new Error("can only hash Uint8Arrays");
    }
    this._value = value2;
    this._hashFn = hashFn2;
    this._depth = -1;
    this._availableBits = 0;
    this._currentBufferIndex = 0;
    this._buffers = [];
  }
  async take(bits2) {
    let pendingBits = bits2;
    while (this._availableBits < pendingBits) {
      await this._produceMoreBits();
    }
    let result = 0;
    while (pendingBits > 0) {
      const hash3 = this._buffers[this._currentBufferIndex];
      const available = Math.min(hash3.availableBits(), pendingBits);
      const took = hash3.take(available);
      result = (result << available) + took;
      pendingBits -= available;
      this._availableBits -= available;
      if (hash3.availableBits() === 0) {
        this._currentBufferIndex++;
      }
    }
    return result;
  }
  untake(bits2) {
    let pendingBits = bits2;
    while (pendingBits > 0) {
      const hash3 = this._buffers[this._currentBufferIndex];
      const availableForUntake = Math.min(hash3.totalBits() - hash3.availableBits(), pendingBits);
      hash3.untake(availableForUntake);
      pendingBits -= availableForUntake;
      this._availableBits += availableForUntake;
      if (this._currentBufferIndex > 0 && hash3.totalBits() === hash3.availableBits()) {
        this._depth--;
        this._currentBufferIndex--;
      }
    }
  }
  async _produceMoreBits() {
    this._depth++;
    const value2 = this._depth > 0 ? concat([this._value, Uint8Array.from([this._depth])]) : this._value;
    const hashValue = await this._hashFn(value2);
    const buffer2 = new ConsumableBuffer(hashValue);
    this._buffers.push(buffer2);
    this._availableBits += buffer2.availableBits();
  }
};
function createHAMT(options) {
  if (options == null || options.hashFn == null) {
    throw new Error("please define an options.hashFn");
  }
  const bucketOptions = {
    bits: options.bits ?? 8,
    hash: wrapHash(options.hashFn)
  };
  return new Bucket(bucketOptions);
}
var DirSharded = class extends dir_default2 {
  /**
   * @param {DirProps} props
   * @param {ImporterOptions} options
   */
  constructor(props, options) {
    super(props, options);
    this._bucket = createHAMT({
      hashFn: options.hamtHashFn,
      bits: options.hamtBucketBits
    });
  }
  /**
   * @param {string} name
   * @param {InProgressImportResult | Dir} value
   */
  async put(name9, value2) {
    await this._bucket.put(name9, value2);
  }
  /**
   * @param {string} name
   */
  get(name9) {
    return this._bucket.get(name9);
  }
  childCount() {
    return this._bucket.leafCount();
  }
  directChildrenCount() {
    return this._bucket.childrenCount();
  }
  onlyChild() {
    return this._bucket.onlyChild();
  }
  async *eachChildSeries() {
    for await (const { key, value: value2 } of this._bucket.eachLeafSeries()) {
      yield {
        key,
        child: value2
      };
    }
  }
  /**
   * @param {Blockstore} blockstore
   * @returns {AsyncIterable<ImportResult>}
   */
  async *flush(blockstore) {
    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {
      yield {
        ...entry,
        path: this.path
      };
    }
  }
};
var dir_sharded_default = DirSharded;
async function* flush(bucket, blockstore, shardRoot, options) {
  const children = bucket._children;
  const links3 = [];
  let childrenSize = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children.get(i2);
    if (!child) {
      continue;
    }
    const labelPrefix = i2.toString(16).toUpperCase().padStart(2, "0");
    if (child instanceof Bucket) {
      let shard;
      for await (const subShard of await flush(child, blockstore, null, options)) {
        shard = subShard;
      }
      if (!shard) {
        throw new Error("Could not flush sharded directory, no subshard found");
      }
      links3.push({
        Name: labelPrefix,
        Tsize: shard.size,
        Hash: shard.cid
      });
      childrenSize += shard.size;
    } else if (typeof child.value.flush === "function") {
      const dir2 = child.value;
      let flushedDir;
      for await (const entry of dir2.flush(blockstore)) {
        flushedDir = entry;
        yield flushedDir;
      }
      const label = labelPrefix + child.key;
      links3.push({
        Name: label,
        Tsize: flushedDir.size,
        Hash: flushedDir.cid
      });
      childrenSize += flushedDir.size;
    } else {
      const value2 = child.value;
      if (!value2.cid) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size2 = value2.size;
      links3.push({
        Name: label,
        Tsize: size2,
        Hash: value2.cid
      });
      childrenSize += size2;
    }
  }
  const data = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data,
    fanout: bucket.tableSize(),
    hashType: options.hamtHashCode,
    mtime: shardRoot && shardRoot.mtime,
    mode: shardRoot && shardRoot.mode
  });
  const node = {
    Data: dir.marshal(),
    Links: links3
  };
  const buffer2 = encode$1(prepare(node));
  const cid = await persist_default(buffer2, blockstore, options);
  const size = buffer2.length + childrenSize;
  yield {
    cid,
    unixfs: dir,
    size
  };
}
async function flatToShard(child, dir, threshold, options) {
  let newDir = dir;
  if (dir instanceof dir_flat_default && dir.directChildrenCount() >= threshold) {
    newDir = await convertToShard(dir, options);
  }
  const parent2 = newDir.parent;
  if (parent2) {
    if (newDir !== dir) {
      if (child) {
        child.parent = newDir;
      }
      if (!newDir.parentKey) {
        throw new Error("No parent key found");
      }
      await parent2.put(newDir.parentKey, newDir);
    }
    return flatToShard(newDir, parent2, threshold, options);
  }
  return newDir;
}
async function convertToShard(oldDir, options) {
  const newDir = new dir_sharded_default({
    root: oldDir.root,
    dir: true,
    parent: oldDir.parent,
    parentKey: oldDir.parentKey,
    path: oldDir.path,
    dirty: oldDir.dirty,
    flat: false,
    mtime: oldDir.mtime,
    mode: oldDir.mode
  }, options);
  for await (const { key, child } of oldDir.eachChildSeries()) {
    await newDir.put(key, child);
  }
  return newDir;
}
var flat_to_shard_default = flatToShard;
var toPathComponents = (path2 = "") => {
  return (path2.trim().match(/([^\\/]|\\\/)+/g) || []).filter(Boolean);
};
var to_path_components_default = toPathComponents;
async function addToTree(elem, tree2, options) {
  const pathElems = to_path_components_default(elem.path || "");
  const lastIndex = pathElems.length - 1;
  let parent2 = tree2;
  let currentPath = "";
  for (let i2 = 0; i2 < pathElems.length; i2++) {
    const pathElem = pathElems[i2];
    currentPath += `${currentPath ? "/" : ""}${pathElem}`;
    const last2 = i2 === lastIndex;
    parent2.dirty = true;
    parent2.cid = void 0;
    parent2.size = void 0;
    if (last2) {
      await parent2.put(pathElem, elem);
      tree2 = await flat_to_shard_default(null, parent2, options.shardSplitThreshold, options);
    } else {
      let dir = await parent2.get(pathElem);
      if (!dir || !(dir instanceof dir_default2)) {
        dir = new dir_flat_default({
          root: false,
          dir: true,
          parent: parent2,
          parentKey: pathElem,
          path: currentPath,
          dirty: true,
          flat: true,
          mtime: dir && dir.unixfs && dir.unixfs.mtime,
          mode: dir && dir.unixfs && dir.unixfs.mode
        }, options);
      }
      await parent2.put(pathElem, dir);
      parent2 = dir;
    }
  }
  return tree2;
}
async function* flushAndYield(tree2, blockstore) {
  if (!(tree2 instanceof dir_default2)) {
    if (tree2 && tree2.unixfs && tree2.unixfs.isDirectory()) {
      yield tree2;
    }
    return;
  }
  yield* tree2.flush(blockstore);
}
async function* treeBuilder(source, block, options) {
  let tree2 = new dir_flat_default({
    root: true,
    dir: true,
    path: "",
    dirty: true,
    flat: true
  }, options);
  for await (const entry of source) {
    if (!entry) {
      continue;
    }
    tree2 = await addToTree(entry, tree2, options);
    if (!entry.unixfs || !entry.unixfs.isDirectory()) {
      yield entry;
    }
  }
  if (options.wrapWithDirectory) {
    yield* flushAndYield(tree2, block);
  } else {
    for await (const unwrapped of tree2.eachChildSeries()) {
      if (!unwrapped) {
        continue;
      }
      yield* flushAndYield(unwrapped.child, block);
    }
  }
}
var tree_builder_default = treeBuilder;
async function* importer2(source, blockstore, options = {}) {
  const opts = options_default(options);
  let dagBuilder2;
  if (typeof options.dagBuilder === "function") {
    dagBuilder2 = options.dagBuilder;
  } else {
    dagBuilder2 = dag_builder_default;
  }
  let treeBuilder2;
  if (typeof options.treeBuilder === "function") {
    treeBuilder2 = options.treeBuilder;
  } else {
    treeBuilder2 = tree_builder_default;
  }
  let candidates;
  if (Symbol.asyncIterator in source || Symbol.iterator in source) {
    candidates = source;
  } else {
    candidates = [source];
  }
  for await (const entry of treeBuilder2(parallelBatch(dagBuilder2(candidates, blockstore, opts), opts.fileImportConcurrency), blockstore, opts)) {
    yield {
      cid: entry.cid,
      path: entry.path,
      unixfs: entry.unixfs,
      size: entry.size
    };
  }
}
var import_err_code37 = __toESM(require_err_code(), 1);
async function* normaliseCandidateMultiple(input, normaliseContent3) {
  if (typeof input === "string" || input instanceof String || isBytes(input) || isBlob$1(input) || input._readableState) {
    throw (0, import_err_code37.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isReadableStream(input)) {
    input = browserReadableStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = peekableIterator(input);
    const { value: value2, done } = await peekable.peek();
    if (done) {
      yield* [];
      return;
    }
    peekable.push(value2);
    if (Number.isInteger(value2)) {
      throw (0, import_err_code37.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
    }
    if (value2._readableState) {
      yield* map(peekable, (value3) => toFileObject2({ content: value3 }, normaliseContent3));
      return;
    }
    if (isBytes(value2)) {
      yield toFileObject2({ content: peekable }, normaliseContent3);
      return;
    }
    if (isFileObject(value2) || value2[Symbol.iterator] || value2[Symbol.asyncIterator] || isReadableStream(value2) || isBlob$1(value2)) {
      yield* map(peekable, (value3) => toFileObject2(value3, normaliseContent3));
      return;
    }
  }
  if (isFileObject(input)) {
    throw (0, import_err_code37.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  throw (0, import_err_code37.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject2(input, normaliseContent3) {
  const { path: path2, mode, mtime, content } = input;
  const file = {
    path: path2 || "",
    mode: parseMode(mode),
    mtime: parseMtime(mtime)
  };
  if (content) {
    file.content = await normaliseContent3(content);
  } else if (!path2) {
    file.content = await normaliseContent3(input);
  }
  return file;
}
function normaliseInput3(input) {
  return normaliseCandidateMultiple(input, normaliseContent);
}
var parseChunkerString = (chunker) => {
  if (!chunker) {
    return {
      chunker: "fixed"
    };
  } else if (chunker.startsWith("size-")) {
    const sizeStr = chunker.split("-")[1];
    const size = parseInt(sizeStr);
    if (isNaN(size)) {
      throw new Error("Chunker parameter size must be an integer");
    }
    return {
      chunker: "fixed",
      maxChunkSize: size
    };
  } else if (chunker.startsWith("rabin")) {
    return {
      chunker: "rabin",
      ...parseRabinString(chunker)
    };
  } else {
    throw new Error(`Unrecognized chunker option: ${chunker}`);
  }
};
var parseRabinString = (chunker) => {
  const options = {};
  const parts2 = chunker.split("-");
  switch (parts2.length) {
    case 1:
      options.avgChunkSize = 262144;
      break;
    case 2:
      options.avgChunkSize = parseChunkSize(parts2[1], "avg");
      break;
    case 4:
      options.minChunkSize = parseChunkSize(parts2[1], "min");
      options.avgChunkSize = parseChunkSize(parts2[2], "avg");
      options.maxChunkSize = parseChunkSize(parts2[3], "max");
      break;
    default:
      throw new Error('Incorrect chunker format (expected "rabin" "rabin-[avg]" or "rabin-[min]-[avg]-[max]"');
  }
  return options;
};
var parseChunkSize = (str, name9) => {
  const size = parseInt(str);
  if (isNaN(size)) {
    throw new Error(`Chunker parameter ${name9} must be an integer`);
  }
  return size;
};
var mergeOptions3 = merge_options_default.bind({ ignoreUndefined: true });
function createAddAll2({ repo, preload: preload2, hashers, options }) {
  const isShardingEnabled = options && options.sharding;
  async function* addAll(source, options2 = {}) {
    const opts = mergeOptions3({
      shardSplitThreshold: isShardingEnabled ? 1e3 : Infinity,
      strategy: "balanced"
    }, options2, {
      ...parseChunkerString(options2.chunker)
    });
    if (opts.hashAlg && opts.hashAlg !== "sha2-256" && opts.cidVersion !== 1) {
      opts.cidVersion = 1;
    }
    if (opts.trickle) {
      opts.strategy = "trickle";
    }
    if (opts.strategy === "trickle") {
      opts.leafType = "raw";
      opts.reduceSingleLeafToSelf = false;
    }
    if (opts.cidVersion > 0 && opts.rawLeaves === void 0) {
      opts.rawLeaves = true;
    }
    if (opts.hashAlg !== void 0 && opts.rawLeaves === void 0) {
      opts.rawLeaves = true;
    }
    delete opts.trickle;
    const totals = {};
    if (opts.progress) {
      const prog = opts.progress;
      opts.progress = (bytes2, path2) => {
        if (!totals[path2]) {
          totals[path2] = 0;
        }
        totals[path2] += bytes2;
        prog(totals[path2], path2);
      };
    }
    let hasher;
    if (opts.hashAlg != null) {
      hasher = await hashers.getHasher(opts.hashAlg);
    }
    const iterator = pipe(
      normaliseInput3(source),
      /**
       * @param {Source<import('ipfs-unixfs-importer').ImportCandidate>} source
       */
      (source2) => importer2(source2, repo.blocks, {
        ...opts,
        hasher,
        pin: false
      }),
      transformFile(opts),
      preloadFile(preload2, opts),
      pinFile(repo, opts)
    );
    const releaseLock = await repo.gcLock.readLock();
    try {
      for await (const added of iterator) {
        const path2 = added.path ?? added.cid.toString();
        delete totals[path2];
        yield {
          ...added,
          path: path2
        };
      }
    } finally {
      releaseLock();
    }
  }
  return withTimeoutOption(addAll);
}
function transformFile(opts) {
  async function* transformFile2(source) {
    for await (const file of source) {
      let cid = file.cid;
      if (opts.cidVersion === 1) {
        cid = cid.toV1();
      }
      let path2 = file.path ? file.path : cid.toString();
      if (opts.wrapWithDirectory && !file.path) {
        path2 = "";
      }
      yield {
        path: path2,
        cid,
        size: file.size,
        mode: file.unixfs && file.unixfs.mode,
        mtime: file.unixfs && file.unixfs.mtime
      };
    }
  }
  return transformFile2;
}
function preloadFile(preload2, opts) {
  async function* maybePreloadFile(source) {
    for await (const file of source) {
      const isRootFile = !file.path || opts.wrapWithDirectory ? file.path === "" : !file.path.includes("/");
      const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false;
      if (shouldPreload) {
        preload2(file.cid);
      }
      yield file;
    }
  }
  return maybePreloadFile;
}
function pinFile(repo, opts) {
  async function* maybePinFile(source) {
    for await (const file of source) {
      const isRootDir = !(file.path && file.path.includes("/"));
      const shouldPin = (opts.pin == null ? true : opts.pin) && isRootDir && !opts.onlyHash;
      if (shouldPin) {
        await repo.pins.pinRecursively(file.cid);
      }
      yield file;
    }
  }
  return maybePinFile;
}
var import_err_code45 = __toESM(require_err_code());
var import_err_code44 = __toESM(require_err_code(), 1);
var import_err_code40 = __toESM(require_err_code(), 1);
var hashFn = async function(buf2) {
  return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
};
var addLinksToHamtBucket = (links3, bucket, rootBucket) => {
  return Promise.all(
    links3.map((link) => {
      if (link.Name == null) {
        throw new Error("Unexpected Link without a Name");
      }
      if (link.Name.length === 2) {
        const pos = parseInt(link.Name, 16);
        return bucket._putObjectAt(pos, new Bucket({
          hash: rootBucket._options.hash,
          bits: rootBucket._options.bits
        }, bucket, pos));
      }
      return rootBucket.put(link.Name.substring(2), true);
    })
  );
};
var toPrefix = (position) => {
  return position.toString(16).toUpperCase().padStart(2, "0").substring(0, 2);
};
var toBucketPath = (position) => {
  let bucket = position.bucket;
  const path2 = [];
  while (bucket._parent) {
    path2.push(bucket);
    bucket = bucket._parent;
  }
  path2.push(bucket);
  return path2.reverse();
};
var findShardCid = async (node, name9, blockstore, context, options) => {
  if (!context) {
    const rootBucket = createHAMT({
      hashFn
    });
    context = {
      rootBucket,
      hamtDepth: 1,
      lastBucket: rootBucket
    };
  }
  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);
  const position = await context.rootBucket._findNewBucketAndPos(name9);
  let prefix = toPrefix(position.pos);
  const bucketPath = toBucketPath(position);
  if (bucketPath.length > context.hamtDepth) {
    context.lastBucket = bucketPath[context.hamtDepth];
    prefix = toPrefix(context.lastBucket._posAtParent);
  }
  const link = node.Links.find((link2) => {
    if (link2.Name == null) {
      return false;
    }
    const entryPrefix = link2.Name.substring(0, 2);
    const entryName = link2.Name.substring(2);
    if (entryPrefix !== prefix) {
      return false;
    }
    if (entryName && entryName !== name9) {
      return false;
    }
    return true;
  });
  if (!link) {
    return null;
  }
  if (link.Name != null && link.Name.substring(2) === name9) {
    return link.Hash;
  }
  context.hamtDepth++;
  const block = await blockstore.get(link.Hash, options);
  node = decode2$1(block);
  return findShardCid(node, name9, blockstore, context, options);
};
var find_cid_in_shard_default = findShardCid;
function extractDataFromBlock(block, blockStart, requestedStart, requestedEnd) {
  const blockLength = block.length;
  const blockEnd = blockStart + blockLength;
  if (requestedStart >= blockEnd || requestedEnd < blockStart) {
    return new Uint8Array(0);
  }
  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {
    block = block.subarray(0, requestedEnd - blockStart);
  }
  if (requestedStart >= blockStart && requestedStart < blockEnd) {
    block = block.subarray(requestedStart - blockStart);
  }
  return block;
}
var extract_data_from_block_default = extractDataFromBlock;
var import_err_code38 = __toESM(require_err_code(), 1);
var validateOffsetAndLength = (size, offset, length3) => {
  if (!offset) {
    offset = 0;
  }
  if (offset < 0) {
    throw (0, import_err_code38.default)(new Error("Offset must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
  }
  if (offset > size) {
    throw (0, import_err_code38.default)(new Error("Offset must be less than the file size"), "ERR_INVALID_PARAMS");
  }
  if (!length3 && length3 !== 0) {
    length3 = size - offset;
  }
  if (length3 < 0) {
    throw (0, import_err_code38.default)(new Error("Length must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
  }
  if (offset + length3 > size) {
    length3 = size - offset;
  }
  return {
    offset,
    length: length3
  };
};
var validate_offset_and_length_default = validateOffsetAndLength;
var import_err_code39 = __toESM(require_err_code(), 1);
async function walkDAG(blockstore, node, queue, streamPosition, start, end, walkQueue, options) {
  if (node instanceof Uint8Array) {
    queue.push(extract_data_from_block_default(node, streamPosition, start, end));
    return;
  }
  if (node.Data == null) {
    throw (0, import_err_code39.default)(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
  }
  let file;
  try {
    file = UnixFS.unmarshal(node.Data);
  } catch (err2) {
    throw (0, import_err_code39.default)(err2, "ERR_NOT_UNIXFS");
  }
  if (file.data != null) {
    const data = file.data;
    const buf2 = extract_data_from_block_default(data, streamPosition, start, end);
    queue.push(buf2);
    streamPosition += buf2.byteLength;
  }
  const childOps = [];
  for (let i2 = 0; i2 < node.Links.length; i2++) {
    const childLink = node.Links[i2];
    const childStart = streamPosition;
    const childEnd = childStart + file.blockSizes[i2];
    if (start >= childStart && start < childEnd || // child has offset byte
    end >= childStart && end <= childEnd || // child has end byte
    start < childStart && end > childEnd) {
      childOps.push({
        link: childLink,
        blockStart: streamPosition
      });
    }
    streamPosition = childEnd;
    if (streamPosition > end) {
      break;
    }
  }
  await pipe(
    childOps,
    (source) => map(source, (op) => {
      return async () => {
        const block = await blockstore.get(op.link.Hash, {
          signal: options.signal
        });
        return {
          ...op,
          block
        };
      };
    }),
    (source) => parallel(source, {
      ordered: true
    }),
    async (source) => {
      for await (const { link, block, blockStart } of source) {
        let child;
        switch (link.Hash.code) {
          case code:
            child = decode2$1(block);
            break;
          case code6:
            child = block;
            break;
          default:
            queue.end((0, import_err_code39.default)(new Error(`Unsupported codec: ${link.Hash.code}`), "ERR_NOT_UNIXFS"));
            return;
        }
        walkQueue.add(async () => {
          await walkDAG(blockstore, child, queue, blockStart, start, end, walkQueue, options);
        });
      }
    }
  );
}
var fileContent = (cid, node, unixfs, path2, resolve7, depth, blockstore) => {
  async function* yieldFileContent(options = {}) {
    const fileSize = unixfs.fileSize();
    if (fileSize === void 0) {
      throw new Error("File was a directory");
    }
    const {
      offset,
      length: length3
    } = validate_offset_and_length_default(fileSize, options.offset, options.length);
    if (length3 === 0) {
      return;
    }
    const walkQueue = new PQueue({
      concurrency: 1
    });
    const queue = pushable();
    walkQueue.add(async () => {
      await walkDAG(blockstore, node, queue, 0, offset, offset + length3, walkQueue, options);
    });
    walkQueue.on("error", (error) => {
      queue.end(error);
    });
    let read2 = 0;
    for await (const buf2 of queue) {
      if (buf2 == null) {
        continue;
      }
      read2 += buf2.byteLength;
      if (read2 === length3) {
        queue.end();
      }
      yield buf2;
    }
  }
  return yieldFileContent;
};
var file_default2 = fileContent;
var directoryContent = (cid, node, unixfs, path2, resolve7, depth, blockstore) => {
  async function* yieldDirectoryContent(options = {}) {
    const offset = options.offset || 0;
    const length3 = options.length || node.Links.length;
    const links3 = node.Links.slice(offset, length3);
    for (const link of links3) {
      const result = await resolve7(link.Hash, link.Name || "", `${path2}/${link.Name || ""}`, [], depth + 1, blockstore, options);
      if (result.entry) {
        yield result.entry;
      }
    }
  }
  return yieldDirectoryContent;
};
var directory_default = directoryContent;
var hamtShardedDirectoryContent = (cid, node, unixfs, path2, resolve7, depth, blockstore) => {
  function yieldHamtDirectoryContent(options = {}) {
    return listDirectory(node, path2, resolve7, depth, blockstore, options);
  }
  return yieldHamtDirectoryContent;
};
async function* listDirectory(node, path2, resolve7, depth, blockstore, options) {
  const links3 = node.Links;
  for (const link of links3) {
    const name9 = link.Name != null ? link.Name.substring(2) : null;
    if (name9) {
      const result = await resolve7(link.Hash, name9, `${path2}/${name9}`, [], depth + 1, blockstore, options);
      yield result.entry;
    } else {
      const block = await blockstore.get(link.Hash);
      node = decode2$1(block);
      for await (const file of listDirectory(node, path2, resolve7, depth, blockstore, options)) {
        yield file;
      }
    }
  }
}
var hamt_sharded_directory_default = hamtShardedDirectoryContent;
var findLinkCid = (node, name9) => {
  const link = node.Links.find((link2) => link2.Name === name9);
  return link && link.Hash;
};
var contentExporters = {
  raw: file_default2,
  file: file_default2,
  directory: directory_default,
  "hamt-sharded-directory": hamt_sharded_directory_default,
  metadata: (cid, node, unixfs, path2, resolve7, depth, blockstore) => {
    return () => [];
  },
  symlink: (cid, node, unixfs, path2, resolve7, depth, blockstore) => {
    return () => [];
  }
};
var unixFsResolver = async (cid, name9, path2, toResolve, resolve7, depth, blockstore, options) => {
  const block = await blockstore.get(cid, options);
  const node = decode2$1(block);
  let unixfs;
  let next;
  if (!name9) {
    name9 = cid.toString();
  }
  if (node.Data == null) {
    throw (0, import_err_code40.default)(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
  }
  try {
    unixfs = UnixFS.unmarshal(node.Data);
  } catch (err2) {
    throw (0, import_err_code40.default)(err2, "ERR_NOT_UNIXFS");
  }
  if (!path2) {
    path2 = name9;
  }
  if (toResolve.length) {
    let linkCid;
    if (unixfs && unixfs.type === "hamt-sharded-directory") {
      linkCid = await find_cid_in_shard_default(node, toResolve[0], blockstore);
    } else {
      linkCid = findLinkCid(node, toResolve[0]);
    }
    if (!linkCid) {
      throw (0, import_err_code40.default)(new Error("file does not exist"), "ERR_NOT_FOUND");
    }
    const nextName = toResolve.shift();
    const nextPath = `${path2}/${nextName}`;
    next = {
      cid: linkCid,
      toResolve,
      name: nextName || "",
      path: nextPath
    };
  }
  return {
    entry: {
      type: unixfs.isDirectory() ? "directory" : "file",
      name: name9,
      path: path2,
      cid,
      // @ts-ignore
      content: contentExporters[unixfs.type](cid, node, unixfs, path2, resolve7, depth, blockstore),
      unixfs,
      depth,
      node,
      size: unixfs.fileSize()
    },
    next
  };
};
var unixfs_v1_default = unixFsResolver;
var import_err_code41 = __toESM(require_err_code(), 1);
var rawContent = (node) => {
  async function* contentGenerator(options = {}) {
    const {
      offset,
      length: length3
    } = validate_offset_and_length_default(node.length, options.offset, options.length);
    yield extract_data_from_block_default(node, 0, offset, offset + length3);
  }
  return contentGenerator;
};
var resolve2 = async (cid, name9, path2, toResolve, resolve7, depth, blockstore, options) => {
  if (toResolve.length) {
    throw (0, import_err_code41.default)(new Error(`No link named ${path2} found in raw node ${cid}`), "ERR_NOT_FOUND");
  }
  const block = await blockstore.get(cid, options);
  return {
    entry: {
      type: "raw",
      name: name9,
      path: path2,
      cid,
      content: rawContent(block),
      depth,
      size: block.length,
      node: block
    }
  };
};
var raw_default = resolve2;
var import_err_code42 = __toESM(require_err_code(), 1);
var resolve3 = async (cid, name9, path2, toResolve, resolve7, depth, blockstore, options) => {
  const block = await blockstore.get(cid);
  const object = decode4(block);
  let subObject = object;
  let subPath = path2;
  while (toResolve.length) {
    const prop = toResolve[0];
    if (prop in subObject) {
      toResolve.shift();
      subPath = `${subPath}/${prop}`;
      const subObjectCid = CID.asCID(subObject[prop]);
      if (subObjectCid) {
        return {
          entry: {
            type: "object",
            name: name9,
            path: path2,
            cid,
            node: block,
            depth,
            size: block.length,
            content: async function* () {
              yield object;
            }
          },
          next: {
            cid: subObjectCid,
            name: prop,
            path: subPath,
            toResolve
          }
        };
      }
      subObject = subObject[prop];
    } else {
      throw (0, import_err_code42.default)(new Error(`No property named ${prop} found in cbor node ${cid}`), "ERR_NO_PROP");
    }
  }
  return {
    entry: {
      type: "object",
      name: name9,
      path: path2,
      cid,
      node: block,
      depth,
      size: block.length,
      content: async function* () {
        yield object;
      }
    }
  };
};
var dag_cbor_default = resolve3;
var import_err_code43 = __toESM(require_err_code(), 1);
var rawContent2 = (node) => {
  async function* contentGenerator(options = {}) {
    const {
      offset,
      length: length3
    } = validate_offset_and_length_default(node.length, options.offset, options.length);
    yield extract_data_from_block_default(node, 0, offset, offset + length3);
  }
  return contentGenerator;
};
var resolve4 = async (cid, name9, path2, toResolve, resolve7, depth, blockstore, options) => {
  if (toResolve.length) {
    throw (0, import_err_code43.default)(new Error(`No link named ${path2} found in raw node ${cid}`), "ERR_NOT_FOUND");
  }
  const buf2 = await decode3$3(cid.multihash.bytes);
  return {
    entry: {
      type: "identity",
      name: name9,
      path: path2,
      cid,
      content: rawContent2(buf2.digest),
      depth,
      size: buf2.digest.length,
      node: buf2.digest
    }
  };
};
var identity_default = resolve4;
var resolvers2 = {
  [code]: unixfs_v1_default,
  [code6]: raw_default,
  [code2]: dag_cbor_default,
  [identity.code]: identity_default
};
function resolve5(cid, name9, path2, toResolve, depth, blockstore, options) {
  const resolver = resolvers2[cid.code];
  if (!resolver) {
    throw (0, import_err_code44.default)(new Error(`No resolver for code ${cid.code}`), "ERR_NO_RESOLVER");
  }
  return resolver(cid, name9, path2, toResolve, resolve5, depth, blockstore, options);
}
var resolvers_default = resolve5;
var toPathComponents2 = (path2 = "") => {
  return (path2.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
};
var cidAndRest = (path2) => {
  if (path2 instanceof Uint8Array) {
    return {
      cid: CID.decode(path2),
      toResolve: []
    };
  }
  const cid = CID.asCID(path2);
  if (cid) {
    return {
      cid,
      toResolve: []
    };
  }
  if (typeof path2 === "string") {
    if (path2.indexOf("/ipfs/") === 0) {
      path2 = path2.substring(6);
    }
    const output = toPathComponents2(path2);
    return {
      cid: CID.parse(output[0]),
      toResolve: output.slice(1)
    };
  }
  throw (0, import_err_code45.default)(new Error(`Unknown path type ${path2}`), "ERR_BAD_PATH");
};
async function* walkPath(path2, blockstore, options = {}) {
  let {
    cid,
    toResolve
  } = cidAndRest(path2);
  let name9 = cid.toString();
  let entryPath = name9;
  const startingDepth = toResolve.length;
  while (true) {
    const result = await resolvers_default(cid, name9, entryPath, toResolve, startingDepth, blockstore, options);
    if (!result.entry && !result.next) {
      throw (0, import_err_code45.default)(new Error(`Could not resolve ${path2}`), "ERR_NOT_FOUND");
    }
    if (result.entry) {
      yield result.entry;
    }
    if (!result.next) {
      return;
    }
    toResolve = result.next.toResolve;
    cid = result.next.cid;
    name9 = result.next.name;
    entryPath = result.next.path;
  }
}
async function exporter2(path2, blockstore, options = {}) {
  const result = await last(walkPath(path2, blockstore, options));
  if (!result) {
    throw (0, import_err_code45.default)(new Error(`Could not resolve ${path2}`), "ERR_NOT_FOUND");
  }
  return result;
}
async function* recursive(path2, blockstore, options = {}) {
  const node = await exporter2(path2, blockstore, options);
  if (!node) {
    return;
  }
  yield node;
  if (node.type === "directory") {
    for await (const child of recurse(node, options)) {
      yield child;
    }
  }
  async function* recurse(node2, options2) {
    for await (const file of node2.content(options2)) {
      yield file;
      if (file instanceof Uint8Array) {
        continue;
      }
      if (file.type === "directory") {
        yield* recurse(file, options2);
      }
    }
  }
}
function createCat({ repo, preload: preload2 }) {
  async function* cat(ipfsPath3, options = {}) {
    ipfsPath3 = normalizeCidPath(ipfsPath3);
    if (options.preload !== false) {
      const pathComponents = ipfsPath3.split("/");
      preload2(CID.parse(pathComponents[0]));
    }
    const file = await exporter2(ipfsPath3, repo.blocks, options);
    if (file.type === "directory") {
      throw new Error("this dag node is a directory");
    }
    if (!file.content) {
      throw new Error("this dag node has no content");
    }
    yield* file.content(options);
  }
  return withTimeoutOption(cat);
}
var import_err_code46 = __toESM(require_err_code(), 1);
function compare2(a, b) {
  for (let i2 = 0; i2 < a.byteLength; i2++) {
    if (a[i2] < b[i2]) {
      return -1;
    }
    if (a[i2] > b[i2]) {
      return 1;
    }
  }
  if (a.byteLength > b.byteLength) {
    return 1;
  }
  if (a.byteLength < b.byteLength) {
    return -1;
  }
  return 0;
}
fromString3("ustar\0", "binary");
fromString3("ustar ", "binary");
fromString3(" \0", "binary");
function reader2(source) {
  const reader3 = async function* () {
    let bytes2 = yield;
    let bl = new Uint8ArrayList();
    for await (const chunk of source) {
      if (bytes2 == null) {
        bl.append(chunk);
        bytes2 = yield bl;
        bl = new Uint8ArrayList();
        continue;
      }
      bl.append(chunk);
      while (bl.length >= bytes2) {
        const data = bl.sublist(0, bytes2);
        bl.consume(bytes2);
        bytes2 = yield data;
        if (bytes2 == null) {
          if (bl.length > 0) {
            bytes2 = yield bl;
            bl = new Uint8ArrayList();
          }
          break;
        }
      }
    }
    if (bytes2 != null) {
      throw Object.assign(new Error(`stream ended before ${bytes2} bytes became available`), { code: "ERR_UNDER_READ", buffer: bl });
    }
  }();
  void reader3.next();
  return reader3;
}
var import_iso_constants = __toESM(require_index_browser(), 1);
var ZEROS = "0000000000000000000";
var SEVENS = "7777777777777777777";
var ZERO_OFFSET2 = "0".charCodeAt(0);
var USTAR_MAGIC2 = fromString3("ustar\0", "binary");
var USTAR_VER = fromString3("00", "binary");
var MASK = parseInt("7777", 8);
var MAGIC_OFFSET = 257;
var VERSION_OFFSET = 263;
var toTypeflag = function(flag) {
  switch (flag) {
    case "file":
      return 0;
    case "link":
      return 1;
    case "symlink":
      return 2;
    case "character-device":
      return 3;
    case "block-device":
      return 4;
    case "directory":
      return 5;
    case "fifo":
      return 6;
    case "contiguous-file":
      return 7;
    case "pax-header":
      return 72;
    default:
      return 0;
  }
};
var cksum = function(block) {
  let sum = 8 * 32;
  for (let i2 = 0; i2 < 148; i2++)
    sum += block[i2];
  for (let j = 156; j < 512; j++)
    sum += block[j];
  return sum;
};
var encodeOct = function(val, n) {
  const str = val.toString(8);
  if (str.length > n) {
    return fromString3(SEVENS.slice(0, n) + " ");
  }
  return fromString3(ZEROS.slice(0, n - str.length) + str + " ");
};
var addLength = function(str) {
  const len = fromString3(str).byteLength;
  let digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
  if (len + digits >= Math.pow(10, digits)) {
    digits++;
  }
  return `${len + digits}${str}`;
};
function encodePax(opts) {
  let result = "";
  if (opts.name != null) {
    result += addLength(" path=" + opts.name + "\n");
  }
  if (opts.linkname != null) {
    result += addLength(" linkpath=" + opts.linkname + "\n");
  }
  const pax = opts.pax;
  if (pax != null) {
    for (const key in pax) {
      if (Object.prototype.hasOwnProperty.call(pax, key)) {
        result += addLength(" " + key + "=" + pax[key] + "\n");
      }
    }
  }
  return fromString3(result);
}
function encode13(opts) {
  const buf2 = new Uint8Array(512);
  let name9 = opts.name;
  let prefix = "";
  if (opts.typeflag === 5 && name9[name9.length - 1] !== "/") {
    name9 += "/";
  }
  if (fromString3(name9).byteLength !== name9.length) {
    return null;
  }
  while (fromString3(name9).byteLength > 100) {
    const i2 = name9.indexOf("/");
    if (i2 === -1) {
      return null;
    }
    prefix += prefix !== "" ? "/" + name9.slice(0, i2) : name9.slice(0, i2);
    name9 = name9.slice(i2 + 1);
  }
  if (fromString3(name9).byteLength > 100 || fromString3(prefix).byteLength > 155) {
    return null;
  }
  if (opts.linkname != null && fromString3(opts.linkname).byteLength > 100) {
    return null;
  }
  buf2.set(fromString3(name9), 0);
  buf2.set(encodeOct(opts.mode & MASK, 6), 100);
  buf2.set(encodeOct(opts.uid, 6), 108);
  buf2.set(encodeOct(opts.gid, 6), 116);
  buf2.set(encodeOct(opts.size, 11), 124);
  buf2.set(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
  buf2[156] = ZERO_OFFSET2 + toTypeflag(opts.type);
  if (opts.linkname != null) {
    buf2.set(fromString3(opts.linkname), 157);
  }
  buf2.set(USTAR_MAGIC2, MAGIC_OFFSET);
  buf2.set(USTAR_VER, VERSION_OFFSET);
  if (opts.uname != null) {
    buf2.set(fromString3(opts.uname), 265);
  }
  if (opts.gname != null) {
    buf2.set(fromString3(opts.gname), 297);
  }
  buf2.set(encodeOct(opts.devmajor ?? 0, 6), 329);
  buf2.set(encodeOct(opts.devminor ?? 0, 6), 337);
  if (prefix != null) {
    buf2.set(fromString3(prefix), 345);
  }
  buf2.set(encodeOct(cksum(buf2), 6), 148);
  return buf2;
}
var { S_IFMT, S_IFBLK, S_IFCHR, S_IFDIR, S_IFIFO, S_IFLNK } = import_iso_constants.default;
var DMODE = parseInt("755", 8);
var FMODE = parseInt("644", 8);
var END_OF_TAR = new Uint8Array(1024);
function modeToType(mode = 0) {
  switch (mode & S_IFMT) {
    case S_IFBLK:
      return "block-device";
    case S_IFCHR:
      return "character-device";
    case S_IFDIR:
      return "directory";
    case S_IFIFO:
      return "fifo";
    case S_IFLNK:
      return "symlink";
    default:
      return "file";
  }
}
function getPadding(size) {
  size &= 511;
  if (size !== 0) {
    return END_OF_TAR.subarray(0, 512 - size);
  }
  return new Uint8Array(0);
}
function encode14(header) {
  if (header.pax == null) {
    const encoded = encode13(header);
    if (encoded != null) {
      return encoded;
    }
  }
  return encodePax2(header);
}
function encodePax2(header) {
  const paxHeader = encodePax(header);
  const newHeader = {
    name: "PaxHeader",
    mode: header.mode,
    uid: header.uid,
    gid: header.gid,
    size: paxHeader.length,
    mtime: header.mtime,
    type: "pax-header",
    linkname: header.linkname,
    uname: header.uname,
    gname: header.gname,
    devmajor: header.devmajor,
    devminor: header.devminor
  };
  return new Uint8ArrayList(encode13(newHeader) ?? new Uint8Array(0), paxHeader, getPadding(paxHeader.length), encode13({ ...newHeader, size: header.size, type: header.type }) ?? new Uint8Array(0)).subarray();
}
function pack() {
  return async function* (source) {
    for await (let { header: partialHeader, body } of source) {
      const header = {
        ...partialHeader,
        size: partialHeader.type === "symlink" ? 0 : partialHeader.size ?? 0,
        type: partialHeader.type ?? modeToType(partialHeader.mode),
        mode: partialHeader.mode ?? (partialHeader.type === "directory" ? DMODE : FMODE),
        uid: partialHeader.uid ?? 0,
        gid: partialHeader.gid ?? 0,
        mtime: partialHeader.mtime ?? new Date()
      };
      if (typeof body === "string") {
        body = fromString3(body);
      }
      if (body instanceof Uint8Array || isUint8ArrayList(body)) {
        header.size = body.length;
        yield encode14(header);
        yield isUint8ArrayList(body) ? body.subarray() : body;
        yield getPadding(header.size);
        continue;
      }
      if (header.type === "symlink" && header.linkname == null) {
        if (body == null) {
          throw new Error("type was symlink but no linkname or body specified");
        }
        header.linkname = toString3(await toBuffer(body));
        yield encode14(header);
        continue;
      }
      yield encode14(header);
      if (header.type !== "file" && header.type !== "contiguous-file") {
        continue;
      }
      let written = 0;
      for await (const chunk of body ?? []) {
        written += chunk.length;
        yield isUint8ArrayList(chunk) ? chunk.subarray() : chunk;
      }
      if (written !== header.size) {
        throw new Error(`size mismatch, wrote ${written} of ${header.size} bytes`);
      }
      yield getPadding(header.size);
    }
    yield END_OF_TAR;
  };
}
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf2) {
  let len = buf2.length;
  while (--len >= 0) {
    buf2[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
var extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
var extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
var send_bits = (s, value2, length3) => {
  if (s.bi_valid > Buf_size - length3) {
    s.bi_buf |= value2 << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value2 >> Buf_size - s.bi_valid;
    s.bi_valid += length3 - Buf_size;
  } else {
    s.bi_buf |= value2 << s.bi_valid & 65535;
    s.bi_valid += length3;
  }
};
var send_code = (s, c, tree2) => {
  send_bits(
    s,
    tree2[c * 2],
    tree2[c * 2 + 1]
    /*.Len*/
  );
};
var bi_reverse = (code8, len) => {
  let res = 0;
  do {
    res |= code8 & 1;
    code8 >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree2 = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base3 = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits2;
  let xbits;
  let f;
  let overflow = 0;
  for (bits2 = 0; bits2 <= MAX_BITS$1; bits2++) {
    s.bl_count[bits2] = 0;
  }
  tree2[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits2 = tree2[tree2[n * 2 + 1] * 2 + 1] + 1;
    if (bits2 > max_length) {
      bits2 = max_length;
      overflow++;
    }
    tree2[n * 2 + 1] = bits2;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits2]++;
    xbits = 0;
    if (n >= base3) {
      xbits = extra[n - base3];
    }
    f = tree2[n * 2];
    s.opt_len += f * (bits2 + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits2 = max_length - 1;
    while (s.bl_count[bits2] === 0) {
      bits2--;
    }
    s.bl_count[bits2]--;
    s.bl_count[bits2 + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits2 = max_length; bits2 !== 0; bits2--) {
    n = s.bl_count[bits2];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree2[m * 2 + 1] !== bits2) {
        s.opt_len += (bits2 - tree2[m * 2 + 1]) * tree2[m * 2];
        tree2[m * 2 + 1] = bits2;
      }
      n--;
    }
  }
};
var gen_codes = (tree2, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code8 = 0;
  let bits2;
  let n;
  for (bits2 = 1; bits2 <= MAX_BITS$1; bits2++) {
    code8 = code8 + bl_count[bits2 - 1] << 1;
    next_code[bits2] = code8;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree2[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree2[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n;
  let bits2;
  let length3;
  let code8;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length3 = 0;
  for (code8 = 0; code8 < LENGTH_CODES$1 - 1; code8++) {
    base_length[code8] = length3;
    for (n = 0; n < 1 << extra_lbits[code8]; n++) {
      _length_code[length3++] = code8;
    }
  }
  _length_code[length3 - 1] = code8;
  dist = 0;
  for (code8 = 0; code8 < 16; code8++) {
    base_dist[code8] = dist;
    for (n = 0; n < 1 << extra_dbits[code8]; n++) {
      _dist_code[dist++] = code8;
    }
  }
  dist >>= 7;
  for (; code8 < D_CODES$1; code8++) {
    base_dist[code8] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code8] - 7; n++) {
      _dist_code[256 + dist++] = code8;
    }
  }
  for (bits2 = 0; bits2 <= MAX_BITS$1; bits2++) {
    bl_count[bits2] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var smaller = (tree2, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree2[_n2] < tree2[_m2] || tree2[_n2] === tree2[_m2] && depth[n] <= depth[m];
};
var pqdownheap = (s, tree2, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree2, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree2, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code8;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code8 = _length_code[lc];
        send_code(s, code8 + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code8];
        if (extra !== 0) {
          lc -= base_length[code8];
          send_bits(s, lc, extra);
        }
        dist--;
        code8 = d_code(dist);
        send_code(s, code8, dtree);
        extra = extra_dbits[code8];
        if (extra !== 0) {
          dist -= base_dist[code8];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree2 = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree2[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree2[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree2[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree2, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree2,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree2[node * 2] = tree2[n * 2] + tree2[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree2[n * 2 + 1] = tree2[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree2,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree2, max_code, s.bl_count);
};
var scan_tree = (s, tree2, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree2[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree2[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree2[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree2, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree2[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree2[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf2, stored_len, last2) => {
  send_bits(s, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf2, buf2 + stored_len), s.pending);
  }
  s.pending += stored_len;
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf2, stored_len, last2) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf2 !== -1) {
    _tr_stored_block$1(s, buf2, stored_len, last2);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last2) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf2, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf2[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table2 = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table2[n] = c;
  }
  return table2;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf2, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i2 = pos; i2 < end; i2++) {
    crc = crc >>> 8 ^ t[(crc ^ buf2[i2]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank$1 = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
var zero = (buf2) => {
  let len = buf2.length;
  while (--len >= 0) {
    buf2[len] = 0;
  }
};
var slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
};
var HASH_ZLIB = (s, prev2, data) => (prev2 << s.hash_shift ^ data) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last2) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last2);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
var putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
var read_buf = (strm, buf2, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf2.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf2, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf2, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev2 = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev2[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush3) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last2 = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush3 !== Z_FINISH$3 || flush3 === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last2 = flush3 === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last2);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last2 === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last2) {
    return BS_FINISH_DONE;
  }
  if (flush3 !== Z_NO_FLUSH$2 && flush3 !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush3 === Z_FINISH$3) && flush3 !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last2 = flush3 === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last2);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last2 ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s, flush3) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush3 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush3 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush3) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush3 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush3 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush3) => {
  let bflush;
  let prev2;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush3 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev2 = _win[scan];
      if (prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush3 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush3) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush3 === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush3 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap2 = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap2 = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap2 !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap2;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush3) => {
  if (deflateStateCheck(strm) || flush3 > Z_BLOCK$1 || flush3 < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush3 !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush3;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank$1(flush3) <= rank$1(old_flush) && flush3 !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush3 !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush3) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush3) : s.strategy === Z_RLE ? deflate_rle(s, flush3) : configuration_table[s.level].func(s, flush3);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush3 === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush3 !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush3 === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush3 !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap2 = s.wrap;
  if (wrap2 === 2 || wrap2 === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap2 === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap2 === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap2;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i2 = 0, l = chunks.length; i2 < l; i2++) {
    len += chunks[i2].length;
  }
  const result = new Uint8Array(len);
  for (let i2 = 0, pos = 0, l = chunks.length; i2 < l; i2++) {
    let chunk = chunks[i2];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf2, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf2 = new Uint8Array(buf_len);
  for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf2[i2++] = c;
    } else if (c < 2048) {
      buf2[i2++] = 192 | c >>> 6;
      buf2[i2++] = 128 | c & 63;
    } else if (c < 65536) {
      buf2[i2++] = 224 | c >>> 12;
      buf2[i2++] = 128 | c >>> 6 & 63;
      buf2[i2++] = 128 | c & 63;
    } else {
      buf2[i2++] = 240 | c >>> 18;
      buf2[i2++] = 128 | c >>> 12 & 63;
      buf2[i2++] = 128 | c >>> 6 & 63;
      buf2[i2++] = 128 | c & 63;
    }
  }
  return buf2;
};
var buf2binstring = (buf2, len) => {
  if (len < 65534) {
    if (buf2.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf2.length === len ? buf2 : buf2.subarray(0, len));
    }
  }
  let result = "";
  for (let i2 = 0; i2 < len; i2++) {
    result += String.fromCharCode(buf2[i2]);
  }
  return result;
};
var buf2string = (buf2, max) => {
  const len = max || buf2.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf2.subarray(0, max));
  }
  let i2, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i2 = 0; i2 < len; ) {
    let c = buf2[i2++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i2 += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i2 < len) {
      c = c << 6 | buf2[i2++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf2, max) => {
  max = max || buf2.length;
  if (max > buf2.length) {
    max = buf2.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf2[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf2[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last2;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits2;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from3;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last2 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits2 = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits2 < 15) {
        hold += input[_in++] << bits2;
        bits2 += 8;
        hold += input[_in++] << bits2;
        bits2 += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits2 -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits2 < op) {
                hold += input[_in++] << bits2;
                bits2 += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits2 -= op;
            }
            if (bits2 < 15) {
              hold += input[_in++] << bits2;
              bits2 += 8;
              hold += input[_in++] << bits2;
              bits2 += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits2 -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits2 < op) {
                    hold += input[_in++] << bits2;
                    bits2 += 8;
                    if (bits2 < op) {
                      hold += input[_in++] << bits2;
                      bits2 += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits2 -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from3 = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from3 += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from3++];
                        } while (--op);
                        from3 = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from3 += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from3++];
                        } while (--op);
                        from3 = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from3++];
                          } while (--op);
                          from3 = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from3 += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from3++];
                        } while (--op);
                        from3 = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from3++];
                      output[_out++] = from_source[from3++];
                      output[_out++] = from_source[from3++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from3++];
                      if (len > 1) {
                        output[_out++] = from_source[from3++];
                      }
                    }
                  } else {
                    from3 = _out - dist;
                    do {
                      output[_out++] = output[from3++];
                      output[_out++] = output[from3++];
                      output[_out++] = output[from3++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from3++];
                      if (len > 1) {
                        output[_out++] = output[from3++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last2 && _out < end);
  len = bits2 >> 3;
  _in -= len;
  bits2 -= len << 3;
  hold &= (1 << bits2) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits2;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type, lens, lens_index, codes6, table2, table_index, work, opts) => {
  const bits2 = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root2 = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base3 = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes6; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root2 = bits2;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root2 > max) {
    root2 = max;
  }
  if (max === 0) {
    table2[table_index++] = 1 << 24 | 64 << 16 | 0;
    table2[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root2 < min) {
    root2 = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes6; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base3 = extra = work;
    match = 20;
  } else if (type === LENS$1) {
    base3 = lbase;
    extra = lext;
    match = 257;
  } else {
    base3 = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root2;
  drop = 0;
  low = -1;
  used = 1 << root2;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base3[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table2[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root2 && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root2;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table2[low] = root2 << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table2[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root2;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE2 = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap2;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else {
    wrap2 = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap2;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src2, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src2.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src2.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src2.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush3) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits2;
  let _in, _out;
  let copy;
  let from3;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits2 = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits2 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits2 = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits2 -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits2 = 0;
          break;
        case FLAGS:
          while (bits2 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits2 = 0;
          state.mode = TIME;
        case TIME:
          while (bits2 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits2 = 0;
          state.mode = OS;
        case OS:
          while (bits2 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits2 = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits2 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits2 = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits2 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits2 = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits2 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits2 = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits2;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush3 === Z_BLOCK || flush3 === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits2 & 7;
            bits2 -= bits2 & 7;
            state.mode = CHECK;
            break;
          }
          while (bits2 < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits2 -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush3 === Z_TREES) {
                hold >>>= 2;
                bits2 -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits2 -= 2;
          break;
        case STORED:
          hold >>>= bits2 & 7;
          bits2 -= bits2 & 7;
          while (bits2 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits2 = 0;
          state.mode = COPY_;
          if (flush3 === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits2 < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits2 -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits2 -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits2 -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits2 < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits2 -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits2) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits2 -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits2 < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits2;
                  bits2 += 8;
                }
                hold >>>= here_bits;
                bits2 -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits2 -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits2 < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits2;
                  bits2 += 8;
                }
                hold >>>= here_bits;
                bits2 -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits2 -= 3;
              } else {
                n = here_bits + 7;
                while (bits2 < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits2;
                  bits2 += 8;
                }
                hold >>>= here_bits;
                bits2 -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits2 -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush3 === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits2;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits2 = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits2) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits2) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            hold >>>= last_bits;
            bits2 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits2 -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits2 < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits2 -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits2) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits2) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            hold >>>= last_bits;
            bits2 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits2 -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits2 < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits2 -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from3 = state.wsize - copy;
            } else {
              from3 = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from3 = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from3++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits2 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits2;
              bits2 += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits2 = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits2 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits2 = 0;
          }
          state.mode = DONE2;
        case DONE2:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits2;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush3 !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush3 === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString5 = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString5.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString5.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var Deflate_1 = Deflate;
var deflate_1 = deflate;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var Inflate_1 = Inflate;
var inflate_1 = inflate;
var inflateRaw_1 = inflateRaw;
var ungzip_1 = ungzip;
var constants_1 = constants$2;
var pako = {
  Deflate: Deflate_1,
  deflate: deflate_1,
  deflateRaw: deflateRaw_1,
  gzip: gzip_1,
  Inflate: Inflate_1,
  inflate: inflate_1,
  inflateRaw: inflateRaw_1,
  ungzip: ungzip_1,
  constants: constants_1
};
var DEFAULT_COMPRESSION_LEVEL = 6;
function createGet2({ repo, preload: preload2 }) {
  async function* get3(ipfsPath3, options = {}) {
    if (options.compressionLevel != null && (options.compressionLevel < -1 || options.compressionLevel > 9)) {
      throw (0, import_err_code46.default)(new Error("Compression level must be between -1 and 9"), "ERR_INVALID_PARAMS");
    }
    if (options.preload !== false) {
      let pathComponents;
      try {
        pathComponents = normalizeCidPath(ipfsPath3).split("/");
      } catch (err2) {
        throw (0, import_err_code46.default)(err2, "ERR_INVALID_PATH");
      }
      preload2(CID.parse(pathComponents[0]));
    }
    const ipfsPathOrCid = CID.asCID(ipfsPath3) || ipfsPath3;
    const file = await exporter2(ipfsPathOrCid, repo.blocks, options);
    if (file.type === "file" || file.type === "raw") {
      const args = [];
      if (!options.compress || options.archive === true) {
        args.push(
          [{
            header: {
              name: file.path,
              mode: file.type === "file" && file.unixfs.mode,
              mtime: file.type === "file" && file.unixfs.mtime ? new Date(file.unixfs.mtime.secs * 1e3) : void 0,
              size: file.size,
              type: "file"
            },
            body: file.content()
          }],
          pack()
        );
      } else {
        args.push(
          file.content
        );
      }
      if (options.compress) {
        args.push(
          /**
           * @param {AsyncIterable<Uint8Array>} source
           */
          async function* (source) {
            const buf2 = await toBuffer(source);
            yield pako.gzip(buf2, {
              level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL
            });
          }
        );
      }
      yield* pipe(...args);
      return;
    }
    if (file.type === "directory") {
      const args = [
        recursive(ipfsPathOrCid, repo.blocks, options),
        /**
         * @param {AsyncIterable<import('ipfs-unixfs-exporter').UnixFSEntry>} source
         */
        async function* (source) {
          for await (const entry of source) {
            const output = {
              header: {
                name: entry.path,
                size: entry.size
              }
            };
            if (entry.type === "file") {
              output.header.type = "file";
              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : void 0;
              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1e3) : void 0;
              output.body = entry.content();
            } else if (entry.type === "raw") {
              output.header.type = "file";
              output.body = entry.content();
            } else if (entry.type === "directory") {
              output.header.type = "directory";
              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : void 0;
              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1e3) : void 0;
            } else {
              throw (0, import_err_code46.default)(new Error("Not a UnixFS node"), "ERR_NOT_UNIXFS");
            }
            yield output;
          }
        },
        pack()
      ];
      if (options.compress) {
        if (!options.archive) {
          throw (0, import_err_code46.default)(new Error("file is not regular"), "ERR_INVALID_PATH");
        }
        if (options.compress) {
          args.push(
            /**
             * @param {AsyncIterable<Uint8Array>} source
             */
            async function* (source) {
              const buf2 = await toBuffer(source);
              yield pako.gzip(buf2, {
                level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL
              });
            }
          );
        }
      }
      yield* pipe(...args);
      return;
    }
    throw (0, import_err_code46.default)(new Error("Not a UnixFS node"), "ERR_NOT_UNIXFS");
  }
  return withTimeoutOption(get3);
}
var import_err_code47 = __toESM(require_err_code(), 1);
function createLs2({ repo, preload: preload2 }) {
  async function* ls(ipfsPath3, options = {}) {
    const legacyPath = normalizeCidPath(ipfsPath3);
    const pathComponents = legacyPath.split("/");
    if (options.preload !== false) {
      preload2(CID.parse(pathComponents[0]));
    }
    const ipfsPathOrCid = CID.asCID(legacyPath) || legacyPath;
    const file = await exporter2(ipfsPathOrCid, repo.blocks, options);
    if (file.type === "file") {
      yield mapFile(file);
      return;
    }
    if (file.type === "directory") {
      for await (const child of file.content()) {
        yield mapFile(child);
      }
      return;
    }
    throw (0, import_err_code47.default)(new Error(`Unknown UnixFS type ${file.type}`), "ERR_UNKNOWN_UNIXFS_TYPE");
  }
  return withTimeoutOption(ls);
}
var RootAPI = class {
  /**
   * @param {Context} context
   */
  constructor({ preload: preload2, repo, hashers, options }) {
    const addAll = createAddAll2({
      preload: preload2,
      repo,
      options,
      hashers
    });
    this.addAll = addAll;
    this.add = createAdd3({ addAll });
    this.cat = createCat({ repo, preload: preload2 });
    this.get = createGet2({ repo, preload: preload2 });
    this.ls = createLs2({ repo, preload: preload2 });
  }
};
var ipfsCore = "0.18.0";
var commit = "";
var interfaceIpfsCore = "^0.158.0";
function createVersion({ repo }) {
  async function version3(_options = {}) {
    const repoVersion2 = await repo.version.get();
    return {
      version: ipfsCore,
      commit,
      repo: `${repoVersion2}`,
      "ipfs-core": ipfsCore,
      "interface-ipfs-core": interfaceIpfsCore
    };
  }
  return withTimeoutOption(version3);
}
var import_err_code48 = __toESM(require_err_code(), 1);
var log16 = logger("ipfs:components:id");
function createId({ peerId, network }) {
  async function id(options = {}) {
    const net = network.try();
    if (!net) {
      if (options.peerId) {
        throw new NotStartedError();
      }
      if (peerId.publicKey == null) {
        throw (0, import_err_code48.default)(new Error("Public key missing"), "ERR_MISSING_PUBLIC_KEY");
      }
      return {
        id: peerId,
        publicKey: toString3(peerId.publicKey, "base64pad"),
        addresses: [],
        agentVersion: `js-ipfs/${ipfsCore}`,
        protocolVersion: "9000",
        protocols: []
      };
    }
    const { libp2p } = net;
    const peerIdToId = options.peerId ? options.peerId : peerId;
    const peer = await findPeer(peerIdToId, libp2p, options);
    const agentVersion = toString3(peer.metadata.get("AgentVersion") || new Uint8Array());
    const protocolVersion = toString3(peer.metadata.get("ProtocolVersion") || new Uint8Array());
    const idStr = peer.id.toString();
    const publicKeyStr = peer.publicKey ? toString3(peer.publicKey, "base64pad") : "";
    return {
      id: peerIdToId,
      publicKey: publicKeyStr,
      addresses: (peer.addresses || []).map((ma) => {
        const str = ma.toString();
        if (str.endsWith(`/p2p/${idStr}`)) {
          return str;
        }
        return `${str}/p2p/${idStr}`;
      }).sort().map((ma) => multiaddr(ma)),
      agentVersion,
      protocolVersion,
      protocols: (peer.protocols || []).sort()
    };
  }
  return withTimeoutOption(id);
}
async function findPeer(peerId, libp2p, options) {
  let peer = await libp2p.peerStore.get(peerId);
  if (!peer) {
    peer = await findPeerOnDht(peerId, libp2p, options);
  }
  let publicKey = peerId.publicKey ? peerId.publicKey : await libp2p.peerStore.keyBook.get(peerId);
  if (publicKey == null) {
    try {
      publicKey = await libp2p.getPublicKey(peerId, options);
    } catch (err2) {
      log16.error("Could not load public key for", peerId.toString(), err2);
    }
  }
  return {
    ...peer,
    publicKey,
    metadata: peer.metadata || /* @__PURE__ */ new Map(),
    addresses: peer.addresses.map((addr) => addr.multiaddr)
  };
}
async function findPeerOnDht(peerId, libp2p, options) {
  if (libp2p.dht == null) {
    throw (0, import_err_code48.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
  }
  for await (const event of libp2p.dht.findPeer(peerId, options)) {
    if (event.name === "FINAL_PEER") {
      break;
    }
  }
  const peer = await libp2p.peerStore.get(peerId);
  if (!peer) {
    throw (0, import_err_code48.default)(new Error("Could not find peer"), "ERR_NOT_FOUND");
  }
  return peer;
}
var objectSafeSet = set;
function set(obj, propsArg, value2) {
  var props, lastProp;
  if (Array.isArray(propsArg)) {
    props = propsArg.slice(0);
  }
  if (typeof propsArg == "string") {
    props = propsArg.split(".");
  }
  if (typeof propsArg == "symbol") {
    props = [propsArg];
  }
  if (!Array.isArray(props)) {
    throw new Error("props arg must be an array, a string or a symbol");
  }
  lastProp = props.pop();
  if (!lastProp) {
    return false;
  }
  prototypeCheck(lastProp);
  var thisProp;
  while (thisProp = props.shift()) {
    prototypeCheck(thisProp);
    if (typeof obj[thisProp] == "undefined") {
      obj[thisProp] = {};
    }
    obj = obj[thisProp];
    if (!obj || typeof obj != "object") {
      return false;
    }
  }
  obj[lastProp] = value2;
  return true;
}
function prototypeCheck(prop) {
  if (prop == "__proto__" || prop == "constructor" || prop == "prototype") {
    throw new Error("setting of prototype values not supported");
  }
}
var profiles = {
  server: {
    description: "Recommended for nodes with public IPv4 address (servers, VPSes, etc.), disables host and content discovery and UPnP in local networks.",
    transform: (config2) => {
      objectSafeSet(config2, "Discovery.MDNS.Enabled", false);
      objectSafeSet(config2, "Discovery.webRTCStar.Enabled", false);
      config2.Swarm = {
        ...config2.Swarm || {},
        DisableNatPortMap: true
      };
      return config2;
    }
  },
  "local-discovery": {
    description: "Sets default values to fields affected by `server` profile, enables discovery and UPnP in local networks.",
    transform: (config2) => {
      objectSafeSet(config2, "Discovery.MDNS.Enabled", true);
      objectSafeSet(config2, "Discovery.webRTCStar.Enabled", true);
      objectSafeSet(config2, "Swarm", {
        ...config2.Swarm || {},
        DisableNatPortMap: false
      });
      return config2;
    }
  },
  test: {
    description: "Reduces external interference, useful for running ipfs in test environments. Note that with these settings node won't be able to talk to the rest of the network without manual bootstrap.",
    transform: (config2) => {
      const defaultConfig = config_browser_default();
      objectSafeSet(config2, "Addresses.API", defaultConfig.Addresses.API ? "/ip4/127.0.0.1/tcp/0" : "");
      objectSafeSet(config2, "Addresses.Gateway", defaultConfig.Addresses.Gateway ? "/ip4/127.0.0.1/tcp/0" : "");
      objectSafeSet(config2, "Addresses.Swarm", defaultConfig.Addresses.Swarm.length ? ["/ip4/127.0.0.1/tcp/0"] : []);
      objectSafeSet(config2, "Addresses.Delegates", []);
      objectSafeSet(config2, "Bootstrap", []);
      objectSafeSet(config2, "Discovery.MDNS.Enabled", false);
      objectSafeSet(config2, "Discovery.webRTCStar.Enabled", false);
      objectSafeSet(config2, "Swarm", {
        ...config2.Swarm || {},
        DisableNatPortMap: true
      });
      return config2;
    }
  },
  "default-networking": {
    description: "Restores default network settings. Inverse profile of the `test` profile.",
    transform: (config2) => {
      const defaultConfig = config_browser_default();
      objectSafeSet(config2, "Addresses.API", defaultConfig.Addresses.API);
      objectSafeSet(config2, "Addresses.Gateway", defaultConfig.Addresses.Gateway);
      objectSafeSet(config2, "Addresses.Swarm", defaultConfig.Addresses.Swarm);
      objectSafeSet(config2, "Addresses.Delegates", defaultConfig.Addresses.Delegates);
      objectSafeSet(config2, "Bootstrap", defaultConfig.Bootstrap);
      objectSafeSet(config2, "Discovery.MDNS.Enabled", defaultConfig.Discovery.MDNS.Enabled);
      objectSafeSet(config2, "Discovery.webRTCStar.Enabled", defaultConfig.Discovery.webRTCStar.Enabled);
      objectSafeSet(config2, "Swarm", {
        ...config2.Swarm || {},
        DisableNatPortMap: false
      });
      return config2;
    }
  },
  lowpower: {
    description: "Reduces daemon overhead on the system. May affect node functionality,performance of content discovery and data fetching may be degraded. Recommended for low power systems.",
    transform: (config2) => {
      const Swarm = config2.Swarm || {};
      const ConnMgr = Swarm.ConnMgr || {};
      ConnMgr.LowWater = 20;
      ConnMgr.HighWater = 40;
      Swarm.ConnMgr = ConnMgr;
      config2.Swarm = Swarm;
      return config2;
    }
  },
  "default-power": {
    description: 'Inverse of "lowpower" profile.',
    transform: (config2) => {
      const defaultConfig = config_browser_default();
      config2.Swarm = defaultConfig.Swarm;
      return config2;
    }
  }
};
var log17 = logger("ipfs:core:config");
function createConfig({ repo }) {
  return {
    getAll: withTimeoutOption(getAll),
    get: withTimeoutOption(get3),
    set: withTimeoutOption(set2),
    replace: withTimeoutOption(replace),
    profiles: {
      apply: withTimeoutOption(applyProfile),
      list: withTimeoutOption(listProfiles)
    }
  };
  async function getAll(options = {}) {
    return repo.config.getAll(options);
  }
  async function get3(key, options) {
    if (!key) {
      return Promise.reject(new Error("key argument is required"));
    }
    return repo.config.get(key, options);
  }
  async function set2(key, value2, options) {
    return repo.config.set(key, value2, options);
  }
  async function replace(value2, options) {
    return repo.config.replace(value2, options);
  }
  async function applyProfile(profileName, options = { dryRun: false }) {
    const { dryRun } = options;
    const profile = profiles[profileName];
    if (!profile) {
      throw new Error(`No profile with name '${profileName}' exists`);
    }
    try {
      const oldCfg = await repo.config.getAll(options);
      let newCfg = JSON.parse(JSON.stringify(oldCfg));
      newCfg = profile.transform(newCfg);
      if (!dryRun) {
        await repo.config.replace(newCfg, options);
      }
      delete oldCfg.Identity.PrivKey;
      delete newCfg.Identity.PrivKey;
      return { original: oldCfg, updated: newCfg };
    } catch (err2) {
      log17(err2);
      throw new Error(`Could not apply profile '${profileName}' to config: ${err2.message}`);
    }
  }
}
async function listProfiles(_options) {
  return Object.keys(profiles).map((name9) => ({
    name: name9,
    description: profiles[name9].description
  }));
}
function readonly({ enumerable = true, configurable = false } = {}) {
  return { enumerable, configurable, writable: false };
}
function* linksWithin(path2, value2) {
  if (value2 != null && typeof value2 === "object") {
    if (Array.isArray(value2)) {
      for (const [index2, element] of value2.entries()) {
        const elementPath = [...path2, index2];
        const cid = CID.asCID(element);
        if (cid) {
          yield [elementPath.join("/"), cid];
        } else if (typeof element === "object") {
          yield* links2(element, elementPath);
        }
      }
    } else {
      const cid = CID.asCID(value2);
      if (cid) {
        yield [path2.join("/"), cid];
      } else {
        yield* links2(value2, path2);
      }
    }
  }
}
function* links2(source, base3) {
  if (source == null || source instanceof Uint8Array) {
    return;
  }
  const cid = CID.asCID(source);
  if (cid) {
    yield [base3.join("/"), cid];
  }
  for (const [key, value2] of Object.entries(source)) {
    const path2 = (
      /** @type {[string|number, string]} */
      [...base3, key]
    );
    yield* linksWithin(path2, value2);
  }
}
function* treeWithin(path2, value2) {
  if (Array.isArray(value2)) {
    for (const [index2, element] of value2.entries()) {
      const elementPath = [...path2, index2];
      yield elementPath.join("/");
      if (typeof element === "object" && !CID.asCID(element)) {
        yield* tree(element, elementPath);
      }
    }
  } else {
    yield* tree(value2, path2);
  }
}
function* tree(source, base3) {
  if (source == null || typeof source !== "object") {
    return;
  }
  for (const [key, value2] of Object.entries(source)) {
    const path2 = (
      /** @type {[string|number, string]} */
      [...base3, key]
    );
    yield path2.join("/");
    if (value2 != null && !(value2 instanceof Uint8Array) && typeof value2 === "object" && !CID.asCID(value2)) {
      yield* treeWithin(path2, value2);
    }
  }
}
function get(source, path2) {
  let node = (
    /** @type {Record<string, any>} */
    source
  );
  for (const [index2, key] of path2.entries()) {
    node = node[key];
    if (node == null) {
      throw new Error(`Object has no property at ${path2.slice(0, index2 + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID.asCID(node);
    if (cid) {
      return { value: cid, remaining: path2.slice(index2 + 1).join("/") };
    }
  }
  return { value: node };
}
var Block$1 = class Block3 {
  /**
   * @param {object} options
   * @param {CID<T, C, A, V>} options.cid
   * @param {API.ByteView<T>} options.bytes
   * @param {T} options.value
   */
  constructor({ cid, bytes: bytes2, value: value2 }) {
    if (!cid || !bytes2 || typeof value2 === "undefined") {
      throw new Error("Missing required argument");
    }
    this.cid = cid;
    this.bytes = bytes2;
    this.value = value2;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly(),
      bytes: readonly(),
      value: readonly(),
      asBlock: readonly()
    });
  }
  links() {
    return links2(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  /**
   *
   * @param {string} [path]
   * @returns {API.BlockCursorView<unknown>}
   */
  get(path2 = "/") {
    return get(this.value, path2.split("/").filter(Boolean));
  }
};
function createUnsafe({ bytes: bytes2, cid, value: maybeValue, codec }) {
  const value2 = maybeValue !== void 0 ? maybeValue : codec && codec.decode(bytes2);
  if (value2 === void 0)
    throw new Error('Missing required argument, must either provide "value" or "codec"');
  return new Block$1({
    // eslint-disable-next-line object-shorthand
    cid: (
      /** @type {CID<T, Code, Alg, V>} */
      cid
    ),
    bytes: bytes2,
    value: value2
  });
}
var import_varint4 = __toESM(require_varint(), 1);
function createHeader(roots) {
  const headerBytes = encode3({ version: 1, roots });
  const varintBytes = import_varint4.default.encode(headerBytes.length);
  const header = new Uint8Array(varintBytes.length + headerBytes.length);
  header.set(varintBytes, 0);
  header.set(headerBytes, varintBytes.length);
  return header;
}
function createEncoder(writer2) {
  return {
    /**
     * @param {CID[]} roots
     * @returns {Promise<void>}
     */
    async setRoots(roots) {
      const bytes2 = createHeader(roots);
      await writer2.write(bytes2);
    },
    /**
     * @param {Block} block
     * @returns {Promise<void>}
     */
    async writeBlock(block) {
      const { cid, bytes: bytes2 } = block;
      await writer2.write(new Uint8Array(import_varint4.default.encode(cid.bytes.length + bytes2.length)));
      await writer2.write(cid.bytes);
      if (bytes2.length) {
        await writer2.write(bytes2);
      }
    },
    /**
     * @returns {Promise<void>}
     */
    async close() {
      await writer2.end();
    }
  };
}
function noop$1() {
}
function create6() {
  const chunkQueue = [];
  let drainer = null;
  let drainerResolver = noop$1;
  let ended = false;
  let outWait = null;
  let outWaitResolver = noop$1;
  const makeDrainer = () => {
    if (!drainer) {
      drainer = new Promise((resolve7) => {
        drainerResolver = () => {
          drainer = null;
          drainerResolver = noop$1;
          resolve7();
        };
      });
    }
    return drainer;
  };
  const writer2 = {
    /**
     * @param {T} chunk
     * @returns {Promise<void>}
     */
    write(chunk) {
      chunkQueue.push(chunk);
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    },
    async end() {
      ended = true;
      const drainer2 = makeDrainer();
      outWaitResolver();
      await drainer2;
    }
  };
  const iterator = {
    /** @returns {Promise<IteratorResult<T>>} */
    async next() {
      const chunk = chunkQueue.shift();
      if (chunk) {
        if (chunkQueue.length === 0) {
          drainerResolver();
        }
        return { done: false, value: chunk };
      }
      if (ended) {
        drainerResolver();
        return { done: true, value: void 0 };
      }
      if (!outWait) {
        outWait = new Promise((resolve7) => {
          outWaitResolver = () => {
            outWait = null;
            outWaitResolver = noop$1;
            return resolve7(iterator.next());
          };
        });
      }
      return outWait;
    }
  };
  return { writer: writer2, iterator };
}
var import_varint5 = __toESM(require_varint(), 1);
var Kinds = {
  Null: (
    /**
     * @param {any} obj
     * @returns {boolean}
     */
    (obj) => obj === null
  ),
  Int: (
    /**
     * @param {any} obj
     * @returns {boolean}
     */
    (obj) => Number.isInteger(obj)
  ),
  Float: (
    /**
     * @param {any} obj
     * @returns {boolean}
     */
    (obj) => typeof obj === "number" && Number.isFinite(obj)
  ),
  String: (
    /**
     * @param {any} obj
     * @returns {boolean}
     */
    (obj) => typeof obj === "string"
  ),
  Bool: (
    /**
     * @param {any} obj
     * @returns {boolean}
     */
    (obj) => typeof obj === "boolean"
  ),
  Bytes: (
    /**
     * @param {any} obj
     * @returns {boolean}
     */
    (obj) => obj instanceof Uint8Array
  ),
  Link: (
    /**
     * @param {any} obj
     * @returns {boolean}
     */
    (obj) => !Kinds.Null(obj) && typeof obj === "object" && obj.asCID === obj
  ),
  List: (
    /**
     * @param {any} obj
     * @returns {boolean}
     */
    (obj) => Array.isArray(obj)
  ),
  Map: (
    /**
     * @param {any} obj
     * @returns {boolean}
     */
    (obj) => !Kinds.Null(obj) && typeof obj === "object" && obj.asCID !== obj && !Kinds.List(obj) && !Kinds.Bytes(obj)
  )
};
var Types = {
  Int: Kinds.Int,
  "CarHeader > version": (
    /**
     * @param {any} obj
     * @returns {boolean}
     */
    (obj) => Types.Int(obj)
  ),
  "CarHeader > roots (anon) > valueType (anon)": Kinds.Link,
  "CarHeader > roots (anon)": (
    /**
     * @param {any} obj
     * @returns {boolean}
     */
    (obj) => Kinds.List(obj) && Array.prototype.every.call(obj, Types["CarHeader > roots (anon) > valueType (anon)"])
  ),
  "CarHeader > roots": (
    /**
     * @param {any} obj
     * @returns {boolean}
     */
    (obj) => Types["CarHeader > roots (anon)"](obj)
  ),
  CarHeader: (
    /**
     * @param {any} obj
     * @returns {boolean}
     */
    (obj) => {
      const keys = obj && Object.keys(obj);
      return Kinds.Map(obj) && ["version"].every((k) => keys.includes(k)) && Object.entries(obj).every(([name9, value2]) => Types["CarHeader > " + name9] && Types["CarHeader > " + name9](value2));
    }
  )
};
var CarHeader = Types.CarHeader;
var CIDV0_BYTES = {
  SHA2_256: 18,
  LENGTH: 32,
  DAG_PB: 112
};
var V2_HEADER_LENGTH = (
  /* characteristics */
  16 + 8 + 8 + 8
);
async function readVarint(reader3) {
  const bytes2 = await reader3.upTo(8);
  if (!bytes2.length) {
    throw new Error("Unexpected end of data");
  }
  const i2 = import_varint5.default.decode(bytes2);
  reader3.seek(
    /** @type {number} */
    import_varint5.default.decode.bytes
  );
  return i2;
}
async function readV2Header(reader3) {
  const bytes2 = await reader3.exactly(V2_HEADER_LENGTH);
  const dv = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
  let offset = 0;
  const header = {
    version: 2,
    /** @type {[bigint, bigint]} */
    characteristics: [
      dv.getBigUint64(offset, true),
      dv.getBigUint64(offset += 8, true)
    ],
    dataOffset: Number(dv.getBigUint64(offset += 8, true)),
    dataSize: Number(dv.getBigUint64(offset += 8, true)),
    indexOffset: Number(dv.getBigUint64(offset += 8, true))
  };
  reader3.seek(V2_HEADER_LENGTH);
  return header;
}
async function readHeader(reader3, strictVersion) {
  const length3 = await readVarint(reader3);
  if (length3 === 0) {
    throw new Error("Invalid CAR header (zero length)");
  }
  const header = await reader3.exactly(length3);
  reader3.seek(length3);
  const block = decode4(header);
  if (!CarHeader(block)) {
    throw new Error("Invalid CAR header format");
  }
  if (block.version !== 1 && block.version !== 2 || strictVersion !== void 0 && block.version !== strictVersion) {
    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== void 0 ? ` (expected ${strictVersion})` : ""}`);
  }
  const hasRoots = Array.isArray(block.roots);
  if (block.version === 1 && !hasRoots || block.version === 2 && hasRoots) {
    throw new Error("Invalid CAR header format");
  }
  if (block.version === 1) {
    return block;
  }
  const v2Header = await readV2Header(reader3);
  reader3.seek(v2Header.dataOffset - reader3.pos);
  const v1Header = await readHeader(reader3, 1);
  return Object.assign(v1Header, v2Header);
}
async function readMultihash(reader3) {
  const bytes2 = await reader3.upTo(8);
  import_varint5.default.decode(bytes2);
  const codeLength = (
    /** @type {number} */
    import_varint5.default.decode.bytes
  );
  const length3 = import_varint5.default.decode(bytes2.subarray(import_varint5.default.decode.bytes));
  const lengthLength = (
    /** @type {number} */
    import_varint5.default.decode.bytes
  );
  const mhLength = codeLength + lengthLength + length3;
  const multihash = await reader3.exactly(mhLength);
  reader3.seek(mhLength);
  return multihash;
}
async function readCid(reader3) {
  const first2 = await reader3.exactly(2);
  if (first2[0] === CIDV0_BYTES.SHA2_256 && first2[1] === CIDV0_BYTES.LENGTH) {
    const bytes3 = await reader3.exactly(34);
    reader3.seek(34);
    const multihash2 = decode3$3(bytes3);
    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
  }
  const version3 = await readVarint(reader3);
  if (version3 !== 1) {
    throw new Error(`Unexpected CID version (${version3})`);
  }
  const codec = await readVarint(reader3);
  const bytes2 = await readMultihash(reader3);
  const multihash = decode3$3(bytes2);
  return CID.create(version3, codec, multihash);
}
async function readBlockHead(reader3) {
  const start = reader3.pos;
  let length3 = await readVarint(reader3);
  if (length3 === 0) {
    throw new Error("Invalid CAR section (zero length)");
  }
  length3 += reader3.pos - start;
  const cid = await readCid(reader3);
  const blockLength = length3 - Number(reader3.pos - start);
  return { cid, length: length3, blockLength };
}
async function readBlock(reader3) {
  const { cid, blockLength } = await readBlockHead(reader3);
  const bytes2 = await reader3.exactly(blockLength);
  reader3.seek(blockLength);
  return { bytes: bytes2, cid };
}
async function readBlockIndex(reader3) {
  const offset = reader3.pos;
  const { cid, length: length3, blockLength } = await readBlockHead(reader3);
  const index2 = { cid, length: length3, blockLength, offset, blockOffset: reader3.pos };
  reader3.seek(index2.blockLength);
  return index2;
}
function createDecoder(reader3) {
  const headerPromise = (async () => {
    const header = await readHeader(reader3);
    if (header.version === 2) {
      const v1length = reader3.pos - header.dataOffset;
      reader3 = limitReader(reader3, header.dataSize - v1length);
    }
    return header;
  })();
  return {
    header: () => headerPromise,
    async *blocks() {
      await headerPromise;
      while ((await reader3.upTo(8)).length > 0) {
        yield await readBlock(reader3);
      }
    },
    async *blocksIndex() {
      await headerPromise;
      while ((await reader3.upTo(8)).length > 0) {
        yield await readBlockIndex(reader3);
      }
    }
  };
}
function bytesReader(bytes2) {
  let pos = 0;
  return {
    async upTo(length3) {
      return bytes2.subarray(pos, pos + Math.min(length3, bytes2.length - pos));
    },
    async exactly(length3) {
      if (length3 > bytes2.length - pos) {
        throw new Error("Unexpected end of data");
      }
      return bytes2.subarray(pos, pos + length3);
    },
    seek(length3) {
      pos += length3;
    },
    get pos() {
      return pos;
    }
  };
}
function chunkReader(readChunk) {
  let pos = 0;
  let have = 0;
  let offset = 0;
  let currentChunk = new Uint8Array(0);
  const read2 = async (length3) => {
    have = currentChunk.length - offset;
    const bufa = [currentChunk.subarray(offset)];
    while (have < length3) {
      const chunk = await readChunk();
      if (chunk == null) {
        break;
      }
      if (have < 0) {
        if (chunk.length > have) {
          bufa.push(chunk.subarray(-have));
        }
      } else {
        bufa.push(chunk);
      }
      have += chunk.length;
    }
    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));
    let off = 0;
    for (const b of bufa) {
      currentChunk.set(b, off);
      off += b.length;
    }
    offset = 0;
  };
  return {
    async upTo(length3) {
      if (currentChunk.length - offset < length3) {
        await read2(length3);
      }
      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length3));
    },
    async exactly(length3) {
      if (currentChunk.length - offset < length3) {
        await read2(length3);
      }
      if (currentChunk.length - offset < length3) {
        throw new Error("Unexpected end of data");
      }
      return currentChunk.subarray(offset, offset + length3);
    },
    seek(length3) {
      pos += length3;
      offset += length3;
    },
    get pos() {
      return pos;
    }
  };
}
function asyncIterableReader(asyncIterable) {
  const iterator = asyncIterable[Symbol.asyncIterator]();
  async function readChunk() {
    const next = await iterator.next();
    if (next.done) {
      return null;
    }
    return next.value;
  }
  return chunkReader(readChunk);
}
function limitReader(reader3, byteLimit) {
  let bytesRead = 0;
  return {
    async upTo(length3) {
      let bytes2 = await reader3.upTo(length3);
      if (bytes2.length + bytesRead > byteLimit) {
        bytes2 = bytes2.subarray(0, byteLimit - bytesRead);
      }
      return bytes2;
    },
    async exactly(length3) {
      const bytes2 = await reader3.exactly(length3);
      if (bytes2.length + bytesRead > byteLimit) {
        throw new Error("Unexpected end of data");
      }
      return bytes2;
    },
    seek(length3) {
      bytesRead += length3;
      reader3.seek(length3);
    },
    get pos() {
      return reader3.pos;
    }
  };
}
var CarWriter = class {
  /**
   * @param {CID[]} roots
   * @param {CarEncoder} encoder
   */
  constructor(roots, encoder2) {
    this._encoder = encoder2;
    this._mutex = encoder2.setRoots(roots);
    this._ended = false;
  }
  /**
   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.
   *
   * @function
   * @memberof CarWriter
   * @instance
   * @async
   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.
   * @returns {Promise<void>} The returned promise will only resolve once the
   * bytes this block generates are written to the `out` iterable.
   */
  async put(block) {
    if (!(block.bytes instanceof Uint8Array) || !block.cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    if (this._ended) {
      throw new Error("Already closed");
    }
    const cid = CID.asCID(block.cid);
    if (!cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    this._mutex = this._mutex.then(() => this._encoder.writeBlock({ cid, bytes: block.bytes }));
    return this._mutex;
  }
  /**
   * Finalise the CAR archive and signal that the `out` iterable should end once
   * any remaining bytes are written.
   *
   * @function
   * @memberof CarWriter
   * @instance
   * @async
   * @returns {Promise<void>}
   */
  async close() {
    if (this._ended) {
      throw new Error("Already closed");
    }
    await this._mutex;
    this._ended = true;
    return this._encoder.close();
  }
  /**
   * Create a new CAR writer "channel" which consists of a
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.
   *
   * @async
   * @static
   * @memberof CarWriter
   * @param {CID[] | CID | void} roots
   * @returns {WriterChannel} The channel takes the form of
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.
   */
  static create(roots) {
    roots = toRoots(roots);
    const { encoder: encoder2, iterator } = encodeWriter();
    const writer2 = new CarWriter(roots, encoder2);
    const out = new CarWriterOut(iterator);
    return { writer: writer2, out };
  }
  /**
   * Create a new CAR appender "channel" which consists of a
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.
   * This appender does not consider roots and does not produce a CAR header.
   * It is designed to append blocks to an _existing_ CAR archive. It is
   * expected that `out` will be concatenated onto the end of an existing
   * archive that already has a properly formatted header.
   *
   * @async
   * @static
   * @memberof CarWriter
   * @returns {WriterChannel} The channel takes the form of
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.
   */
  static createAppender() {
    const { encoder: encoder2, iterator } = encodeWriter();
    encoder2.setRoots = () => Promise.resolve();
    const writer2 = new CarWriter([], encoder2);
    const out = new CarWriterOut(iterator);
    return { writer: writer2, out };
  }
  /**
   * Update the list of roots in the header of an existing CAR as represented
   * in a Uint8Array.
   *
   * This operation is an _overwrite_, the total length of the CAR will not be
   * modified. A rejection will occur if the new header will not be the same
   * length as the existing header, in which case the CAR will not be modified.
   * It is the responsibility of the user to ensure that the roots being
   * replaced encode as the same length as the new roots.
   *
   * The byte array passed in an argument will be modified and also returned
   * upon successful modification.
   *
   * @async
   * @static
   * @memberof CarWriter
   * @param {Uint8Array} bytes
   * @param {CID[]} roots - A new list of roots to replace the existing list in
   * the CAR header. The new header must take up the same number of bytes as the
   * existing header, so the roots should collectively be the same byte length
   * as the existing roots.
   * @returns {Promise<Uint8Array>}
   */
  static async updateRootsInBytes(bytes2, roots) {
    const reader3 = bytesReader(bytes2);
    await readHeader(reader3);
    const newHeader = createHeader(roots);
    if (Number(reader3.pos) !== newHeader.length) {
      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader3.pos} bytes, new header is ${newHeader.length} bytes)`);
    }
    bytes2.set(newHeader, 0);
    return bytes2;
  }
};
var CarWriterOut = class {
  /**
   * @param {AsyncIterator<Uint8Array>} iterator
   */
  constructor(iterator) {
    this._iterator = iterator;
  }
  [Symbol.asyncIterator]() {
    if (this._iterating) {
      throw new Error("Multiple iterator not supported");
    }
    this._iterating = true;
    return this._iterator;
  }
};
function encodeWriter() {
  const iw = create6();
  const { writer: writer2, iterator } = iw;
  const encoder2 = createEncoder(writer2);
  return { encoder: encoder2, iterator };
}
function toRoots(roots) {
  if (roots === void 0) {
    return [];
  }
  if (!Array.isArray(roots)) {
    const cid = CID.asCID(roots);
    if (!cid) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    return [cid];
  }
  const _roots = [];
  for (const root2 of roots) {
    const _root = CID.asCID(root2);
    if (!_root) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    _roots.push(_root);
  }
  return _roots;
}
var walk = async ({ cid, load, seen }) => {
  seen = seen || /* @__PURE__ */ new Set();
  const b58Cid = cid.toString(base58btc);
  if (seen.has(b58Cid)) {
    return;
  }
  const block = await load(cid);
  seen.add(b58Cid);
  if (block === null) {
    return;
  }
  for (const [, cid2] of block.links()) {
    await walk({ cid: cid2, load, seen });
  }
};
var log18 = logger("ipfs:components:dag:import");
var NO_LINKS_CODECS = [
  code6,
  code7
  // JSON
];
function createExport({ repo, preload: preload2, codecs: codecs2 }) {
  async function* dagExport(root2, options = {}) {
    if (options.preload !== false) {
      preload2(root2);
    }
    const cid = CID.asCID(root2);
    if (!cid) {
      throw new Error(`Unexpected error converting CID type: ${root2}`);
    }
    log18(`Exporting ${cid} as car`);
    const { writer: writer2, out } = await CarWriter.create([cid]);
    let err2 = null;
    (async () => {
      try {
        const load = makeLoader(repo, writer2, {
          signal: options.signal,
          timeout: options.timeout
        }, codecs2);
        await walk({ cid, load });
      } catch (e) {
        err2 = e;
      } finally {
        writer2.close();
      }
    })();
    for await (const chunk of out) {
      if (err2) {
        break;
      }
      yield chunk;
    }
    if (err2) {
      throw err2;
    }
  }
  return withTimeoutOption(dagExport);
}
function makeLoader(repo, writer2, options, codecs2) {
  return async (cid) => {
    const codec = await codecs2.getCodec(cid.code);
    if (!codec) {
      throw new Error(`Can't decode links in block with codec 0x${cid.code.toString(16)} to form complete DAG`);
    }
    const bytes2 = await repo.blocks.get(cid, options);
    log18(`Adding block ${cid} to car`);
    await writer2.put({ cid, bytes: bytes2 });
    if (NO_LINKS_CODECS.includes(cid.code)) {
      return null;
    }
    return createUnsafe({ bytes: bytes2, cid, codec });
  };
}
async function first(source) {
  for await (const entry of source) {
    return entry;
  }
  return void 0;
}
var import_err_code49 = __toESM(require_err_code(), 1);
function createGet3({ codecs: codecs2, repo, preload: preload2 }) {
  const get3 = async function get4(cid, options = {}) {
    if (options.preload !== false) {
      preload2(cid);
    }
    if (options.path) {
      const entry = options.localResolve ? await first(resolve(cid, options.path, codecs2, repo, options)) : await last(resolve(cid, options.path, codecs2, repo, options));
      const result = entry;
      if (!result) {
        throw (0, import_err_code49.default)(new Error("Not found"), "ERR_NOT_FOUND");
      }
      return result;
    }
    const codec = await codecs2.getCodec(cid.code);
    const block = await repo.blocks.get(cid, options);
    const node = codec.decode(block);
    return {
      value: node,
      remainderPath: ""
    };
  };
  return withTimeoutOption(get3);
}
var CarIteratorBase = class {
  /**
   * @param {number} version
   * @param {CID[]} roots
   * @param {AsyncIterable<Block>|void} iterable
   */
  constructor(version3, roots, iterable) {
    this._version = version3;
    this._roots = roots;
    this._iterable = iterable;
    this._decoded = false;
  }
  get version() {
    return this._version;
  }
  /**
   * @returns {Promise<CID[]>}
   */
  async getRoots() {
    return this._roots;
  }
};
var CarBlockIterator = class extends CarIteratorBase {
  // inherited method
  /**
   * Get the list of roots defined by the CAR referenced by this iterator. May be
   * zero or more `CID`s.
   *
   * @function getRoots
   * @memberof CarBlockIterator
   * @instance
   * @async
   * @returns {Promise<CID[]>}
   */
  /**
   * @returns {AsyncIterator<Block>}
   */
  [Symbol.asyncIterator]() {
    if (this._decoded) {
      throw new Error("Cannot decode more than once");
    }
    if (!this._iterable) {
      throw new Error("Block iterable not found");
    }
    this._decoded = true;
    return this._iterable[Symbol.asyncIterator]();
  }
  /**
   * Instantiate a {@link CarBlockIterator} from a `Uint8Array` blob. Rather
   * than decoding the entire byte array prior to returning the iterator, as in
   * {@link CarReader.fromBytes}, only the header is decoded and the remainder
   * of the CAR is parsed as the `Block`s as yielded.
   *
   * @async
   * @static
   * @memberof CarBlockIterator
   * @param {Uint8Array} bytes
   * @returns {Promise<CarBlockIterator>}
   */
  static async fromBytes(bytes2) {
    const { version: version3, roots, iterator } = await fromBytes2(bytes2);
    return new CarBlockIterator(version3, roots, iterator);
  }
  /**
   * Instantiate a {@link CarBlockIterator} from a `AsyncIterable<Uint8Array>`,
   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
   * Rather than decoding the entire byte array prior to returning the iterator,
   * as in {@link CarReader.fromIterable}, only the header is decoded and the
   * remainder of the CAR is parsed as the `Block`s as yielded.
   *
   * @async
   * @static
   * @param {AsyncIterable<Uint8Array>} asyncIterable
   * @returns {Promise<CarBlockIterator>}
   */
  static async fromIterable(asyncIterable) {
    const { version: version3, roots, iterator } = await fromIterable(asyncIterable);
    return new CarBlockIterator(version3, roots, iterator);
  }
};
async function fromBytes2(bytes2) {
  if (!(bytes2 instanceof Uint8Array)) {
    throw new TypeError("fromBytes() requires a Uint8Array");
  }
  return decodeIterator(bytesReader(bytes2));
}
async function fromIterable(asyncIterable) {
  if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
    throw new TypeError("fromIterable() requires an async iterable");
  }
  return decodeIterator(asyncIterableReader(asyncIterable));
}
async function decodeIterator(reader3) {
  const decoder = createDecoder(reader3);
  const { version: version3, roots } = await decoder.header();
  return { version: version3, roots, iterator: decoder.blocks() };
}
var log19 = logger("ipfs:components:dag:import");
function createImport({ repo }) {
  async function* dagImport(sources, options = {}) {
    const release = await repo.gcLock.readLock();
    try {
      const abortOptions = { signal: options.signal, timeout: options.timeout };
      const peekable = peekableIterator(sources);
      const { value: value2, done } = await peekable.peek();
      if (done) {
        return;
      }
      if (value2) {
        peekable.push(value2);
      }
      let cars;
      if (value2 instanceof Uint8Array) {
        cars = [peekable];
      } else {
        cars = peekable;
      }
      for await (const car of cars) {
        const roots = await importCar(repo, abortOptions, car);
        if (options.pinRoots !== false) {
          for (const cid of roots) {
            let pinErrorMsg = "";
            try {
              if (await repo.blocks.has(cid)) {
                log19(`Pinning root ${cid}`);
                await repo.pins.pinRecursively(cid);
              } else {
                pinErrorMsg = "blockstore: block not found";
              }
            } catch (err2) {
              pinErrorMsg = err2.message;
            }
            yield { root: { cid, pinErrorMsg } };
          }
        }
      }
    } finally {
      release();
    }
  }
  return withTimeoutOption(dagImport);
}
async function importCar(repo, options, source) {
  const reader3 = await CarBlockIterator.fromIterable(source);
  const roots = await reader3.getRoots();
  await drain(
    repo.blocks.putMany(
      map(reader3, ({ cid: key, bytes: value2 }) => {
        log19(`Import block ${key}`);
        return { key, value: value2 };
      }),
      { signal: options.signal }
    )
  );
  return roots;
}
function createPut2({ repo, codecs: codecs2, hashers, preload: preload2 }) {
  async function put(dagNode, options = {}) {
    const release = options.pin ? await repo.gcLock.readLock() : null;
    try {
      const storeCodec = await codecs2.getCodec(options.storeCodec || "dag-cbor");
      if (!storeCodec) {
        throw new Error(`Unknown storeCodec ${options.storeCodec}, please configure additional BlockCodecs for this IPFS instance`);
      }
      if (options.inputCodec) {
        if (!(dagNode instanceof Uint8Array)) {
          throw new Error("Can only inputCodec on raw bytes that can be decoded");
        }
        const inputCodec = await codecs2.getCodec(options.inputCodec);
        if (!inputCodec) {
          throw new Error(`Unknown inputCodec ${options.inputCodec}, please configure additional BlockCodecs for this IPFS instance`);
        }
        dagNode = inputCodec.decode(dagNode);
      }
      const cidVersion = options.version != null ? options.version : 1;
      const hasher = await hashers.getHasher(options.hashAlg || "sha2-256");
      if (!hasher) {
        throw new Error(`Unknown hash algorithm ${options.hashAlg}, please configure additional MultihashHashers for this IPFS instance`);
      }
      const buf2 = storeCodec.encode(dagNode);
      const hash3 = await hasher.digest(buf2);
      const cid = CID.create(cidVersion, storeCodec.code, hash3);
      await repo.blocks.put(cid, buf2, {
        signal: options.signal
      });
      if (options.pin) {
        await repo.pins.pinRecursively(cid);
      }
      if (options.preload !== false) {
        preload2(cid);
      }
      return cid;
    } finally {
      if (release) {
        release();
      }
    }
  }
  return withTimeoutOption(put);
}
function createResolve3({ repo, codecs: codecs2, preload: preload2 }) {
  async function dagResolve(ipfsPath3, options = {}) {
    const {
      cid
    } = toCidAndPath(ipfsPath3);
    if (options.preload !== false) {
      preload2(cid);
    }
    return resolvePath(repo, codecs2, ipfsPath3, options);
  }
  return withTimeoutOption(dagResolve);
}
var DagAPI = class {
  /**
   * @param {object} config
   * @param {import('ipfs-core-utils/multihashes').Multihashes} config.hashers
   * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs
   * @param {import('../../types').Preload} config.preload
   * @param {import('ipfs-repo').IPFSRepo} config.repo
   */
  constructor({ repo, codecs: codecs2, hashers, preload: preload2 }) {
    this.export = createExport({ repo, preload: preload2, codecs: codecs2 });
    this.get = createGet3({ codecs: codecs2, repo, preload: preload2 });
    this.import = createImport({ repo });
    this.resolve = createResolve3({ repo, codecs: codecs2, preload: preload2 });
    this.put = createPut2({ repo, codecs: codecs2, hashers, preload: preload2 });
  }
};
var reduceValue = (_, v) => v;
var tcpUri = (str, port, parts2, opts) => {
  if (opts != null && opts.assumeHttp === false)
    return `tcp://${str}:${port}`;
  let protocol4 = "tcp";
  let explicitPort = `:${port}`;
  const last2 = parts2[parts2.length - 1];
  if (last2.protocol === "tcp") {
    protocol4 = port === "443" ? "https" : "http";
    explicitPort = port === "443" || port === "80" ? "" : explicitPort;
  }
  return `${protocol4}://${str}${explicitPort}`;
};
var Reducers = {
  ip4: reduceValue,
  ip6: (str, content, i2, parts2) => parts2.length === 1 && parts2[0].protocol === "ip6" ? content : `[${content}]`,
  tcp: (str, content, i2, parts2, opts) => parts2.some((p) => ["http", "https", "ws", "wss"].includes(p.protocol)) ? `${str}:${content}` : tcpUri(str, content, parts2, opts),
  udp: (str, content) => `udp://${str}:${content}`,
  dnsaddr: reduceValue,
  dns4: reduceValue,
  dns6: reduceValue,
  ipfs: (str, content) => `${str}/ipfs/${content}`,
  p2p: (str, content) => `${str}/p2p/${content}`,
  http: (str) => `http://${str}`,
  https: (str) => `https://${str}`,
  ws: (str) => `ws://${str}`,
  wss: (str) => `wss://${str}`,
  "p2p-websocket-star": (str) => `${str}/p2p-websocket-star`,
  "p2p-webrtc-star": (str) => `${str}/p2p-webrtc-star`,
  "p2p-webrtc-direct": (str) => `${str}/p2p-webrtc-direct`
};
function multiaddrToUri(input, opts) {
  const ma = multiaddr(input);
  const parts2 = ma.toString().split("/").slice(1);
  return ma.tuples().map((tuple) => ({
    protocol: parts2.shift() ?? "",
    content: tuple[1] != null ? parts2.shift() ?? "" : ""
  })).reduce((str, part, i2, parts3) => {
    const reduce2 = Reducers[part.protocol];
    if (reduce2 == null) {
      throw new Error(`Unsupported protocol ${part.protocol}`);
    }
    return reduce2(str, part.content, i2, parts3, opts);
  }, "");
}
function arrayShuffle(array) {
  if (!Array.isArray(array)) {
    throw new TypeError(`Expected an array, got ${typeof array}`);
  }
  array = [...array];
  for (let index2 = array.length - 1; index2 > 0; index2--) {
    const newIndex = Math.floor(Math.random() * (index2 + 1));
    [array[index2], array[newIndex]] = [array[newIndex], array[index2]];
  }
  return array;
}
var import_http2 = __toESM(require_http());
var log20 = logger("ipfs:preload");
var Queue2 = PQueue.default ? PQueue.default : PQueue;
var httpQueue2 = new Queue2({ concurrency: 4 });
function preload(url2, options = {}) {
  log20(url2);
  return httpQueue2.add(async () => {
    const res = await import_http2.default.post(url2, { signal: options.signal });
    const reader3 = res.body.getReader();
    try {
      while (true) {
        const { done } = await reader3.read();
        if (done)
          return;
      }
    } finally {
      reader3.releaseLock();
    }
  });
}
var import_hashlru3 = __toESM(require_hashlru(), 1);
var log21 = logger("ipfs:preload");
function createPreloader(options = {}) {
  options.enabled = Boolean(options.enabled);
  options.addresses = options.addresses || [];
  options.cache = options.cache || 1e3;
  if (!options.enabled || !options.addresses.length) {
    log21("preload disabled");
    const api2 = () => {
    };
    return Object.assign(api2, {
      start: () => {
      },
      stop: () => {
      }
    });
  }
  let stopped = true;
  let requests = [];
  const apiUris = options.addresses.map((str) => multiaddrToUri(str));
  const cache4 = (0, import_hashlru3.default)(options.cache);
  const api = async (cid) => {
    try {
      if (stopped) {
        throw new Error(`preload ${cid} but preloader is not started`);
      }
      const path2 = cid.toString();
      if (cache4.has(path2)) {
        return;
      }
      cache4.set(path2, true);
      const fallbackApiUris = arrayShuffle(apiUris);
      let success = false;
      const now = Date.now();
      for (const uri of fallbackApiUris) {
        if (stopped)
          throw new Error(`preload aborted for ${path2}`);
        let controller;
        try {
          controller = new AbortController();
          requests = requests.concat(controller);
          await preload(`${uri}/api/v0/refs?r=true&arg=${encodeURIComponent(path2)}`, { signal: controller.signal });
          success = true;
        } catch (err2) {
          if (err2.type !== "aborted")
            log21.error(err2);
        } finally {
          requests = requests.filter((r) => r !== controller);
        }
        if (success)
          break;
      }
      log21(`${success ? "" : "un"}successfully preloaded ${path2} in ${Date.now() - now}ms`);
    } catch (err2) {
      log21.error(err2);
    }
  };
  api.start = () => {
    stopped = false;
  };
  api.stop = () => {
    stopped = true;
    log21(`aborting ${requests.length} pending preload request(s)`);
    requests.forEach((r) => r.abort());
    requests = [];
  };
  return api;
}
var log22 = logger("ipfs:mfs-preload");
function createMfsPreloader({ preload: preload2, files, options = {} }) {
  options.interval = options.interval || 30 * 1e3;
  if (!options.enabled) {
    log22("MFS preload disabled");
    const noop5 = async () => {
    };
    return { start: noop5, stop: noop5 };
  }
  let rootCid = "";
  let timeoutId;
  const preloadMfs = async () => {
    try {
      const stats = await files.stat("/");
      const nextRootCid = stats.cid.toString();
      if (rootCid !== nextRootCid) {
        log22(`preloading updated MFS root ${rootCid} -> ${stats.cid}`);
        await preload2(stats.cid);
        rootCid = nextRootCid;
      }
    } catch (err2) {
      log22.error("failed to preload MFS root", err2);
    } finally {
      timeoutId = setTimeout(preloadMfs, options.interval);
    }
  };
  return {
    /**
     * @returns {Promise<void>}
     */
    async start() {
      const stats = await files.stat("/");
      rootCid = stats.cid.toString();
      log22(`monitoring MFS root ${stats.cid}`);
      timeoutId = setTimeout(preloadMfs, options.interval);
    },
    /**
     * @returns {void}
     */
    stop() {
      clearTimeout(timeoutId);
    }
  };
}
var TimeoutError3 = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "TimeoutError";
  }
};
var AbortError4 = class extends Error {
  constructor(message2) {
    super();
    this.name = "AbortError";
    this.message = message2;
  }
};
var getDOMException2 = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError4(errorMessage) : new DOMException(errorMessage);
var getAbortedReason2 = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException2("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException2(reason);
};
function pTimeout2(promise, options) {
  const {
    milliseconds,
    fallback,
    message: message2,
    customTimers = { setTimeout, clearTimeout }
  } = options;
  let timer;
  const cancelablePromise = new Promise((resolve7, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve7(promise);
      return;
    }
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason2(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason2(signal));
      });
    }
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve7(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message2 === false) {
        resolve7();
      } else if (message2 instanceof Error) {
        reject(message2);
      } else {
        const errorMessage = message2 ?? `Promise timed out after ${milliseconds} milliseconds`;
        reject(new TimeoutError3(errorMessage));
      }
    }, milliseconds);
    (async () => {
      try {
        resolve7(await promise);
      } catch (error) {
        reject(error);
      } finally {
        customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}
var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";
var events = {};
var observable = (worker) => {
  worker.addEventListener("message", (event) => {
    observable.dispatchEvent("message", worker, event);
  });
  if (worker.port != null) {
    worker.port.addEventListener("message", (event) => {
      observable.dispatchEvent("message", worker, event);
    });
  }
};
observable.addEventListener = (type, fn) => {
  if (events[type] == null) {
    events[type] = [];
  }
  events[type].push(fn);
};
observable.removeEventListener = (type, fn) => {
  if (events[type] == null) {
    return;
  }
  events[type] = events[type].filter((listener) => listener === fn);
};
observable.dispatchEvent = function(type, worker, event) {
  if (events[type] == null) {
    return;
  }
  events[type].forEach((fn) => fn(worker, event));
};
var src_default = observable;
var handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
  return (worker, event) => {
    if (event.data.type !== requestType) {
      return;
    }
    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    };
    emitter.dispatchEvent(new MessageEvent(masterEvent, {
      data: {
        name: requestEvent.name,
        handler: async () => {
          worker.postMessage({
            type: grantType,
            name: requestEvent.name,
            identifier: requestEvent.identifier
          });
          return await new Promise((resolve7) => {
            const releaseEventListener = (event2) => {
              if (event2 == null || event2.data == null) {
                return;
              }
              const releaseEvent = {
                type: event2.data.type,
                name: event2.data.name,
                identifier: event2.data.identifier
              };
              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                worker.removeEventListener("message", releaseEventListener);
                resolve7();
              }
            };
            worker.addEventListener("message", releaseEventListener);
          });
        }
      }
    }));
  };
};
var makeWorkerLockRequest = (name9, requestType, grantType, releaseType) => {
  return async () => {
    const id = nanoid();
    globalThis.postMessage({
      type: requestType,
      identifier: id,
      name: name9
    });
    return await new Promise((resolve7) => {
      const listener = (event) => {
        if (event == null || event.data == null) {
          return;
        }
        const responseEvent = {
          type: event.data.type,
          identifier: event.data.identifier
        };
        if (responseEvent.type === grantType && responseEvent.identifier === id) {
          globalThis.removeEventListener("message", listener);
          resolve7(() => {
            globalThis.postMessage({
              type: releaseType,
              identifier: id,
              name: name9
            });
          });
        }
      };
      globalThis.addEventListener("message", listener);
    });
  };
};
var defaultOptions2 = {
  singleProcess: false
};
var browser_default$1 = (options) => {
  options = Object.assign({}, defaultOptions2, options);
  const isPrimary = Boolean(globalThis.document) || options.singleProcess;
  if (isPrimary) {
    const emitter = new EventTarget();
    src_default.addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
    src_default.addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
    return emitter;
  }
  return {
    isWorker: true,
    readLock: (name9) => makeWorkerLockRequest(name9, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
    writeLock: (name9) => makeWorkerLockRequest(name9, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
  };
};
var mutexes = {};
var implementation;
async function createReleaseable(queue, options) {
  let res;
  const p = new Promise((resolve7) => {
    res = resolve7;
  });
  void queue.add(async () => await pTimeout2((async () => {
    return await new Promise((resolve7) => {
      res(() => {
        resolve7();
      });
    });
  })(), {
    milliseconds: options.timeout
  }));
  return await p;
}
var createMutex = (name9, options) => {
  if (implementation.isWorker === true) {
    return {
      readLock: implementation.readLock(name9, options),
      writeLock: implementation.writeLock(name9, options)
    };
  }
  const masterQueue = new PQueue({ concurrency: 1 });
  let readQueue;
  return {
    async readLock() {
      if (readQueue != null) {
        return await createReleaseable(readQueue, options);
      }
      readQueue = new PQueue({
        concurrency: options.concurrency,
        autoStart: false
      });
      const localReadQueue = readQueue;
      const readPromise = createReleaseable(readQueue, options);
      void masterQueue.add(async () => {
        localReadQueue.start();
        return await localReadQueue.onIdle().then(() => {
          if (readQueue === localReadQueue) {
            readQueue = null;
          }
        });
      });
      return await readPromise;
    },
    async writeLock() {
      readQueue = null;
      return await createReleaseable(masterQueue, options);
    }
  };
};
var defaultOptions3 = {
  name: "lock",
  concurrency: Infinity,
  timeout: 846e5,
  singleProcess: false
};
function createMortice(options) {
  const opts = Object.assign({}, defaultOptions3, options);
  if (implementation == null) {
    implementation = browser_default$1(opts);
    if (implementation.isWorker !== true) {
      implementation.addEventListener("requestReadLock", (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].readLock().then(async (release) => await event.data.handler().finally(() => release()));
      });
      implementation.addEventListener("requestWriteLock", async (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].writeLock().then(async (release) => await event.data.handler().finally(() => release()));
      });
    }
  }
  if (mutexes[opts.name] == null) {
    mutexes[opts.name] = createMutex(opts.name, opts);
  }
  return mutexes[opts.name];
}
var lock;
function createLock(repoOwner = false) {
  if (lock) {
    return lock;
  }
  const mutex = createMortice({
    // ordinarily the main thread would store the read/write lock but
    // if we are the thread that owns the repo, we can store the lock
    // on this process even if we are a worker thread
    singleProcess: repoOwner
  });
  lock = {
    readLock: (func) => {
      return async (...args) => {
        const releaseLock = await mutex.readLock();
        try {
          return await func.apply(null, args);
        } finally {
          releaseLock();
        }
      };
    },
    writeLock: (func) => {
      return async (...args) => {
        const releaseLock = await mutex.writeLock();
        try {
          return await func.apply(null, args);
        } finally {
          releaseLock();
        }
      };
    }
  };
  return lock;
}
var import_err_code50 = __toESM(require_err_code(), 1);
var log23 = logger("ipfs:mfs:utils:with-mfs-root");
async function loadMfsRoot(context, options) {
  if (options && options.signal && options.signal.aborted) {
    throw (0, import_err_code50.default)(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
  }
  await context.repo.datastore.open();
  let cid;
  try {
    const buf2 = await context.repo.datastore.get(MFS_ROOT_KEY);
    cid = CID.decode(buf2);
  } catch (err2) {
    if (err2.code !== "ERR_NOT_FOUND") {
      throw err2;
    }
    log23("Creating new MFS root");
    const buf2 = encode$1({
      Data: new UnixFS({ type: "directory" }).marshal(),
      Links: []
    });
    const hash3 = await sha256.digest(buf2);
    cid = CID.createV0(hash3);
    await context.repo.blocks.put(cid, buf2);
    if (options && options.signal && options.signal.aborted) {
      throw (0, import_err_code50.default)(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
    }
    await context.repo.datastore.put(MFS_ROOT_KEY, cid.bytes);
  }
  log23(`Loaded MFS root /ipfs/${cid}`);
  return cid;
}
function toPathComponents3(path2 = "") {
  return (path2.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
}
var import_err_code51 = __toESM(require_err_code(), 1);
var IPFS_PREFIX2 = "ipfs";
var toMfsPath = async (context, path2, options) => {
  const root2 = await loadMfsRoot(context, options);
  let output = {
    entryType: "file"
  };
  let ipfsPath3 = "";
  if (CID.asCID(path2)) {
    ipfsPath3 = `/ipfs/${path2}`;
  } else {
    ipfsPath3 = path2.toString();
  }
  ipfsPath3 = ipfsPath3.trim();
  ipfsPath3 = ipfsPath3.replace(/(\/\/+)/g, "/");
  if (ipfsPath3.endsWith("/") && ipfsPath3.length > 1) {
    ipfsPath3 = ipfsPath3.substring(0, ipfsPath3.length - 1);
  }
  if (!ipfsPath3) {
    throw (0, import_err_code51.default)(new Error("paths must not be empty"), "ERR_NO_PATH");
  }
  if (ipfsPath3.substring(0, 1) !== "/") {
    throw (0, import_err_code51.default)(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
  }
  if (ipfsPath3.substring(ipfsPath3.length - 1) === "/") {
    ipfsPath3 = ipfsPath3.substring(0, ipfsPath3.length - 1);
  }
  const pathComponents = toPathComponents3(ipfsPath3);
  if (pathComponents[0] === IPFS_PREFIX2) {
    let mfsDirectory;
    if (pathComponents.length === 2) {
      mfsDirectory = `/${pathComponents.join("/")}`;
    } else {
      mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join("/")}`;
    }
    output = {
      type: "ipfs",
      depth: pathComponents.length - 2,
      entryType: "file",
      mfsPath: `/${pathComponents.join("/")}`,
      mfsDirectory,
      parts: pathComponents,
      path: `/${pathComponents.join("/")}`,
      name: pathComponents[pathComponents.length - 1]
    };
  } else {
    const mfsPath = `/${IPFS_PREFIX2}/${root2}${pathComponents.length ? "/" + pathComponents.join("/") : ""}`;
    const mfsDirectory = `/${IPFS_PREFIX2}/${root2}/${pathComponents.slice(0, pathComponents.length - 1).join("/")}`;
    output = {
      type: "mfs",
      depth: pathComponents.length,
      entryType: "file",
      mfsDirectory,
      mfsPath,
      parts: pathComponents,
      path: `/${pathComponents.join("/")}`,
      name: pathComponents[pathComponents.length - 1]
    };
  }
  const cidPath = output.type === "mfs" ? output.mfsPath : output.path;
  try {
    const res = await exporter2(cidPath, context.repo.blocks, options);
    output.cid = res.cid;
    output.mfsPath = `/ipfs/${res.path}`;
    output.entryType = res.type;
    output.content = res.content;
    if ((output.entryType === "file" || output.entryType === "directory") && (res.type === "file" || res.type === "directory")) {
      output.unixfs = res.unixfs;
    }
  } catch (err2) {
    if (err2.code !== "ERR_NOT_FOUND") {
      throw err2;
    }
  }
  output.exists = Boolean(output.cid);
  return output;
};
var import_err_code52 = __toESM(require_err_code(), 1);
var mergeOptions4 = merge_options_default.bind({ ignoreUndefined: true });
var log24 = logger("ipfs:mfs:stat");
var defaultOptions4 = {
  withLocal: false
};
function createStat3(context) {
  async function mfsStat(path2, options = {}) {
    options = mergeOptions4(defaultOptions4, options);
    log24(`Fetching stats for ${path2}`);
    const {
      type,
      cid,
      mfsPath
    } = await toMfsPath(context, path2, options);
    const exportPath = type === "ipfs" && cid ? cid : mfsPath;
    let file;
    try {
      file = await exporter2(exportPath, context.repo.blocks);
    } catch (err2) {
      if (err2.code === "ERR_NOT_FOUND") {
        throw (0, import_err_code52.default)(new Error(`${path2} does not exist`), "ERR_NOT_FOUND");
      }
      throw err2;
    }
    if (!statters[file.type]) {
      throw new Error(`Cannot stat codec ${file.cid.code}`);
    }
    return statters[file.type](file);
  }
  return withTimeoutOption(mfsStat);
}
var statters = {
  /**
   * @param {import('ipfs-unixfs-exporter').RawNode} file
   */
  raw: (file) => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      blocks: 0,
      type: "file",
      // for go compatibility
      local: void 0,
      sizeLocal: void 0,
      withLocality: false
    };
  },
  /**
   * @param {import('ipfs-unixfs-exporter').UnixFSFile} file
   */
  file: (file) => {
    const stat = {
      cid: file.cid,
      type: "file",
      size: file.unixfs.fileSize(),
      cumulativeSize: encode$1(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),
      blocks: file.unixfs.blockSizes.length,
      local: void 0,
      sizeLocal: void 0,
      withLocality: false,
      mode: file.unixfs.mode
    };
    if (file.unixfs.mtime) {
      stat.mtime = file.unixfs.mtime;
    }
    return stat;
  },
  /**
   * @param {import('ipfs-unixfs-exporter').UnixFSDirectory} file
   */
  directory: (file) => {
    const stat = {
      cid: file.cid,
      type: "directory",
      size: 0,
      cumulativeSize: encode$1(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),
      blocks: file.node.Links.length,
      local: void 0,
      sizeLocal: void 0,
      withLocality: false,
      mode: file.unixfs.mode
    };
    if (file.unixfs.mtime) {
      stat.mtime = file.unixfs.mtime;
    }
    return stat;
  },
  /**
   * @param {import('ipfs-unixfs-exporter').ObjectNode} file
   */
  object: (file) => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      type: "file",
      // for go compatibility
      blocks: 0,
      local: void 0,
      sizeLocal: void 0,
      withLocality: false
    };
  },
  /**
   * @param {import('ipfs-unixfs-exporter').IdentityNode} file
   */
  identity: (file) => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      blocks: 0,
      type: "file",
      // for go compatibility
      local: void 0,
      sizeLocal: void 0,
      withLocality: false
    };
  }
};
var import_err_code59 = __toESM(require_err_code(), 1);
var log25 = logger("ipfs:mfs:utils:to-trail");
async function toTrail(context, path2) {
  log25(`Creating trail for path ${path2}`);
  const output = [];
  for await (const fsEntry of walkPath(path2, context.repo.blocks)) {
    output.push({
      name: fsEntry.name,
      cid: fsEntry.cid,
      size: fsEntry.size,
      type: fsEntry.type
    });
  }
  return output;
}
var persist2 = async (buffer2, blockstore, options) => {
  if (!options.codec) {
    options.codec = src_exports;
  }
  if (!options.hasher) {
    options.hasher = sha256;
  }
  if (options.cidVersion === void 0) {
    options.cidVersion = 1;
  }
  if (options.codec === src_exports && options.hasher !== sha256) {
    options.cidVersion = 1;
  }
  const multihash = await options.hasher.digest(buffer2);
  const cid = CID.create(options.cidVersion, options.codec.code, multihash);
  if (!options.onlyHash) {
    await blockstore.put(cid, buffer2, {
      signal: options.signal
    });
  }
  return cid;
};
var hamtHashCode = murmur3128.code;
var hamtBucketBits = 8;
async function hamtHashFn2(buf2) {
  return (await murmur3128.encode(buf2)).subarray(0, 8).reverse();
}
var Dir2 = class {
  /**
   * @param {DirProps} props
   * @param {DirOptions} options
   */
  constructor(props, options) {
    this.options = options || {};
    this.root = props.root;
    this.dir = props.dir;
    this.path = props.path;
    this.dirty = props.dirty;
    this.flat = props.flat;
    this.parent = props.parent;
    this.parentKey = props.parentKey;
    this.unixfs = props.unixfs;
    this.mode = props.mode;
    this.mtime = props.mtime;
    this.cid = void 0;
    this.size = void 0;
  }
  /**
   * @param {string} name
   * @param {DirContents} value
   */
  async put(name9, value2) {
  }
  /**
   * @param {string} name
   * @returns {Promise<DirContents | undefined>}
   */
  get(name9) {
    return Promise.resolve(this);
  }
  /**
   * @returns {AsyncIterable<{ key: string, child: DirContents}>}
   */
  async *eachChildSeries() {
  }
  /**
   * @param {Blockstore} blockstore
   * @returns {AsyncIterable<ImportResult>}
   */
  async *flush(blockstore) {
  }
};
var DirSharded2 = class extends Dir2 {
  /**
   * @param {DirProps} props
   * @param {DirOptions} options
   */
  constructor(props, options) {
    super(props, options);
    this._bucket = createHAMT({
      hashFn: hamtHashFn2,
      bits: hamtBucketBits
    });
  }
  /**
   * @param {string} name
   * @param {DirContents} value
   */
  async put(name9, value2) {
    await this._bucket.put(name9, value2);
  }
  /**
   * @param {string} name
   */
  get(name9) {
    return this._bucket.get(name9);
  }
  childCount() {
    return this._bucket.leafCount();
  }
  directChildrenCount() {
    return this._bucket.childrenCount();
  }
  onlyChild() {
    return this._bucket.onlyChild();
  }
  async *eachChildSeries() {
    for await (const { key, value: value2 } of this._bucket.eachLeafSeries()) {
      yield {
        key,
        child: value2
      };
    }
  }
  /**
   * @param {Blockstore} blockstore
   * @returns {AsyncIterable<ImportResult>}
   */
  async *flush(blockstore) {
    yield* flush2(this._bucket, blockstore, this, this.options);
  }
};
async function* flush2(bucket, blockstore, shardRoot, options) {
  const children = bucket._children;
  const links3 = [];
  let childrenSize = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children.get(i2);
    if (!child) {
      continue;
    }
    const labelPrefix = i2.toString(16).toUpperCase().padStart(2, "0");
    if (child instanceof Bucket) {
      let shard;
      for await (const subShard of await flush2(child, blockstore, null, options)) {
        shard = subShard;
      }
      if (!shard) {
        throw new Error("Could not flush sharded directory, no subshard found");
      }
      links3.push({
        Name: labelPrefix,
        Tsize: shard.size,
        Hash: shard.cid
      });
      childrenSize += shard.size;
    } else if (typeof child.value.flush === "function") {
      const dir2 = child.value;
      let flushedDir;
      for await (const entry of dir2.flush(blockstore)) {
        flushedDir = entry;
        yield flushedDir;
      }
      const label = labelPrefix + child.key;
      links3.push({
        Name: label,
        Tsize: flushedDir.size,
        Hash: flushedDir.cid
      });
      childrenSize += flushedDir.size;
    } else {
      const value2 = child.value;
      if (!value2.cid) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size2 = value2.size;
      links3.push({
        Name: label,
        Tsize: size2,
        Hash: value2.cid
      });
      childrenSize += size2;
    }
  }
  const data = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data,
    fanout: bucket.tableSize(),
    hashType: hamtHashCode,
    mtime: shardRoot && shardRoot.mtime,
    mode: shardRoot && shardRoot.mode
  });
  const node = {
    Data: dir.marshal(),
    Links: links3
  };
  const buffer2 = encode$1(prepare(node));
  const cid = await persist2(buffer2, blockstore, options);
  const size = buffer2.length + childrenSize;
  yield {
    cid,
    node,
    size
  };
}
var log26 = logger("ipfs:mfs:core:utils:hamt-utils");
var updateHamtDirectory = async (context, links3, bucket, options) => {
  if (!options.parent.Data) {
    throw new Error("Could not update HAMT directory because parent had no data");
  }
  const data = Uint8Array.from(bucket._children.bitField().reverse());
  const node = UnixFS.unmarshal(options.parent.Data);
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data,
    fanout: bucket.tableSize(),
    hashType: hamtHashCode,
    mode: node.mode,
    mtime: node.mtime
  });
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const parent2 = {
    Data: dir.marshal(),
    Links: links3.sort((a, b) => (a.Name || "").localeCompare(b.Name || ""))
  };
  const buf2 = encode$1(parent2);
  const hash3 = await hasher.digest(buf2);
  const cid = CID.create(options.cidVersion, code, hash3);
  if (options.flush) {
    await context.repo.blocks.put(cid, buf2);
  }
  return {
    node: parent2,
    cid,
    size: links3.reduce((sum, link) => sum + (link.Tsize || 0), buf2.length)
  };
};
var recreateHamtLevel = async (context, links3, rootBucket, parentBucket, positionAtParent) => {
  const bucket = new Bucket({
    hash: rootBucket._options.hash,
    bits: rootBucket._options.bits
  }, parentBucket, positionAtParent);
  parentBucket._putObjectAt(positionAtParent, bucket);
  await addLinksToHamtBucket2(context, links3, bucket, rootBucket);
  return bucket;
};
var recreateInitialHamtLevel = async (links3) => {
  const bucket = createHAMT({
    hashFn: hamtHashFn2,
    bits: hamtBucketBits
  });
  await Promise.all(
    links3.map(async (link) => {
      const linkName = link.Name || "";
      if (linkName.length === 2) {
        const pos = parseInt(linkName, 16);
        const subBucket = new Bucket({
          hash: bucket._options.hash,
          bits: bucket._options.bits
        }, bucket, pos);
        bucket._putObjectAt(pos, subBucket);
        return Promise.resolve();
      }
      return bucket.put(linkName.substring(2), {
        size: link.Tsize,
        cid: link.Hash
      });
    })
  );
  return bucket;
};
var addLinksToHamtBucket2 = async (context, links3, bucket, rootBucket) => {
  await Promise.all(
    links3.map(async (link) => {
      const linkName = link.Name || "";
      if (linkName.length === 2) {
        log26("Populating sub bucket", linkName);
        const pos = parseInt(linkName, 16);
        const block = await context.repo.blocks.get(link.Hash);
        const node = decode2$1(block);
        const subBucket = new Bucket({
          hash: rootBucket._options.hash,
          bits: rootBucket._options.bits
        }, bucket, pos);
        bucket._putObjectAt(pos, subBucket);
        await addLinksToHamtBucket2(context, node.Links, subBucket, rootBucket);
        return Promise.resolve();
      }
      return rootBucket.put(linkName.substring(2), {
        size: link.Tsize,
        cid: link.Hash
      });
    })
  );
};
var toPrefix2 = (position) => {
  return position.toString(16).toUpperCase().padStart(2, "0").substring(0, 2);
};
var generatePath = async (context, fileName, rootNode) => {
  const rootBucket = await recreateInitialHamtLevel(rootNode.Links);
  const position = await rootBucket._findNewBucketAndPos(fileName);
  const path2 = [{
    bucket: position.bucket,
    prefix: toPrefix2(position.pos)
  }];
  let currentBucket = position.bucket;
  while (currentBucket !== rootBucket) {
    path2.push({
      bucket: currentBucket,
      prefix: toPrefix2(currentBucket._posAtParent)
    });
    currentBucket = currentBucket._parent;
  }
  path2.reverse();
  path2[0].node = rootNode;
  for (let i2 = 0; i2 < path2.length; i2++) {
    const segment = path2[i2];
    if (!segment.node) {
      throw new Error("Could not generate HAMT path");
    }
    const link = segment.node.Links.filter((link2) => (link2.Name || "").substring(0, 2) === segment.prefix).pop();
    if (!link) {
      log26(`Link ${segment.prefix}${fileName} will be added`);
      continue;
    }
    if (link.Name === `${segment.prefix}${fileName}`) {
      log26(`Link ${segment.prefix}${fileName} will be replaced`);
      continue;
    }
    log26(`Found subshard ${segment.prefix}`);
    const block = await context.repo.blocks.get(link.Hash);
    const node = decode2$1(block);
    if (!path2[i2 + 1]) {
      log26(`Loaded new subshard ${segment.prefix}`);
      await recreateHamtLevel(context, node.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));
      const position2 = await rootBucket._findNewBucketAndPos(fileName);
      path2.push({
        bucket: position2.bucket,
        prefix: toPrefix2(position2.pos),
        node
      });
      continue;
    }
    const nextSegment = path2[i2 + 1];
    await addLinksToHamtBucket2(context, node.Links, nextSegment.bucket, rootBucket);
    nextSegment.node = node;
  }
  await rootBucket.put(fileName, true);
  path2.reverse();
  return {
    rootBucket,
    path: path2
  };
};
var createShard = async (context, contents, options = {}) => {
  const shard = new DirSharded2({
    root: true,
    dir: true,
    parent: void 0,
    parentKey: void 0,
    path: "",
    dirty: true,
    flat: false,
    mtime: options.mtime,
    mode: options.mode
  }, options);
  for (let i2 = 0; i2 < contents.length; i2++) {
    await shard._bucket.put(contents[i2].name, {
      size: contents[i2].size,
      cid: contents[i2].cid
    });
  }
  const res = await last(shard.flush(context.repo.blocks));
  if (!res) {
    throw new Error("Flushing shard yielded no result");
  }
  return res;
};
var import_err_code53 = __toESM(require_err_code(), 1);
var log27 = logger("ipfs:mfs:core:utils:add-link");
async function addLink(context, options) {
  let parent2 = options.parent;
  if (options.parentCid) {
    const parentCid = CID.asCID(options.parentCid);
    if (parentCid === null) {
      throw (0, import_err_code53.default)(new Error("Invalid CID passed to addLink"), "EINVALIDPARENTCID");
    }
    if (parentCid.code !== code) {
      throw (0, import_err_code53.default)(new Error("Unsupported codec. Only DAG-PB is supported"), "EINVALIDPARENTCID");
    }
    log27(`Loading parent node ${parentCid}`);
    const block = await context.repo.blocks.get(parentCid);
    parent2 = decode2$1(block);
  }
  if (!parent2) {
    throw (0, import_err_code53.default)(new Error("No parent node or CID passed to addLink"), "EINVALIDPARENT");
  }
  if (!options.cid) {
    throw (0, import_err_code53.default)(new Error("No child cid passed to addLink"), "EINVALIDCHILDCID");
  }
  if (!options.name) {
    throw (0, import_err_code53.default)(new Error("No child name passed to addLink"), "EINVALIDCHILDNAME");
  }
  if (!options.size && options.size !== 0) {
    throw (0, import_err_code53.default)(new Error("No child size passed to addLink"), "EINVALIDCHILDSIZE");
  }
  if (!parent2.Data) {
    throw (0, import_err_code53.default)(new Error("Parent node with no data passed to addLink"), "ERR_INVALID_PARENT");
  }
  const meta = UnixFS.unmarshal(parent2.Data);
  if (meta.type === "hamt-sharded-directory") {
    log27("Adding link to sharded directory");
    return addToShardedDirectory(context, {
      ...options,
      parent: parent2
    });
  }
  if (parent2.Links.length >= options.shardSplitThreshold) {
    log27("Converting directory to sharded directory");
    return convertToShardedDirectory(context, {
      ...options,
      parent: parent2,
      mtime: meta.mtime,
      mode: meta.mode
    });
  }
  log27(`Adding ${options.name} (${options.cid}) to regular directory`);
  return addToDirectory(context, {
    ...options,
    parent: parent2
  });
}
var convertToShardedDirectory = async (context, options) => {
  const result = await createShard(context, options.parent.Links.map((link) => ({
    name: link.Name || "",
    size: link.Tsize || 0,
    cid: link.Hash
  })).concat({
    name: options.name,
    size: options.size,
    cid: options.cid
  }), options);
  log27(`Converted directory to sharded directory ${result.cid}`);
  return result;
};
var addToDirectory = async (context, options) => {
  const parentLinks = options.parent.Links.filter((link) => {
    return link.Name !== options.name;
  });
  parentLinks.push({
    Name: options.name,
    Tsize: options.size,
    Hash: options.cid
  });
  if (!options.parent.Data) {
    throw (0, import_err_code53.default)(new Error("Parent node with no data passed to addToDirectory"), "ERR_INVALID_PARENT");
  }
  const node = UnixFS.unmarshal(options.parent.Data);
  let data;
  if (node.mtime) {
    const ms = Date.now();
    const secs = Math.floor(ms / 1e3);
    node.mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
    data = node.marshal();
  } else {
    data = options.parent.Data;
  }
  options.parent = prepare({
    Data: data,
    Links: parentLinks
  });
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const buf2 = encode$1(options.parent);
  const hash3 = await hasher.digest(buf2);
  const cid = CID.create(options.cidVersion, code, hash3);
  if (options.flush) {
    await context.repo.blocks.put(cid, buf2);
  }
  return {
    node: options.parent,
    cid,
    size: buf2.length
  };
};
var addToShardedDirectory = async (context, options) => {
  const {
    shard,
    path: path2
  } = await addFileToShardedDirectory(context, options);
  const result = await last(shard.flush(context.repo.blocks));
  if (!result) {
    throw new Error("No result from flushing shard");
  }
  const block = await context.repo.blocks.get(result.cid);
  const node = decode2$1(block);
  const parentLinks = options.parent.Links.filter((link) => {
    return (link.Name || "").substring(0, 2) !== path2[0].prefix;
  });
  const newLink = node.Links.find((link) => (link.Name || "").substring(0, 2) === path2[0].prefix);
  if (!newLink) {
    throw new Error(`No link found with prefix ${path2[0].prefix}`);
  }
  parentLinks.push(newLink);
  return updateHamtDirectory(context, parentLinks, path2[0].bucket, options);
};
var addFileToShardedDirectory = async (context, options) => {
  const file = {
    name: options.name,
    cid: options.cid,
    size: options.size
  };
  if (!options.parent.Data) {
    throw (0, import_err_code53.default)(new Error("Parent node with no data passed to addFileToShardedDirectory"), "ERR_INVALID_PARENT");
  }
  const rootBucket = await recreateInitialHamtLevel(options.parent.Links);
  const node = UnixFS.unmarshal(options.parent.Data);
  const shard = new DirSharded2({
    root: true,
    dir: true,
    parent: void 0,
    parentKey: void 0,
    path: "",
    dirty: true,
    flat: false,
    mode: node.mode
  }, options);
  shard._bucket = rootBucket;
  if (node.mtime) {
    shard.mtime = {
      secs: Math.round(Date.now() / 1e3)
    };
  }
  const position = await rootBucket._findNewBucketAndPos(file.name);
  const path2 = toBucketPath2(position);
  path2[0].node = options.parent;
  let index2 = 0;
  while (index2 < path2.length) {
    const segment = path2[index2];
    index2++;
    const node2 = segment.node;
    if (!node2) {
      throw new Error("Segment had no node");
    }
    const link = node2.Links.find((link2) => (link2.Name || "").substring(0, 2) === segment.prefix);
    if (!link) {
      log27(`Link ${segment.prefix}${file.name} will be added`);
      index2 = path2.length;
      break;
    }
    if (link.Name === `${segment.prefix}${file.name}`) {
      log27(`Link ${segment.prefix}${file.name} will be replaced`);
      index2 = path2.length;
      break;
    }
    if ((link.Name || "").length > 2) {
      log27(`Link ${link.Name} ${link.Hash} will be replaced with a subshard`);
      index2 = path2.length;
      break;
    }
    log27(`Found subshard ${segment.prefix}`);
    const block = await context.repo.blocks.get(link.Hash);
    const subShard = decode2$1(block);
    if (!path2[index2]) {
      log27(`Loaded new subshard ${segment.prefix}`);
      await recreateHamtLevel(context, subShard.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));
      const position2 = await rootBucket._findNewBucketAndPos(file.name);
      path2.push({
        bucket: position2.bucket,
        prefix: toPrefix2(position2.pos),
        node: subShard
      });
      break;
    }
    const nextSegment = path2[index2];
    await addLinksToHamtBucket2(context, subShard.Links, nextSegment.bucket, rootBucket);
    nextSegment.node = subShard;
  }
  await shard._bucket.put(file.name, {
    size: file.size,
    cid: file.cid
  });
  return {
    shard,
    path: path2
  };
};
var toBucketPath2 = (position) => {
  const path2 = [{
    bucket: position.bucket,
    prefix: toPrefix2(position.pos)
  }];
  let bucket = position.bucket._parent;
  let positionInBucket = position.bucket._posAtParent;
  while (bucket) {
    path2.push({
      bucket,
      prefix: toPrefix2(positionInBucket)
    });
    positionInBucket = bucket._posAtParent;
    bucket = bucket._parent;
  }
  path2.reverse();
  return path2;
};
var log28 = logger("ipfs:mfs:utils:update-tree");
var defaultOptions5 = {
  shardSplitThreshold: 1e3
};
async function updateTree(context, trail, options) {
  options = Object.assign({}, defaultOptions5, options);
  log28("Trail", trail);
  trail = trail.slice().reverse();
  let index2 = 0;
  let child;
  for await (const block of context.repo.blocks.getMany(trail.map((node) => node.cid))) {
    const node = decode2$1(block);
    const cid2 = trail[index2].cid;
    const name9 = trail[index2].name;
    index2++;
    if (!child) {
      child = {
        cid: cid2,
        name: name9,
        size: block.length
      };
      continue;
    }
    const result = await addLink(context, {
      parent: node,
      name: child.name,
      cid: child.cid,
      // TODO vmx 2021-04-05: check what to do with the size
      size: child.size,
      flush: options.flush,
      shardSplitThreshold: options.shardSplitThreshold,
      hashAlg: options.hashAlg,
      cidVersion: options.cidVersion
    });
    child = {
      cid: result.cid,
      name: name9,
      // TODO vmx 2021-04-05: check what to do with the size
      size: result.size
    };
  }
  const { cid } = child;
  log28(`Final CID ${cid}`);
  return cid;
}
var import_err_code54 = __toESM(require_err_code(), 1);
var log29 = logger("ipfs:mfs:utils:update-mfs-root");
async function updateMfsRoot(context, cid, options) {
  if (options && options.signal && options.signal.aborted) {
    throw (0, import_err_code54.default)(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
  }
  log29(`New MFS root will be ${cid}`);
  await context.repo.datastore.put(MFS_ROOT_KEY, cid.bytes);
  return cid;
}
var import_err_code55 = __toESM(require_err_code(), 1);
async function createNode2(context, type, options) {
  const metadata = new UnixFS({
    type,
    mode: options.mode,
    mtime: options.mtime
  });
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const node = {
    Data: metadata.marshal(),
    Links: []
  };
  const buf2 = encode$1(node);
  const hash3 = await hasher.digest(buf2);
  const cid = CID.create(options.cidVersion, code, hash3);
  if (options.flush) {
    await context.repo.blocks.put(cid, buf2);
  }
  return {
    cid,
    node
  };
}
var mergeOptions5 = merge_options_default.bind({ ignoreUndefined: true });
var log30 = logger("ipfs:mfs:mkdir");
var defaultOptions6 = {
  parents: false,
  hashAlg: "sha2-256",
  cidVersion: 0,
  shardSplitThreshold: 1e3,
  flush: true
};
function createMkdir(context) {
  async function mfsMkdir(path2, options = {}) {
    const opts = mergeOptions5(defaultOptions6, options);
    if (!path2) {
      throw new Error("no path given to Mkdir");
    }
    path2 = path2.trim();
    if (path2 === "/") {
      if (opts.parents) {
        return;
      }
      throw (0, import_err_code55.default)(new Error("cannot create directory '/': Already exists"), "ERR_INVALID_PATH");
    }
    if (path2.substring(0, 1) !== "/") {
      throw (0, import_err_code55.default)(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
    }
    log30(`Creating ${path2}`);
    const pathComponents = toPathComponents3(path2);
    if (pathComponents[0] === "ipfs") {
      throw (0, import_err_code55.default)(new Error("path cannot have the prefix 'ipfs'"), "ERR_INVALID_PATH");
    }
    const root2 = await loadMfsRoot(context, opts);
    let parent2;
    const trail = [];
    const emptyDir = await createNode2(context, "directory", opts);
    for (let i2 = 0; i2 <= pathComponents.length; i2++) {
      const subPathComponents = pathComponents.slice(0, i2);
      const subPath = `/ipfs/${root2}/${subPathComponents.join("/")}`;
      try {
        parent2 = await exporter2(subPath, context.repo.blocks);
        if (parent2.type !== "file" && parent2.type !== "directory") {
          throw (0, import_err_code55.default)(new Error(`${path2} was not a UnixFS node`), "ERR_NOT_UNIXFS");
        }
        if (i2 === pathComponents.length) {
          if (opts.parents) {
            return;
          }
          throw (0, import_err_code55.default)(new Error("file already exists"), "ERR_ALREADY_EXISTS");
        }
        trail.push({
          name: parent2.name,
          cid: parent2.cid
        });
      } catch (err2) {
        if (err2.code === "ERR_NOT_FOUND") {
          if (i2 < pathComponents.length && !opts.parents) {
            throw (0, import_err_code55.default)(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), "ERR_NOT_FOUND");
          }
          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts);
        } else {
          throw err2;
        }
      }
    }
    const newRootCid = await updateTree(context, trail, opts);
    await updateMfsRoot(context, newRootCid, opts);
  }
  return withTimeoutOption(mfsMkdir);
}
var addEmptyDir = async (context, childName, emptyDir, parent2, trail, options) => {
  log30(`Adding empty dir called ${childName} to ${parent2.cid}`);
  const result = await addLink(context, {
    parent: parent2.node,
    parentCid: parent2.cid,
    // TODO vmx 2021-03-09: Remove the usage of size completely
    size: 0,
    cid: emptyDir.cid,
    name: childName,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  trail[trail.length - 1].cid = result.cid;
  trail.push({
    name: childName,
    cid: emptyDir.cid
  });
};
var import_err_code56 = __toESM(require_err_code(), 1);
var mergeOptions6 = merge_options_default.bind({ ignoreUndefined: true });
var log31 = logger("ipfs:mfs:cp");
var defaultOptions7 = {
  parents: false,
  flush: true,
  hashAlg: "sha2-256",
  cidVersion: 0,
  shardSplitThreshold: 1e3
};
function createCp(context) {
  async function mfsCp(from3, to, opts = {}) {
    const options = mergeOptions6(defaultOptions7, opts);
    if (!Array.isArray(from3)) {
      from3 = [from3];
    }
    const sources = await Promise.all(
      from3.map((path2) => toMfsPath(context, path2, options))
    );
    let destination = await toMfsPath(context, to, options);
    if (!sources.length || !destination) {
      throw (0, import_err_code56.default)(new Error("Please supply at least one source"), "ERR_INVALID_PARAMS");
    }
    const missing = sources.find((source) => !source.exists);
    if (missing) {
      throw (0, import_err_code56.default)(new Error(`${missing.path} does not exist`), "ERR_INVALID_PARAMS");
    }
    const destinationIsDirectory = isDirectory(destination);
    if (destination.exists) {
      log31("Destination exists");
      if (sources.length === 1 && !destinationIsDirectory) {
        throw (0, import_err_code56.default)(new Error("directory already has entry by that name"), "ERR_ALREADY_EXISTS");
      }
    } else {
      log31("Destination does not exist");
      if (sources.length > 1) {
        if (!options.parents) {
          throw (0, import_err_code56.default)(new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
        }
        await createMkdir(context)(destination.path, options);
        destination = await toMfsPath(context, destination.path, options);
      } else if (destination.parts.length > 1) {
        const parentFolder = `/${destination.parts.slice(0, -1).join("/")}`;
        try {
          await createStat3(context)(parentFolder, options);
        } catch (err2) {
          if (err2.code !== "ERR_NOT_FOUND") {
            throw err2;
          }
          if (!options.parents) {
            throw (0, import_err_code56.default)(new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
          }
          await createMkdir(context)(parentFolder, options);
          destination = await toMfsPath(context, destination.path, options);
        }
      }
    }
    const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory;
    const trail = await toTrail(context, destinationPath);
    if (sources.length === 1) {
      const source = sources.pop();
      if (!source) {
        throw (0, import_err_code56.default)(new Error("could not find source"), "ERR_INVALID_PARAMS");
      }
      const destinationName = destinationIsDirectory ? source.name : destination.name;
      log31(`Only one source, copying to destination ${destinationIsDirectory ? "directory" : "file"} ${destinationName}`);
      return copyToFile(context, source, destinationName, trail, options);
    }
    log31("Multiple sources, wrapping in a directory");
    return copyToDirectory(context, sources, destination, trail, options);
  }
  return withTimeoutOption(mfsCp);
}
var isDirectory = (destination) => {
  return destination.unixfs && destination.unixfs.type && destination.unixfs.type.includes("directory");
};
var copyToFile = async (context, source, destination, destinationTrail, options) => {
  let parent2 = destinationTrail.pop();
  if (!parent2) {
    throw (0, import_err_code56.default)(new Error("destination had no parent"), "ERR_INVALID_PARAMS");
  }
  parent2 = await addSourceToParent(context, source, destination, parent2, options);
  destinationTrail.push(parent2);
  const newRootCid = await updateTree(context, destinationTrail, options);
  await updateMfsRoot(context, newRootCid, options);
};
var copyToDirectory = async (context, sources, destination, destinationTrail, options) => {
  for (let i2 = 0; i2 < sources.length; i2++) {
    const source = sources[i2];
    destination = await addSourceToParent(context, source, source.name, destination, options);
  }
  destinationTrail[destinationTrail.length - 1] = destination;
  const newRootCid = await updateTree(context, destinationTrail, options);
  await updateMfsRoot(context, newRootCid, options);
};
var addSourceToParent = async (context, source, childName, parent2, options) => {
  const sourceBlock = await context.repo.blocks.get(source.cid);
  const {
    node,
    cid,
    size
  } = await addLink(context, {
    parentCid: parent2.cid,
    size: sourceBlock.length,
    cid: source.cid,
    name: childName,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  parent2.node = node;
  parent2.cid = cid;
  parent2.size = size;
  return parent2;
};
var import_err_code58 = __toESM(require_err_code(), 1);
var import_err_code57 = __toESM(require_err_code(), 1);
var log32 = logger("ipfs:mfs:core:utils:remove-link");
async function removeLink(context, options) {
  let parent2 = options.parent;
  if (options.parentCid) {
    const parentCid = CID.asCID(options.parentCid);
    if (parentCid === null) {
      throw (0, import_err_code57.default)(new Error("Invalid CID passed to removeLink"), "EINVALIDPARENTCID");
    }
    log32(`Loading parent node ${parentCid}`);
    const block = await context.repo.blocks.get(parentCid);
    parent2 = decode2$1(block);
  }
  if (!parent2) {
    throw (0, import_err_code57.default)(new Error("No parent node or CID passed to removeLink"), "EINVALIDPARENT");
  }
  if (!options.name) {
    throw (0, import_err_code57.default)(new Error("No child name passed to removeLink"), "EINVALIDCHILDNAME");
  }
  if (!parent2.Data) {
    throw (0, import_err_code57.default)(new Error("Parent node had no data"), "ERR_INVALID_NODE");
  }
  const meta = UnixFS.unmarshal(parent2.Data);
  if (meta.type === "hamt-sharded-directory") {
    log32(`Removing ${options.name} from sharded directory`);
    return removeFromShardedDirectory(context, {
      ...options,
      parent: parent2
    });
  }
  log32(`Removing link ${options.name} regular directory`);
  return removeFromDirectory(context, {
    ...options,
    parent: parent2
  });
}
var removeFromDirectory = async (context, options) => {
  options.parent.Links = options.parent.Links.filter((link) => {
    return link.Name !== options.name;
  });
  const parentBlock = await encode$1(options.parent);
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const hash3 = await hasher.digest(parentBlock);
  const parentCid = CID.create(options.cidVersion, code, hash3);
  await context.repo.blocks.put(parentCid, parentBlock);
  log32(`Updated regular directory ${parentCid}`);
  return {
    node: options.parent,
    cid: parentCid
  };
};
var removeFromShardedDirectory = async (context, options) => {
  const {
    rootBucket,
    path: path2
  } = await generatePath(context, options.name, options.parent);
  await rootBucket.del(options.name);
  const {
    node
  } = await updateShard(context, path2, options.name, options);
  return updateHamtDirectory(context, node.Links, rootBucket, options);
};
var updateShard = async (context, positions, name9, options) => {
  const last2 = positions.pop();
  if (!last2) {
    throw (0, import_err_code57.default)(new Error("Could not find parent"), "EINVALIDPARENT");
  }
  const {
    bucket,
    prefix,
    node
  } = last2;
  if (!node) {
    throw (0, import_err_code57.default)(new Error("Could not find parent"), "EINVALIDPARENT");
  }
  const link = node.Links.find((link2) => (link2.Name || "").substring(0, 2) === prefix);
  if (!link) {
    throw (0, import_err_code57.default)(new Error(`No link found with prefix ${prefix} for file ${name9}`), "ERR_NOT_FOUND");
  }
  if (link.Name === `${prefix}${name9}`) {
    log32(`Removing existing link ${link.Name}`);
    const links3 = node.Links.filter((nodeLink) => {
      return nodeLink.Name !== link.Name;
    });
    await bucket.del(name9);
    return updateHamtDirectory(context, links3, bucket, options);
  }
  log32(`Descending into sub-shard ${link.Name} for ${prefix}${name9}`);
  const result = await updateShard(context, positions, name9, options);
  let cid = result.cid;
  let size = result.size;
  let newName = prefix;
  if (result.node.Links.length === 1) {
    log32(`Removing subshard for ${prefix}`);
    const link2 = result.node.Links[0];
    newName = `${prefix}${(link2.Name || "").substring(2)}`;
    cid = link2.Hash;
    size = link2.Tsize || 0;
  }
  log32(`Updating shard ${prefix} with name ${newName}`);
  return updateShardParent(context, bucket, node, prefix, newName, size, cid, options);
};
var updateShardParent = (context, bucket, parent2, oldName, newName, size, cid, options) => {
  const parentLinks = parent2.Links.filter((link) => {
    return link.Name !== oldName;
  });
  parentLinks.push({
    Name: newName,
    Tsize: size,
    Hash: cid
  });
  return updateHamtDirectory(context, parentLinks, bucket, options);
};
var mergeOptions7 = merge_options_default.bind({ ignoreUndefined: true });
var defaultOptions8 = {
  recursive: false,
  cidVersion: 0,
  hashAlg: "sha2-256",
  flush: true,
  shardSplitThreshold: 1e3
};
function createRm4(context) {
  async function mfsRm(paths, opts = {}) {
    const options = mergeOptions7(defaultOptions8, opts);
    if (!Array.isArray(paths)) {
      paths = [paths];
    }
    const sources = await Promise.all(
      paths.map((path2) => toMfsPath(context, path2, options))
    );
    if (!sources.length) {
      throw (0, import_err_code58.default)(new Error("Please supply at least one path to remove"), "ERR_INVALID_PARAMS");
    }
    sources.forEach((source) => {
      if (source.path === "/") {
        throw (0, import_err_code58.default)(new Error("Cannot delete root"), "ERR_INVALID_PARAMS");
      }
    });
    for (const source of sources) {
      await removePath(context, source.path, options);
    }
  }
  return withTimeoutOption(mfsRm);
}
var removePath = async (context, path2, options) => {
  const mfsPath = await toMfsPath(context, path2, options);
  const trail = await toTrail(context, mfsPath.mfsPath);
  const child = trail[trail.length - 1];
  trail.pop();
  const parent2 = trail[trail.length - 1];
  if (!parent2) {
    throw (0, import_err_code58.default)(new Error(`${path2} does not exist`), "ERR_NOT_FOUND");
  }
  if (child.type === "directory" && !options.recursive) {
    throw (0, import_err_code58.default)(new Error(`${path2} is a directory, use -r to remove directories`), "ERR_WAS_DIR");
  }
  const {
    cid
  } = await removeLink(context, {
    parentCid: parent2.cid,
    name: child.name,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  parent2.cid = cid;
  const newRootCid = await updateTree(context, trail, options);
  await updateMfsRoot(context, newRootCid, options);
};
var mergeOptions8 = merge_options_default.bind({ ignoreUndefined: true });
var log33 = logger("ipfs:mfs:touch");
var defaultOptions9 = {
  flush: true,
  shardSplitThreshold: 1e3,
  hashAlg: "sha2-256",
  cidVersion: 0,
  recursive: false
};
function calculateModification(mode, originalMode, isDirectory2) {
  let modification = 0;
  if (mode.includes("x") || mode.includes("X") && (isDirectory2 || (originalMode & 1 || originalMode & 8 || originalMode & 64))) {
    modification += 1;
  }
  if (mode.includes("w")) {
    modification += 2;
  }
  if (mode.includes("r")) {
    modification += 4;
  }
  return modification;
}
function calculateUGO(references, modification) {
  let ugo = 0;
  if (references.includes("u")) {
    ugo += modification << 6;
  }
  if (references.includes("g")) {
    ugo += modification << 3;
  }
  if (references.includes("o")) {
    ugo += modification;
  }
  return ugo;
}
function calculateSpecial(references, mode, modification) {
  if (mode.includes("t")) {
    modification += parseInt("1000", 8);
  }
  if (mode.includes("s")) {
    if (references.includes("u")) {
      modification += parseInt("4000", 8);
    }
    if (references.includes("g")) {
      modification += parseInt("2000", 8);
    }
  }
  return modification;
}
function parseSymbolicMode(input, originalMode, isDirectory2) {
  if (!originalMode) {
    originalMode = 0;
  }
  const match = input.match(/^(u?g?o?a?)(-?\+?=?)?(r?w?x?X?s?t?)$/);
  if (!match) {
    throw new Error(`Invalid file mode: ${input}`);
  }
  let [
    ,
    references,
    operator,
    mode
  ] = match;
  if (references === "a" || !references) {
    references = "ugo";
  }
  let modification = calculateModification(mode, originalMode, isDirectory2);
  modification = calculateUGO(references, modification);
  modification = calculateSpecial(references, mode, modification);
  if (operator === "=") {
    if (references.includes("u")) {
      originalMode = originalMode & parseInt("7077", 8);
      originalMode = originalMode | modification;
    }
    if (references.includes("g")) {
      originalMode = originalMode & parseInt("7707", 8);
      originalMode = originalMode | modification;
    }
    if (references.includes("o")) {
      originalMode = originalMode & parseInt("7770", 8);
      originalMode = originalMode | modification;
    }
    return originalMode;
  }
  if (operator === "+") {
    return modification | originalMode;
  }
  if (operator === "-") {
    return modification ^ originalMode;
  }
  return originalMode;
}
function calculateMode(mode, metadata) {
  if (mode instanceof String || typeof mode === "string") {
    const strMode = `${mode}`;
    if (strMode.match(/^\d+$/g)) {
      mode = parseInt(strMode, 8);
    } else {
      mode = 0 + strMode.split(",").reduce((curr, acc) => {
        return parseSymbolicMode(acc, curr, metadata.isDirectory());
      }, metadata.mode || 0);
    }
  }
  return mode;
}
function createChmod(context) {
  async function mfsChmod(path2, mode, options = {}) {
    const opts = mergeOptions8(defaultOptions9, options);
    log33(`Fetching stats for ${path2}`);
    const {
      cid,
      mfsDirectory,
      name: name9
    } = await toMfsPath(context, path2, opts);
    if (cid.code !== code) {
      throw (0, import_err_code59.default)(new Error(`${path2} was not a UnixFS node`), "ERR_NOT_UNIXFS");
    }
    if (opts.recursive) {
      const root2 = await pipe(
        async function* () {
          for await (const entry of recursive(cid, context.repo.blocks)) {
            if (entry.type !== "file" && entry.type !== "directory") {
              throw (0, import_err_code59.default)(new Error(`${path2} was not a UnixFS node`), "ERR_NOT_UNIXFS");
            }
            entry.unixfs.mode = calculateMode(mode, entry.unixfs);
            const node2 = prepare({
              Data: entry.unixfs.marshal(),
              Links: entry.node.Links
            });
            yield {
              path: entry.path,
              content: node2
            };
          }
        },
        // @ts-expect-error we account for the incompatible source type with our custom dag builder below
        (source) => importer2(source, context.repo.blocks, {
          ...opts,
          pin: false,
          dagBuilder: async function* (source2, block2, opts2) {
            for await (const entry of source2) {
              yield async function() {
                const node2 = entry.content;
                const buf2 = encode$1(node2);
                const cid2 = await persist2(buf2, block2, opts2);
                if (!node2.Data) {
                  throw (0, import_err_code59.default)(new Error(`${cid2} had no data`), "ERR_INVALID_NODE");
                }
                const unixfs = UnixFS.unmarshal(node2.Data);
                return {
                  cid: cid2,
                  size: buf2.length,
                  path: entry.path,
                  unixfs
                };
              };
            }
          }
        }),
        (nodes) => last(nodes)
      );
      if (!root2) {
        throw (0, import_err_code59.default)(new Error(`Could not chmod ${path2}`), "ERR_COULD_NOT_CHMOD");
      }
      await createRm4(context)(path2, opts);
      await createCp(context)(`/ipfs/${root2.cid}`, path2, opts);
      return;
    }
    const block = await context.repo.blocks.get(cid);
    const node = decode2$1(block);
    if (!node.Data) {
      throw (0, import_err_code59.default)(new Error(`${cid} had no data`), "ERR_INVALID_NODE");
    }
    const metadata = UnixFS.unmarshal(node.Data);
    metadata.mode = calculateMode(mode, metadata);
    const updatedBlock = encode$1({
      Data: metadata.marshal(),
      Links: node.Links
    });
    const hashAlg = opts.hashAlg || defaultOptions9.hashAlg;
    const hasher = await context.hashers.getHasher(hashAlg);
    const hash3 = await hasher.digest(updatedBlock);
    const updatedCid = CID.create(opts.cidVersion, code, hash3);
    if (opts.flush) {
      await context.repo.blocks.put(updatedCid, updatedBlock);
    }
    const trail = await toTrail(context, mfsDirectory);
    const parent2 = trail[trail.length - 1];
    const parentCid = CID.decode(parent2.cid.bytes);
    const parentBlock = await context.repo.blocks.get(parentCid);
    const parentNode = decode2$1(parentBlock);
    const result = await addLink(context, {
      parent: parentNode,
      name: name9,
      cid: updatedCid,
      size: updatedBlock.length,
      flush: opts.flush,
      // TODO vmx 2021-03-29: decide on the API, whether it should be a `hashAlg` or `hasher`
      hashAlg,
      cidVersion: cid.version,
      shardSplitThreshold: Infinity
    });
    parent2.cid = result.cid;
    const newRootCid = await updateTree(context, trail, opts);
    await updateMfsRoot(context, newRootCid, opts);
  }
  return withTimeoutOption(mfsChmod);
}
var mergeOptions9 = merge_options_default.bind({ ignoreUndefined: true });
var defaultOptions10 = {};
function createFlush(context) {
  async function mfsFlush(path2, options = {}) {
    options = mergeOptions9(defaultOptions10, options);
    const { cid } = await createStat3(context)(path2, options);
    return cid;
  }
  return withTimeoutOption(mfsFlush);
}
var mergeOptions10 = merge_options_default.bind({ ignoreUndefined: true });
var defaultOptions11 = {
  parents: false,
  flush: true,
  cidVersion: 0,
  hashAlg: "sha2-256",
  shardSplitThreshold: 1e3
};
function createMv(context) {
  async function mfsMv(from3, to, options = {}) {
    const opts = mergeOptions10(defaultOptions11, options);
    await createCp(context)(from3, to, opts);
    await createRm4(context)(from3, {
      ...opts,
      recursive: true
    });
  }
  return withTimeoutOption(mfsMv);
}
var import_err_code60 = __toESM(require_err_code(), 1);
var mergeOptions11 = merge_options_default.bind({ ignoreUndefined: true });
var log34 = logger("ipfs:mfs:touch");
var defaultOptions12 = {
  flush: true,
  shardSplitThreshold: 1e3,
  cidVersion: 0,
  hashAlg: "sha2-256"
};
function createTouch(context) {
  async function mfsTouch(path2, options = {}) {
    const settings = mergeOptions11(defaultOptions12, options);
    settings.mtime = settings.mtime || new Date();
    log34(`Touching ${path2} mtime: ${settings.mtime}`);
    const {
      cid,
      mfsDirectory,
      name: name9,
      exists: exists2
    } = await toMfsPath(context, path2, settings);
    const hashAlg = options.hashAlg || defaultOptions12.hashAlg;
    const hasher = await context.hashers.getHasher(hashAlg);
    let updatedBlock;
    let updatedCid;
    let cidVersion = settings.cidVersion;
    if (!exists2) {
      const metadata = new UnixFS({
        type: "file",
        mtime: settings.mtime
      });
      updatedBlock = encode$1({ Data: metadata.marshal(), Links: [] });
      const hash3 = await hasher.digest(updatedBlock);
      updatedCid = CID.create(settings.cidVersion, code, hash3);
      if (settings.flush) {
        await context.repo.blocks.put(updatedCid, updatedBlock);
      }
    } else {
      if (cid.code !== code) {
        throw (0, import_err_code60.default)(new Error(`${path2} was not a UnixFS node`), "ERR_NOT_UNIXFS");
      }
      cidVersion = cid.version;
      const block = await context.repo.blocks.get(cid);
      const node = decode2$1(block);
      if (!node.Data) {
        throw (0, import_err_code60.default)(new Error(`${path2} had no data`), "ERR_INVALID_NODE");
      }
      const metadata = UnixFS.unmarshal(node.Data);
      metadata.mtime = settings.mtime;
      updatedBlock = encode$1({
        Data: metadata.marshal(),
        Links: node.Links
      });
      const hash3 = await hasher.digest(updatedBlock);
      updatedCid = CID.create(settings.cidVersion, code, hash3);
      if (settings.flush) {
        await context.repo.blocks.put(updatedCid, updatedBlock);
      }
    }
    const trail = await toTrail(context, mfsDirectory);
    const parent2 = trail[trail.length - 1];
    const parentCid = parent2.cid;
    const parentBlock = await context.repo.blocks.get(parentCid);
    const parentNode = decode2$1(parentBlock);
    const result = await addLink(context, {
      parent: parentNode,
      name: name9,
      cid: updatedCid,
      size: updatedBlock.length,
      flush: settings.flush,
      shardSplitThreshold: settings.shardSplitThreshold,
      hashAlg: settings.hashAlg,
      cidVersion
    });
    parent2.cid = result.cid;
    const newRootCid = await updateTree(context, trail, settings);
    await updateMfsRoot(context, newRootCid, settings);
  }
  return withTimeoutOption(mfsTouch);
}
var import_err_code61 = __toESM(require_err_code(), 1);
var mergeOptions12 = merge_options_default.bind({ ignoreUndefined: true });
var defaultOptions13 = {
  offset: 0,
  length: Infinity
};
function createRead(context) {
  function mfsRead(path2, options = {}) {
    options = mergeOptions12(defaultOptions13, options);
    return {
      [Symbol.asyncIterator]: async function* read2() {
        const mfsPath = await toMfsPath(context, path2, options);
        const result = await exporter2(mfsPath.mfsPath, context.repo.blocks);
        if (result.type !== "file" && result.type !== "raw") {
          throw (0, import_err_code61.default)(new Error(`${path2} was not a file or raw bytes`), "ERR_NOT_FILE");
        }
        if (!result.content) {
          throw (0, import_err_code61.default)(new Error(`Could not load content stream from ${path2}`), "ERR_NO_CONTENT");
        }
        for await (const buf2 of result.content({
          offset: options.offset,
          length: options.length
        })) {
          yield buf2;
        }
      }
    };
  }
  return withTimeoutOption(mfsRead);
}
var import_err_code62 = __toESM(require_err_code(), 1);
var log35 = logger("ipfs:mfs:utils:to-async-iterator");
function toAsyncIterator(content) {
  if (!content) {
    throw (0, import_err_code62.default)(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
  }
  if (typeof content === "string" || content instanceof String) {
    log35("Content was a string");
    content = fromString3(content.toString());
  }
  if (content.length) {
    log35("Content was array-like");
    return {
      [Symbol.asyncIterator]: function* bufferContent() {
        yield content;
      }
    };
  }
  if (content[Symbol.asyncIterator]) {
    log35("Content was an async iterator");
    return content;
  }
  if (content[Symbol.iterator]) {
    log35("Content was an iterator");
    return content;
  }
  if (globalThis.Blob && content instanceof globalThis.Blob) {
    log35("Content was an HTML5 Blob");
    return browserReadableStreamToIt(content.stream());
  }
  throw (0, import_err_code62.default)(new Error(`Don't know how to convert ${content} into an async iterator`), "ERR_INVALID_PARAMS");
}
var import_err_code63 = __toESM(require_err_code(), 1);
var mergeOptions13 = merge_options_default.bind({ ignoreUndefined: true });
var log36 = logger("ipfs:mfs:write");
var defaultOptions14 = {
  offset: 0,
  // the offset in the file to begin writing
  length: Infinity,
  // how many bytes from the incoming buffer to write
  create: false,
  // whether to create the file if it does not exist
  truncate: false,
  // whether to truncate the file first
  rawLeaves: false,
  reduceSingleLeafToSelf: false,
  cidVersion: 0,
  hashAlg: "sha2-256",
  parents: false,
  // whether to create intermediate directories if they do not exist
  progress: (bytes2, path2) => {
  },
  strategy: "trickle",
  flush: true,
  leafType: "raw",
  shardSplitThreshold: 1e3
};
function createWrite(context) {
  async function mfsWrite(path2, content, opts = {}) {
    const options = mergeOptions13(defaultOptions14, opts);
    let source;
    let destination;
    let parent2;
    log36("Reading source, destination and parent");
    await createLock().readLock(async () => {
      source = await toAsyncIterator(content);
      destination = await toMfsPath(context, path2, options);
      parent2 = await toMfsPath(context, destination.mfsDirectory, options);
    })();
    log36("Read source, destination and parent");
    if (!options.parents && !parent2.exists) {
      throw (0, import_err_code63.default)(new Error("directory does not exist"), "ERR_NO_EXIST");
    }
    if (source == null) {
      throw (0, import_err_code63.default)(new Error("could not create source"), "ERR_NO_SOURCE");
    }
    if (destination == null) {
      throw (0, import_err_code63.default)(new Error("could not create destination"), "ERR_NO_DESTINATION");
    }
    if (!options.create && !destination.exists) {
      throw (0, import_err_code63.default)(new Error("file does not exist"), "ERR_NO_EXIST");
    }
    if (destination.entryType !== "file") {
      throw (0, import_err_code63.default)(new Error("not a file"), "ERR_NOT_A_FILE");
    }
    return updateOrImport(context, path2, source, destination, options);
  }
  return withTimeoutOption(mfsWrite);
}
var updateOrImport = async (context, path2, source, destination, options) => {
  const child = await write(context, source, destination, options);
  await createLock().writeLock(async () => {
    const pathComponents = toPathComponents3(path2);
    const fileName = pathComponents.pop();
    if (fileName == null) {
      throw (0, import_err_code63.default)(new Error("source does not exist"), "ERR_NO_EXIST");
    }
    let parentExists = false;
    try {
      await createStat3(context)(`/${pathComponents.join("/")}`, options);
      parentExists = true;
    } catch (err2) {
      if (err2.code !== "ERR_NOT_FOUND") {
        throw err2;
      }
    }
    if (!parentExists) {
      await createMkdir(context)(`/${pathComponents.join("/")}`, options);
    }
    const updatedPath = await toMfsPath(context, path2, options);
    const trail = await toTrail(context, updatedPath.mfsDirectory);
    const parent2 = trail[trail.length - 1];
    if (!parent2) {
      throw (0, import_err_code63.default)(new Error("directory does not exist"), "ERR_NO_EXIST");
    }
    if (!parent2.type || !parent2.type.includes("directory")) {
      throw (0, import_err_code63.default)(new Error(`cannot write to ${parent2.name}: Not a directory`), "ERR_NOT_A_DIRECTORY");
    }
    const parentBlock = await context.repo.blocks.get(parent2.cid);
    const parentNode = decode2$1(parentBlock);
    const result = await addLink(context, {
      parent: parentNode,
      name: fileName,
      cid: child.cid,
      size: child.size,
      flush: options.flush,
      shardSplitThreshold: options.shardSplitThreshold,
      hashAlg: options.hashAlg,
      cidVersion: options.cidVersion
    });
    parent2.cid = result.cid;
    const newRootCid = await updateTree(context, trail, options);
    await updateMfsRoot(context, newRootCid, options);
  })();
};
var write = async (context, source, destination, options) => {
  if (destination.exists) {
    log36(`Overwriting file ${destination.cid} offset ${options.offset} length ${options.length}`);
  } else {
    log36(`Writing file offset ${options.offset} length ${options.length}`);
  }
  const sources = [];
  if (options.offset > 0) {
    if (destination.unixfs) {
      log36(`Writing first ${options.offset} bytes of original file`);
      sources.push(
        () => {
          return destination.content({
            offset: 0,
            length: options.offset
          });
        }
      );
      if (destination.unixfs.fileSize() < options.offset) {
        const extra = options.offset - destination.unixfs.fileSize();
        log36(`Writing zeros for extra ${extra} bytes`);
        sources.push(
          asyncZeroes(extra)
        );
      }
    } else {
      log36(`Writing zeros for first ${options.offset} bytes`);
      sources.push(
        asyncZeroes(options.offset)
      );
    }
  }
  sources.push(
    limitAsyncStreamBytes(source, options.length)
  );
  const content = countBytesStreamed(catAsyncIterators(sources), (bytesWritten) => {
    if (destination.unixfs && !options.truncate) {
      const fileSize = destination.unixfs.fileSize();
      if (fileSize > bytesWritten) {
        log36(`Writing last ${fileSize - bytesWritten} of ${fileSize} bytes from original file starting at offset ${bytesWritten}`);
        return destination.content({
          offset: bytesWritten
        });
      } else {
        log36("Not writing last bytes from original file");
      }
    }
    return {
      [Symbol.asyncIterator]: async function* () {
      }
    };
  });
  let mode;
  if (options.mode !== void 0 && options.mode !== null) {
    mode = parseMode(options.mode);
  } else if (destination && destination.unixfs) {
    mode = destination.unixfs.mode;
  }
  let mtime;
  if (options.mtime != null) {
    mtime = parseMtime(options.mtime);
  } else if (destination && destination.unixfs) {
    mtime = destination.unixfs.mtime;
  }
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const result = await last(importer2([{
    content,
    // persist mode & mtime if set previously
    mode,
    mtime
  }], context.repo.blocks, {
    progress: options.progress,
    hasher,
    cidVersion: options.cidVersion,
    strategy: options.strategy,
    rawLeaves: options.rawLeaves,
    reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,
    leafType: options.leafType
  }));
  if (!result) {
    throw (0, import_err_code63.default)(new Error(`cannot write to ${parent.name}`), "ERR_COULD_NOT_WRITE");
  }
  log36(`Wrote ${result.cid}`);
  return {
    cid: result.cid,
    size: result.size
  };
};
var limitAsyncStreamBytes = (stream, limit) => {
  return async function* _limitAsyncStreamBytes() {
    let emitted = 0;
    for await (const buf2 of stream) {
      emitted += buf2.length;
      if (emitted > limit) {
        yield buf2.subarray(0, limit - emitted);
        return;
      }
      yield buf2;
    }
  };
};
var asyncZeroes = (count, chunkSize = MFS_MAX_CHUNK_SIZE) => {
  const buf2 = new Uint8Array(chunkSize);
  async function* _asyncZeroes() {
    while (true) {
      yield buf2;
    }
  }
  return limitAsyncStreamBytes(_asyncZeroes(), count);
};
var catAsyncIterators = async function* (sources) {
  for (let i2 = 0; i2 < sources.length; i2++) {
    yield* sources[i2]();
  }
};
var countBytesStreamed = async function* (source, notify) {
  let wrote = 0;
  for await (const buf2 of source) {
    wrote += buf2.length;
    yield buf2;
  }
  for await (const buf2 of notify(wrote)) {
    wrote += buf2.length;
    yield buf2;
  }
};
var toOutput = (fsEntry) => {
  const output = {
    cid: fsEntry.cid,
    name: fsEntry.name,
    type: fsEntry.type === "directory" ? "directory" : "file",
    size: fsEntry.size
  };
  if (fsEntry.type === "file" || fsEntry.type === "directory") {
    output.mode = fsEntry.unixfs.mode;
    output.mtime = fsEntry.unixfs.mtime;
  }
  return output;
};
function createLs3(context) {
  async function* mfsLs(path2, options = {}) {
    const mfsPath = await toMfsPath(context, path2, options);
    const fsEntry = await exporter2(mfsPath.mfsPath, context.repo.blocks);
    if (fsEntry.type === "directory") {
      yield* map(fsEntry.content(options), toOutput);
      return;
    }
    yield toOutput(fsEntry);
  }
  return withTimeoutOption(mfsLs);
}
var readOperations = {
  stat: createStat3
};
var writeOperations = {
  chmod: createChmod,
  cp: createCp,
  flush: createFlush,
  mkdir: createMkdir,
  mv: createMv,
  rm: createRm4,
  touch: createTouch
};
var unwrappedOperations = {
  write: createWrite,
  read: createRead,
  ls: createLs3
};
var wrap = ({
  options,
  mfs,
  operations,
  lock: lock3
}) => {
  Object.keys(operations).forEach((key) => {
    mfs[key] = lock3(operations[key](options));
  });
};
var defaultOptions15 = {
  repoOwner: true,
  repo: null
};
function createMfs(options) {
  const {
    repoOwner
  } = Object.assign({}, defaultOptions15 || {}, options);
  const lock3 = createLock(repoOwner);
  const readLock = (operation) => {
    return lock3.readLock(operation);
  };
  const writeLock = (operation) => {
    return lock3.writeLock(operation);
  };
  const mfs = {};
  wrap({
    options,
    mfs,
    operations: readOperations,
    lock: readLock
  });
  wrap({
    options,
    mfs,
    operations: writeOperations,
    lock: writeLock
  });
  Object.keys(unwrappedOperations).forEach((key) => {
    mfs[key] = unwrappedOperations[key](options);
  });
  return mfs;
}
function createFiles({ repo, preload: preload2, hashers, options: constructorOptions }) {
  const methods2 = createMfs({
    repo,
    repoOwner: constructorOptions.repoOwner !== false,
    hashers
  });
  const withPreload = (fn) => {
    const wrapped = (...args) => {
      const paths = args.filter((arg) => ipfsPath(arg) || isCID(arg));
      if (paths.length) {
        const options = args[args.length - 1];
        if (options && options.preload !== false) {
          paths.forEach((path2) => preload2(path2));
        }
      }
      return fn(...args);
    };
    return wrapped;
  };
  return {
    ...methods2,
    chmod: methods2.chmod,
    cp: withPreload(methods2.cp),
    mkdir: methods2.mkdir,
    stat: withPreload(methods2.stat),
    rm: methods2.rm,
    read: withPreload(methods2.read),
    touch: methods2.touch,
    write: methods2.write,
    mv: withPreload(methods2.mv),
    flush: methods2.flush,
    ls: withPreload(async function* (...args) {
      for await (const file of methods2.ls(...args)) {
        yield { ...file, size: file.size || 0 };
      }
    })
  };
}
function createExport2({ keychain }) {
  const exportKey2 = (name9, password) => keychain.exportKey(name9, password);
  return withTimeoutOption(exportKey2);
}
var DEFAULT_KEY_TYPE = "Ed25519";
var DEFAULT_KEY_SIZE = 2048;
function createGen({ keychain }) {
  const gen = (name9, options = { type: DEFAULT_KEY_TYPE, size: DEFAULT_KEY_SIZE }) => {
    return keychain.createKey(name9, options.type || DEFAULT_KEY_TYPE, options.size || DEFAULT_KEY_SIZE);
  };
  return withTimeoutOption(gen);
}
function createImport2({ keychain }) {
  const importKey2 = (name9, pem, password) => {
    return keychain.importKey(name9, pem, password);
  };
  return withTimeoutOption(importKey2);
}
function createInfo({ keychain }) {
  const info = (name9) => keychain.findKeyByName(name9);
  return withTimeoutOption(info);
}
function createList2({ keychain }) {
  const list = () => keychain.listKeys();
  return withTimeoutOption(list);
}
function createRename({ keychain }) {
  const rename = async (oldName, newName) => {
    const key = await keychain.renameKey(oldName, newName);
    return {
      was: oldName,
      now: key.name,
      id: key.id,
      overwrite: false
    };
  };
  return withTimeoutOption(rename);
}
function createRm5({ keychain }) {
  const rm = (name9) => keychain.removeKey(name9);
  return withTimeoutOption(rm);
}
var KeyAPI = class {
  /**
   * @param {object} config
   * @param {Keychain} config.keychain
   */
  constructor({ keychain }) {
    this.gen = createGen({ keychain });
    this.list = createList2({ keychain });
    this.rm = createRm5({ keychain });
    this.rename = createRename({ keychain });
    this.export = createExport2({ keychain });
    this.import = createImport2({ keychain });
    this.info = createInfo({ keychain });
  }
};
function createGet4({ repo, preload: preload2 }) {
  async function get3(cid, options = {}) {
    if (options.preload !== false) {
      preload2(cid);
    }
    const block = await repo.blocks.get(cid, options);
    return decode2$1(block);
  }
  return withTimeoutOption(get3);
}
function createData({ repo, preload: preload2 }) {
  const get3 = createGet4({ repo, preload: preload2 });
  async function data(multihash, options = {}) {
    const node = await get3(multihash, options);
    return node.Data || new Uint8Array(0);
  }
  return withTimeoutOption(data);
}
function findLinks(node, links3 = []) {
  for (const key in node) {
    const val = node[key];
    if (key === "/" && Object.keys(node).length === 1) {
      try {
        links3.push({
          Name: "",
          Tsize: 0,
          Hash: CID.parse(val)
        });
        continue;
      } catch (_) {
      }
    }
    const cid = CID.asCID(val);
    if (cid) {
      links3.push({
        Name: "",
        Tsize: 0,
        Hash: cid
      });
      continue;
    }
    if (Array.isArray(val)) {
      findLinks(val, links3);
    }
    if (val && typeof val === "object") {
      findLinks(val, links3);
    }
  }
  return links3;
}
function createLinks({ repo, codecs: codecs2 }) {
  async function links3(cid, options = {}) {
    const codec = await codecs2.getCodec(cid.code);
    const block = await repo.blocks.get(cid, options);
    const node = codec.decode(block);
    switch (cid.code) {
      case code6:
        return [];
      case code:
        return node.Links;
      case code2:
      case code3:
        return findLinks(node);
      default:
        throw new Error(`Cannot resolve links from codec ${cid.code}`);
    }
  }
  return withTimeoutOption(links3);
}
function createNew({ repo, preload: preload2 }) {
  async function _new(options = {}) {
    let data;
    if (options.template) {
      if (options.template === "unixfs-dir") {
        data = new UnixFS({ type: "directory" }).marshal();
      } else {
        throw new Error("unknown template");
      }
    }
    const buf2 = encode$1({
      Data: data,
      Links: []
    });
    const hash3 = await sha256.digest(buf2);
    const cid = CID.createV0(hash3);
    await repo.blocks.put(cid, buf2, {
      signal: options.signal
    });
    if (options.preload !== false) {
      preload2(cid);
    }
    return cid;
  }
  return withTimeoutOption(_new);
}
function createPut3({ repo, preload: preload2 }) {
  async function put(obj, options = {}) {
    const release = await repo.gcLock.readLock();
    try {
      const buf2 = encode$1(obj);
      const hash3 = await sha256.digest(buf2);
      const cid = CID.createV1(code, hash3);
      await repo.blocks.put(cid, buf2, {
        signal: options.signal
      });
      if (options.preload !== false) {
        preload2(cid);
      }
      if (options.pin) {
        await repo.pins.pinRecursively(cid, {
          signal: options.signal
        });
      }
      return cid;
    } finally {
      release();
    }
  }
  return withTimeoutOption(put);
}
function createStat4({ repo, preload: preload2 }) {
  const get3 = createGet4({ repo, preload: preload2 });
  async function stat(cid, options = {}) {
    const node = await get3(cid, options);
    const serialized = encode$1(node);
    const blockSize = serialized.length;
    const linkLength = node.Links.reduce((a, l) => a + (l.Tsize || 0), 0);
    return {
      Hash: cid,
      NumLinks: node.Links.length,
      BlockSize: blockSize,
      LinksSize: blockSize - (node.Data || []).length,
      DataSize: (node.Data || []).length,
      CumulativeSize: blockSize + linkLength
    };
  }
  return withTimeoutOption(stat);
}
function createAddLink({ repo, preload: preload2 }) {
  const get3 = createGet4({ repo, preload: preload2 });
  const put = createPut3({ repo, preload: preload2 });
  async function addLink2(cid, link, options = {}) {
    const node = await get3(cid, options);
    return put({
      ...node,
      Links: node.Links.concat([link])
    }, options);
  }
  return withTimeoutOption(addLink2);
}
function createAppendData({ repo, preload: preload2 }) {
  const get3 = createGet4({ repo, preload: preload2 });
  const put = createPut3({ repo, preload: preload2 });
  async function appendData(cid, data, options = {}) {
    const node = await get3(cid, options);
    const newData = concat([node.Data || [], data]);
    return put({
      ...node,
      Data: newData
    }, options);
  }
  return withTimeoutOption(appendData);
}
function createRmLink({ repo, preload: preload2 }) {
  const get3 = createGet4({ repo, preload: preload2 });
  const put = createPut3({ repo, preload: preload2 });
  async function rmLink(cid, link, options = {}) {
    const node = await get3(cid, options);
    const name9 = (typeof link === "string" ? link : link.Name) || "";
    node.Links = node.Links.filter((l) => l.Name !== name9);
    return put(node, options);
  }
  return withTimeoutOption(rmLink);
}
function createSetData({ repo, preload: preload2 }) {
  const get3 = createGet4({ repo, preload: preload2 });
  const put = createPut3({ repo, preload: preload2 });
  async function setData(cid, data, options = {}) {
    const node = await get3(cid, options);
    return put({
      ...node,
      Data: data
    }, options);
  }
  return withTimeoutOption(setData);
}
var ObjectPatchAPI = class {
  /**
   * @param {object} config
   * @param {import('ipfs-repo').IPFSRepo} config.repo
   * @param {Preload} config.preload
   */
  constructor({ repo, preload: preload2 }) {
    this.addLink = createAddLink({ repo, preload: preload2 });
    this.appendData = createAppendData({ repo, preload: preload2 });
    this.rmLink = createRmLink({ repo, preload: preload2 });
    this.setData = createSetData({ repo, preload: preload2 });
  }
};
var ObjectAPI = class {
  /**
   * @param {object} config
   * @param {import('ipfs-repo').IPFSRepo} config.repo
   * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs
   * @param {Preload} config.preload
   */
  constructor({ repo, codecs: codecs2, preload: preload2 }) {
    this.data = createData({ repo, preload: preload2 });
    this.get = createGet4({ repo, preload: preload2 });
    this.links = createLinks({ repo, codecs: codecs2 });
    this.new = createNew({ repo, preload: preload2 });
    this.put = createPut3({ repo, preload: preload2 });
    this.stat = createStat4({ repo, preload: preload2 });
    this.patch = new ObjectPatchAPI({ repo, preload: preload2 });
  }
};
var log37 = logger("ipfs:repo:gc");
function createGc({ repo, hashers }) {
  async function* gc2(options = {}) {
    const start = Date.now();
    let mfsRootCid;
    try {
      mfsRootCid = await loadMfsRoot({
        repo,
        hashers
      }, options);
      await repo.pins.pinRecursively(mfsRootCid);
      yield* repo.gc();
    } finally {
      if (mfsRootCid) {
        await repo.pins.unpin(mfsRootCid);
      }
    }
    log37(`Complete (${Date.now() - start}ms)`);
  }
  return withTimeoutOption(gc2);
}
function createStat5({ repo }) {
  async function stat(options = {}) {
    const stats = await repo.stat();
    return {
      numObjects: BigInt(stats.numObjects.toString()),
      repoSize: BigInt(stats.repoSize.toString()),
      repoPath: stats.repoPath,
      version: `${stats.version}`,
      storageMax: BigInt(stats.storageMax.toString())
    };
  }
  return withTimeoutOption(stat);
}
var repoVersion = 12;
function createVersion2({ repo }) {
  async function version3(options = {}) {
    try {
      await repo._checkInitialized(options);
    } catch (err2) {
      const match = [
        /Key not found in database \[\/version\]/,
        /ENOENT/,
        /repo is not initialized yet/
      ].some((m) => {
        return m.test(err2.message);
      });
      if (match) {
        return repoVersion;
      }
      throw err2;
    }
    return repo.version.get();
  }
  return withTimeoutOption(version3);
}
var RepoAPI = class {
  /**
   * @param {object} config
   * @param {import('ipfs-repo').IPFSRepo} config.repo
   * @param {Multihashes} config.hashers
   */
  constructor({ repo, hashers }) {
    this.gc = createGc({ repo, hashers });
    this.stat = createStat5({ repo });
    this.version = createVersion2({ repo });
    this.setApiAddr = (addr) => repo.apiAddr.set(addr);
  }
};
var import_err_code64 = __toESM(require_err_code(), 1);
function getBandwidthStats(libp2p, opts) {
  return {
    totalIn: BigInt(0),
    totalOut: BigInt(0),
    rateIn: 0,
    rateOut: 0
  };
}
function createBw({ network }) {
  const bw = async function* (options = {}) {
    const { libp2p } = await network.use(options);
    if (!options.poll) {
      yield getBandwidthStats();
      return;
    }
    const interval = options.interval || 1e3;
    let ms = -1;
    try {
      ms = typeof interval === "string" ? parse_duration_default(interval) || -1 : interval;
      if (!ms || ms < 0)
        throw new Error("invalid duration");
    } catch (err2) {
      throw (0, import_err_code64.default)(err2, "ERR_INVALID_POLL_INTERVAL");
    }
    let timeoutId;
    try {
      while (true) {
        yield getBandwidthStats(libp2p, options);
        await new Promise((resolve7) => {
          timeoutId = setTimeout(resolve7, ms);
        });
      }
    } finally {
      clearTimeout(timeoutId);
    }
  };
  return withTimeoutOption(bw);
}
var StatsAPI = class {
  /**
   * @param {object} config
   * @param {import('ipfs-repo').IPFSRepo} config.repo
   * @param {import('../../types').NetworkService} config.network
   */
  constructor({ repo, network }) {
    this.repo = createStat5({ repo });
    this.bw = createBw({ network });
    this.bitswap = createStat({ network });
  }
};
var objectSafeGet = get2;
function get2(obj, propsArg, defaultValue) {
  if (!obj) {
    return defaultValue;
  }
  var props, prop;
  if (Array.isArray(propsArg)) {
    props = propsArg.slice(0);
  }
  if (typeof propsArg == "string") {
    props = propsArg.split(".");
  }
  if (typeof propsArg == "symbol") {
    props = [propsArg];
  }
  if (!Array.isArray(props)) {
    throw new Error("props arg must be an array, a string or a symbol");
  }
  while (props.length) {
    prop = props.shift();
    if (!obj) {
      return defaultValue;
    }
    obj = obj[prop];
    if (obj === void 0) {
      return defaultValue;
    }
  }
  return obj;
}
var import_debug10 = __toESM(require_browser$1());
var import_err_code70 = __toESM(require_err_code());
var import_debug2 = __toESM(require_browser$1(), 1);
async function length(iterator) {
  let count = 0;
  for await (const _ of iterator) {
    count++;
  }
  return count;
}
var log38 = (0, import_debug2.default)("ipfs:repo:migrator:migration-8");
function unwrap(blockstore) {
  if (blockstore.child) {
    return unwrap(blockstore.child);
  }
  return blockstore;
}
function keyToMultihash(key) {
  try {
    const buf2 = base32.decode(`b${key.toString().toLowerCase().slice(1)}`);
    const multihash = CID.decode(buf2).multihash.bytes;
    const multihashStr = base32.encode(multihash).slice(1).toUpperCase();
    return new Key(`/${multihashStr}`, false);
  } catch (err2) {
    return key;
  }
}
function keyToCid(key) {
  try {
    const buf2 = base32.decode(`b${key.toString().toLowerCase().slice(1)}`);
    const digest2 = decode3$3(buf2);
    const multihash = base32.encode(CID.createV1(code6, digest2).bytes).slice(1);
    return new Key(`/${multihash.toUpperCase()}`, false);
  } catch {
    return key;
  }
}
async function process2(backends, onProgress, keyFunction) {
  const blockstore = backends.blocks;
  await blockstore.open();
  const unwrapped = unwrap(blockstore);
  const blockCount = await length(unwrapped.queryKeys({
    filters: [(key) => {
      const newKey = keyFunction(key);
      return newKey.toString() !== key.toString();
    }]
  }));
  try {
    let counter = 0;
    for await (const block of unwrapped.query({})) {
      const newKey = keyFunction(block.key);
      if (newKey.toString() !== block.key.toString()) {
        counter += 1;
        log38(`Migrating Block from ${block.key} to ${newKey}`, await unwrapped.has(block.key));
        await unwrapped.delete(block.key);
        await unwrapped.put(newKey, block.value);
        onProgress(counter / blockCount * 100, `Migrated Block from ${block.key} to ${newKey}`);
      }
    }
  } finally {
    await blockstore.close();
  }
}
var migration = {
  version: 8,
  description: "Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32",
  migrate: (backends, onProgress = () => {
  }) => {
    return process2(backends, onProgress, keyToMultihash);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process2(backends, onProgress, keyToCid);
  }
};
var import_minimal3 = __toESM(require_minimal2(), 1);
var $Reader2 = import_minimal3.default.Reader;
var $Writer2 = import_minimal3.default.Writer;
import_minimal3.default.util;
var $root2 = import_minimal3.default.roots["default"] || (import_minimal3.default.roots["default"] = {});
var ipfs = $root2.ipfs = (() => {
  const ipfs2 = {};
  ipfs2.pin = function() {
    const pin = {};
    pin.Set = function() {
      function Set2(p) {
        if (p) {
          for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
            if (p[ks[i2]] != null)
              this[ks[i2]] = p[ks[i2]];
        }
      }
      Set2.prototype.version = 0;
      Set2.prototype.fanout = 0;
      Set2.prototype.seed = 0;
      Set2.encode = function encode21(m, w) {
        if (!w)
          w = $Writer2.create();
        if (m.version != null && Object.hasOwnProperty.call(m, "version"))
          w.uint32(8).uint32(m.version);
        if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
          w.uint32(16).uint32(m.fanout);
        if (m.seed != null && Object.hasOwnProperty.call(m, "seed"))
          w.uint32(29).fixed32(m.seed);
        return w;
      };
      Set2.decode = function decode17(r, l) {
        if (!(r instanceof $Reader2))
          r = $Reader2.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root2.ipfs.pin.Set();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.version = r.uint32();
              break;
            case 2:
              m.fanout = r.uint32();
              break;
            case 3:
              m.seed = r.fixed32();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Set2.fromObject = function fromObject(d) {
        if (d instanceof $root2.ipfs.pin.Set)
          return d;
        var m = new $root2.ipfs.pin.Set();
        if (d.version != null) {
          m.version = d.version >>> 0;
        }
        if (d.fanout != null) {
          m.fanout = d.fanout >>> 0;
        }
        if (d.seed != null) {
          m.seed = d.seed >>> 0;
        }
        return m;
      };
      Set2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.version = 0;
          d.fanout = 0;
          d.seed = 0;
        }
        if (m.version != null && m.hasOwnProperty("version")) {
          d.version = m.version;
        }
        if (m.fanout != null && m.hasOwnProperty("fanout")) {
          d.fanout = m.fanout;
        }
        if (m.seed != null && m.hasOwnProperty("seed")) {
          d.seed = m.seed;
        }
        return d;
      };
      Set2.prototype.toJSON = function toJSON2() {
        return this.constructor.toObject(this, import_minimal3.default.util.toJSONOptions);
      };
      return Set2;
    }();
    return pin;
  }();
  return ipfs2;
})();
var import_fnv1a = __toESM(require_fnv1a(), 1);
var import_varint6 = __toESM(require_varint(), 1);
var PIN_DS_KEY = new Key("/local/pins");
var DEFAULT_FANOUT = 256;
var MAX_ITEMS = 8192;
var EMPTY_KEY = CID.parse("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n");
var PinTypes2 = {
  direct: "direct",
  recursive: "recursive"
};
function cidToKey(cid) {
  return new Key(`/${base32.encode(cid.multihash.bytes).toUpperCase().substring(1)}`);
}
var PinSet = ipfs.pin.Set;
function readHeader2(rootNode) {
  const rootData = rootNode.Data;
  if (!rootData) {
    throw new Error("No data present");
  }
  const hdrLength = import_varint6.default.decode(rootData);
  const vBytes = import_varint6.default.decode.bytes ?? 0;
  if (vBytes <= 0) {
    throw new Error("Invalid Set header length");
  }
  if (vBytes + hdrLength > rootData.length) {
    throw new Error("Impossibly large set header length");
  }
  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);
  const header = PinSet.toObject(PinSet.decode(hdrSlice), {
    defaults: false,
    arrays: true,
    longs: Number,
    objects: false
  });
  if (header.version !== 1) {
    throw new Error(`Unsupported Set version: ${header.version}`);
  }
  if (header.fanout > rootNode.Links.length) {
    throw new Error("Impossibly large fanout");
  }
  return {
    header,
    data: rootData.slice(hdrLength + vBytes)
  };
}
function hash(seed2, key) {
  const buffer2 = new Uint8Array(4);
  const dataView2 = new DataView(buffer2.buffer);
  dataView2.setUint32(0, seed2, true);
  const encodedKey = fromString3(key.toString());
  const data = concat([buffer2, encodedKey], buffer2.byteLength + encodedKey.byteLength);
  return (0, import_fnv1a.default)(toString3(data));
}
async function* walkItems(blockstore, node) {
  const pbh = readHeader2(node);
  let idx = 0;
  for (const link of node.Links) {
    if (idx < pbh.header.fanout) {
      const linkHash = link.Hash;
      if (!EMPTY_KEY.equals(linkHash)) {
        const buf2 = await blockstore.get(linkHash);
        const node2 = decode2$1(buf2);
        yield* walkItems(blockstore, node2);
      }
    } else {
      yield link.Hash;
    }
    idx++;
  }
}
async function* loadSet(blockstore, rootNode, name9) {
  const link = rootNode.Links.find((l) => l.Name === name9);
  if (!link) {
    throw new Error("No link found with name " + name9);
  }
  const buf2 = await blockstore.get(link.Hash);
  const node = decode2$1(buf2);
  yield* walkItems(blockstore, node);
}
function storeItems(blockstore, items) {
  return storePins(items, 0);
  async function storePins(pins, depth) {
    const pbHeader = PinSet.encode({
      version: 1,
      fanout: DEFAULT_FANOUT,
      seed: depth
    }).finish();
    const header = import_varint6.default.encode(pbHeader.length);
    const headerBuf = concat([header, pbHeader]);
    const fanoutLinks = [];
    for (let i2 = 0; i2 < DEFAULT_FANOUT; i2++) {
      fanoutLinks.push({
        Name: "",
        Tsize: 1,
        Hash: EMPTY_KEY
      });
    }
    if (pins.length <= MAX_ITEMS) {
      const nodes = pins.map((item) => {
        return {
          link: {
            Name: "",
            Tsize: 1,
            Hash: item.key
          },
          data: item.data || new Uint8Array()
        };
      }).sort((a, b) => {
        return compare2(a.link.Hash.bytes, b.link.Hash.bytes);
      });
      const rootLinks = fanoutLinks.concat(nodes.map((item) => item.link));
      const rootData = concat([headerBuf, ...nodes.map((item) => item.data)]);
      return {
        Data: rootData,
        Links: rootLinks
      };
    } else {
      const bins = pins.reduce((bins2, pin) => {
        const n = hash(depth, pin.key) % DEFAULT_FANOUT;
        bins2[n] = n in bins2 ? bins2[n].concat([pin]) : [pin];
        return bins2;
      }, []);
      let idx = 0;
      for (const bin of bins) {
        const child = await storePins(bin, depth + 1);
        await storeChild(child, idx);
        idx++;
      }
      return {
        Data: headerBuf,
        Links: fanoutLinks
      };
    }
    async function storeChild(child, binIdx) {
      const buf2 = encode$1(child);
      const digest2 = await sha256.digest(buf2);
      const cid = CID.createV0(digest2);
      await blockstore.put(cid, buf2);
      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf2.length;
      fanoutLinks[binIdx] = {
        Name: "",
        Tsize: size,
        Hash: cid
      };
    }
  }
}
async function storeSet(blockstore, type, cids) {
  const rootNode = await storeItems(blockstore, cids.map((cid2) => {
    return {
      key: cid2
    };
  }));
  const buf2 = encode$1(rootNode);
  const digest2 = await sha256.digest(buf2);
  const cid = CID.createV0(digest2);
  await blockstore.put(cid, buf2);
  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf2.length;
  return {
    Name: type,
    Tsize: size,
    Hash: cid
  };
}
async function pinsToDatastore(blockstore, datastore, pinstore, onProgress) {
  if (!await datastore.has(PIN_DS_KEY)) {
    return;
  }
  const mh = await datastore.get(PIN_DS_KEY);
  const cid = CID.decode(mh);
  const pinRootBuf = await blockstore.get(cid);
  const pinRoot = decode2$1(pinRootBuf);
  let counter = 0;
  const pinCount = await length(loadSet(blockstore, pinRoot, PinTypes2.recursive)) + await length(loadSet(blockstore, pinRoot, PinTypes2.direct));
  for await (const cid2 of loadSet(blockstore, pinRoot, PinTypes2.recursive)) {
    counter++;
    const pin = {
      depth: Infinity
    };
    if (cid2.version !== 0) {
      pin.version = cid2.version;
    }
    if (cid2.code !== code) {
      pin.codec = cid2.code;
    }
    await pinstore.put(cidToKey(cid2), encode2$2(pin));
    onProgress(counter / pinCount * 100, `Migrated recursive pin ${cid2}`);
  }
  for await (const cid2 of loadSet(blockstore, pinRoot, PinTypes2.direct)) {
    counter++;
    const pin = {
      depth: 0
    };
    if (cid2.version !== 0) {
      pin.version = cid2.version;
    }
    if (cid2.code !== code) {
      pin.codec = cid2.code;
    }
    await pinstore.put(cidToKey(cid2), encode2$2(pin));
    onProgress(counter / pinCount * 100, `Migrated direct pin ${cid2}`);
  }
  await blockstore.delete(cid);
  await datastore.delete(PIN_DS_KEY);
}
async function pinsToDAG(blockstore, datastore, pinstore, onProgress) {
  const recursivePins = [];
  const directPins = [];
  let counter = 0;
  const pinCount = await length(pinstore.queryKeys({}));
  for await (const { key, value: value2 } of pinstore.query({})) {
    counter++;
    const pin = decode3$1(value2);
    const cid2 = CID.create(
      pin.version || 0,
      pin.codec || code,
      decode3$3(base32.decode("b" + key.toString().toLowerCase().split("/").pop()))
    );
    if (pin.depth === 0) {
      onProgress(counter / pinCount * 100, `Reverted direct pin ${cid2}`);
      directPins.push(cid2);
    } else {
      onProgress(counter / pinCount * 100, `Reverted recursive pin ${cid2}`);
      recursivePins.push(cid2);
    }
  }
  onProgress(100, "Updating pin root");
  const pinRoot = {
    Links: [
      await storeSet(blockstore, PinTypes2.direct, directPins),
      await storeSet(blockstore, PinTypes2.recursive, recursivePins)
    ]
  };
  const buf2 = encode$1(pinRoot);
  const digest2 = await sha256.digest(buf2);
  const cid = CID.createV0(digest2);
  await blockstore.put(cid, buf2);
  await datastore.put(PIN_DS_KEY, cid.bytes);
}
async function process3(backends, onProgress, fn) {
  const blockstore = backends.blocks;
  const datastore = backends.datastore;
  const pinstore = backends.pins;
  await blockstore.open();
  await datastore.open();
  await pinstore.open();
  try {
    await fn(blockstore, datastore, pinstore, onProgress);
  } finally {
    await pinstore.close();
    await datastore.close();
    await blockstore.close();
  }
}
var migration2 = {
  version: 9,
  description: "Migrates pins to datastore",
  migrate: (backends, onProgress = () => {
  }) => {
    return process3(backends, onProgress, pinsToDatastore);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process3(backends, onProgress, pinsToDAG);
  }
};
var CONFIG_KEY = new Key("/config");
var VERSION_KEY = new Key("/version");
function findLevelJs(store) {
  let db = store;
  while (db.db || db.child) {
    db = db.db || db.child;
    if (db.type === "level-js" || db.constructor.name === "Level") {
      return db;
    }
  }
}
async function hasWithFallback(key, has, store) {
  const result = await has(key);
  if (result) {
    return result;
  }
  const levelJs = findLevelJs(store);
  if (!levelJs) {
    return false;
  }
  return new Promise((resolve7, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      resolve7(Boolean(req.result));
    };
  });
}
async function getWithFallback(key, get3, has, store) {
  if (await has(key)) {
    return get3(key);
  }
  const levelJs = findLevelJs(store);
  if (!levelJs) {
    throw notFoundError();
  }
  return new Promise((resolve7, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      if (req.result) {
        return resolve7(req.result);
      }
      reject(notFoundError());
    };
  });
}
function wrapStore(store) {
  const originalGet = store.get.bind(store);
  const originalHas = store.has.bind(store);
  store.get = (key) => getWithFallback(key, originalGet, originalHas, store);
  store.has = (key) => hasWithFallback(key, originalHas, store);
  return store;
}
function wrapBackends(backends) {
  return {
    ...backends,
    root: wrapStore(backends.root),
    datastore: wrapStore(backends.datastore),
    pins: wrapStore(backends.pins),
    keys: wrapStore(backends.keys)
  };
}
async function keysToBinary(name9, store, onProgress = () => {
}) {
  const db = findLevelJs(store);
  if (!db) {
    onProgress(`${name9} did not need an upgrade`);
    return;
  }
  onProgress(`Upgrading ${name9}`);
  const upgrade = (key, value2) => {
    return [
      { type: "del", key },
      { type: "put", key: fromString3(key), value: value2 }
    ];
  };
  await withEach(db, upgrade);
}
async function keysToStrings(name9, store, onProgress = () => {
}) {
  const db = findLevelJs(store);
  if (!db) {
    onProgress(`${name9} did not need a downgrade`);
    return;
  }
  onProgress(`Downgrading ${name9}`);
  const downgrade = (key, value2) => {
    return [
      { type: "del", key },
      { type: "put", key: toString3(key), value: value2 }
    ];
  };
  await withEach(db, downgrade);
}
function unwrap2(store) {
  if (store.child) {
    return unwrap2(store.child);
  }
  return store;
}
async function process4(backends, onProgress, fn) {
  const datastores = Object.entries(backends).map(([key, backend]) => ({ key, backend: unwrap2(backend) })).filter(({ key, backend }) => backend.constructor.name === "LevelDatastore").map(({ key, backend }) => ({
    name: key,
    store: backend
  }));
  onProgress(0, `Migrating ${datastores.length} dbs`);
  let migrated = 0;
  const progress = (message2) => {
    onProgress(Math.round(migrated / datastores.length * 100), message2);
  };
  for (const { name: name9, store } of datastores) {
    await store.open();
    try {
      await fn(name9, store, progress);
    } finally {
      migrated++;
      await store.close();
    }
  }
  onProgress(100, `Migrated ${datastores.length} dbs`);
}
var migration3 = {
  version: 10,
  description: "Migrates datastore-level keys to binary",
  migrate: (backends, onProgress = () => {
  }) => {
    return process4(backends, onProgress, keysToBinary);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process4(backends, onProgress, keysToStrings);
  }
};
function withEach(db, fn) {
  function batch2(operations, next) {
    const store = db.store("readwrite");
    const transaction = store.transaction;
    let index2 = 0;
    let error;
    transaction.onabort = () => next(error || transaction.error || new Error("aborted by user"));
    transaction.oncomplete = () => next();
    function loop() {
      const op = operations[index2++];
      const key = op.key;
      let req;
      try {
        req = op.type === "del" ? store.delete(key) : store.put(op.value, key);
      } catch (err2) {
        error = err2;
        transaction.abort();
        return;
      }
      if (index2 < operations.length) {
        req.onsuccess = loop;
      }
    }
    loop();
  }
  return new Promise((resolve7, reject) => {
    const it = db.iterator();
    const id = (data) => data;
    it._deserializeKey = it._deserializeValue = id;
    next();
    function next() {
      const handleNext = (err2, key, value2) => {
        if (err2 || key === void 0) {
          const handleEnd = (err22) => {
            if (err22) {
              reject(err22);
              return;
            }
            resolve7();
          };
          it.end(handleEnd);
          return;
        }
        batch2(fn(key, value2), next);
      };
      it.next(handleNext);
    }
  });
}
var MFS_ROOT_KEY2 = new Key("/local/filesroot");
async function storeMfsRootInDatastore(backends, onProgress = () => {
}) {
  onProgress(100, "Migrating MFS root to repo datastore");
  await backends.root.open();
  await backends.datastore.open();
  if (await backends.root.has(MFS_ROOT_KEY2)) {
    const root2 = await backends.root.get(MFS_ROOT_KEY2);
    await backends.datastore.put(MFS_ROOT_KEY2, root2);
    await backends.root.delete(MFS_ROOT_KEY2);
  }
  await backends.datastore.close();
  await backends.root.close();
  onProgress(100, "Stored MFS root in repo datastore");
}
async function storeMfsRootInRoot(backends, onProgress = () => {
}) {
  onProgress(100, "Migrating MFS root to repo root datastore");
  await backends.root.open();
  await backends.datastore.open();
  if (await backends.datastore.has(MFS_ROOT_KEY2)) {
    const root2 = await backends.datastore.get(MFS_ROOT_KEY2);
    await backends.root.put(MFS_ROOT_KEY2, root2);
    await backends.datastore.delete(MFS_ROOT_KEY2);
  }
  await backends.datastore.close();
  await backends.root.close();
  onProgress(100, "Stored MFS root in repo root datastore");
}
var migration4 = {
  version: 11,
  description: "Store mfs root in the datastore",
  migrate: storeMfsRootInDatastore,
  revert: storeMfsRootInRoot
};
var import_minimal9 = __toESM(require_minimal2(), 1);
var import_minimal4 = __toESM(require_minimal2(), 1);
var $Reader3 = import_minimal4.default.Reader;
var $Writer3 = import_minimal4.default.Writer;
var $util3 = import_minimal4.default.util;
var $root3 = import_minimal4.default.roots["default"] || (import_minimal4.default.roots["default"] = {});
var Protocols = $root3.Protocols = (() => {
  function Protocols2(p) {
    this.protocols = [];
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Protocols2.prototype.protocols = $util3.emptyArray;
  Protocols2.encode = function encode21(m, w) {
    if (!w)
      w = $Writer3.create();
    if (m.protocols != null && m.protocols.length) {
      for (var i2 = 0; i2 < m.protocols.length; ++i2)
        w.uint32(10).string(m.protocols[i2]);
    }
    return w;
  };
  Protocols2.decode = function decode17(r, l) {
    if (!(r instanceof $Reader3))
      r = $Reader3.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root3.Protocols();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.protocols && m.protocols.length))
            m.protocols = [];
          m.protocols.push(r.string());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Protocols2.fromObject = function fromObject(d) {
    if (d instanceof $root3.Protocols)
      return d;
    var m = new $root3.Protocols();
    if (d.protocols) {
      if (!Array.isArray(d.protocols))
        throw TypeError(".Protocols.protocols: array expected");
      m.protocols = [];
      for (var i2 = 0; i2 < d.protocols.length; ++i2) {
        m.protocols[i2] = String(d.protocols[i2]);
      }
    }
    return m;
  };
  Protocols2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.protocols = [];
    }
    if (m.protocols && m.protocols.length) {
      d.protocols = [];
      for (var j = 0; j < m.protocols.length; ++j) {
        d.protocols[j] = m.protocols[j];
      }
    }
    return d;
  };
  Protocols2.prototype.toJSON = function toJSON2() {
    return this.constructor.toObject(this, import_minimal4.default.util.toJSONOptions);
  };
  return Protocols2;
})();
var import_minimal5 = __toESM(require_minimal2(), 1);
var $Reader4 = import_minimal5.default.Reader;
var $Writer4 = import_minimal5.default.Writer;
var $util4 = import_minimal5.default.util;
var $root4 = import_minimal5.default.roots["default"] || (import_minimal5.default.roots["default"] = {});
var Addresses = $root4.Addresses = (() => {
  function Addresses2(p) {
    this.addrs = [];
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Addresses2.prototype.addrs = $util4.emptyArray;
  Addresses2.prototype.certifiedRecord = null;
  Addresses2.encode = function encode21(m, w) {
    if (!w)
      w = $Writer4.create();
    if (m.addrs != null && m.addrs.length) {
      for (var i2 = 0; i2 < m.addrs.length; ++i2)
        $root4.Addresses.Address.encode(m.addrs[i2], w.uint32(10).fork()).ldelim();
    }
    if (m.certifiedRecord != null && Object.hasOwnProperty.call(m, "certifiedRecord"))
      $root4.Addresses.CertifiedRecord.encode(m.certifiedRecord, w.uint32(18).fork()).ldelim();
    return w;
  };
  Addresses2.decode = function decode17(r, l) {
    if (!(r instanceof $Reader4))
      r = $Reader4.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root4.Addresses();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.addrs && m.addrs.length))
            m.addrs = [];
          m.addrs.push($root4.Addresses.Address.decode(r, r.uint32()));
          break;
        case 2:
          m.certifiedRecord = $root4.Addresses.CertifiedRecord.decode(r, r.uint32());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Addresses2.fromObject = function fromObject(d) {
    if (d instanceof $root4.Addresses)
      return d;
    var m = new $root4.Addresses();
    if (d.addrs) {
      if (!Array.isArray(d.addrs))
        throw TypeError(".Addresses.addrs: array expected");
      m.addrs = [];
      for (var i2 = 0; i2 < d.addrs.length; ++i2) {
        if (typeof d.addrs[i2] !== "object")
          throw TypeError(".Addresses.addrs: object expected");
        m.addrs[i2] = $root4.Addresses.Address.fromObject(d.addrs[i2]);
      }
    }
    if (d.certifiedRecord != null) {
      if (typeof d.certifiedRecord !== "object")
        throw TypeError(".Addresses.certifiedRecord: object expected");
      m.certifiedRecord = $root4.Addresses.CertifiedRecord.fromObject(d.certifiedRecord);
    }
    return m;
  };
  Addresses2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addrs = [];
    }
    if (o.defaults) {
      d.certifiedRecord = null;
    }
    if (m.addrs && m.addrs.length) {
      d.addrs = [];
      for (var j = 0; j < m.addrs.length; ++j) {
        d.addrs[j] = $root4.Addresses.Address.toObject(m.addrs[j], o);
      }
    }
    if (m.certifiedRecord != null && m.hasOwnProperty("certifiedRecord")) {
      d.certifiedRecord = $root4.Addresses.CertifiedRecord.toObject(m.certifiedRecord, o);
    }
    return d;
  };
  Addresses2.prototype.toJSON = function toJSON2() {
    return this.constructor.toObject(this, import_minimal5.default.util.toJSONOptions);
  };
  Addresses2.Address = function() {
    function Address3(p) {
      if (p) {
        for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
          if (p[ks[i2]] != null)
            this[ks[i2]] = p[ks[i2]];
      }
    }
    Address3.prototype.multiaddr = $util4.newBuffer([]);
    Address3.prototype.isCertified = null;
    let $oneOfFields;
    Object.defineProperty(Address3.prototype, "_isCertified", {
      get: $util4.oneOfGetter($oneOfFields = ["isCertified"]),
      set: $util4.oneOfSetter($oneOfFields)
    });
    Address3.encode = function encode21(m, w) {
      if (!w)
        w = $Writer4.create();
      if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
        w.uint32(10).bytes(m.multiaddr);
      if (m.isCertified != null && Object.hasOwnProperty.call(m, "isCertified"))
        w.uint32(16).bool(m.isCertified);
      return w;
    };
    Address3.decode = function decode17(r, l) {
      if (!(r instanceof $Reader4))
        r = $Reader4.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root4.Addresses.Address();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.multiaddr = r.bytes();
            break;
          case 2:
            m.isCertified = r.bool();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Address3.fromObject = function fromObject(d) {
      if (d instanceof $root4.Addresses.Address)
        return d;
      var m = new $root4.Addresses.Address();
      if (d.multiaddr != null) {
        if (typeof d.multiaddr === "string")
          $util4.base64.decode(d.multiaddr, m.multiaddr = $util4.newBuffer($util4.base64.length(d.multiaddr)), 0);
        else if (d.multiaddr.length)
          m.multiaddr = d.multiaddr;
      }
      if (d.isCertified != null) {
        m.isCertified = Boolean(d.isCertified);
      }
      return m;
    };
    Address3.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.multiaddr = "";
        else {
          d.multiaddr = [];
          if (o.bytes !== Array)
            d.multiaddr = $util4.newBuffer(d.multiaddr);
        }
      }
      if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
        d.multiaddr = o.bytes === String ? $util4.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
      }
      if (m.isCertified != null && m.hasOwnProperty("isCertified")) {
        d.isCertified = m.isCertified;
        if (o.oneofs)
          d._isCertified = "isCertified";
      }
      return d;
    };
    Address3.prototype.toJSON = function toJSON2() {
      return this.constructor.toObject(this, import_minimal5.default.util.toJSONOptions);
    };
    return Address3;
  }();
  Addresses2.CertifiedRecord = function() {
    function CertifiedRecord(p) {
      if (p) {
        for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
          if (p[ks[i2]] != null)
            this[ks[i2]] = p[ks[i2]];
      }
    }
    CertifiedRecord.prototype.seq = $util4.Long ? $util4.Long.fromBits(0, 0, true) : 0;
    CertifiedRecord.prototype.raw = $util4.newBuffer([]);
    CertifiedRecord.encode = function encode21(m, w) {
      if (!w)
        w = $Writer4.create();
      if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
        w.uint32(8).uint64(m.seq);
      if (m.raw != null && Object.hasOwnProperty.call(m, "raw"))
        w.uint32(18).bytes(m.raw);
      return w;
    };
    CertifiedRecord.decode = function decode17(r, l) {
      if (!(r instanceof $Reader4))
        r = $Reader4.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root4.Addresses.CertifiedRecord();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.seq = r.uint64();
            break;
          case 2:
            m.raw = r.bytes();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    CertifiedRecord.fromObject = function fromObject(d) {
      if (d instanceof $root4.Addresses.CertifiedRecord)
        return d;
      var m = new $root4.Addresses.CertifiedRecord();
      if (d.seq != null) {
        if ($util4.Long)
          (m.seq = $util4.Long.fromValue(d.seq)).unsigned = true;
        else if (typeof d.seq === "string")
          m.seq = parseInt(d.seq, 10);
        else if (typeof d.seq === "number")
          m.seq = d.seq;
        else if (typeof d.seq === "object")
          m.seq = new $util4.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
      }
      if (d.raw != null) {
        if (typeof d.raw === "string")
          $util4.base64.decode(d.raw, m.raw = $util4.newBuffer($util4.base64.length(d.raw)), 0);
        else if (d.raw.length)
          m.raw = d.raw;
      }
      return m;
    };
    CertifiedRecord.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if ($util4.Long) {
          var n = new $util4.Long(0, 0, true);
          d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
        } else
          d.seq = o.longs === String ? "0" : 0;
        if (o.bytes === String)
          d.raw = "";
        else {
          d.raw = [];
          if (o.bytes !== Array)
            d.raw = $util4.newBuffer(d.raw);
        }
      }
      if (m.seq != null && m.hasOwnProperty("seq")) {
        if (typeof m.seq === "number")
          d.seq = o.longs === String ? String(m.seq) : m.seq;
        else
          d.seq = o.longs === String ? $util4.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util4.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
      }
      if (m.raw != null && m.hasOwnProperty("raw")) {
        d.raw = o.bytes === String ? $util4.base64.encode(m.raw, 0, m.raw.length) : o.bytes === Array ? Array.prototype.slice.call(m.raw) : m.raw;
      }
      return d;
    };
    CertifiedRecord.prototype.toJSON = function toJSON2() {
      return this.constructor.toObject(this, import_minimal5.default.util.toJSONOptions);
    };
    return CertifiedRecord;
  }();
  return Addresses2;
})();
var import_minimal6 = __toESM(require_minimal2(), 1);
var $Reader5 = import_minimal6.default.Reader;
var $Writer5 = import_minimal6.default.Writer;
var $util5 = import_minimal6.default.util;
var $root5 = import_minimal6.default.roots["default"] || (import_minimal6.default.roots["default"] = {});
var Peer = $root5.Peer = (() => {
  function Peer3(p) {
    this.addresses = [];
    this.protocols = [];
    this.metadata = [];
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Peer3.prototype.addresses = $util5.emptyArray;
  Peer3.prototype.protocols = $util5.emptyArray;
  Peer3.prototype.metadata = $util5.emptyArray;
  Peer3.prototype.pubKey = null;
  Peer3.prototype.peerRecordEnvelope = null;
  let $oneOfFields;
  Object.defineProperty(Peer3.prototype, "_pubKey", {
    get: $util5.oneOfGetter($oneOfFields = ["pubKey"]),
    set: $util5.oneOfSetter($oneOfFields)
  });
  Object.defineProperty(Peer3.prototype, "_peerRecordEnvelope", {
    get: $util5.oneOfGetter($oneOfFields = ["peerRecordEnvelope"]),
    set: $util5.oneOfSetter($oneOfFields)
  });
  Peer3.encode = function encode21(m, w) {
    if (!w)
      w = $Writer5.create();
    if (m.addresses != null && m.addresses.length) {
      for (var i2 = 0; i2 < m.addresses.length; ++i2)
        $root5.Address.encode(m.addresses[i2], w.uint32(10).fork()).ldelim();
    }
    if (m.protocols != null && m.protocols.length) {
      for (var i2 = 0; i2 < m.protocols.length; ++i2)
        w.uint32(18).string(m.protocols[i2]);
    }
    if (m.metadata != null && m.metadata.length) {
      for (var i2 = 0; i2 < m.metadata.length; ++i2)
        $root5.Metadata.encode(m.metadata[i2], w.uint32(26).fork()).ldelim();
    }
    if (m.pubKey != null && Object.hasOwnProperty.call(m, "pubKey"))
      w.uint32(34).bytes(m.pubKey);
    if (m.peerRecordEnvelope != null && Object.hasOwnProperty.call(m, "peerRecordEnvelope"))
      w.uint32(42).bytes(m.peerRecordEnvelope);
    return w;
  };
  Peer3.decode = function decode17(r, l) {
    if (!(r instanceof $Reader5))
      r = $Reader5.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Peer();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.addresses && m.addresses.length))
            m.addresses = [];
          m.addresses.push($root5.Address.decode(r, r.uint32()));
          break;
        case 2:
          if (!(m.protocols && m.protocols.length))
            m.protocols = [];
          m.protocols.push(r.string());
          break;
        case 3:
          if (!(m.metadata && m.metadata.length))
            m.metadata = [];
          m.metadata.push($root5.Metadata.decode(r, r.uint32()));
          break;
        case 4:
          m.pubKey = r.bytes();
          break;
        case 5:
          m.peerRecordEnvelope = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Peer3.fromObject = function fromObject(d) {
    if (d instanceof $root5.Peer)
      return d;
    var m = new $root5.Peer();
    if (d.addresses) {
      if (!Array.isArray(d.addresses))
        throw TypeError(".Peer.addresses: array expected");
      m.addresses = [];
      for (var i2 = 0; i2 < d.addresses.length; ++i2) {
        if (typeof d.addresses[i2] !== "object")
          throw TypeError(".Peer.addresses: object expected");
        m.addresses[i2] = $root5.Address.fromObject(d.addresses[i2]);
      }
    }
    if (d.protocols) {
      if (!Array.isArray(d.protocols))
        throw TypeError(".Peer.protocols: array expected");
      m.protocols = [];
      for (var i2 = 0; i2 < d.protocols.length; ++i2) {
        m.protocols[i2] = String(d.protocols[i2]);
      }
    }
    if (d.metadata) {
      if (!Array.isArray(d.metadata))
        throw TypeError(".Peer.metadata: array expected");
      m.metadata = [];
      for (var i2 = 0; i2 < d.metadata.length; ++i2) {
        if (typeof d.metadata[i2] !== "object")
          throw TypeError(".Peer.metadata: object expected");
        m.metadata[i2] = $root5.Metadata.fromObject(d.metadata[i2]);
      }
    }
    if (d.pubKey != null) {
      if (typeof d.pubKey === "string")
        $util5.base64.decode(d.pubKey, m.pubKey = $util5.newBuffer($util5.base64.length(d.pubKey)), 0);
      else if (d.pubKey.length)
        m.pubKey = d.pubKey;
    }
    if (d.peerRecordEnvelope != null) {
      if (typeof d.peerRecordEnvelope === "string")
        $util5.base64.decode(d.peerRecordEnvelope, m.peerRecordEnvelope = $util5.newBuffer($util5.base64.length(d.peerRecordEnvelope)), 0);
      else if (d.peerRecordEnvelope.length)
        m.peerRecordEnvelope = d.peerRecordEnvelope;
    }
    return m;
  };
  Peer3.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addresses = [];
      d.protocols = [];
      d.metadata = [];
    }
    if (m.addresses && m.addresses.length) {
      d.addresses = [];
      for (var j = 0; j < m.addresses.length; ++j) {
        d.addresses[j] = $root5.Address.toObject(m.addresses[j], o);
      }
    }
    if (m.protocols && m.protocols.length) {
      d.protocols = [];
      for (var j = 0; j < m.protocols.length; ++j) {
        d.protocols[j] = m.protocols[j];
      }
    }
    if (m.metadata && m.metadata.length) {
      d.metadata = [];
      for (var j = 0; j < m.metadata.length; ++j) {
        d.metadata[j] = $root5.Metadata.toObject(m.metadata[j], o);
      }
    }
    if (m.pubKey != null && m.hasOwnProperty("pubKey")) {
      d.pubKey = o.bytes === String ? $util5.base64.encode(m.pubKey, 0, m.pubKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.pubKey) : m.pubKey;
      if (o.oneofs)
        d._pubKey = "pubKey";
    }
    if (m.peerRecordEnvelope != null && m.hasOwnProperty("peerRecordEnvelope")) {
      d.peerRecordEnvelope = o.bytes === String ? $util5.base64.encode(m.peerRecordEnvelope, 0, m.peerRecordEnvelope.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerRecordEnvelope) : m.peerRecordEnvelope;
      if (o.oneofs)
        d._peerRecordEnvelope = "peerRecordEnvelope";
    }
    return d;
  };
  Peer3.prototype.toJSON = function toJSON2() {
    return this.constructor.toObject(this, import_minimal6.default.util.toJSONOptions);
  };
  return Peer3;
})();
$root5.Address = (() => {
  function Address3(p) {
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Address3.prototype.multiaddr = $util5.newBuffer([]);
  Address3.prototype.isCertified = null;
  let $oneOfFields;
  Object.defineProperty(Address3.prototype, "_isCertified", {
    get: $util5.oneOfGetter($oneOfFields = ["isCertified"]),
    set: $util5.oneOfSetter($oneOfFields)
  });
  Address3.encode = function encode21(m, w) {
    if (!w)
      w = $Writer5.create();
    if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
      w.uint32(10).bytes(m.multiaddr);
    if (m.isCertified != null && Object.hasOwnProperty.call(m, "isCertified"))
      w.uint32(16).bool(m.isCertified);
    return w;
  };
  Address3.decode = function decode17(r, l) {
    if (!(r instanceof $Reader5))
      r = $Reader5.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Address();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.multiaddr = r.bytes();
          break;
        case 2:
          m.isCertified = r.bool();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Address3.fromObject = function fromObject(d) {
    if (d instanceof $root5.Address)
      return d;
    var m = new $root5.Address();
    if (d.multiaddr != null) {
      if (typeof d.multiaddr === "string")
        $util5.base64.decode(d.multiaddr, m.multiaddr = $util5.newBuffer($util5.base64.length(d.multiaddr)), 0);
      else if (d.multiaddr.length)
        m.multiaddr = d.multiaddr;
    }
    if (d.isCertified != null) {
      m.isCertified = Boolean(d.isCertified);
    }
    return m;
  };
  Address3.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if (o.bytes === String)
        d.multiaddr = "";
      else {
        d.multiaddr = [];
        if (o.bytes !== Array)
          d.multiaddr = $util5.newBuffer(d.multiaddr);
      }
    }
    if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
      d.multiaddr = o.bytes === String ? $util5.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
    }
    if (m.isCertified != null && m.hasOwnProperty("isCertified")) {
      d.isCertified = m.isCertified;
      if (o.oneofs)
        d._isCertified = "isCertified";
    }
    return d;
  };
  Address3.prototype.toJSON = function toJSON2() {
    return this.constructor.toObject(this, import_minimal6.default.util.toJSONOptions);
  };
  return Address3;
})();
$root5.Metadata = (() => {
  function Metadata4(p) {
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Metadata4.prototype.key = "";
  Metadata4.prototype.value = $util5.newBuffer([]);
  Metadata4.encode = function encode21(m, w) {
    if (!w)
      w = $Writer5.create();
    if (m.key != null && Object.hasOwnProperty.call(m, "key"))
      w.uint32(10).string(m.key);
    if (m.value != null && Object.hasOwnProperty.call(m, "value"))
      w.uint32(18).bytes(m.value);
    return w;
  };
  Metadata4.decode = function decode17(r, l) {
    if (!(r instanceof $Reader5))
      r = $Reader5.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Metadata();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.key = r.string();
          break;
        case 2:
          m.value = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Metadata4.fromObject = function fromObject(d) {
    if (d instanceof $root5.Metadata)
      return d;
    var m = new $root5.Metadata();
    if (d.key != null) {
      m.key = String(d.key);
    }
    if (d.value != null) {
      if (typeof d.value === "string")
        $util5.base64.decode(d.value, m.value = $util5.newBuffer($util5.base64.length(d.value)), 0);
      else if (d.value.length)
        m.value = d.value;
    }
    return m;
  };
  Metadata4.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      d.key = "";
      if (o.bytes === String)
        d.value = "";
      else {
        d.value = [];
        if (o.bytes !== Array)
          d.value = $util5.newBuffer(d.value);
      }
    }
    if (m.key != null && m.hasOwnProperty("key")) {
      d.key = m.key;
    }
    if (m.value != null && m.hasOwnProperty("value")) {
      d.value = o.bytes === String ? $util5.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;
    }
    return d;
  };
  Metadata4.prototype.toJSON = function toJSON2() {
    return this.constructor.toObject(this, import_minimal6.default.util.toJSONOptions);
  };
  return Metadata4;
})();
var import_minimal7 = __toESM(require_minimal2(), 1);
var $Reader6 = import_minimal7.default.Reader;
var $Writer6 = import_minimal7.default.Writer;
var $util6 = import_minimal7.default.util;
var $root6 = import_minimal7.default.roots["default"] || (import_minimal7.default.roots["default"] = {});
var Envelope = $root6.Envelope = (() => {
  function Envelope3(p) {
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Envelope3.prototype.publicKey = $util6.newBuffer([]);
  Envelope3.prototype.payloadType = $util6.newBuffer([]);
  Envelope3.prototype.payload = $util6.newBuffer([]);
  Envelope3.prototype.signature = $util6.newBuffer([]);
  Envelope3.encode = function encode21(m, w) {
    if (!w)
      w = $Writer6.create();
    if (m.publicKey != null && Object.hasOwnProperty.call(m, "publicKey"))
      w.uint32(10).bytes(m.publicKey);
    if (m.payloadType != null && Object.hasOwnProperty.call(m, "payloadType"))
      w.uint32(18).bytes(m.payloadType);
    if (m.payload != null && Object.hasOwnProperty.call(m, "payload"))
      w.uint32(26).bytes(m.payload);
    if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
      w.uint32(42).bytes(m.signature);
    return w;
  };
  Envelope3.decode = function decode17(r, l) {
    if (!(r instanceof $Reader6))
      r = $Reader6.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root6.Envelope();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.publicKey = r.bytes();
          break;
        case 2:
          m.payloadType = r.bytes();
          break;
        case 3:
          m.payload = r.bytes();
          break;
        case 5:
          m.signature = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Envelope3.fromObject = function fromObject(d) {
    if (d instanceof $root6.Envelope)
      return d;
    var m = new $root6.Envelope();
    if (d.publicKey != null) {
      if (typeof d.publicKey === "string")
        $util6.base64.decode(d.publicKey, m.publicKey = $util6.newBuffer($util6.base64.length(d.publicKey)), 0);
      else if (d.publicKey.length)
        m.publicKey = d.publicKey;
    }
    if (d.payloadType != null) {
      if (typeof d.payloadType === "string")
        $util6.base64.decode(d.payloadType, m.payloadType = $util6.newBuffer($util6.base64.length(d.payloadType)), 0);
      else if (d.payloadType.length)
        m.payloadType = d.payloadType;
    }
    if (d.payload != null) {
      if (typeof d.payload === "string")
        $util6.base64.decode(d.payload, m.payload = $util6.newBuffer($util6.base64.length(d.payload)), 0);
      else if (d.payload.length)
        m.payload = d.payload;
    }
    if (d.signature != null) {
      if (typeof d.signature === "string")
        $util6.base64.decode(d.signature, m.signature = $util6.newBuffer($util6.base64.length(d.signature)), 0);
      else if (d.signature.length)
        m.signature = d.signature;
    }
    return m;
  };
  Envelope3.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if (o.bytes === String)
        d.publicKey = "";
      else {
        d.publicKey = [];
        if (o.bytes !== Array)
          d.publicKey = $util6.newBuffer(d.publicKey);
      }
      if (o.bytes === String)
        d.payloadType = "";
      else {
        d.payloadType = [];
        if (o.bytes !== Array)
          d.payloadType = $util6.newBuffer(d.payloadType);
      }
      if (o.bytes === String)
        d.payload = "";
      else {
        d.payload = [];
        if (o.bytes !== Array)
          d.payload = $util6.newBuffer(d.payload);
      }
      if (o.bytes === String)
        d.signature = "";
      else {
        d.signature = [];
        if (o.bytes !== Array)
          d.signature = $util6.newBuffer(d.signature);
      }
    }
    if (m.publicKey != null && m.hasOwnProperty("publicKey")) {
      d.publicKey = o.bytes === String ? $util6.base64.encode(m.publicKey, 0, m.publicKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.publicKey) : m.publicKey;
    }
    if (m.payloadType != null && m.hasOwnProperty("payloadType")) {
      d.payloadType = o.bytes === String ? $util6.base64.encode(m.payloadType, 0, m.payloadType.length) : o.bytes === Array ? Array.prototype.slice.call(m.payloadType) : m.payloadType;
    }
    if (m.payload != null && m.hasOwnProperty("payload")) {
      d.payload = o.bytes === String ? $util6.base64.encode(m.payload, 0, m.payload.length) : o.bytes === Array ? Array.prototype.slice.call(m.payload) : m.payload;
    }
    if (m.signature != null && m.hasOwnProperty("signature")) {
      d.signature = o.bytes === String ? $util6.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
    }
    return d;
  };
  Envelope3.prototype.toJSON = function toJSON2() {
    return this.constructor.toObject(this, import_minimal7.default.util.toJSONOptions);
  };
  return Envelope3;
})();
var import_minimal8 = __toESM(require_minimal2(), 1);
var $Reader7 = import_minimal8.default.Reader;
var $Writer7 = import_minimal8.default.Writer;
var $util7 = import_minimal8.default.util;
var $root7 = import_minimal8.default.roots["default"] || (import_minimal8.default.roots["default"] = {});
var PeerRecord = $root7.PeerRecord = (() => {
  function PeerRecord4(p) {
    this.addresses = [];
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  PeerRecord4.prototype.peerId = $util7.newBuffer([]);
  PeerRecord4.prototype.seq = $util7.Long ? $util7.Long.fromBits(0, 0, true) : 0;
  PeerRecord4.prototype.addresses = $util7.emptyArray;
  PeerRecord4.encode = function encode21(m, w) {
    if (!w)
      w = $Writer7.create();
    if (m.peerId != null && Object.hasOwnProperty.call(m, "peerId"))
      w.uint32(10).bytes(m.peerId);
    if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
      w.uint32(16).uint64(m.seq);
    if (m.addresses != null && m.addresses.length) {
      for (var i2 = 0; i2 < m.addresses.length; ++i2)
        $root7.PeerRecord.AddressInfo.encode(m.addresses[i2], w.uint32(26).fork()).ldelim();
    }
    return w;
  };
  PeerRecord4.decode = function decode17(r, l) {
    if (!(r instanceof $Reader7))
      r = $Reader7.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root7.PeerRecord();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.peerId = r.bytes();
          break;
        case 2:
          m.seq = r.uint64();
          break;
        case 3:
          if (!(m.addresses && m.addresses.length))
            m.addresses = [];
          m.addresses.push($root7.PeerRecord.AddressInfo.decode(r, r.uint32()));
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  PeerRecord4.fromObject = function fromObject(d) {
    if (d instanceof $root7.PeerRecord)
      return d;
    var m = new $root7.PeerRecord();
    if (d.peerId != null) {
      if (typeof d.peerId === "string")
        $util7.base64.decode(d.peerId, m.peerId = $util7.newBuffer($util7.base64.length(d.peerId)), 0);
      else if (d.peerId.length)
        m.peerId = d.peerId;
    }
    if (d.seq != null) {
      if ($util7.Long)
        (m.seq = $util7.Long.fromValue(d.seq)).unsigned = true;
      else if (typeof d.seq === "string")
        m.seq = parseInt(d.seq, 10);
      else if (typeof d.seq === "number")
        m.seq = d.seq;
      else if (typeof d.seq === "object")
        m.seq = new $util7.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
    }
    if (d.addresses) {
      if (!Array.isArray(d.addresses))
        throw TypeError(".PeerRecord.addresses: array expected");
      m.addresses = [];
      for (var i2 = 0; i2 < d.addresses.length; ++i2) {
        if (typeof d.addresses[i2] !== "object")
          throw TypeError(".PeerRecord.addresses: object expected");
        m.addresses[i2] = $root7.PeerRecord.AddressInfo.fromObject(d.addresses[i2]);
      }
    }
    return m;
  };
  PeerRecord4.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addresses = [];
    }
    if (o.defaults) {
      if (o.bytes === String)
        d.peerId = "";
      else {
        d.peerId = [];
        if (o.bytes !== Array)
          d.peerId = $util7.newBuffer(d.peerId);
      }
      if ($util7.Long) {
        var n = new $util7.Long(0, 0, true);
        d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.seq = o.longs === String ? "0" : 0;
    }
    if (m.peerId != null && m.hasOwnProperty("peerId")) {
      d.peerId = o.bytes === String ? $util7.base64.encode(m.peerId, 0, m.peerId.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerId) : m.peerId;
    }
    if (m.seq != null && m.hasOwnProperty("seq")) {
      if (typeof m.seq === "number")
        d.seq = o.longs === String ? String(m.seq) : m.seq;
      else
        d.seq = o.longs === String ? $util7.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util7.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
    }
    if (m.addresses && m.addresses.length) {
      d.addresses = [];
      for (var j = 0; j < m.addresses.length; ++j) {
        d.addresses[j] = $root7.PeerRecord.AddressInfo.toObject(m.addresses[j], o);
      }
    }
    return d;
  };
  PeerRecord4.prototype.toJSON = function toJSON2() {
    return this.constructor.toObject(this, import_minimal8.default.util.toJSONOptions);
  };
  PeerRecord4.AddressInfo = function() {
    function AddressInfo(p) {
      if (p) {
        for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
          if (p[ks[i2]] != null)
            this[ks[i2]] = p[ks[i2]];
      }
    }
    AddressInfo.prototype.multiaddr = $util7.newBuffer([]);
    AddressInfo.encode = function encode21(m, w) {
      if (!w)
        w = $Writer7.create();
      if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
        w.uint32(10).bytes(m.multiaddr);
      return w;
    };
    AddressInfo.decode = function decode17(r, l) {
      if (!(r instanceof $Reader7))
        r = $Reader7.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root7.PeerRecord.AddressInfo();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.multiaddr = r.bytes();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    AddressInfo.fromObject = function fromObject(d) {
      if (d instanceof $root7.PeerRecord.AddressInfo)
        return d;
      var m = new $root7.PeerRecord.AddressInfo();
      if (d.multiaddr != null) {
        if (typeof d.multiaddr === "string")
          $util7.base64.decode(d.multiaddr, m.multiaddr = $util7.newBuffer($util7.base64.length(d.multiaddr)), 0);
        else if (d.multiaddr.length)
          m.multiaddr = d.multiaddr;
      }
      return m;
    };
    AddressInfo.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.multiaddr = "";
        else {
          d.multiaddr = [];
          if (o.bytes !== Array)
            d.multiaddr = $util7.newBuffer(d.multiaddr);
        }
      }
      if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
        d.multiaddr = o.bytes === String ? $util7.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
      }
      return d;
    };
    AddressInfo.prototype.toJSON = function toJSON2() {
      return this.constructor.toObject(this, import_minimal8.default.util.toJSONOptions);
    };
    return AddressInfo;
  }();
  return PeerRecord4;
})();
import_minimal9.default.util.Long = void 0;
import_minimal9.default.configure();
async function storePeerUnderSingleDatastoreKey(backends, onProgress = () => {
}) {
  onProgress(0, "Storing each peerstore key under a single datastore key");
  await backends.datastore.open();
  const peers = {};
  const keys = [];
  for await (const { key, value: value2 } of backends.datastore.query({
    prefix: "/peers"
  })) {
    keys.push(key);
    const keyStr = key.toString();
    const [, prefix, type, peerId, metadataKey] = keyStr.split("/");
    if (prefix !== "peers") {
      continue;
    }
    if (!["protos", "addrs", "metadata", "keys"].includes(type)) {
      continue;
    }
    if (!peerId) {
      continue;
    }
    peers[peerId] = peers[peerId] || {
      addresses: [],
      protocols: [],
      metadata: []
    };
    if (type === "protos") {
      const protos = Protocols.decode(value2);
      peers[peerId].protocols = protos.protocols.sort();
    } else if (type === "addrs") {
      const addrs = Addresses.decode(value2);
      peers[peerId].addresses = addrs.addrs.sort((a, b) => {
        return multiaddr(a.multiaddr).toString().localeCompare(multiaddr(b.multiaddr).toString());
      });
      if (addrs.certifiedRecord && addrs.certifiedRecord.raw) {
        peers[peerId].peerRecordEnvelope = addrs.certifiedRecord.raw;
      }
    } else if (type === "metadata") {
      peers[peerId].metadata.push({ key: metadataKey, value: value2 });
    } else if (type === "keys") {
      peers[peerId].pubKey = value2;
    }
  }
  onProgress(33, "Read peer data from store");
  for (const key of keys) {
    await backends.datastore.delete(key);
  }
  onProgress(66, "Removed existing peer data from store");
  for (const peerId of Object.keys(peers)) {
    const peer = peers[peerId];
    peer.metadata = peer.metadata.sort((a, b) => a.key.localeCompare(b.key));
    const data = Peer.encode(peer).finish();
    await backends.datastore.put(new Key(`/peers/${peerId}`), data);
  }
  await backends.datastore.close();
  onProgress(100, "Stored each peerstore key under a single datastore key");
}
async function storePeerUnderMultipleDatastoreKeys(backends, onProgress = () => {
}) {
  onProgress(0, "Storing each peerstore key under a multiple datastore keys");
  await backends.datastore.open();
  const peers = {};
  const keys = [];
  for await (const { key, value: value2 } of backends.datastore.query({
    prefix: "/peers"
  })) {
    keys.push(key);
    const keyStr = key.toString();
    const [, , peerId] = keyStr.split("/");
    peers[peerId] = Peer.decode(value2);
  }
  onProgress(33, "Read peer data from store");
  for (const key of keys) {
    await backends.datastore.delete(key);
  }
  onProgress(66, "Removed existing peer data from store");
  for (const [peerId, peer] of Object.entries(peers)) {
    if (peer.protocols && peer.protocols.length > 0) {
      await backends.datastore.put(new Key(`/peers/protos/${peerId}`), Protocols.encode({
        protocols: peer.protocols
      }).finish());
    }
    if (peer.addresses && peer.addresses.length > 0) {
      const peerRecordEnvelope = peer.peerRecordEnvelope;
      let certifiedRecord;
      if (peerRecordEnvelope) {
        const envelope = Envelope.decode(peerRecordEnvelope);
        const record = PeerRecord.decode(envelope.payload);
        certifiedRecord = {
          raw: peerRecordEnvelope,
          seq: record.seq
        };
      }
      await backends.datastore.put(new Key(`/peers/addrs/${peerId}`), Addresses.encode({
        addrs: peer.addresses,
        certifiedRecord
      }).finish());
    }
    if (peer.metadata && peer.metadata.length > 0) {
      for (const { key, value: value2 } of peer.metadata) {
        await backends.datastore.put(new Key(`/peers/metadata/${peerId}/${key}`), value2);
      }
    }
    if (peer.pubKey) {
      await backends.datastore.put(new Key(`/peers/keys/${peerId}`), peer.pubKey);
    }
  }
  await backends.datastore.close();
  onProgress(100, "Stored each peerstore key under multiple datastore keys");
}
var migration5 = {
  version: 12,
  description: "Store each peerstore peer under a single datastore key",
  migrate: storePeerUnderSingleDatastoreKey,
  revert: storePeerUnderMultipleDatastoreKeys
};
var emptyMigration = {
  description: "Empty migration.",
  // @ts-ignore
  migrate: () => {
  },
  // @ts-ignore
  revert: () => {
  },
  empty: true
};
var migrations_default = [
  Object.assign({ version: 1 }, emptyMigration),
  Object.assign({ version: 2 }, emptyMigration),
  Object.assign({ version: 3 }, emptyMigration),
  Object.assign({ version: 4 }, emptyMigration),
  Object.assign({ version: 5 }, emptyMigration),
  Object.assign({ version: 6 }, emptyMigration),
  Object.assign({ version: 7 }, emptyMigration),
  migration,
  migration2,
  migration3,
  migration4,
  migration5
];
var import_debug3 = __toESM(require_browser$1(), 1);
var errors_exports3 = {};
__export(errors_exports3, {
  InvalidValueError: () => InvalidValueError,
  MissingRepoOptionsError: () => MissingRepoOptionsError,
  NonReversibleMigrationError: () => NonReversibleMigrationError,
  NotInitializedRepoError: () => NotInitializedRepoError,
  RequiredParameterError: () => RequiredParameterError
});
var NonReversibleMigrationError = class extends Error {
  /**
   * @param {string} message
   */
  constructor(message2) {
    super(message2);
    this.name = "NonReversibleMigrationError";
    this.code = NonReversibleMigrationError.code;
    this.message = message2;
  }
};
NonReversibleMigrationError.code = "ERR_NON_REVERSIBLE_MIGRATION";
var NotInitializedRepoError = class extends Error {
  /**
   * @param {string} message
   */
  constructor(message2) {
    super(message2);
    this.name = "NotInitializedRepoError";
    this.code = NotInitializedRepoError.code;
    this.message = message2;
  }
};
NotInitializedRepoError.code = "ERR_NOT_INITIALIZED_REPO";
var RequiredParameterError = class extends Error {
  /**
   * @param {string} message
   */
  constructor(message2) {
    super(message2);
    this.name = "RequiredParameterError";
    this.code = RequiredParameterError.code;
    this.message = message2;
  }
};
RequiredParameterError.code = "ERR_REQUIRED_PARAMETER";
var InvalidValueError = class extends Error {
  /**
   * @param {string} message
   */
  constructor(message2) {
    super(message2);
    this.name = "InvalidValueError";
    this.code = InvalidValueError.code;
    this.message = message2;
  }
};
InvalidValueError.code = "ERR_INVALID_VALUE";
var MissingRepoOptionsError = class extends Error {
  /**
   * @param {string} message
   */
  constructor(message2) {
    super(message2);
    this.name = "MissingRepoOptionsError";
    this.code = MissingRepoOptionsError.code;
    this.message = message2;
  }
};
MissingRepoOptionsError.code = "ERR_MISSING_REPO_OPTIONS";
var log39 = (0, import_debug3.default)("ipfs:repo:migrator:repo:init");
async function isRepoInitialized(backends) {
  if (!backends) {
    throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
  }
  const root2 = backends.root;
  try {
    await root2.open();
    const versionCheck = await root2.has(VERSION_KEY);
    const configCheck = await root2.has(CONFIG_KEY);
    if (!versionCheck || !configCheck) {
      log39(`Version entry present: ${versionCheck}`);
      log39(`Config entry present: ${configCheck}`);
      return false;
    }
    return true;
  } catch (e) {
    log39("While checking if repo is initialized error was thrown: " + e.message);
    return false;
  } finally {
    if (root2 !== void 0) {
      try {
        await root2.close();
      } catch {
      }
    }
  }
}
async function getVersion(backends) {
  if (!await isRepoInitialized(backends)) {
    throw new NotInitializedRepoError("Repo is not initialized!");
  }
  const store = backends.root;
  await store.open();
  try {
    return parseInt(toString3(await store.get(VERSION_KEY)));
  } finally {
    await store.close();
  }
}
async function setVersion(version3, backends) {
  if (!backends) {
    throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
  }
  const store = backends.root;
  await store.open();
  await store.put(VERSION_KEY, fromString3(String(version3)));
  await store.close();
}
var import_debug4 = __toESM(require_browser$1());
var log40 = (0, import_debug4.default)("ipfs:repo:migrator");
function getLatestMigrationVersion(migrations) {
  migrations = migrations || migrations_default;
  if (!Array.isArray(migrations) || migrations.length === 0) {
    return 0;
  }
  return migrations[migrations.length - 1].version;
}
async function migrate(path2, backends, repoOptions, toVersion, options = {}) {
  const ignoreLock = options.ignoreLock ?? false;
  const onProgress = options.onProgress;
  const isDryRun = options.isDryRun ?? false;
  const migrations = options.migrations ?? migrations_default;
  if (!path2) {
    throw new errors.RequiredParameterError("Path argument is required!");
  }
  if (!repoOptions) {
    throw new errors.RequiredParameterError("repoOptions argument is required!");
  }
  if (!toVersion) {
    throw new errors.RequiredParameterError("toVersion argument is required!");
  }
  if (!Number.isInteger(toVersion) || toVersion <= 0) {
    throw new errors.InvalidValueError("Version has to be positive integer!");
  }
  backends = wrapBackends(backends);
  const currentVersion = await getVersion(backends);
  if (currentVersion === toVersion) {
    log40("Nothing to migrate.");
    return;
  }
  if (currentVersion > toVersion) {
    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`);
  }
  verifyAvailableMigrations(migrations, currentVersion, toVersion);
  let lock3;
  if (!isDryRun && !ignoreLock) {
    lock3 = await repoOptions.repoLock.lock(path2);
  }
  try {
    for (const migration6 of migrations) {
      if (toVersion !== void 0 && migration6.version > toVersion) {
        break;
      }
      if (migration6.version <= currentVersion) {
        continue;
      }
      log40(`Migrating version ${migration6.version}`);
      try {
        if (!isDryRun) {
          let progressCallback = () => {
          };
          if (onProgress) {
            progressCallback = (percent, message2) => onProgress(migration6.version, percent.toFixed(2), message2);
          }
          await migration6.migrate(backends, progressCallback);
        }
      } catch (e) {
        const lastSuccessfullyMigratedVersion = migration6.version - 1;
        log40(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`);
        await setVersion(lastSuccessfullyMigratedVersion, backends);
        throw new Error(`During migration to version ${migration6.version} exception was raised: ${e.stack || e.message || e}`);
      }
      log40(`Migrating to version ${migration6.version} finished`);
    }
    if (!isDryRun) {
      await setVersion(toVersion || getLatestMigrationVersion(migrations), backends);
    }
    log40("Repo successfully migrated", toVersion !== void 0 ? `to version ${toVersion}!` : "to latest version!");
  } finally {
    if (!isDryRun && !ignoreLock && lock3) {
      await lock3.close();
    }
  }
}
async function revert(path2, backends, repoOptions, toVersion, options = {}) {
  const ignoreLock = options.ignoreLock ?? false;
  const onProgress = options.onProgress;
  const isDryRun = options.isDryRun ?? false;
  const migrations = options.migrations ?? migrations_default;
  if (!path2) {
    throw new errors.RequiredParameterError("Path argument is required!");
  }
  if (!repoOptions) {
    throw new errors.RequiredParameterError("repoOptions argument is required!");
  }
  if (!toVersion) {
    throw new errors.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!");
  }
  if (!Number.isInteger(toVersion) || toVersion <= 0) {
    throw new errors.InvalidValueError("Version has to be positive integer!");
  }
  backends = wrapBackends(backends);
  const currentVersion = await getVersion(backends);
  if (currentVersion === toVersion) {
    log40("Nothing to revert.");
    return;
  }
  if (currentVersion < toVersion) {
    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`);
  }
  verifyAvailableMigrations(migrations, toVersion, currentVersion, true);
  let lock3;
  if (!isDryRun && !ignoreLock) {
    lock3 = await repoOptions.repoLock.lock(path2);
  }
  log40(`Reverting from version ${currentVersion} to ${toVersion}`);
  try {
    const reversedMigrationArray = migrations.slice().reverse();
    for (const migration6 of reversedMigrationArray) {
      if (migration6.version <= toVersion) {
        break;
      }
      if (migration6.version > currentVersion) {
        continue;
      }
      log40(`Reverting migration version ${migration6.version}`);
      try {
        if (!isDryRun) {
          let progressCallback = () => {
          };
          if (onProgress) {
            progressCallback = (percent, message2) => onProgress(migration6.version, percent.toFixed(2), message2);
          }
          await migration6.revert(backends, progressCallback);
        }
      } catch (e) {
        const lastSuccessfullyRevertedVersion = migration6.version;
        log40(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`);
        await setVersion(lastSuccessfullyRevertedVersion, backends);
        e.message = `During reversion to version ${migration6.version} exception was raised: ${e.message}`;
        throw e;
      }
      log40(`Reverting to version ${migration6.version} finished`);
    }
    if (!isDryRun) {
      await setVersion(toVersion, backends);
    }
    log40(`All migrations successfully reverted to version ${toVersion}!`);
  } finally {
    if (!isDryRun && !ignoreLock && lock3) {
      await lock3.close();
    }
  }
}
function verifyAvailableMigrations(migrations, fromVersion, toVersion, checkReversibility = false) {
  let migrationCounter = 0;
  for (const migration6 of migrations) {
    if (migration6.version > toVersion) {
      break;
    }
    if (migration6.version > fromVersion) {
      if (checkReversibility && !migration6.revert) {
        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration6.version} is not reversible. Cancelling reversion.`);
      }
      migrationCounter++;
    }
  }
  if (migrationCounter !== toVersion - fromVersion) {
    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`);
  }
}
var errors = errors_exports3;
var import_bytes6 = __toESM(require_bytes());
var import_debug5 = __toESM(require_browser$1(), 1);
var LockExistsError = class extends Error {
  /**
   * @param {string} [message]
   */
  constructor(message2) {
    super(message2);
    this.name = "LockExistsError";
    this.code = LockExistsError.code;
  }
};
LockExistsError.code = "ERR_LOCK_EXISTS";
var NotFoundError = class extends Error {
  /**
   * @param {string} [message]
   */
  constructor(message2) {
    super(message2);
    this.name = "NotFoundError";
    this.code = NotFoundError.code;
  }
};
NotFoundError.code = "ERR_NOT_FOUND";
var InvalidRepoVersionError = class extends Error {
  /**
   * @param {string} [message]
   */
  constructor(message2) {
    super(message2);
    this.name = "InvalidRepoVersionError";
    this.code = InvalidRepoVersionError.code;
  }
};
InvalidRepoVersionError.code = "ERR_INVALID_REPO_VERSION";
var ERR_REPO_NOT_INITIALIZED = "ERR_REPO_NOT_INITIALIZED";
var ERR_REPO_ALREADY_OPEN = "ERR_REPO_ALREADY_OPEN";
var ERR_REPO_ALREADY_CLOSED = "ERR_REPO_ALREADY_CLOSED";
async function hasWithFallback2(key, has, store) {
  const result = await has(key);
  if (result) {
    return result;
  }
  const levelJs = findLevelJs2(store);
  if (!levelJs) {
    return false;
  }
  return new Promise((resolve7, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      resolve7(Boolean(req.result));
    };
  });
}
async function getWithFallback2(key, get3, has, store) {
  if (await has(key)) {
    return get3(key);
  }
  const levelJs = findLevelJs2(store);
  if (!levelJs) {
    throw new NotFoundError();
  }
  return new Promise((resolve7, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      if (req.result) {
        return resolve7(req.result);
      }
      reject(new NotFoundError());
    };
  });
}
function findLevelJs2(store) {
  let db = store;
  while (db.db || db.child) {
    db = db.db || db.child;
    if (db.type === "level-js" || db.constructor.name === "Level") {
      return db;
    }
  }
}
var log41 = (0, import_debug5.default)("ipfs:repo:version");
var versionKey = new Key("version");
function version(store) {
  return {
    /**
     * Check if a version file exists.
     *
     */
    async exists() {
      return hasWithFallback2(versionKey, store.has.bind(store), store);
    },
    /**
     * Get the current version.
     *
     * @returns {Promise<number>}
     */
    async get() {
      const buf2 = await getWithFallback2(versionKey, store.get.bind(store), store.has.bind(store), store);
      return parseInt(toString3(buf2), 10);
    },
    /**
     * Set the version of the repo, writing it to the underlying store.
     *
     * @param {number} version
     * @returns {Promise<void>}
     */
    set(version3) {
      return store.put(versionKey, fromString3(String(version3)));
    },
    /**
     * Check the current version, and returns true if versions matches
     *
     * @param {number} expected
     */
    async check(expected) {
      const version3 = await this.get();
      log41("comparing version: %s and %s", version3, expected);
      const compatibleVersion = version3 === 6 && expected === 7 || expected === 6 && version3 === 7;
      return version3 === expected || compatibleVersion;
    }
  };
}
var import_err_code65 = __toESM(require_err_code(), 1);
var Queue3 = PQueue.default ? PQueue.default : PQueue;
var configKey = new Key("config");
function config(store) {
  const setQueue = new Queue3({ concurrency: 1 });
  const configStore = {
    /**
     * Get the current configuration from the repo.
     *
     * @param {object} [options] - options
     * @param {AbortSignal} [options.signal] - abort this config read
     * @returns {Promise<Config>}
     */
    async getAll(options = {}) {
      const encodedValue = await getWithFallback2(configKey, store.get.bind(store), store.has.bind(store), store);
      return JSON.parse(toString3(encodedValue));
    },
    /**
     * Get the value for the passed configuration key from the repo.
     *
     * @param {string} key - the config key to get
     * @param {object} [options] - options
     * @param {AbortSignal} [options.signal] - abort this config read
     */
    async get(key, options = {}) {
      if (key == null) {
        throw new NotFoundError(`Key ${key} does not exist in config`);
      }
      const config2 = await this.getAll(options);
      const value2 = objectSafeGet(config2, key);
      if (value2 === void 0) {
        throw new NotFoundError(`Key ${key} does not exist in config`);
      }
      return value2;
    },
    /**
     * Set the current configuration for this repo.
     *
     * @param {string} key - the config key to be written
     * @param {any} [value] - the config value to be written
     * @param {object} [options] - options
     * @param {AbortSignal} [options.signal] - abort this config write
     */
    set(key, value2, options = {}) {
      if (typeof key !== "string" && !(key instanceof String)) {
        throw (0, import_err_code65.default)(new Error("Invalid key type: " + typeof key), "ERR_INVALID_KEY");
      }
      if (value2 === void 0 || value2 instanceof Uint8Array) {
        throw (0, import_err_code65.default)(new Error("Invalid value type: " + typeof value2), "ERR_INVALID_VALUE");
      }
      return setQueue.add(() => _maybeDoSet({
        key,
        value: value2
      }, options.signal));
    },
    /**
     * Set the current configuration for this repo.
     *
     * @param {Config} [value] - the config value to be written
     * @param {object} [options] - options
     * @param {AbortSignal} [options.signal] - abort this config write
     */
    replace(value2, options = {}) {
      if (!value2 || value2 instanceof Uint8Array) {
        throw (0, import_err_code65.default)(new Error("Invalid value type: " + typeof value2), "ERR_INVALID_VALUE");
      }
      return setQueue.add(() => _maybeDoSet({
        key: void 0,
        value: value2
      }, options.signal));
    },
    /**
     * Check if a config file exists.
     *
     */
    async exists() {
      return hasWithFallback2(configKey, store.has.bind(store), store);
    }
  };
  return configStore;
  async function _maybeDoSet(m, signal) {
    if (signal && signal.aborted) {
      return;
    }
    const key = m.key;
    const value2 = m.value;
    if (key) {
      const config2 = await configStore.getAll();
      if (typeof config2 === "object" && config2 !== null) {
        objectSafeSet(config2, key, value2);
      }
      return _saveAll(config2);
    }
    return _saveAll(value2);
  }
  function _saveAll(config2) {
    const buf2 = fromString3(JSON.stringify(config2, null, 2));
    return store.put(configKey, buf2);
  }
}
function isPlainObject$1(value2) {
  if (typeof value2 !== "object" || value2 === null) {
    return false;
  }
  const prototype3 = Object.getPrototypeOf(value2);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in value2) && !(Symbol.iterator in value2);
}
function sortKeys(object, options = {}) {
  if (!isPlainObject$1(object) && !Array.isArray(object)) {
    throw new TypeError("Expected a plain object or array");
  }
  const { deep, compare: compare3 } = options;
  const seenInput = [];
  const seenOutput = [];
  const deepSortArray = (array) => {
    const seenIndex = seenInput.indexOf(array);
    if (seenIndex !== -1) {
      return seenOutput[seenIndex];
    }
    const result = [];
    seenInput.push(array);
    seenOutput.push(result);
    result.push(...array.map((item) => {
      if (Array.isArray(item)) {
        return deepSortArray(item);
      }
      if (isPlainObject$1(item)) {
        return _sortKeys(item);
      }
      return item;
    }));
    return result;
  };
  const _sortKeys = (object2) => {
    const seenIndex = seenInput.indexOf(object2);
    if (seenIndex !== -1) {
      return seenOutput[seenIndex];
    }
    const result = {};
    const keys = Object.keys(object2).sort(compare3);
    seenInput.push(object2);
    seenOutput.push(result);
    for (const key of keys) {
      const value2 = object2[key];
      let newValue;
      if (deep && Array.isArray(value2)) {
        newValue = deepSortArray(value2);
      } else {
        newValue = deep && isPlainObject$1(value2) ? _sortKeys(value2) : value2;
      }
      Object.defineProperty(result, key, {
        ...Object.getOwnPropertyDescriptor(object2, key),
        value: newValue
      });
    }
    return result;
  };
  if (Array.isArray(object)) {
    return deep ? deepSortArray(object) : object.slice();
  }
  return _sortKeys(object);
}
var specKey = new Key("datastore_spec");
function spec(store) {
  return {
    /**
     * Check if a datastore spec file exists.
     *
     */
    exists() {
      return store.has(specKey);
    },
    /**
     * Get the current datastore spec.
     *
     * @returns {Promise<Uint8Array>}
     */
    async get() {
      const buf2 = await store.get(specKey);
      return JSON.parse(toString3(buf2));
    },
    /**
     * Set the datastore spec of the repo, writing it to the underlying store.
     * TODO unclear on what the type should be or if it's required
     *
     * @param {any} spec
     * @returns {Promise<void>}
     */
    async set(spec2) {
      return store.put(specKey, fromString3(JSON.stringify(sortKeys(spec2, { deep: true }))));
    }
  };
}
var apiFile = new Key("api");
function apiAddr(store) {
  return {
    /**
     * Get the current configuration from the repo.
     *
     * @returns {Promise<string>}
     */
    async get() {
      const value2 = await store.get(apiFile);
      return value2 && value2.toString();
    },
    /**
     * Set the current configuration for this repo.
     * TODO: fix find the proper type or remove this API
     *
     * @param {string} value - the api address to be written
     */
    set(value2) {
      return store.put(apiFile, fromString3(value2.toString()));
    },
    /**
     * Deletes api file
     */
    delete() {
      return store.delete(apiFile);
    }
  };
}
var import_err_code66 = __toESM(require_err_code(), 1);
function createIdStore(store) {
  return {
    open() {
      return store.open();
    },
    close() {
      return store.close();
    },
    query(query, options) {
      return store.query(query, options);
    },
    queryKeys(query, options) {
      return store.queryKeys(query, options);
    },
    async get(cid, options) {
      const extracted = extractContents(cid);
      if (extracted.isIdentity) {
        return Promise.resolve(extracted.digest);
      }
      return store.get(cid, options);
    },
    async *getMany(cids, options) {
      for await (const cid of cids) {
        yield this.get(cid, options);
      }
    },
    async put(cid, buf2, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return;
      }
      await store.put(cid, buf2, options);
    },
    async *putMany(pairs, options) {
      const output = pushable({
        objectMode: true
      });
      const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
      runner(async () => {
        try {
          await drain(store.putMany(async function* () {
            for await (const { key, value: value2 } of pairs) {
              if (!extractContents(key).isIdentity) {
                yield { key, value: value2 };
              }
              output.push({ key, value: value2 });
            }
          }()));
          output.end();
        } catch (err2) {
          output.end(err2);
        }
      });
      yield* output;
    },
    has(cid, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return Promise.resolve(true);
      }
      return store.has(cid, options);
    },
    delete(cid, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return Promise.resolve();
      }
      return store.delete(cid, options);
    },
    deleteMany(cids, options) {
      return store.deleteMany(filter(cids, (cid) => !extractContents(cid).isIdentity), options);
    },
    batch() {
      const batch2 = store.batch();
      return {
        put(cid, buf2) {
          const { isIdentity } = extractContents(cid);
          if (isIdentity) {
            return;
          }
          batch2.put(cid, buf2);
        },
        delete(cid) {
          const { isIdentity } = extractContents(cid);
          if (isIdentity) {
            return;
          }
          batch2.delete(cid);
        },
        commit: (options) => {
          return batch2.commit(options);
        }
      };
    }
  };
}
function extractContents(k) {
  const cid = CID.asCID(k);
  if (cid == null) {
    throw (0, import_err_code66.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  if (cid.multihash.code !== identity.code) {
    return {
      isIdentity: false
    };
  }
  return {
    isIdentity: true,
    digest: cid.multihash.digest
  };
}
var import_debug6 = __toESM(require_browser$1());
var log42 = (0, import_debug6.default)("ipfs:repo:lock:memory");
var lockFile = "repo.lock";
var LOCKS = {};
async function lock2(dir) {
  const file = dir + "/" + lockFile;
  log42("locking %s", file);
  if (LOCKS[file] === true) {
    throw new LockExistsError(`Lock already being held for file: ${file}`);
  }
  LOCKS[file] = true;
  const closer = {
    async close() {
      if (LOCKS[file]) {
        delete LOCKS[file];
      }
    }
  };
  return closer;
}
async function locked(dir) {
  const file = dir + "/" + lockFile;
  log42(`checking lock: ${file}`);
  return Boolean(LOCKS[file]);
}
var MemoryLock = {
  lock: lock2,
  locked
};
var default_options_default = {
  autoMigrate: true,
  onMigrationProgress: () => {
  },
  repoOwner: true,
  repoLock: MemoryLock
};
var default_datastore_default = {
  Spec: {
    type: "mount",
    mounts: [
      {
        mountpoint: "/blocks",
        type: "measure",
        prefix: "flatfs.datastore",
        child: {
          type: "flatfs",
          path: "blocks",
          sync: true,
          shardFunc: "/repo/flatfs/shard/v1/next-to-last/2"
        }
      },
      {
        mountpoint: "/",
        type: "measure",
        prefix: "leveldb.datastore",
        child: {
          type: "levelds",
          path: "datastore",
          compression: "none"
        }
      }
    ]
  }
};
var import_err_code68 = __toESM(require_err_code(), 1);
var import_debug8 = __toESM(require_browser$1(), 1);
var import_err_code67 = __toESM(require_err_code(), 1);
function cidToKey2(c) {
  const cid = CID.asCID(c);
  if (cid == null) {
    throw (0, import_err_code67.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  const encoded = base32.encode(cid.multihash.bytes);
  return new Key("/" + encoded.slice(1).toUpperCase(), false);
}
function keyToMultihash2(key) {
  return decode3$3(base32.decode(`b${key.toString().toLowerCase().substring(1)}`));
}
var import_debug7 = __toESM(require_browser$1(), 1);
var log43 = (0, import_debug7.default)("ipfs:repo:utils:walk-dag");
async function* walkDag(cid, blockstore, loadCodec, options) {
  try {
    const bytes2 = await blockstore.get(cid, options);
    const codec = await loadCodec(cid.code);
    const block = createUnsafe({ bytes: bytes2, cid, codec });
    for (const [, childCid] of block.links()) {
      yield childCid;
      yield* walkDag(childCid, blockstore, loadCodec, options);
    }
  } catch (err2) {
    log43("Could not walk DAG for CID", cid.toString(), err2);
    throw err2;
  }
}
var QuickLRU = class extends Map {
  constructor(options = {}) {
    super();
    if (!(options.maxSize && options.maxSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    if (typeof options.maxAge === "number" && options.maxAge === 0) {
      throw new TypeError("`maxAge` must be a number greater than 0");
    }
    this.maxSize = options.maxSize;
    this.maxAge = options.maxAge || Number.POSITIVE_INFINITY;
    this.onEviction = options.onEviction;
    this.cache = /* @__PURE__ */ new Map();
    this.oldCache = /* @__PURE__ */ new Map();
    this._size = 0;
  }
  // TODO: Use private class methods when targeting Node.js 16.
  _emitEvictions(cache4) {
    if (typeof this.onEviction !== "function") {
      return;
    }
    for (const [key, item] of cache4) {
      this.onEviction(key, item.value);
    }
  }
  _deleteIfExpired(key, item) {
    if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
      if (typeof this.onEviction === "function") {
        this.onEviction(key, item.value);
      }
      return this.delete(key);
    }
    return false;
  }
  _getOrDeleteIfExpired(key, item) {
    const deleted = this._deleteIfExpired(key, item);
    if (deleted === false) {
      return item.value;
    }
  }
  _getItemValue(key, item) {
    return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
  }
  _peek(key, cache4) {
    const item = cache4.get(key);
    return this._getItemValue(key, item);
  }
  _set(key, value2) {
    this.cache.set(key, value2);
    this._size++;
    if (this._size >= this.maxSize) {
      this._size = 0;
      this._emitEvictions(this.oldCache);
      this.oldCache = this.cache;
      this.cache = /* @__PURE__ */ new Map();
    }
  }
  _moveToRecent(key, item) {
    this.oldCache.delete(key);
    this._set(key, item);
  }
  *_entriesAscending() {
    for (const item of this.oldCache) {
      const [key, value2] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value2);
        if (deleted === false) {
          yield item;
        }
      }
    }
    for (const item of this.cache) {
      const [key, value2] = item;
      const deleted = this._deleteIfExpired(key, value2);
      if (deleted === false) {
        yield item;
      }
    }
  }
  get(key) {
    if (this.cache.has(key)) {
      const item = this.cache.get(key);
      return this._getItemValue(key, item);
    }
    if (this.oldCache.has(key)) {
      const item = this.oldCache.get(key);
      if (this._deleteIfExpired(key, item) === false) {
        this._moveToRecent(key, item);
        return item.value;
      }
    }
  }
  set(key, value2, { maxAge = this.maxAge } = {}) {
    const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
    if (this.cache.has(key)) {
      this.cache.set(key, {
        value: value2,
        expiry
      });
    } else {
      this._set(key, { value: value2, expiry });
    }
  }
  has(key) {
    if (this.cache.has(key)) {
      return !this._deleteIfExpired(key, this.cache.get(key));
    }
    if (this.oldCache.has(key)) {
      return !this._deleteIfExpired(key, this.oldCache.get(key));
    }
    return false;
  }
  peek(key) {
    if (this.cache.has(key)) {
      return this._peek(key, this.cache);
    }
    if (this.oldCache.has(key)) {
      return this._peek(key, this.oldCache);
    }
  }
  delete(key) {
    const deleted = this.cache.delete(key);
    if (deleted) {
      this._size--;
    }
    return this.oldCache.delete(key) || deleted;
  }
  clear() {
    this.cache.clear();
    this.oldCache.clear();
    this._size = 0;
  }
  resize(newSize) {
    if (!(newSize && newSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    const items = [...this._entriesAscending()];
    const removeCount = items.length - newSize;
    if (removeCount < 0) {
      this.cache = new Map(items);
      this.oldCache = /* @__PURE__ */ new Map();
      this._size = items.length;
    } else {
      if (removeCount > 0) {
        this._emitEvictions(items.slice(0, removeCount));
      }
      this.oldCache = new Map(items.slice(removeCount));
      this.cache = /* @__PURE__ */ new Map();
      this._size = 0;
    }
    this.maxSize = newSize;
  }
  *keys() {
    for (const [key] of this) {
      yield key;
    }
  }
  *values() {
    for (const [, value2] of this) {
      yield value2;
    }
  }
  *[Symbol.iterator]() {
    for (const item of this.cache) {
      const [key, value2] = item;
      const deleted = this._deleteIfExpired(key, value2);
      if (deleted === false) {
        yield [key, value2.value];
      }
    }
    for (const item of this.oldCache) {
      const [key, value2] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value2);
        if (deleted === false) {
          yield [key, value2.value];
        }
      }
    }
  }
  *entriesDescending() {
    let items = [...this.cache];
    for (let i2 = items.length - 1; i2 >= 0; --i2) {
      const item = items[i2];
      const [key, value2] = item;
      const deleted = this._deleteIfExpired(key, value2);
      if (deleted === false) {
        yield [key, value2.value];
      }
    }
    items = [...this.oldCache];
    for (let i2 = items.length - 1; i2 >= 0; --i2) {
      const item = items[i2];
      const [key, value2] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value2);
        if (deleted === false) {
          yield [key, value2.value];
        }
      }
    }
  }
  *entriesAscending() {
    for (const [key, value2] of this._entriesAscending()) {
      yield [key, value2.value];
    }
  }
  get size() {
    if (!this._size) {
      return this.oldCache.size;
    }
    let oldCacheSize = 0;
    for (const key of this.oldCache.keys()) {
      if (!this.cache.has(key)) {
        oldCacheSize++;
      }
    }
    return Math.min(this._size + oldCacheSize, this.maxSize);
  }
  entries() {
    return this.entriesAscending();
  }
  forEach(callbackFunction, thisArgument = this) {
    for (const [key, value2] of this.entriesAscending()) {
      callbackFunction.call(thisArgument, value2, key, this);
    }
  }
  get [Symbol.toStringTag]() {
    return JSON.stringify([...this.entriesAscending()]);
  }
};
var CID_CACHE_MAX_SIZE = 2048;
function invalidPinTypeErr(type) {
  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;
  return (0, import_err_code68.default)(new Error(errMsg), "ERR_INVALID_PIN_TYPE");
}
var PinManager = class {
  /**
   * @param {object} config
   * @param {import('interface-datastore').Datastore} config.pinstore
   * @param {import('interface-blockstore').Blockstore} config.blockstore
   * @param {import('./types').loadCodec} config.loadCodec
   */
  constructor({ pinstore, blockstore, loadCodec }) {
    this.pinstore = pinstore;
    this.blockstore = blockstore;
    this.loadCodec = loadCodec;
    this.log = (0, import_debug8.default)("ipfs:repo:pin");
    this.directPins = /* @__PURE__ */ new Set();
    this.recursivePins = /* @__PURE__ */ new Set();
  }
  /**
   * @param {CID} cid
   * @param {PinOptions & AbortOptions} [options]
   */
  async pinDirectly(cid, options = {}) {
    await this.blockstore.get(cid, options);
    const pin = {
      depth: 0
    };
    if (cid.version !== 0) {
      pin.version = cid.version;
    }
    if (cid.code !== code) {
      pin.codec = cid.code;
    }
    if (options.metadata) {
      pin.metadata = options.metadata;
    }
    return this.pinstore.put(cidToKey2(cid), encode2$2(pin));
  }
  /**
   * @param {CID} cid
   * @param {AbortOptions} [options]
   */
  unpin(cid, options) {
    return this.pinstore.delete(cidToKey2(cid), options);
  }
  /**
   * @param {CID} cid
   * @param {PinOptions & FetchCompleteDagOptions & AbortOptions} [options]
   */
  async pinRecursively(cid, options = {}) {
    await this.fetchCompleteDag(cid, options);
    const pin = {
      depth: Infinity
    };
    if (cid.version !== 0) {
      pin.version = cid.version;
    }
    if (cid.code !== code) {
      pin.codec = cid.code;
    }
    if (options.metadata) {
      pin.metadata = options.metadata;
    }
    await this.pinstore.put(cidToKey2(cid), encode2$2(pin));
  }
  /**
   * @param {AbortOptions} [options]
   */
  async *directKeys(options) {
    for await (const entry of this.pinstore.query({
      filters: [(entry2) => {
        const pin = decode3$1(entry2.value);
        return pin.depth === 0;
      }]
    })) {
      const pin = decode3$1(entry.value);
      const version3 = pin.version || 0;
      const codec = pin.codec != null ? pin.codec : code;
      const multihash = keyToMultihash2(entry.key);
      yield {
        cid: CID.create(version3, codec, multihash),
        metadata: pin.metadata
      };
    }
  }
  /**
   * @param {AbortOptions} [options]
   */
  async *recursiveKeys(options) {
    for await (const entry of this.pinstore.query({
      filters: [(entry2) => {
        const pin = decode3$1(entry2.value);
        return pin.depth === Infinity;
      }]
    })) {
      const pin = decode3$1(entry.value);
      const version3 = pin.version || 0;
      const codec = pin.codec != null ? pin.codec : code;
      const multihash = keyToMultihash2(entry.key);
      yield {
        cid: CID.create(version3, codec, multihash),
        metadata: pin.metadata
      };
    }
  }
  /**
   * @param {AbortOptions} [options]
   */
  async *indirectKeys(options) {
    for await (const { cid } of this.recursiveKeys()) {
      for await (const childCid of walkDag(cid, this.blockstore, this.loadCodec, options)) {
        const types2 = [
          PinTypes.recursive
        ];
        const result = await this.isPinnedWithType(childCid, types2);
        if (result.pinned) {
          continue;
        }
        yield childCid;
      }
    }
  }
  /**
   * @param {CID} cid
   * @param {PinQueryType|PinQueryType[]} types
   * @param {AbortOptions} [options]
   */
  async isPinnedWithType(cid, types2, options) {
    if (!Array.isArray(types2)) {
      types2 = [types2];
    }
    const all32 = types2.includes(PinTypes.all);
    const direct = types2.includes(PinTypes.direct);
    const recursive2 = types2.includes(PinTypes.recursive);
    const indirect = types2.includes(PinTypes.indirect);
    if (recursive2 || direct || all32) {
      const result = await first(this.pinstore.query({
        prefix: cidToKey2(cid).toString(),
        filters: [(entry) => {
          if (all32) {
            return true;
          }
          const pin = decode3$1(entry.value);
          return types2.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive);
        }],
        limit: 1
      }));
      if (result) {
        const pin = decode3$1(result.value);
        return {
          cid,
          pinned: true,
          reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,
          metadata: pin.metadata
        };
      }
    }
    const self2 = this;
    async function* findChild(key, source) {
      for await (const { cid: parentCid } of source) {
        for await (const childCid of walkDag(parentCid, self2.blockstore, self2.loadCodec)) {
          if (childCid.equals(key)) {
            yield parentCid;
            return;
          }
        }
      }
    }
    if (all32 || indirect) {
      const parentCid = await first(findChild(cid, this.recursiveKeys()));
      if (parentCid) {
        return {
          cid,
          pinned: true,
          reason: PinTypes.indirect,
          parent: parentCid
        };
      }
    }
    return {
      cid,
      pinned: false
    };
  }
  /**
   * @param {CID} cid
   * @param {FetchCompleteDagOptions} [options]
   */
  async fetchCompleteDag(cid, options = {}) {
    const seen = new QuickLRU({ maxSize: options.cidCacheMaxSize ?? CID_CACHE_MAX_SIZE });
    const walkDag2 = async (cid2, options2) => {
      if (seen.has(cid2.toString())) {
        return;
      }
      seen.set(cid2.toString(), true);
      const bytes2 = await this.blockstore.get(cid2, options2);
      const codec = await this.loadCodec(cid2.code);
      const block = createUnsafe({ bytes: bytes2, cid: cid2, codec });
      await Promise.all(
        [...block.links()].map(([, childCid]) => walkDag2(childCid, options2))
      );
    };
    await walkDag2(cid, options);
  }
  /**
   * Throws an error if the pin type is invalid
   *
   * @param {any} type
   * @returns {type is PinType}
   */
  static checkPinType(type) {
    if (typeof type !== "string" || !Object.keys(PinTypes).includes(type)) {
      throw invalidPinTypeErr(type);
    }
    return true;
  }
};
var import_err_code69 = __toESM(require_err_code(), 1);
function createPinnedBlockstore(pins, store) {
  return {
    open() {
      return store.open();
    },
    close() {
      return store.close();
    },
    query(query, options) {
      return store.query(query, options);
    },
    queryKeys(query, options) {
      return store.queryKeys(query, options);
    },
    async get(cid, options) {
      return store.get(cid, options);
    },
    async *getMany(cids, options) {
      yield* store.getMany(cids, options);
    },
    async put(cid, buf2, options) {
      await store.put(cid, buf2, options);
    },
    async *putMany(pairs, options) {
      yield* store.putMany(pairs, options);
    },
    has(cid, options) {
      return store.has(cid, options);
    },
    async delete(cid, options) {
      await ensureNotPinned(cid, pins);
      return store.delete(cid, options);
    },
    deleteMany(cids, options) {
      return store.deleteMany(map(cids, async (cid) => {
        await ensureNotPinned(cid, pins);
        return cid;
      }), options);
    },
    batch() {
      return store.batch();
    }
  };
}
async function ensureNotPinned(cid, pins) {
  const { pinned, reason } = await pins.isPinnedWithType(cid, PinTypes.all);
  if (pinned) {
    throw (0, import_err_code69.default)(new Error(`pinned: ${reason}`), "ERR_BLOCK_PINNED");
  }
}
var import_debug9 = __toESM(require_browser$1(), 1);
async function* parallelBatch2(source, size = 1) {
  for await (const tasks of batch(source, size)) {
    const things = tasks.map(async (p) => {
      return await p().then((value2) => ({ ok: true, value: value2 }), (err2) => ({ ok: false, err: err2 }));
    });
    for (let i2 = 0; i2 < things.length; i2++) {
      const result = await things[i2];
      if (result.ok) {
        yield result.value;
      } else {
        throw result.err;
      }
    }
  }
}
var log44 = (0, import_debug9.default)("ipfs:repo:gc");
var ERR_NOT_FOUND4 = notFoundError().code;
var BLOCK_RM_CONCURRENCY2 = 256;
var MFS_ROOT_KEY3 = new Key("/local/filesroot");
function gc({ gcLock, pins, blockstore, root: root2, loadCodec }) {
  async function* gc2() {
    const start = Date.now();
    log44("Creating set of marked blocks");
    const release = await gcLock.writeLock();
    try {
      const markedSet = await createMarkedSet({ pins, blockstore, root: root2, loadCodec });
      const blockKeys = blockstore.queryKeys({});
      yield* deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys);
      log44(`Complete (${Date.now() - start}ms)`);
    } finally {
      release();
    }
  }
  return gc2;
}
async function createMarkedSet({ pins, blockstore, loadCodec, root: root2 }) {
  const mfsSource = async function* () {
    let mh;
    try {
      mh = await root2.get(MFS_ROOT_KEY3);
    } catch (err2) {
      if (err2.code === ERR_NOT_FOUND4) {
        log44("No blocks in MFS");
        return;
      }
      throw err2;
    }
    const rootCid = CID.decode(mh);
    yield rootCid;
    yield* walkDag(rootCid, blockstore, loadCodec);
  }();
  const pinsSource = merge$1(
    map(pins.recursiveKeys(), ({ cid }) => cid),
    pins.indirectKeys(),
    map(pins.directKeys(), ({ cid }) => cid),
    mfsSource
  );
  const output = /* @__PURE__ */ new Set();
  for await (const cid of merge$1(pinsSource, mfsSource)) {
    output.add(base32.encode(cid.multihash.bytes));
  }
  return output;
}
async function* deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys) {
  let blocksCount = 0;
  let removedBlocksCount = 0;
  const removeBlock = async (cid) => {
    return async function remove() {
      blocksCount++;
      try {
        const b32 = base32.encode(cid.multihash.bytes);
        if (markedSet.has(b32)) {
          return null;
        }
        try {
          await blockstore.delete(cid);
          removedBlocksCount++;
        } catch (err2) {
          return {
            err: new Error(`Could not delete block with CID ${cid}: ${err2.message}`)
          };
        }
        return { cid };
      } catch (err2) {
        const msg = `Could delete block with CID ${cid}`;
        log44(msg, err2);
        return { err: new Error(msg + `: ${err2.message}`) };
      }
    };
  };
  yield* pipe(
    parallelBatch2(map(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY2),
    // filter nulls (blocks that were retained)
    (source) => filter(source, Boolean)
  );
  log44(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. Deleted ${removedBlocksCount} blocks.`);
}
var log45 = (0, import_debug10.default)("ipfs:repo");
var noLimit = Number.MAX_SAFE_INTEGER;
var AUTO_MIGRATE_CONFIG_KEY = "repoAutoMigrate";
var Repo = class {
  /**
   * @param {string} path - Where this repo is stored
   * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs
   * @param {Backends} backends - backends used by this repo
   * @param {Partial<Options>} [options] - Configuration
   */
  constructor(path2, loadCodec, backends, options) {
    if (typeof path2 !== "string") {
      throw new Error("missing repo path");
    }
    if (typeof loadCodec !== "function") {
      throw new Error("missing codec loader");
    }
    this.options = merge_options_default(default_options_default, options);
    this.closed = true;
    this.path = path2;
    this.root = backends.root;
    this.datastore = backends.datastore;
    this.keys = backends.keys;
    const blockstore = backends.blocks;
    const pinstore = backends.pins;
    this.pins = new PinManager({ pinstore, blockstore, loadCodec });
    const pinnedBlockstore = createPinnedBlockstore(this.pins, blockstore);
    this.blocks = createIdStore(pinnedBlockstore);
    this.version = version(this.root);
    this.config = config(this.root);
    this.spec = spec(this.root);
    this.apiAddr = apiAddr(this.root);
    this.gcLock = createMortice({
      name: path2,
      singleProcess: this.options.repoOwner !== false
    });
    this.gc = gc({ gcLock: this.gcLock, pins: this.pins, blockstore: this.blocks, root: this.root, loadCodec });
  }
  /**
   * Initialize a new repo.
   *
   * @param {import('./types').Config} config - config to write into `config`.
   * @returns {Promise<void>}
   */
  async init(config2) {
    log45("initializing at: %s", this.path);
    await this._openRoot();
    await this.config.replace(buildConfig(config2));
    await this.spec.set(buildDatastoreSpec(config2));
    await this.version.set(repoVersion);
  }
  /**
   * Check if the repo is already initialized.
   *
   * @returns {Promise<boolean>}
   */
  async isInitialized() {
    if (!this.closed) {
      return true;
    }
    try {
      await this._openRoot();
      await this._checkInitialized();
      await this.root.close();
      return true;
    } catch (err2) {
      return false;
    }
  }
  /**
   * Open the repo. If the repo is already open an error will be thrown.
   * If the repo is not initialized it will throw an error.
   *
   * @returns {Promise<void>}
   */
  async open() {
    if (!this.closed) {
      throw (0, import_err_code70.default)(new Error("repo is already open"), ERR_REPO_ALREADY_OPEN);
    }
    log45("opening at: %s", this.path);
    try {
      await this._openRoot();
      await this._checkInitialized();
      this._lockfile = await this._openLock();
      log45("acquired repo.lock");
      const isCompatible = await this.version.check(repoVersion);
      if (!isCompatible) {
        if (await this._isAutoMigrationEnabled()) {
          await this._migrate(repoVersion, {
            root: this.root,
            datastore: this.datastore,
            pins: this.pins.pinstore,
            blocks: this.pins.blockstore,
            keys: this.keys
          });
        } else {
          throw new InvalidRepoVersionError("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");
        }
      }
      log45("creating datastore");
      await this.datastore.open();
      log45("creating blocks");
      await this.blocks.open();
      log45("creating keystore");
      await this.keys.open();
      log45("creating pins");
      await this.pins.pinstore.open();
      this.closed = false;
      log45("all opened");
    } catch (err2) {
      if (this._lockfile) {
        try {
          await this._closeLock();
          this._lockfile = null;
        } catch (err22) {
          log45("error removing lock", err22);
        }
      }
      throw err2;
    }
  }
  /**
   * Opens the root backend, catching and ignoring an 'Already open' error
   *
   * @private
   */
  async _openRoot() {
    try {
      await this.root.open();
    } catch (err2) {
      if (err2.message !== "Already open") {
        throw err2;
      }
    }
  }
  /**
   * Creates a lock on the repo if a locker is specified. The lockfile object will
   * be returned in the callback if one has been created.
   *
   * @private
   * @returns {Promise<LockCloser>}
   */
  async _openLock() {
    const lockfile = await this.options.repoLock.lock(this.path);
    if (typeof lockfile.close !== "function") {
      throw (0, import_err_code70.default)(new Error("Locks must have a close method"), "ERR_NO_CLOSE_FUNCTION");
    }
    return lockfile;
  }
  /**
   * Closes the lock on the repo
   *
   * @private
   */
  _closeLock() {
    return this._lockfile && this._lockfile.close();
  }
  /**
   * Check if the repo is already initialized.
   *
   * @private
   */
  async _checkInitialized() {
    log45("init check");
    let config2;
    try {
      [config2] = await Promise.all([
        this.config.exists(),
        this.spec.exists(),
        this.version.exists()
      ]);
    } catch (err2) {
      if (err2.code === "ERR_NOT_FOUND") {
        throw (0, import_err_code70.default)(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, {
          path: this.path
        });
      }
      throw err2;
    }
    if (!config2) {
      throw (0, import_err_code70.default)(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, {
        path: this.path
      });
    }
  }
  /**
   * Close the repo and cleanup.
   *
   * @returns {Promise<void>}
   */
  async close() {
    if (this.closed) {
      throw (0, import_err_code70.default)(new Error("repo is already closed"), ERR_REPO_ALREADY_CLOSED);
    }
    log45("closing at: %s", this.path);
    try {
      await this.apiAddr.delete();
    } catch (err2) {
      if (err2.code !== ERR_REPO_NOT_INITIALIZED && !err2.message.startsWith("ENOENT")) {
        throw err2;
      }
    }
    await Promise.all([
      this.root,
      this.blocks,
      this.keys,
      this.datastore,
      this.pins.pinstore
    ].map((store) => store && store.close()));
    log45("unlocking");
    this.closed = true;
    await this._closeLock();
  }
  /**
   * Check if a repo exists.
   *
   * @returns {Promise<boolean>}
   */
  exists() {
    return this.version.exists();
  }
  /**
   * Get repo status.
   *
   * @returns {Promise<Stat>}
   */
  async stat() {
    if (this.datastore && this.keys) {
      const [storageMax, blocks, version3, datastore, keys] = await Promise.all([
        this._storageMaxStat(),
        this._blockStat(),
        this.version.get(),
        getSize(this.datastore),
        getSize(this.keys)
      ]);
      const size = blocks.size + datastore + keys;
      return {
        repoPath: this.path,
        storageMax,
        version: version3,
        numObjects: blocks.count,
        repoSize: size
      };
    }
    throw (0, import_err_code70.default)(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, {
      path: this.path
    });
  }
  /**
   * @private
   */
  async _isAutoMigrationEnabled() {
    if (this.options.autoMigrate !== void 0) {
      return this.options.autoMigrate;
    }
    let autoMigrateConfig;
    try {
      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY);
    } catch (e) {
      if (e.code === NotFoundError.code) {
        autoMigrateConfig = true;
      } else {
        throw e;
      }
    }
    return autoMigrateConfig;
  }
  /**
   * Internal migration
   *
   * @private
   * @param {number} toVersion
   * @param {Backends} backends
   */
  async _migrate(toVersion, backends) {
    const currentRepoVersion = await this.version.get();
    if (currentRepoVersion > toVersion) {
      log45(`reverting to version ${toVersion}`);
      return revert(this.path, backends, this.options, toVersion, {
        ignoreLock: true,
        onProgress: this.options.onMigrationProgress
      });
    } else {
      log45(`migrating to version ${toVersion}`);
      return migrate(this.path, backends, this.options, toVersion, {
        ignoreLock: true,
        onProgress: this.options.onMigrationProgress
      });
    }
  }
  /**
   * @private
   */
  async _storageMaxStat() {
    try {
      const max = (
        /** @type {number} */
        await this.config.get("Datastore.StorageMax")
      );
      return BigInt((0, import_bytes6.default)(max));
    } catch (err2) {
      return BigInt(noLimit);
    }
  }
  /**
   * @private
   */
  async _blockStat() {
    let count = BigInt(0);
    let size = BigInt(0);
    if (this.blocks) {
      for await (const { key, value: value2 } of this.blocks.query({})) {
        count += BigInt(1);
        size += BigInt(value2.byteLength);
        size += BigInt(key.bytes.byteLength);
      }
    }
    return { count, size };
  }
};
async function getSize(datastore) {
  let sum = BigInt(0);
  for await (const block of datastore.query({})) {
    sum += BigInt(block.value.byteLength);
    sum += BigInt(block.key.uint8Array().byteLength);
  }
  return sum;
}
function createRepo(path2, loadCodec, backends, options) {
  return new Repo(path2, loadCodec, backends, options);
}
function buildConfig(_config) {
  _config.Datastore = Object.assign({}, default_datastore_default, objectSafeGet(_config, "datastore"));
  return _config;
}
function buildDatastoreSpec(_config) {
  const spec2 = {
    ...default_datastore_default.Spec,
    ...objectSafeGet(_config, "Datastore.Spec")
  };
  return {
    type: spec2.type,
    mounts: spec2.mounts.map((mounting) => ({
      mountpoint: mounting.mountpoint,
      type: mounting.child.type,
      path: mounting.child.path,
      shardFunc: mounting.child.shardFunc
    }))
  };
}
async function* sort(source, sorter) {
  const arr = await all(source);
  yield* arr.sort(sorter);
}
var import_level3 = __toESM(require_browser3());
var LevelDatastore = class extends BaseDatastore {
  /**
   * @param {string | LevelDb} path
   * @param {import('level').DatabaseOptions<string, Uint8Array> & import('level').OpenOptions} [opts]
   */
  constructor(path2, opts = {}) {
    super();
    this.db = typeof path2 === "string" ? new import_level3.Level(path2, {
      ...opts,
      keyEncoding: "utf8",
      valueEncoding: "view"
    }) : path2;
    this.opts = {
      createIfMissing: true,
      compression: false,
      // same default as go
      ...opts
    };
  }
  async open() {
    try {
      await this.db.open(this.opts);
    } catch (err2) {
      throw errors_exports.dbOpenFailedError(err2);
    }
  }
  /**
   * @param {Key} key
   * @param {Uint8Array} value
   */
  async put(key, value2) {
    try {
      await this.db.put(key.toString(), value2);
    } catch (err2) {
      throw errors_exports.dbWriteFailedError(err2);
    }
  }
  /**
   * @param {Key} key
   * @returns {Promise<Uint8Array>}
   */
  async get(key) {
    let data;
    try {
      data = await this.db.get(key.toString());
    } catch (err2) {
      if (err2.notFound)
        throw errors_exports.notFoundError(err2);
      throw errors_exports.dbWriteFailedError(err2);
    }
    return data;
  }
  /**
   * @param {Key} key
   * @returns {Promise<boolean>}
   */
  async has(key) {
    try {
      await this.db.get(key.toString());
    } catch (err2) {
      if (err2.notFound)
        return false;
      throw err2;
    }
    return true;
  }
  /**
   * @param {Key} key
   * @returns {Promise<void>}
   */
  async delete(key) {
    try {
      await this.db.del(key.toString());
    } catch (err2) {
      throw errors_exports.dbDeleteFailedError(err2);
    }
  }
  close() {
    return this.db && this.db.close();
  }
  /**
   * @returns {Batch}
   */
  batch() {
    const ops = [];
    return {
      put: (key, value2) => {
        ops.push({
          type: "put",
          key: key.toString(),
          value: value2
        });
      },
      delete: (key) => {
        ops.push({
          type: "del",
          key: key.toString()
        });
      },
      commit: () => {
        return this.db.batch(ops);
      }
    };
  }
  /**
   * @param {Query} q
   */
  query(q) {
    let it = this._query({
      values: true,
      prefix: q.prefix
    });
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => filter(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sort(it2, f), it);
    }
    const { offset, limit } = q;
    if (offset) {
      let i2 = 0;
      it = filter(it, () => i2++ >= offset);
    }
    if (limit) {
      it = take(it, limit);
    }
    return it;
  }
  /**
   * @param {KeyQuery} q
   */
  queryKeys(q) {
    let it = map(this._query({
      values: false,
      prefix: q.prefix
    }), ({ key }) => key);
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => filter(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sort(it2, f), it);
    }
    const { offset, limit } = q;
    if (offset) {
      let i2 = 0;
      it = filter(it, () => i2++ >= offset);
    }
    if (limit) {
      it = take(it, limit);
    }
    return it;
  }
  /**
   * @param {object} opts
   * @param {boolean} opts.values
   * @param {string} [opts.prefix]
   * @returns {AsyncIterable<Pair>}
   */
  _query(opts) {
    const iteratorOpts = {
      keys: true,
      keyEncoding: "buffer",
      values: opts.values
    };
    if (opts.prefix != null) {
      const prefix = opts.prefix.toString();
      iteratorOpts.gte = prefix;
      iteratorOpts.lt = prefix + "ÿ";
    }
    const iterator = this.db.iterator(iteratorOpts);
    if (iterator[Symbol.asyncIterator]) {
      return levelIteratorToIterator(iterator);
    }
    if (iterator.next != null && iterator.end != null) {
      return oldLevelIteratorToIterator(iterator);
    }
    throw new Error("Level returned incompatible iterator");
  }
};
async function* levelIteratorToIterator(li) {
  for await (const [key, value2] of li) {
    yield { key: new Key(key, false), value: value2 };
  }
  await li.close();
}
function oldLevelIteratorToIterator(li) {
  return {
    [Symbol.asyncIterator]() {
      return {
        next: () => new Promise((resolve7, reject) => {
          li.next((err2, key, value2) => {
            if (err2)
              return reject(err2);
            if (key == null) {
              return li.end((err3) => {
                if (err3)
                  return reject(err3);
                resolve7({ done: true, value: void 0 });
              });
            }
            resolve7({ done: false, value: { key: new Key(key, false), value: value2 } });
          });
        }),
        return: () => new Promise((resolve7, reject) => {
          li.end((err2) => {
            if (err2)
              return reject(err2);
            resolve7({ done: true, value: void 0 });
          });
        })
      };
    }
  };
}
var import_err_code71 = __toESM(require_err_code());
var sortAll2 = (iterable, sorter) => {
  return async function* () {
    const values = await all(iterable);
    yield* values.sort(sorter);
  }();
};
var BaseBlockstore = class {
  /**
   * @returns {Promise<void>}
   */
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  /**
   * @returns {Promise<void>}
   */
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  /**
   * @param {CID} key
   * @param {Uint8Array} val
   * @param {Options} [options]
   * @returns {Promise<void>}
   */
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  /**
   * @param {CID} key
   * @param {Options} [options]
   * @returns {Promise<Uint8Array>}
   */
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  /**
   * @param {CID} key
   * @param {Options} [options]
   * @returns {Promise<boolean>}
   */
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  /**
   * @param {CID} key
   * @param {Options} [options]
   * @returns {Promise<void>}
   */
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  /**
   * @param {AwaitIterable<Pair>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<Pair>}
   */
  async *putMany(source, options = {}) {
    for await (const { key, value: value2 } of source) {
      await this.put(key, value2, options);
      yield { key, value: value2 };
    }
  }
  /**
   * @param {AwaitIterable<CID>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<Uint8Array>}
   */
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield this.get(key, options);
    }
  }
  /**
   * @param {AwaitIterable<CID>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<CID>}
   */
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  /**
   * @returns {Batch}
   */
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value2) {
        puts.push({ key, value: value2 });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await drain(this.putMany(puts, options));
        puts = [];
        await drain(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  /**
   * Extending classes should override `query` or implement this method
   *
   * @param {Query} q
   * @param {Options} [options]
   * @returns {AsyncIterable<Pair>}
   */
  // eslint-disable-next-line require-yield
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  /**
   * Extending classes should override `queryKeys` or implement this method
   *
   * @param {KeyQuery} q
   * @param {Options} [options]
   * @returns {AsyncIterable<CID>}
   */
  // eslint-disable-next-line require-yield
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  /**
   * @param {Query} q
   * @param {Options} [options]
   */
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      it = filter(
        it,
        (e) => e.key.toString().startsWith(q.prefix || "")
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => filter(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll2(it2, f), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      it = filter(it, () => i2++ >= (q.offset || 0));
    }
    if (q.limit != null) {
      it = take(it, q.limit);
    }
    return it;
  }
  /**
   * @param {KeyQuery} q
   * @param {Options} [options]
   */
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      it = filter(it, (cid) => cid.toString().startsWith(q.prefix || ""));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => filter(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll2(it2, f), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      it = filter(it, () => i2++ >= /** @type {number} */
      q.offset);
    }
    if (q.limit != null) {
      it = take(it, q.limit);
    }
    return it;
  }
};
function cidToKey3(cid) {
  const c = CID.asCID(cid);
  if (!c) {
    throw (0, import_err_code71.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  return new Key("/" + base32.encode(c.multihash.bytes).slice(1).toUpperCase(), false);
}
function keyToCid2(key) {
  return CID.createV1(code6, decode3$3(base32.decode("b" + key.toString().slice(1).toLowerCase())));
}
function convertPrefix(prefix) {
  const firstChar = prefix.substring(0, 1);
  if (firstChar === "/") {
    return convertPrefix(prefix.substring(1));
  }
  let decoder;
  if (firstChar.toLowerCase() === "b") {
    decoder = (input) => base32.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar.toLowerCase() === "c") {
    decoder = (input) => base32pad.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar === "z") {
    decoder = (input) => base58btc.decode(input).subarray(2);
  } else if (firstChar === "Q") {
    decoder = (input) => base58btc.decode("z" + input);
  } else {
    decoder = (input) => base32.decode("b" + input.toLowerCase()).subarray(2);
  }
  let bytes2;
  for (let i2 = 1; i2 < prefix.length; i2++) {
    try {
      bytes2 = decoder(prefix.substring(0, i2));
    } catch (err2) {
      if (err2.message !== "Unexpected end of data") {
        throw err2;
      }
    }
  }
  let str = "/C";
  if (bytes2) {
    str = `/${base32.encode(bytes2).slice(1, -1).toUpperCase() || "C"}`;
  }
  return str;
}
function convertQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : void 0,
    filters: query.filters ? query.filters.map(
      (filter32) => (pair2) => {
        return filter32({ key: keyToCid2(pair2.key), value: pair2.value });
      }
    ) : void 0,
    orders: query.orders ? query.orders.map(
      (order) => (a, b) => {
        return order({ key: keyToCid2(a.key), value: a.value }, { key: keyToCid2(b.key), value: b.value });
      }
    ) : void 0
  };
}
function convertKeyQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : void 0,
    filters: query.filters ? query.filters.map(
      (filter32) => (key) => {
        return filter32(keyToCid2(key));
      }
    ) : void 0,
    orders: query.orders ? query.orders.map(
      (order) => (a, b) => {
        return order(keyToCid2(a), keyToCid2(b));
      }
    ) : void 0
  };
}
var BlockstoreDatastoreAdapter = class extends BaseBlockstore {
  /**
   * @param {Datastore} datastore
   */
  constructor(datastore) {
    super();
    this.child = datastore;
  }
  open() {
    return this.child.open();
  }
  close() {
    return this.child.close();
  }
  /**
   * @param {Query} query
   * @param {Options} [options]
   */
  async *query(query, options) {
    for await (const { key, value: value2 } of this.child.query(convertQuery(query), options)) {
      yield { key: keyToCid2(key), value: value2 };
    }
  }
  /**
   * @param {KeyQuery} query
   * @param {Options} [options]
   */
  async *queryKeys(query, options) {
    for await (const key of this.child.queryKeys(convertKeyQuery(query), options)) {
      yield keyToCid2(key);
    }
  }
  /**
   * @param {CID} cid
   * @param {Options} [options]
   * @returns
   */
  async get(cid, options) {
    return this.child.get(cidToKey3(cid), options);
  }
  /**
   * @param {AsyncIterable<CID> | Iterable<CID>} cids
   * @param {Options} [options]
   */
  async *getMany(cids, options) {
    for await (const cid of cids) {
      yield this.get(cid, options);
    }
  }
  /**
   * @param {CID} cid
   * @param {Uint8Array} value
   * @param {Options} [options]
   */
  async put(cid, value2, options) {
    await this.child.put(cidToKey3(cid), value2, options);
  }
  /**
   * @param {AsyncIterable<Pair> | Iterable<Pair>} blocks
   * @param {Options} [options]
   */
  async *putMany(blocks, options) {
    const output = pushable({
      objectMode: true
    });
    const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
    runner(async () => {
      try {
        const store = this.child;
        await drain(this.child.putMany(async function* () {
          for await (const block of blocks) {
            const key = cidToKey3(block.key);
            const exists2 = await store.has(key, options);
            if (!exists2) {
              yield { key, value: block.value };
            }
            output.push(block);
          }
        }()));
        output.end();
      } catch (err2) {
        output.end(err2);
      }
    });
    yield* output;
  }
  /**
   * @param {CID} cid
   * @param {Options} [options]
   */
  has(cid, options) {
    return this.child.has(cidToKey3(cid), options);
  }
  /**
   * @param {CID} cid
   * @param {Options} [options]
   */
  delete(cid, options) {
    return this.child.delete(cidToKey3(cid), options);
  }
  /**
   * @param {AsyncIterable<CID> | Iterable<CID>} cids
   * @param {Options} [options]
   */
  deleteMany(cids, options) {
    const out = pushable({
      objectMode: true
    });
    drain(this.child.deleteMany(async function* () {
      for await (const cid of cids) {
        yield cidToKey3(cid);
        out.push(cid);
      }
      out.end();
    }(), options)).catch((err2) => {
      out.end(err2);
    });
    return out;
  }
};
function createRepo2(print, codecs2, options) {
  const repoPath = options.path || "ipfs";
  return createRepo(repoPath, (codeOrName) => codecs2.getCodec(codeOrName), {
    root: new LevelDatastore(repoPath, {
      prefix: "",
      version: 2
    }),
    blocks: new BlockstoreDatastoreAdapter(
      new LevelDatastore(`${repoPath}/blocks`, {
        prefix: "",
        version: 2
      })
    ),
    datastore: new LevelDatastore(`${repoPath}/datastore`, {
      prefix: "",
      version: 2
    }),
    keys: new LevelDatastore(`${repoPath}/keys`, {
      prefix: "",
      version: 2
    }),
    pins: new LevelDatastore(`${repoPath}/pins`, {
      prefix: "",
      version: 2
    })
  }, {
    autoMigrate: options.autoMigrate,
    onMigrationProgress: options.onMigrationProgress || print,
    repoLock: MemoryLock
  });
}
var import_err_code138 = __toESM(require_err_code(), 1);
var import_err_code72 = __toESM(require_err_code(), 1);
var codes2 = {
  ERR_SIGNATURE_NOT_VALID: "ERR_SIGNATURE_NOT_VALID"
};
var Envelope2;
(function(Envelope3) {
  let _codec;
  Envelope3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (opts.writeDefaults === true || obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.payloadType);
        }
        if (opts.writeDefaults === true || obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.payload);
        }
        if (opts.writeDefaults === true || obj.signature != null && obj.signature.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {
          publicKey: new Uint8Array(0),
          payloadType: new Uint8Array(0),
          payload: new Uint8Array(0),
          signature: new Uint8Array(0)
        };
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.publicKey = reader3.bytes();
              break;
            case 2:
              obj.payloadType = reader3.bytes();
              break;
            case 3:
              obj.payload = reader3.bytes();
              break;
            case 5:
              obj.signature = reader3.bytes();
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope3.encode = (obj) => {
    return encodeMessage(obj, Envelope3.codec());
  };
  Envelope3.decode = (buf2) => {
    return decodeMessage(buf2, Envelope3.codec());
  };
})(Envelope2 || (Envelope2 = {}));
function accessor(buf2) {
  if (buf2 instanceof Uint8Array) {
    return {
      get(index2) {
        return buf2[index2];
      },
      set(index2, value2) {
        buf2[index2] = value2;
      }
    };
  }
  return {
    get(index2) {
      return buf2.get(index2);
    },
    set(index2, value2) {
      buf2.set(index2, value2);
    }
  };
}
var TWO_32 = 4294967296;
var LongBits = class {
  constructor(hi = 0, lo = 0) {
    this.hi = hi;
    this.lo = lo;
  }
  /**
   * Returns these hi/lo bits as a BigInt
   */
  toBigInt(unsigned2) {
    if (unsigned2 === true) {
      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    }
    if (this.hi >>> 31 !== 0) {
      const lo = ~this.lo + 1 >>> 0;
      let hi = ~this.hi >>> 0;
      if (lo === 0) {
        hi = hi + 1 >>> 0;
      }
      return -(BigInt(lo) + (BigInt(hi) << 32n));
    }
    return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
  }
  /**
   * Returns these hi/lo bits as a Number - this may overflow, toBigInt
   * should be preferred
   */
  toNumber(unsigned2) {
    return Number(this.toBigInt(unsigned2));
  }
  /**
   * ZigZag decode a LongBits object
   */
  zzDecode() {
    const mask = -(this.lo & 1);
    const lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    const hi = (this.hi >>> 1 ^ mask) >>> 0;
    return new LongBits(hi, lo);
  }
  /**
   * ZigZag encode a LongBits object
   */
  zzEncode() {
    const mask = this.hi >> 31;
    const hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    const lo = (this.lo << 1 ^ mask) >>> 0;
    return new LongBits(hi, lo);
  }
  /**
   * Encode a LongBits object as a varint byte array
   */
  toBytes(buf2, offset = 0) {
    const access = accessor(buf2);
    while (this.hi > 0) {
      access.set(offset++, this.lo & 127 | 128);
      this.lo = (this.lo >>> 7 | this.hi << 25) >>> 0;
      this.hi >>>= 7;
    }
    while (this.lo > 127) {
      access.set(offset++, this.lo & 127 | 128);
      this.lo = this.lo >>> 7;
    }
    access.set(offset++, this.lo);
  }
  /**
   * Parse a LongBits object from a BigInt
   */
  static fromBigInt(value2) {
    if (value2 === 0n) {
      return new LongBits();
    }
    const negative = value2 < 0;
    if (negative) {
      value2 = -value2;
    }
    let hi = Number(value2 >> 32n) | 0;
    let lo = Number(value2 - (BigInt(hi) << 32n)) | 0;
    if (negative) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > TWO_32) {
        lo = 0;
        if (++hi > TWO_32) {
          hi = 0;
        }
      }
    }
    return new LongBits(hi, lo);
  }
  /**
   * Parse a LongBits object from a Number
   */
  static fromNumber(value2) {
    if (value2 === 0) {
      return new LongBits();
    }
    const sign4 = value2 < 0;
    if (sign4) {
      value2 = -value2;
    }
    let lo = value2 >>> 0;
    let hi = (value2 - lo) / 4294967296 >>> 0;
    if (sign4) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295) {
          hi = 0;
        }
      }
    }
    return new LongBits(hi, lo);
  }
  /**
   * Parse a LongBits object from a varint byte array
   */
  static fromBytes(buf2, offset = 0) {
    const access = accessor(buf2);
    const bits2 = new LongBits();
    let i2 = 0;
    if (buf2.length - offset > 4) {
      for (; i2 < 4; ++i2) {
        bits2.lo = (bits2.lo | (access.get(offset) & 127) << i2 * 7) >>> 0;
        if (access.get(offset++) < 128) {
          return bits2;
        }
      }
      bits2.lo = (bits2.lo | (access.get(offset) & 127) << 28) >>> 0;
      bits2.hi = (bits2.hi | (access.get(offset) & 127) >> 4) >>> 0;
      if (access.get(offset++) < 128) {
        return bits2;
      }
      i2 = 0;
    } else {
      for (; i2 < 4; ++i2) {
        if (offset >= buf2.length) {
          throw RangeError(`index out of range: ${offset} > ${buf2.length}`);
        }
        bits2.lo = (bits2.lo | (access.get(offset) & 127) << i2 * 7) >>> 0;
        if (access.get(offset++) < 128) {
          return bits2;
        }
      }
    }
    if (buf2.length - offset > 4) {
      for (; i2 < 5; ++i2) {
        bits2.hi = (bits2.hi | (access.get(offset) & 127) << i2 * 7 + 3) >>> 0;
        if (access.get(offset++) < 128) {
          return bits2;
        }
      }
    } else if (offset < buf2.byteLength) {
      for (; i2 < 5; ++i2) {
        if (offset >= buf2.length) {
          throw RangeError(`index out of range: ${offset} > ${buf2.length}`);
        }
        bits2.hi = (bits2.hi | (access.get(offset) & 127) << i2 * 7 + 3) >>> 0;
        if (access.get(offset++) < 128) {
          return bits2;
        }
      }
    }
    throw RangeError("invalid varint encoding");
  }
};
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var unsigned = {
  encodingLength(value2) {
    if (value2 < N1) {
      return 1;
    }
    if (value2 < N2) {
      return 2;
    }
    if (value2 < N3) {
      return 3;
    }
    if (value2 < N4) {
      return 4;
    }
    if (value2 < N5) {
      return 5;
    }
    if (value2 < N6) {
      return 6;
    }
    if (value2 < N7) {
      return 7;
    }
    if (value2 < N8) {
      return 8;
    }
    if (value2 < N9) {
      return 9;
    }
    return 10;
  },
  encode(value2, buf2, offset = 0) {
    if (Number.MAX_SAFE_INTEGER != null && value2 > Number.MAX_SAFE_INTEGER) {
      throw new RangeError("Could not encode varint");
    }
    if (buf2 == null) {
      buf2 = allocUnsafe(unsigned.encodingLength(value2));
    }
    LongBits.fromNumber(value2).toBytes(buf2, offset);
    return buf2;
  },
  decode(buf2, offset = 0) {
    return LongBits.fromBytes(buf2, offset).toNumber(true);
  }
};
var RecordEnvelope = class {
  /**
   * The Envelope is responsible for keeping an arbitrary signed record
   * by a libp2p peer.
   */
  constructor(init) {
    const { peerId, payloadType, payload, signature } = init;
    this.peerId = peerId;
    this.payloadType = payloadType;
    this.payload = payload;
    this.signature = signature;
  }
  /**
   * Marshal the envelope content
   */
  marshal() {
    if (this.peerId.publicKey == null) {
      throw new Error("Missing public key");
    }
    if (this.marshaled == null) {
      this.marshaled = Envelope2.encode({
        publicKey: this.peerId.publicKey,
        payloadType: this.payloadType,
        payload: this.payload.subarray(),
        signature: this.signature
      });
    }
    return this.marshaled;
  }
  /**
   * Verifies if the other Envelope is identical to this one
   */
  equals(other) {
    return equals(this.marshal(), other.marshal());
  }
  /**
   * Validate envelope data signature for the given domain
   */
  async validate(domain) {
    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
    if (this.peerId.publicKey == null) {
      throw new Error("Missing public key");
    }
    const key = unmarshalPublicKey2(this.peerId.publicKey);
    return await key.verify(signData.subarray(), this.signature);
  }
};
RecordEnvelope.createFromProtobuf = async (data) => {
  const envelopeData = Envelope2.decode(data);
  const peerId = await peerIdFromKeys(envelopeData.publicKey);
  return new RecordEnvelope({
    peerId,
    payloadType: envelopeData.payloadType,
    payload: envelopeData.payload,
    signature: envelopeData.signature
  });
};
RecordEnvelope.seal = async (record, peerId) => {
  if (peerId.privateKey == null) {
    throw new Error("Missing private key");
  }
  const domain = record.domain;
  const payloadType = record.codec;
  const payload = record.marshal();
  const signData = formatSignaturePayload(domain, payloadType, payload);
  const key = await unmarshalPrivateKey3(peerId.privateKey);
  const signature = await key.sign(signData.subarray());
  return new RecordEnvelope({
    peerId,
    payloadType,
    payload,
    signature
  });
};
RecordEnvelope.openAndCertify = async (data, domain) => {
  const envelope = await RecordEnvelope.createFromProtobuf(data);
  const valid = await envelope.validate(domain);
  if (!valid) {
    throw (0, import_err_code72.default)(new Error("envelope signature is not valid for the given domain"), codes2.ERR_SIGNATURE_NOT_VALID);
  }
  return envelope;
};
var formatSignaturePayload = (domain, payloadType, payload) => {
  const domainUint8Array = fromString3(domain);
  const domainLength = unsigned.encode(domainUint8Array.byteLength);
  const payloadTypeLength = unsigned.encode(payloadType.length);
  const payloadLength = unsigned.encode(payload.length);
  return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
};
function arrayEquals(a, b) {
  const sort2 = (a2, b2) => a2.toString().localeCompare(b2.toString());
  if (a.length !== b.length) {
    return false;
  }
  b.sort(sort2);
  return a.sort(sort2).every((item, index2) => b[index2].equals(item));
}
var PeerRecord2;
(function(PeerRecord4) {
  (function(AddressInfo2) {
    let _codec2;
    AddressInfo2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (opts.writeDefaults === true || obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.multiaddr);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader3, length3) => {
          const obj = {
            multiaddr: new Uint8Array(0)
          };
          const end = length3 == null ? reader3.len : reader3.pos + length3;
          while (reader3.pos < end) {
            const tag = reader3.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.multiaddr = reader3.bytes();
                break;
              default:
                reader3.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    AddressInfo2.encode = (obj) => {
      return encodeMessage(obj, AddressInfo2.codec());
    };
    AddressInfo2.decode = (buf2) => {
      return decodeMessage(buf2, AddressInfo2.codec());
    };
  })(PeerRecord4.AddressInfo || (PeerRecord4.AddressInfo = {}));
  let _codec;
  PeerRecord4.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.peerId != null && obj.peerId.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.peerId);
        }
        if (opts.writeDefaults === true || obj.seq !== 0n) {
          w.uint32(16);
          w.uint64(obj.seq);
        }
        if (obj.addresses != null) {
          for (const value2 of obj.addresses) {
            w.uint32(26);
            PeerRecord4.AddressInfo.codec().encode(value2, w, {
              writeDefaults: true
            });
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {
          peerId: new Uint8Array(0),
          seq: 0n,
          addresses: []
        };
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.peerId = reader3.bytes();
              break;
            case 2:
              obj.seq = reader3.uint64();
              break;
            case 3:
              obj.addresses.push(PeerRecord4.AddressInfo.codec().decode(reader3, reader3.uint32()));
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerRecord4.encode = (obj) => {
    return encodeMessage(obj, PeerRecord4.codec());
  };
  PeerRecord4.decode = (buf2) => {
    return decodeMessage(buf2, PeerRecord4.codec());
  };
})(PeerRecord2 || (PeerRecord2 = {}));
var ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
var ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);
var PeerRecord3 = class {
  constructor(init) {
    this.domain = PeerRecord3.DOMAIN;
    this.codec = PeerRecord3.CODEC;
    const { peerId, multiaddrs, seqNumber } = init;
    this.peerId = peerId;
    this.multiaddrs = multiaddrs ?? [];
    this.seqNumber = seqNumber ?? BigInt(Date.now());
  }
  /**
   * Marshal a record to be used in an envelope
   */
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = PeerRecord2.encode({
        peerId: this.peerId.toBytes(),
        seq: BigInt(this.seqNumber),
        addresses: this.multiaddrs.map((m) => ({
          multiaddr: m.bytes
        }))
      });
    }
    return this.marshaled;
  }
  /**
   * Returns true if `this` record equals the `other`
   */
  equals(other) {
    if (!(other instanceof PeerRecord3)) {
      return false;
    }
    if (!this.peerId.equals(other.peerId)) {
      return false;
    }
    if (this.seqNumber !== other.seqNumber) {
      return false;
    }
    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
      return false;
    }
    return true;
  }
};
PeerRecord3.createFromProtobuf = (buf2) => {
  const peerRecord = PeerRecord2.decode(buf2);
  const peerId = peerIdFromBytes(peerRecord.peerId);
  const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr));
  const seqNumber = peerRecord.seq;
  return new PeerRecord3({ peerId, multiaddrs, seqNumber });
};
PeerRecord3.DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;
PeerRecord3.CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;
var topologySymbol = Symbol.for("@libp2p/topology");
function isTopology(other) {
  return other != null && Boolean(other[topologySymbol]);
}
var noop2 = () => {
};
var TopologyImpl = class {
  constructor(init) {
    this.min = init.min ?? 0;
    this.max = init.max ?? Infinity;
    this.peers = /* @__PURE__ */ new Set();
    this.onConnect = init.onConnect ?? noop2;
    this.onDisconnect = init.onDisconnect ?? noop2;
  }
  get [Symbol.toStringTag]() {
    return topologySymbol.toString();
  }
  get [topologySymbol]() {
    return true;
  }
  async setRegistrar(registrar) {
    this.registrar = registrar;
  }
  /**
   * Notify about peer disconnected event
   */
  disconnect(peerId) {
    this.onDisconnect(peerId);
  }
};
function createTopology(init) {
  return new TopologyImpl(init);
}
var __classPrivateFieldGet4 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EventEmitter_listeners;
var EventEmitter2 = class extends EventTarget {
  constructor() {
    super(...arguments);
    _EventEmitter_listeners.set(this, /* @__PURE__ */ new Map());
  }
  listenerCount(type) {
    const listeners = __classPrivateFieldGet4(this, _EventEmitter_listeners, "f").get(type);
    if (listeners == null) {
      return 0;
    }
    return listeners.length;
  }
  addEventListener(type, listener, options) {
    super.addEventListener(type, listener, options);
    let list = __classPrivateFieldGet4(this, _EventEmitter_listeners, "f").get(type);
    if (list == null) {
      list = [];
      __classPrivateFieldGet4(this, _EventEmitter_listeners, "f").set(type, list);
    }
    list.push({
      callback: listener,
      once: (options !== true && options !== false && options?.once) ?? false
    });
  }
  removeEventListener(type, listener, options) {
    super.removeEventListener(type.toString(), listener ?? null, options);
    let list = __classPrivateFieldGet4(this, _EventEmitter_listeners, "f").get(type);
    if (list == null) {
      return;
    }
    list = list.filter(({ callback }) => callback !== listener);
    __classPrivateFieldGet4(this, _EventEmitter_listeners, "f").set(type, list);
  }
  dispatchEvent(event) {
    const result = super.dispatchEvent(event);
    let list = __classPrivateFieldGet4(this, _EventEmitter_listeners, "f").get(event.type);
    if (list == null) {
      return result;
    }
    list = list.filter(({ once }) => !once);
    __classPrivateFieldGet4(this, _EventEmitter_listeners, "f").set(event.type, list);
    return result;
  }
  safeDispatchEvent(type, detail) {
    return this.dispatchEvent(new CustomEvent2(type, detail));
  }
};
_EventEmitter_listeners = /* @__PURE__ */ new WeakMap();
var CustomEventPolyfill = class extends Event {
  constructor(message2, data) {
    super(message2, data);
    this.detail = data?.detail;
  }
};
var CustomEvent2 = globalThis.CustomEvent ?? CustomEventPolyfill;
var MessageCache = class {
  /**
   * Holds history of messages in timebounded history arrays
   */
  constructor(gossip, historyCapacity, msgIdToStrFn) {
    this.gossip = gossip;
    this.msgs = /* @__PURE__ */ new Map();
    this.history = [];
    this.notValidatedCount = 0;
    this.msgIdToStrFn = msgIdToStrFn;
    for (let i2 = 0; i2 < historyCapacity; i2++) {
      this.history[i2] = [];
    }
  }
  get size() {
    return this.msgs.size;
  }
  /**
   * Adds a message to the current window and the cache
   * Returns true if the message is not known and is inserted in the cache
   */
  put(messageId, msg, validated = false) {
    const { msgIdStr } = messageId;
    if (this.msgs.has(msgIdStr)) {
      return false;
    }
    this.msgs.set(msgIdStr, {
      message: msg,
      validated,
      originatingPeers: /* @__PURE__ */ new Set(),
      iwantCounts: /* @__PURE__ */ new Map()
    });
    this.history[0].push({ ...messageId, topic: msg.topic });
    if (!validated) {
      this.notValidatedCount++;
    }
    return true;
  }
  observeDuplicate(msgId2, fromPeerIdStr) {
    const entry = this.msgs.get(msgId2);
    if (entry && // if the message is already validated, we don't need to store extra peers sending us
    // duplicates as the message has already been forwarded
    !entry.validated) {
      entry.originatingPeers.add(fromPeerIdStr);
    }
  }
  /**
   * Retrieves a message from the cache by its ID, if it is still present
   */
  get(msgId2) {
    return this.msgs.get(this.msgIdToStrFn(msgId2))?.message;
  }
  /**
   * Increases the iwant count for the given message by one and returns the message together
   * with the iwant if the message exists.
   */
  getWithIWantCount(msgIdStr, p) {
    const msg = this.msgs.get(msgIdStr);
    if (!msg) {
      return null;
    }
    const count = (msg.iwantCounts.get(p) ?? 0) + 1;
    msg.iwantCounts.set(p, count);
    return { msg: msg.message, count };
  }
  /**
   * Retrieves a list of message IDs for a set of topics
   */
  getGossipIDs(topics) {
    const msgIdsByTopic = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < this.gossip; i2++) {
      this.history[i2].forEach((entry) => {
        const msg = this.msgs.get(entry.msgIdStr);
        if (msg && msg.validated && topics.has(entry.topic)) {
          let msgIds = msgIdsByTopic.get(entry.topic);
          if (!msgIds) {
            msgIds = [];
            msgIdsByTopic.set(entry.topic, msgIds);
          }
          msgIds.push(entry.msgId);
        }
      });
    }
    return msgIdsByTopic;
  }
  /**
   * Gets a message with msgId and tags it as validated.
   * This function also returns the known peers that have sent us this message. This is used to
   * prevent us sending redundant messages to peers who have already propagated it.
   */
  validate(msgId2) {
    const entry = this.msgs.get(msgId2);
    if (!entry) {
      return null;
    }
    if (!entry.validated) {
      this.notValidatedCount--;
    }
    const { message: message2, originatingPeers } = entry;
    entry.validated = true;
    entry.originatingPeers = /* @__PURE__ */ new Set();
    return { message: message2, originatingPeers };
  }
  /**
   * Shifts the current window, discarding messages older than this.history.length of the cache
   */
  shift() {
    const lastCacheEntries = this.history[this.history.length - 1];
    lastCacheEntries.forEach((cacheEntry) => {
      const entry = this.msgs.get(cacheEntry.msgIdStr);
      if (entry) {
        this.msgs.delete(cacheEntry.msgIdStr);
        if (!entry.validated) {
          this.notValidatedCount--;
        }
      }
    });
    this.history.pop();
    this.history.unshift([]);
  }
  remove(msgId2) {
    const entry = this.msgs.get(msgId2);
    if (!entry) {
      return null;
    }
    this.msgs.delete(msgId2);
    return entry;
  }
};
var import_rpc = __toESM(require_rpc3(), 1);
var { RPC } = import_rpc.default;
var second = 1e3;
var minute2 = 60 * second;
var FloodsubID = "/floodsub/1.0.0";
var GossipsubIDv10 = "/meshsub/1.0.0";
var GossipsubIDv11 = "/meshsub/1.1.0";
var GossipsubD = 6;
var GossipsubDlo = 4;
var GossipsubDhi = 12;
var GossipsubDscore = 4;
var GossipsubDout = 2;
var GossipsubHistoryLength = 5;
var GossipsubHistoryGossip = 3;
var GossipsubDlazy = 6;
var GossipsubGossipFactor = 0.25;
var GossipsubGossipRetransmission = 3;
var GossipsubHeartbeatInitialDelay = 100;
var GossipsubHeartbeatInterval = second;
var GossipsubFanoutTTL = minute2;
var GossipsubPrunePeers = 16;
var GossipsubPruneBackoff = minute2;
var GossipsubPruneBackoffTicks = 15;
var GossipsubDirectConnectTicks = 300;
var GossipsubDirectConnectInitialDelay = second;
var GossipsubOpportunisticGraftTicks = 60;
var GossipsubOpportunisticGraftPeers = 2;
var GossipsubGraftFloodThreshold = 10 * second;
var GossipsubMaxIHaveLength = 5e3;
var GossipsubMaxIHaveMessages = 10;
var GossipsubIWantFollowupTime = 3 * second;
var GossipsubSeenTTL = 2 * minute2;
var TimeCacheDuration = 120 * 1e3;
var ERR_TOPIC_VALIDATOR_REJECT = "ERR_TOPIC_VALIDATOR_REJECT";
var ERR_TOPIC_VALIDATOR_IGNORE = "ERR_TOPIC_VALIDATOR_IGNORE";
var ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE = 0;
var ACCEPT_FROM_WHITELIST_MAX_MESSAGES = 128;
var ACCEPT_FROM_WHITELIST_DURATION_MS = 1e3;
var DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS = 1e3;
function shuffle(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  const randInt = () => {
    return Math.floor(Math.random() * Math.floor(arr.length));
  };
  for (let i2 = 0; i2 < arr.length; i2++) {
    const j = randInt();
    const tmp = arr[i2];
    arr[i2] = arr[j];
    arr[j] = tmp;
  }
  return arr;
}
function messageIdToString(msgId2) {
  return toString3(msgId2, "base64");
}
var StrictSign = "StrictSign";
var StrictNoSign = "StrictNoSign";
var TopicValidatorResult;
(function(TopicValidatorResult2) {
  TopicValidatorResult2["Accept"] = "accept";
  TopicValidatorResult2["Ignore"] = "ignore";
  TopicValidatorResult2["Reject"] = "reject";
})(TopicValidatorResult || (TopicValidatorResult = {}));
var SignaturePolicy;
(function(SignaturePolicy2) {
  SignaturePolicy2["StrictSign"] = "StrictSign";
  SignaturePolicy2["StrictNoSign"] = "StrictNoSign";
})(SignaturePolicy || (SignaturePolicy = {}));
var PublishConfigType;
(function(PublishConfigType2) {
  PublishConfigType2[PublishConfigType2["Signing"] = 0] = "Signing";
  PublishConfigType2[PublishConfigType2["Anonymous"] = 1] = "Anonymous";
})(PublishConfigType || (PublishConfigType = {}));
var RejectReason;
(function(RejectReason2) {
  RejectReason2["Error"] = "error";
  RejectReason2["Ignore"] = "ignore";
  RejectReason2["Reject"] = "reject";
  RejectReason2["Blacklisted"] = "blacklisted";
})(RejectReason || (RejectReason = {}));
var ValidateError;
(function(ValidateError2) {
  ValidateError2["InvalidSignature"] = "invalid_signature";
  ValidateError2["InvalidSeqno"] = "invalid_seqno";
  ValidateError2["InvalidPeerId"] = "invalid_peerid";
  ValidateError2["SignaturePresent"] = "signature_present";
  ValidateError2["SeqnoPresent"] = "seqno_present";
  ValidateError2["FromPresent"] = "from_present";
  ValidateError2["TransformFailed"] = "transform_failed";
})(ValidateError || (ValidateError = {}));
var MessageStatus;
(function(MessageStatus2) {
  MessageStatus2["duplicate"] = "duplicate";
  MessageStatus2["invalid"] = "invalid";
  MessageStatus2["valid"] = "valid";
})(MessageStatus || (MessageStatus = {}));
function rejectReasonFromAcceptance(acceptance) {
  switch (acceptance) {
    case TopicValidatorResult.Ignore:
      return RejectReason.Ignore;
    case TopicValidatorResult.Reject:
      return RejectReason.Reject;
  }
}
async function getPublishConfigFromPeerId(signaturePolicy, peerId) {
  switch (signaturePolicy) {
    case StrictSign: {
      if (!peerId) {
        throw Error("Must provide PeerId");
      }
      if (peerId.privateKey == null) {
        throw Error("Cannot sign message, no private key present");
      }
      if (peerId.publicKey == null) {
        throw Error("Cannot sign message, no public key present");
      }
      const privateKey = await unmarshalPrivateKey3(peerId.privateKey);
      return {
        type: PublishConfigType.Signing,
        author: peerId,
        key: peerId.publicKey,
        privateKey
      };
    }
    case StrictNoSign:
      return {
        type: PublishConfigType.Anonymous
      };
    default:
      throw new Error(`Unknown signature policy "${signaturePolicy}"`);
  }
}
var ERR_INVALID_PEER_SCORE_PARAMS = "ERR_INVALID_PEER_SCORE_PARAMS";
var defaultPeerScoreParams = {
  topics: {},
  topicScoreCap: 10,
  appSpecificScore: () => 0,
  appSpecificWeight: 10,
  IPColocationFactorWeight: -5,
  IPColocationFactorThreshold: 10,
  IPColocationFactorWhitelist: /* @__PURE__ */ new Set(),
  behaviourPenaltyWeight: -10,
  behaviourPenaltyThreshold: 0,
  behaviourPenaltyDecay: 0.2,
  decayInterval: 1e3,
  decayToZero: 0.1,
  retainScore: 3600 * 1e3
};
var defaultTopicScoreParams = {
  topicWeight: 0.5,
  timeInMeshWeight: 1,
  timeInMeshQuantum: 1,
  timeInMeshCap: 3600,
  firstMessageDeliveriesWeight: 1,
  firstMessageDeliveriesDecay: 0.5,
  firstMessageDeliveriesCap: 2e3,
  meshMessageDeliveriesWeight: -1,
  meshMessageDeliveriesDecay: 0.5,
  meshMessageDeliveriesCap: 100,
  meshMessageDeliveriesThreshold: 20,
  meshMessageDeliveriesWindow: 10,
  meshMessageDeliveriesActivation: 5e3,
  meshFailurePenaltyWeight: -1,
  meshFailurePenaltyDecay: 0.5,
  invalidMessageDeliveriesWeight: -1,
  invalidMessageDeliveriesDecay: 0.3
};
function createPeerScoreParams(p = {}) {
  return {
    ...defaultPeerScoreParams,
    ...p,
    topics: p.topics ? Object.entries(p.topics).reduce((topics, [topic, topicScoreParams]) => {
      topics[topic] = createTopicScoreParams(topicScoreParams);
      return topics;
    }, {}) : {}
  };
}
function createTopicScoreParams(p = {}) {
  return {
    ...defaultTopicScoreParams,
    ...p
  };
}
function validatePeerScoreParams(p) {
  for (const [topic, params] of Object.entries(p.topics)) {
    try {
      validateTopicScoreParams(params);
    } catch (e) {
      throw new CodeError(`invalid score parameters for topic ${topic}: ${e.message}`, ERR_INVALID_PEER_SCORE_PARAMS);
    }
  }
  if (p.topicScoreCap < 0) {
    throw new CodeError("invalid topic score cap; must be positive (or 0 for no cap)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.appSpecificScore === null || p.appSpecificScore === void 0) {
    throw new CodeError("missing application specific score function", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.IPColocationFactorWeight > 0) {
    throw new CodeError("invalid IPColocationFactorWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.IPColocationFactorWeight !== 0 && p.IPColocationFactorThreshold < 1) {
    throw new CodeError("invalid IPColocationFactorThreshold; must be at least 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.behaviourPenaltyWeight > 0) {
    throw new CodeError("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.behaviourPenaltyWeight !== 0 && (p.behaviourPenaltyDecay <= 0 || p.behaviourPenaltyDecay >= 1)) {
    throw new CodeError("invalid BehaviourPenaltyDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.decayInterval < 1e3) {
    throw new CodeError("invalid DecayInterval; must be at least 1s", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.decayToZero <= 0 || p.decayToZero >= 1) {
    throw new CodeError("invalid DecayToZero; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
}
function validateTopicScoreParams(p) {
  if (p.topicWeight < 0) {
    throw new CodeError("invalid topic weight; must be >= 0", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshQuantum === 0) {
    throw new CodeError("invalid TimeInMeshQuantum; must be non zero", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshWeight < 0) {
    throw new CodeError("invalid TimeInMeshWeight; must be positive (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshWeight !== 0 && p.timeInMeshQuantum <= 0) {
    throw new CodeError("invalid TimeInMeshQuantum; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshWeight !== 0 && p.timeInMeshCap <= 0) {
    throw new CodeError("invalid TimeInMeshCap; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.firstMessageDeliveriesWeight < 0) {
    throw new CodeError("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.firstMessageDeliveriesWeight !== 0 && (p.firstMessageDeliveriesDecay <= 0 || p.firstMessageDeliveriesDecay >= 1)) {
    throw new CodeError("invalid FirstMessageDeliveriesDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.firstMessageDeliveriesWeight !== 0 && p.firstMessageDeliveriesCap <= 0) {
    throw new CodeError("invalid FirstMessageDeliveriesCap; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight > 0) {
    throw new CodeError("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && (p.meshMessageDeliveriesDecay <= 0 || p.meshMessageDeliveriesDecay >= 1)) {
    throw new CodeError("invalid MeshMessageDeliveriesDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesCap <= 0) {
    throw new CodeError("invalid MeshMessageDeliveriesCap; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesThreshold <= 0) {
    throw new CodeError("invalid MeshMessageDeliveriesThreshold; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWindow < 0) {
    throw new CodeError("invalid MeshMessageDeliveriesWindow; must be non-negative", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesActivation < 1e3) {
    throw new CodeError("invalid MeshMessageDeliveriesActivation; must be at least 1s", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshFailurePenaltyWeight > 0) {
    throw new CodeError("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshFailurePenaltyWeight !== 0 && (p.meshFailurePenaltyDecay <= 0 || p.meshFailurePenaltyDecay >= 1)) {
    throw new CodeError("invalid MeshFailurePenaltyDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.invalidMessageDeliveriesWeight > 0) {
    throw new CodeError("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.invalidMessageDeliveriesDecay <= 0 || p.invalidMessageDeliveriesDecay >= 1) {
    throw new CodeError("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
}
var defaultPeerScoreThresholds = {
  gossipThreshold: -10,
  publishThreshold: -50,
  graylistThreshold: -80,
  acceptPXThreshold: 10,
  opportunisticGraftThreshold: 20
};
function createPeerScoreThresholds(p = {}) {
  return {
    ...defaultPeerScoreThresholds,
    ...p
  };
}
function computeScore(peer, pstats, params, peerIPs) {
  let score = 0;
  Object.entries(pstats.topics).forEach(([topic, tstats]) => {
    const topicParams = params.topics[topic];
    if (topicParams === void 0) {
      return;
    }
    let topicScore = 0;
    if (tstats.inMesh) {
      let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;
      if (p1 > topicParams.timeInMeshCap) {
        p1 = topicParams.timeInMeshCap;
      }
      topicScore += p1 * topicParams.timeInMeshWeight;
    }
    let p2 = tstats.firstMessageDeliveries;
    if (p2 > topicParams.firstMessageDeliveriesCap) {
      p2 = topicParams.firstMessageDeliveriesCap;
    }
    topicScore += p2 * topicParams.firstMessageDeliveriesWeight;
    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
      const p3 = deficit * deficit;
      topicScore += p3 * topicParams.meshMessageDeliveriesWeight;
    }
    const p3b = tstats.meshFailurePenalty;
    topicScore += p3b * topicParams.meshFailurePenaltyWeight;
    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
    topicScore += p4 * topicParams.invalidMessageDeliveriesWeight;
    score += topicScore * topicParams.topicWeight;
  });
  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
    score = params.topicScoreCap;
  }
  const p5 = params.appSpecificScore(peer);
  score += p5 * params.appSpecificWeight;
  pstats.knownIPs.forEach((ip) => {
    if (params.IPColocationFactorWhitelist.has(ip)) {
      return;
    }
    const peersInIP = peerIPs.get(ip);
    const numPeersInIP = peersInIP ? peersInIP.size : 0;
    if (numPeersInIP > params.IPColocationFactorThreshold) {
      const surplus = numPeersInIP - params.IPColocationFactorThreshold;
      const p6 = surplus * surplus;
      score += p6 * params.IPColocationFactorWeight;
    }
  });
  if (pstats.behaviourPenalty > params.behaviourPenaltyThreshold) {
    const excess = pstats.behaviourPenalty - params.behaviourPenaltyThreshold;
    const p7 = excess * excess;
    score += p7 * params.behaviourPenaltyWeight;
  }
  return score;
}
var import_denque = __toESM(require_denque(), 1);
var DeliveryRecordStatus;
(function(DeliveryRecordStatus2) {
  DeliveryRecordStatus2[DeliveryRecordStatus2["unknown"] = 0] = "unknown";
  DeliveryRecordStatus2[DeliveryRecordStatus2["valid"] = 1] = "valid";
  DeliveryRecordStatus2[DeliveryRecordStatus2["invalid"] = 2] = "invalid";
  DeliveryRecordStatus2[DeliveryRecordStatus2["ignored"] = 3] = "ignored";
})(DeliveryRecordStatus || (DeliveryRecordStatus = {}));
var MessageDeliveries = class {
  constructor() {
    this.records = /* @__PURE__ */ new Map();
    this.queue = new import_denque.default();
  }
  ensureRecord(msgIdStr) {
    let drec = this.records.get(msgIdStr);
    if (drec) {
      return drec;
    }
    drec = {
      status: DeliveryRecordStatus.unknown,
      firstSeen: Date.now(),
      validated: 0,
      peers: /* @__PURE__ */ new Set()
    };
    this.records.set(msgIdStr, drec);
    const entry = {
      msgId: msgIdStr,
      expire: Date.now() + TimeCacheDuration
    };
    this.queue.push(entry);
    return drec;
  }
  gc() {
    const now = Date.now();
    let head = this.queue.peekFront();
    while (head && head.expire < now) {
      this.records.delete(head.msgId);
      this.queue.shift();
      head = this.queue.peekFront();
    }
  }
  clear() {
    this.records.clear();
    this.queue.clear();
  }
};
function removeItemsFromSet(superSet, ineed, cond = () => true) {
  const subset = /* @__PURE__ */ new Set();
  if (ineed <= 0)
    return subset;
  for (const id of superSet) {
    if (subset.size >= ineed)
      break;
    if (cond(id)) {
      subset.add(id);
      superSet.delete(id);
    }
  }
  return subset;
}
function removeFirstNItemsFromSet(superSet, ineed) {
  return removeItemsFromSet(superSet, ineed, () => true);
}
var MapDef = class extends Map {
  constructor(getDefault) {
    super();
    this.getDefault = getDefault;
  }
  getOrDefault(key) {
    let value2 = super.get(key);
    if (value2 === void 0) {
      value2 = this.getDefault();
      this.set(key, value2);
    }
    return value2;
  }
};
var log46 = logger("libp2p:gossipsub:score");
var PeerScore = class {
  constructor(params, metrics, opts) {
    this.params = params;
    this.metrics = metrics;
    this.peerStats = /* @__PURE__ */ new Map();
    this.peerIPs = new MapDef(() => /* @__PURE__ */ new Set());
    this.scoreCache = /* @__PURE__ */ new Map();
    this.deliveryRecords = new MessageDeliveries();
    validatePeerScoreParams(params);
    this.scoreCacheValidityMs = opts.scoreCacheValidityMs;
    this.computeScore = opts.computeScore ?? computeScore;
  }
  get size() {
    return this.peerStats.size;
  }
  /**
   * Start PeerScore instance
   */
  start() {
    if (this._backgroundInterval) {
      log46("Peer score already running");
      return;
    }
    this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval);
    log46("started");
  }
  /**
   * Stop PeerScore instance
   */
  stop() {
    if (!this._backgroundInterval) {
      log46("Peer score already stopped");
      return;
    }
    clearInterval(this._backgroundInterval);
    delete this._backgroundInterval;
    this.peerIPs.clear();
    this.peerStats.clear();
    this.deliveryRecords.clear();
    log46("stopped");
  }
  /**
   * Periodic maintenance
   */
  background() {
    this.refreshScores();
    this.deliveryRecords.gc();
  }
  dumpPeerScoreStats() {
    return Object.fromEntries(Array.from(this.peerStats.entries()).map(([peer, stats]) => [peer, stats]));
  }
  /**
   * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.
   */
  refreshScores() {
    const now = Date.now();
    const decayToZero = this.params.decayToZero;
    this.peerStats.forEach((pstats, id) => {
      if (!pstats.connected) {
        if (now > pstats.expire) {
          this.removeIPsForPeer(id, pstats.knownIPs);
          this.peerStats.delete(id);
          this.scoreCache.delete(id);
        }
        return;
      }
      Object.entries(pstats.topics).forEach(([topic, tstats]) => {
        const tparams = this.params.topics[topic];
        if (tparams === void 0) {
          return;
        }
        tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;
        if (tstats.firstMessageDeliveries < decayToZero) {
          tstats.firstMessageDeliveries = 0;
        }
        tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;
        if (tstats.meshMessageDeliveries < decayToZero) {
          tstats.meshMessageDeliveries = 0;
        }
        tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;
        if (tstats.meshFailurePenalty < decayToZero) {
          tstats.meshFailurePenalty = 0;
        }
        tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;
        if (tstats.invalidMessageDeliveries < decayToZero) {
          tstats.invalidMessageDeliveries = 0;
        }
        if (tstats.inMesh) {
          tstats.meshTime = now - tstats.graftTime;
          if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {
            tstats.meshMessageDeliveriesActive = true;
          }
        }
      });
      pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;
      if (pstats.behaviourPenalty < decayToZero) {
        pstats.behaviourPenalty = 0;
      }
    });
  }
  /**
   * Return the score for a peer
   */
  score(id) {
    this.metrics?.scoreFnCalls.inc();
    const pstats = this.peerStats.get(id);
    if (!pstats) {
      return 0;
    }
    const now = Date.now();
    const cacheEntry = this.scoreCache.get(id);
    if (cacheEntry && cacheEntry.cacheUntil > now) {
      return cacheEntry.score;
    }
    this.metrics?.scoreFnRuns.inc();
    const score = this.computeScore(id, pstats, this.params, this.peerIPs);
    const cacheUntil = now + this.scoreCacheValidityMs;
    if (cacheEntry) {
      this.metrics?.scoreCachedDelta.observe(Math.abs(score - cacheEntry.score));
      cacheEntry.score = score;
      cacheEntry.cacheUntil = cacheUntil;
    } else {
      this.scoreCache.set(id, { score, cacheUntil });
    }
    return score;
  }
  /**
   * Apply a behavioural penalty to a peer
   */
  addPenalty(id, penalty, penaltyLabel) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      pstats.behaviourPenalty += penalty;
      this.metrics?.onScorePenalty(penaltyLabel);
    }
  }
  addPeer(id) {
    const pstats = {
      connected: true,
      expire: 0,
      topics: {},
      knownIPs: /* @__PURE__ */ new Set(),
      behaviourPenalty: 0
    };
    this.peerStats.set(id, pstats);
  }
  /** Adds a new IP to a peer, if the peer is not known the update is ignored */
  addIP(id, ip) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      pstats.knownIPs.add(ip);
    }
    this.peerIPs.getOrDefault(ip).add(id);
  }
  /** Remove peer association with IP */
  removeIP(id, ip) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      pstats.knownIPs.delete(ip);
    }
    const peersWithIP = this.peerIPs.get(ip);
    if (peersWithIP) {
      peersWithIP.delete(id);
      if (peersWithIP.size === 0) {
        this.peerIPs.delete(ip);
      }
    }
  }
  removePeer(id) {
    const pstats = this.peerStats.get(id);
    if (!pstats) {
      return;
    }
    if (this.score(id) > 0) {
      this.removeIPsForPeer(id, pstats.knownIPs);
      this.peerStats.delete(id);
      return;
    }
    Object.entries(pstats.topics).forEach(([topic, tstats]) => {
      tstats.firstMessageDeliveries = 0;
      const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
      if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
        const deficit = threshold - tstats.meshMessageDeliveries;
        tstats.meshFailurePenalty += deficit * deficit;
      }
      tstats.inMesh = false;
      tstats.meshMessageDeliveriesActive = false;
    });
    pstats.connected = false;
    pstats.expire = Date.now() + this.params.retainScore;
  }
  /** Handles scoring functionality as a peer GRAFTs to a topic. */
  graft(id, topic) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        tstats.inMesh = true;
        tstats.graftTime = Date.now();
        tstats.meshTime = 0;
        tstats.meshMessageDeliveriesActive = false;
      }
    }
  }
  /** Handles scoring functionality as a peer PRUNEs from a topic. */
  prune(id, topic) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
        if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
          const deficit = threshold - tstats.meshMessageDeliveries;
          tstats.meshFailurePenalty += deficit * deficit;
        }
        tstats.meshMessageDeliveriesActive = false;
        tstats.inMesh = false;
      }
    }
  }
  validateMessage(msgIdStr) {
    this.deliveryRecords.ensureRecord(msgIdStr);
  }
  deliverMessage(from3, msgIdStr, topic) {
    this.markFirstMessageDelivery(from3, topic);
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    const now = Date.now();
    if (drec.status !== DeliveryRecordStatus.unknown) {
      log46("unexpected delivery: message from %s was first seen %s ago and has delivery status %s", from3, now - drec.firstSeen, DeliveryRecordStatus[drec.status]);
      return;
    }
    drec.status = DeliveryRecordStatus.valid;
    drec.validated = now;
    drec.peers.forEach((p) => {
      if (p !== from3.toString()) {
        this.markDuplicateMessageDelivery(p, topic);
      }
    });
  }
  /**
   * Similar to `rejectMessage` except does not require the message id or reason for an invalid message.
   */
  rejectInvalidMessage(from3, topic) {
    this.markInvalidMessageDelivery(from3, topic);
  }
  rejectMessage(from3, msgIdStr, topic, reason) {
    switch (reason) {
      case RejectReason.Error:
        this.markInvalidMessageDelivery(from3, topic);
        return;
      case RejectReason.Blacklisted:
        return;
    }
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    if (drec.status !== DeliveryRecordStatus.unknown) {
      log46("unexpected rejection: message from %s was first seen %s ago and has delivery status %d", from3, Date.now() - drec.firstSeen, DeliveryRecordStatus[drec.status]);
      return;
    }
    if (reason === RejectReason.Ignore) {
      drec.status = DeliveryRecordStatus.ignored;
      drec.peers.clear();
      return;
    }
    drec.status = DeliveryRecordStatus.invalid;
    this.markInvalidMessageDelivery(from3, topic);
    drec.peers.forEach((p) => {
      this.markInvalidMessageDelivery(p, topic);
    });
    drec.peers.clear();
  }
  duplicateMessage(from3, msgIdStr, topic) {
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    if (drec.peers.has(from3)) {
      return;
    }
    switch (drec.status) {
      case DeliveryRecordStatus.unknown:
        drec.peers.add(from3);
        break;
      case DeliveryRecordStatus.valid:
        drec.peers.add(from3);
        this.markDuplicateMessageDelivery(from3, topic, drec.validated);
        break;
      case DeliveryRecordStatus.invalid:
        this.markInvalidMessageDelivery(from3, topic);
        break;
      case DeliveryRecordStatus.ignored:
        break;
    }
  }
  /**
   * Increments the "invalid message deliveries" counter for all scored topics the message is published in.
   */
  markInvalidMessageDelivery(from3, topic) {
    const pstats = this.peerStats.get(from3);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        tstats.invalidMessageDeliveries += 1;
      }
    }
  }
  /**
   * Increments the "first message deliveries" counter for all scored topics the message is published in,
   * as well as the "mesh message deliveries" counter, if the peer is in the mesh for the topic.
   * Messages already known (with the seenCache) are counted with markDuplicateMessageDelivery()
   */
  markFirstMessageDelivery(from3, topic) {
    const pstats = this.peerStats.get(from3);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        let cap = this.params.topics[topic].firstMessageDeliveriesCap;
        tstats.firstMessageDeliveries = Math.min(cap, tstats.firstMessageDeliveries + 1);
        if (tstats.inMesh) {
          cap = this.params.topics[topic].meshMessageDeliveriesCap;
          tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
        }
      }
    }
  }
  /**
   * Increments the "mesh message deliveries" counter for messages we've seen before,
   * as long the message was received within the P3 window.
   */
  markDuplicateMessageDelivery(from3, topic, validatedTime) {
    const pstats = this.peerStats.get(from3);
    if (pstats) {
      const now = validatedTime !== void 0 ? Date.now() : 0;
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats && tstats.inMesh) {
        const tparams = this.params.topics[topic];
        if (validatedTime !== void 0) {
          const deliveryDelayMs = now - validatedTime;
          const isLateDelivery = deliveryDelayMs > tparams.meshMessageDeliveriesWindow;
          this.metrics?.onDuplicateMsgDelivery(topic, deliveryDelayMs, isLateDelivery);
          if (isLateDelivery) {
            return;
          }
        }
        const cap = tparams.meshMessageDeliveriesCap;
        tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
      }
    }
  }
  /**
   * Removes an IP list from the tracking list for a peer.
   */
  removeIPsForPeer(id, ipsToRemove) {
    for (const ipToRemove of ipsToRemove) {
      const peerSet = this.peerIPs.get(ipToRemove);
      if (peerSet) {
        peerSet.delete(id);
        if (peerSet.size === 0) {
          this.peerIPs.delete(ipToRemove);
        }
      }
    }
  }
  /**
   * Returns topic stats if they exist, otherwise if the supplied parameters score the
   * topic, inserts the default stats and returns a reference to those. If neither apply, returns None.
   */
  getPtopicStats(pstats, topic) {
    let topicStats = pstats.topics[topic];
    if (topicStats !== void 0) {
      return topicStats;
    }
    if (this.params.topics[topic] !== void 0) {
      topicStats = {
        inMesh: false,
        graftTime: 0,
        meshTime: 0,
        firstMessageDeliveries: 0,
        meshMessageDeliveries: 0,
        meshMessageDeliveriesActive: false,
        meshFailurePenalty: 0,
        invalidMessageDeliveries: 0
      };
      pstats.topics[topic] = topicStats;
      return topicStats;
    }
    return null;
  }
};
var IWantTracer = class {
  constructor(gossipsubIWantFollowupMs, msgIdToStrFn, metrics) {
    this.gossipsubIWantFollowupMs = gossipsubIWantFollowupMs;
    this.msgIdToStrFn = msgIdToStrFn;
    this.metrics = metrics;
    this.promises = /* @__PURE__ */ new Map();
    this.requestMsByMsg = /* @__PURE__ */ new Map();
    this.requestMsByMsgExpire = 10 * gossipsubIWantFollowupMs;
  }
  get size() {
    return this.promises.size;
  }
  get requestMsByMsgSize() {
    return this.requestMsByMsg.size;
  }
  /**
   * Track a promise to deliver a message from a list of msgIds we are requesting
   */
  addPromise(from3, msgIds) {
    const ix = Math.floor(Math.random() * msgIds.length);
    const msgId2 = msgIds[ix];
    const msgIdStr = this.msgIdToStrFn(msgId2);
    let expireByPeer = this.promises.get(msgIdStr);
    if (!expireByPeer) {
      expireByPeer = /* @__PURE__ */ new Map();
      this.promises.set(msgIdStr, expireByPeer);
    }
    const now = Date.now();
    if (!expireByPeer.has(from3)) {
      expireByPeer.set(from3, now + this.gossipsubIWantFollowupMs);
      if (this.metrics) {
        this.metrics.iwantPromiseStarted.inc(1);
        if (!this.requestMsByMsg.has(msgIdStr)) {
          this.requestMsByMsg.set(msgIdStr, now);
        }
      }
    }
  }
  /**
   * Returns the number of broken promises for each peer who didn't follow up on an IWANT request.
   *
   * This should be called not too often relative to the expire times, since it iterates over the whole data.
   */
  getBrokenPromises() {
    const now = Date.now();
    const result = /* @__PURE__ */ new Map();
    let brokenPromises = 0;
    this.promises.forEach((expireByPeer, msgId2) => {
      expireByPeer.forEach((expire, p) => {
        if (expire < now) {
          result.set(p, (result.get(p) ?? 0) + 1);
          expireByPeer.delete(p);
          brokenPromises++;
        }
      });
      if (!expireByPeer.size) {
        this.promises.delete(msgId2);
      }
    });
    this.metrics?.iwantPromiseBroken.inc(brokenPromises);
    return result;
  }
  /**
   * Someone delivered a message, stop tracking promises for it
   */
  deliverMessage(msgIdStr, isDuplicate = false) {
    this.trackMessage(msgIdStr);
    const expireByPeer = this.promises.get(msgIdStr);
    if (expireByPeer) {
      this.promises.delete(msgIdStr);
      if (this.metrics) {
        this.metrics.iwantPromiseResolved.inc(1);
        if (isDuplicate)
          this.metrics.iwantPromiseResolvedFromDuplicate.inc(1);
        this.metrics.iwantPromiseResolvedPeers.inc(expireByPeer.size);
      }
    }
  }
  /**
   * A message got rejected, so we can stop tracking promises and let the score penalty apply from invalid message delivery,
   * unless its an obviously invalid message.
   */
  rejectMessage(msgIdStr, reason) {
    this.trackMessage(msgIdStr);
    switch (reason) {
      case RejectReason.Error:
        return;
    }
    this.promises.delete(msgIdStr);
  }
  clear() {
    this.promises.clear();
  }
  prune() {
    const maxMs = Date.now() - this.requestMsByMsgExpire;
    let count = 0;
    for (const [k, v] of this.requestMsByMsg.entries()) {
      if (v < maxMs) {
        this.requestMsByMsg.delete(k);
        count++;
      } else {
        break;
      }
    }
    this.metrics?.iwantMessagePruned.inc(count);
  }
  trackMessage(msgIdStr) {
    if (this.metrics) {
      const requestMs = this.requestMsByMsg.get(msgIdStr);
      if (requestMs !== void 0) {
        this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - requestMs) / 1e3);
        this.requestMsByMsg.delete(msgIdStr);
      }
    }
  }
};
var SimpleTimeCache = class {
  constructor(opts) {
    this.entries = /* @__PURE__ */ new Map();
    this.validityMs = opts.validityMs;
  }
  get size() {
    return this.entries.size;
  }
  /** Returns true if there was a key collision and the entry is dropped */
  put(key, value2) {
    if (this.entries.has(key)) {
      return true;
    }
    this.entries.set(key, { value: value2, validUntilMs: Date.now() + this.validityMs });
    return false;
  }
  prune() {
    const now = Date.now();
    for (const [k, v] of this.entries.entries()) {
      if (v.validUntilMs < now) {
        this.entries.delete(k);
      } else {
        break;
      }
    }
  }
  has(key) {
    return this.entries.has(key);
  }
  get(key) {
    const value2 = this.entries.get(key);
    return value2 && value2.validUntilMs >= Date.now() ? value2.value : void 0;
  }
  clear() {
    this.entries.clear();
  }
};
var MessageSource;
(function(MessageSource2) {
  MessageSource2["forward"] = "forward";
  MessageSource2["publish"] = "publish";
})(MessageSource || (MessageSource = {}));
var InclusionReason;
(function(InclusionReason2) {
  InclusionReason2["Fanout"] = "fanout";
  InclusionReason2["Random"] = "random";
  InclusionReason2["Subscribed"] = "subscribed";
  InclusionReason2["Outbound"] = "outbound";
  InclusionReason2["NotEnough"] = "not_enough";
  InclusionReason2["Opportunistic"] = "opportunistic";
})(InclusionReason || (InclusionReason = {}));
var ChurnReason;
(function(ChurnReason2) {
  ChurnReason2["Dc"] = "disconnected";
  ChurnReason2["BadScore"] = "bad_score";
  ChurnReason2["Prune"] = "prune";
  ChurnReason2["Unsub"] = "unsubscribed";
  ChurnReason2["Excess"] = "excess";
})(ChurnReason || (ChurnReason = {}));
var ScorePenalty;
(function(ScorePenalty2) {
  ScorePenalty2["GraftBackoff"] = "graft_backoff";
  ScorePenalty2["BrokenPromise"] = "broken_promise";
  ScorePenalty2["MessageDeficit"] = "message_deficit";
  ScorePenalty2["IPColocation"] = "IP_colocation";
})(ScorePenalty || (ScorePenalty = {}));
var IHaveIgnoreReason;
(function(IHaveIgnoreReason2) {
  IHaveIgnoreReason2["LowScore"] = "low_score";
  IHaveIgnoreReason2["MaxIhave"] = "max_ihave";
  IHaveIgnoreReason2["MaxIasked"] = "max_iasked";
})(IHaveIgnoreReason || (IHaveIgnoreReason = {}));
var ScoreThreshold;
(function(ScoreThreshold2) {
  ScoreThreshold2["graylist"] = "graylist";
  ScoreThreshold2["publish"] = "publish";
  ScoreThreshold2["gossip"] = "gossip";
  ScoreThreshold2["mesh"] = "mesh";
})(ScoreThreshold || (ScoreThreshold = {}));
function getMetrics(register, topicStrToLabel, opts) {
  return {
    /* Metrics for static config */
    protocolsEnabled: register.gauge({
      name: "gossipsub_protocol",
      help: "Status of enabled protocols",
      labelNames: ["protocol"]
    }),
    /* Metrics per known topic */
    /** Status of our subscription to this topic. This metric allows analyzing other topic metrics
     *  filtered by our current subscription status.
     *  = rust-libp2p `topic_subscription_status` */
    topicSubscriptionStatus: register.gauge({
      name: "gossipsub_topic_subscription_status",
      help: "Status of our subscription to this topic",
      labelNames: ["topicStr"]
    }),
    /** Number of peers subscribed to each topic. This allows us to analyze a topic's behaviour
     * regardless of our subscription status. */
    topicPeersCount: register.gauge({
      name: "gossipsub_topic_peer_count",
      help: "Number of peers subscribed to each topic",
      labelNames: ["topicStr"]
    }),
    /* Metrics regarding mesh state */
    /** Number of peers in our mesh. This metric should be updated with the count of peers for a
     *  topic in the mesh regardless of inclusion and churn events.
     *  = rust-libp2p `mesh_peer_counts` */
    meshPeerCounts: register.gauge({
      name: "gossipsub_mesh_peer_count",
      help: "Number of peers in our mesh",
      labelNames: ["topicStr"]
    }),
    /** Number of times we include peers in a topic mesh for different reasons.
     *  = rust-libp2p `mesh_peer_inclusion_events` */
    meshPeerInclusionEvents: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_total",
      help: "Number of times we include peers in a topic mesh for different reasons",
      labelNames: ["topic", "reason"]
    }),
    /** Number of times we remove peers in a topic mesh for different reasons.
     *  = rust-libp2p `mesh_peer_churn_events` */
    meshPeerChurnEvents: register.gauge({
      name: "gossipsub_peer_churn_events_total",
      help: "Number of times we remove peers in a topic mesh for different reasons",
      labelNames: ["topic", "reason"]
    }),
    /* General Metrics */
    /** Gossipsub supports floodsub, gossipsub v1.0 and gossipsub v1.1. Peers are classified based
     *  on which protocol they support. This metric keeps track of the number of peers that are
     *  connected of each type. */
    peersPerProtocol: register.gauge({
      name: "gossipsub_peers_per_protocol_count",
      help: "Peers connected for each topic",
      labelNames: ["protocol"]
    }),
    /** The time it takes to complete one iteration of the heartbeat. */
    heartbeatDuration: register.histogram({
      name: "gossipsub_heartbeat_duration_seconds",
      help: "The time it takes to complete one iteration of the heartbeat",
      // Should take <10ms, over 1s it's a huge issue that needs debugging, since a heartbeat will be cancelled
      buckets: [0.01, 0.1, 1]
    }),
    /** Heartbeat run took longer than heartbeat interval so next is skipped */
    heartbeatSkipped: register.gauge({
      name: "gossipsub_heartbeat_skipped",
      help: "Heartbeat run took longer than heartbeat interval so next is skipped"
    }),
    /** Message validation results for each topic.
     *  Invalid == Reject?
     *  = rust-libp2p `invalid_messages`, `accepted_messages`, `ignored_messages`, `rejected_messages` */
    asyncValidationResult: register.gauge({
      name: "gossipsub_async_validation_result_total",
      help: "Message validation result for each topic",
      labelNames: ["topic", "acceptance"]
    }),
    /** When the user validates a message, it tries to re propagate it to its mesh peers. If the
     *  message expires from the memcache before it can be validated, we count this a cache miss
     *  and it is an indicator that the memcache size should be increased.
     *  = rust-libp2p `mcache_misses` */
    asyncValidationMcacheHit: register.gauge({
      name: "gossipsub_async_validation_mcache_hit_total",
      help: "Async validation result reported by the user layer",
      labelNames: ["hit"]
    }),
    // RPC outgoing. Track byte length + data structure sizes
    rpcRecvBytes: register.gauge({ name: "gossipsub_rpc_recv_bytes_total", help: "RPC recv" }),
    rpcRecvCount: register.gauge({ name: "gossipsub_rpc_recv_count_total", help: "RPC recv" }),
    rpcRecvSubscription: register.gauge({ name: "gossipsub_rpc_recv_subscription_total", help: "RPC recv" }),
    rpcRecvMessage: register.gauge({ name: "gossipsub_rpc_recv_message_total", help: "RPC recv" }),
    rpcRecvControl: register.gauge({ name: "gossipsub_rpc_recv_control_total", help: "RPC recv" }),
    rpcRecvIHave: register.gauge({ name: "gossipsub_rpc_recv_ihave_total", help: "RPC recv" }),
    rpcRecvIWant: register.gauge({ name: "gossipsub_rpc_recv_iwant_total", help: "RPC recv" }),
    rpcRecvGraft: register.gauge({ name: "gossipsub_rpc_recv_graft_total", help: "RPC recv" }),
    rpcRecvPrune: register.gauge({ name: "gossipsub_rpc_recv_prune_total", help: "RPC recv" }),
    /** Total count of RPC dropped because acceptFrom() == false */
    rpcRecvNotAccepted: register.gauge({
      name: "gossipsub_rpc_rcv_not_accepted_total",
      help: "Total count of RPC dropped because acceptFrom() == false"
    }),
    // RPC incoming. Track byte length + data structure sizes
    rpcSentBytes: register.gauge({ name: "gossipsub_rpc_sent_bytes_total", help: "RPC sent" }),
    rpcSentCount: register.gauge({ name: "gossipsub_rpc_sent_count_total", help: "RPC sent" }),
    rpcSentSubscription: register.gauge({ name: "gossipsub_rpc_sent_subscription_total", help: "RPC sent" }),
    rpcSentMessage: register.gauge({ name: "gossipsub_rpc_sent_message_total", help: "RPC sent" }),
    rpcSentControl: register.gauge({ name: "gossipsub_rpc_sent_control_total", help: "RPC sent" }),
    rpcSentIHave: register.gauge({ name: "gossipsub_rpc_sent_ihave_total", help: "RPC sent" }),
    rpcSentIWant: register.gauge({ name: "gossipsub_rpc_sent_iwant_total", help: "RPC sent" }),
    rpcSentGraft: register.gauge({ name: "gossipsub_rpc_sent_graft_total", help: "RPC sent" }),
    rpcSentPrune: register.gauge({ name: "gossipsub_rpc_sent_prune_total", help: "RPC sent" }),
    // publish message. Track peers sent to and bytes
    /** Total count of msg published by topic */
    msgPublishCount: register.gauge({
      name: "gossipsub_msg_publish_count_total",
      help: "Total count of msg published by topic",
      labelNames: ["topic"]
    }),
    /** Total count of peers that we publish a msg to */
    msgPublishPeers: register.gauge({
      name: "gossipsub_msg_publish_peers_total",
      help: "Total count of peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    /** Total count of peers (by group) that we publish a msg to */
    // NOTE: Do not use 'group' label since it's a generic already used by Prometheus to group instances
    msgPublishPeersByGroup: register.gauge({
      name: "gossipsub_msg_publish_peers_by_group",
      help: "Total count of peers (by group) that we publish a msg to",
      labelNames: ["topic", "peerGroup"]
    }),
    /** Total count of msg publish data.length bytes */
    msgPublishBytes: register.gauge({
      name: "gossipsub_msg_publish_bytes_total",
      help: "Total count of msg publish data.length bytes",
      labelNames: ["topic"]
    }),
    /** Total count of msg forwarded by topic */
    msgForwardCount: register.gauge({
      name: "gossipsub_msg_forward_count_total",
      help: "Total count of msg forwarded by topic",
      labelNames: ["topic"]
    }),
    /** Total count of peers that we forward a msg to */
    msgForwardPeers: register.gauge({
      name: "gossipsub_msg_forward_peers_total",
      help: "Total count of peers that we forward a msg to",
      labelNames: ["topic"]
    }),
    /** Total count of recv msgs before any validation */
    msgReceivedPreValidation: register.gauge({
      name: "gossipsub_msg_received_prevalidation_total",
      help: "Total count of recv msgs before any validation",
      labelNames: ["topic"]
    }),
    /** Tracks distribution of recv msgs by duplicate, invalid, valid */
    msgReceivedStatus: register.gauge({
      name: "gossipsub_msg_received_status_total",
      help: "Tracks distribution of recv msgs by duplicate, invalid, valid",
      labelNames: ["topic", "status"]
    }),
    /** Tracks specific reason of invalid */
    msgReceivedInvalid: register.gauge({
      name: "gossipsub_msg_received_invalid_total",
      help: "Tracks specific reason of invalid",
      labelNames: ["topic", "error"]
    }),
    /** Track duplicate message delivery time */
    duplicateMsgDeliveryDelay: register.histogram({
      name: "gossisub_duplicate_msg_delivery_delay_seconds",
      help: "Time since the 1st duplicated message validated",
      labelNames: ["topic"],
      buckets: [
        0.25 * opts.maxMeshMessageDeliveriesWindowSec,
        0.5 * opts.maxMeshMessageDeliveriesWindowSec,
        1 * opts.maxMeshMessageDeliveriesWindowSec,
        2 * opts.maxMeshMessageDeliveriesWindowSec,
        4 * opts.maxMeshMessageDeliveriesWindowSec
      ]
    }),
    /** Total count of late msg delivery total by topic */
    duplicateMsgLateDelivery: register.gauge({
      name: "gossisub_duplicate_msg_late_delivery_total",
      help: "Total count of late duplicate message delivery by topic, which triggers P3 penalty",
      labelNames: ["topic"]
    }),
    /* Metrics related to scoring */
    /** Total times score() is called */
    scoreFnCalls: register.gauge({
      name: "gossipsub_score_fn_calls_total",
      help: "Total times score() is called"
    }),
    /** Total times score() call actually computed computeScore(), no cache */
    scoreFnRuns: register.gauge({
      name: "gossipsub_score_fn_runs_total",
      help: "Total times score() call actually computed computeScore(), no cache"
    }),
    scoreCachedDelta: register.histogram({
      name: "gossipsub_score_cache_delta",
      help: "Delta of score between cached values that expired",
      buckets: [10, 100, 1e3]
    }),
    /** Current count of peers by score threshold */
    peersByScoreThreshold: register.gauge({
      name: "gossipsub_peers_by_score_threshold_count",
      help: "Current count of peers by score threshold",
      labelNames: ["threshold"]
    }),
    score: register.avgMinMax({
      name: "gossipsub_score",
      help: "Avg min max of gossip scores",
      labelNames: ["topic", "p"]
    }),
    /** Separate score weights */
    scoreWeights: register.avgMinMax({
      name: "gossipsub_score_weights",
      help: "Separate score weights",
      labelNames: ["topic", "p"]
    }),
    /** Histogram of the scores for each mesh topic. */
    // TODO: Not implemented
    scorePerMesh: register.avgMinMax({
      name: "gossipsub_score_per_mesh",
      help: "Histogram of the scores for each mesh topic",
      labelNames: ["topic"]
    }),
    /** A counter of the kind of penalties being applied to peers. */
    // TODO: Not fully implemented
    scoringPenalties: register.gauge({
      name: "gossipsub_scoring_penalties_total",
      help: "A counter of the kind of penalties being applied to peers",
      labelNames: ["penalty"]
    }),
    behaviourPenalty: register.histogram({
      name: "gossipsub_peer_stat_behaviour_penalty",
      help: "Current peer stat behaviour_penalty at each scrape",
      buckets: [
        0.25 * opts.behaviourPenaltyThreshold,
        0.5 * opts.behaviourPenaltyThreshold,
        1 * opts.behaviourPenaltyThreshold,
        2 * opts.behaviourPenaltyThreshold,
        4 * opts.behaviourPenaltyThreshold
      ]
    }),
    // TODO:
    // - iasked per peer (on heartbeat)
    // - when promise is resolved, track messages from promises
    /** Total received IHAVE messages that we ignore for some reason */
    ihaveRcvIgnored: register.gauge({
      name: "gossipsub_ihave_rcv_ignored_total",
      help: "Total received IHAVE messages that we ignore for some reason",
      labelNames: ["reason"]
    }),
    /** Total received IHAVE messages by topic */
    ihaveRcvMsgids: register.gauge({
      name: "gossipsub_ihave_rcv_msgids_total",
      help: "Total received IHAVE messages by topic",
      labelNames: ["topic"]
    }),
    /** Total messages per topic we don't have. Not actual requests.
     *  The number of times we have decided that an IWANT control message is required for this
     *  topic. A very high metric might indicate an underperforming network.
     *  = rust-libp2p `topic_iwant_msgs` */
    ihaveRcvNotSeenMsgids: register.gauge({
      name: "gossipsub_ihave_rcv_not_seen_msgids_total",
      help: "Total messages per topic we do not have, not actual requests",
      labelNames: ["topic"]
    }),
    /** Total received IWANT messages by topic */
    iwantRcvMsgids: register.gauge({
      name: "gossipsub_iwant_rcv_msgids_total",
      help: "Total received IWANT messages by topic",
      labelNames: ["topic"]
    }),
    /** Total requested messageIDs that we don't have */
    iwantRcvDonthaveMsgids: register.gauge({
      name: "gossipsub_iwant_rcv_dont_have_msgids_total",
      help: "Total requested messageIDs that we do not have"
    }),
    iwantPromiseStarted: register.gauge({
      name: "gossipsub_iwant_promise_sent_total",
      help: "Total count of started IWANT promises"
    }),
    /** Total count of resolved IWANT promises */
    iwantPromiseResolved: register.gauge({
      name: "gossipsub_iwant_promise_resolved_total",
      help: "Total count of resolved IWANT promises"
    }),
    /** Total count of resolved IWANT promises from duplicate messages */
    iwantPromiseResolvedFromDuplicate: register.gauge({
      name: "gossipsub_iwant_promise_resolved_from_duplicate_total",
      help: "Total count of resolved IWANT promises from duplicate messages"
    }),
    /** Total count of peers we have asked IWANT promises that are resolved */
    iwantPromiseResolvedPeers: register.gauge({
      name: "gossipsub_iwant_promise_resolved_peers",
      help: "Total count of peers we have asked IWANT promises that are resolved"
    }),
    iwantPromiseBroken: register.gauge({
      name: "gossipsub_iwant_promise_broken",
      help: "Total count of broken IWANT promises"
    }),
    iwantMessagePruned: register.gauge({
      name: "gossipsub_iwant_message_pruned",
      help: "Total count of pruned IWANT messages"
    }),
    /** Histogram of delivery time of resolved IWANT promises */
    iwantPromiseDeliveryTime: register.histogram({
      name: "gossipsub_iwant_promise_delivery_seconds",
      help: "Histogram of delivery time of resolved IWANT promises",
      buckets: [
        0.5 * opts.gossipPromiseExpireSec,
        1 * opts.gossipPromiseExpireSec,
        2 * opts.gossipPromiseExpireSec,
        4 * opts.gossipPromiseExpireSec
      ]
    }),
    /* Data structure sizes */
    /** Unbounded cache sizes */
    cacheSize: register.gauge({
      name: "gossipsub_cache_size",
      help: "Unbounded cache sizes",
      labelNames: ["cache"]
    }),
    /** Current mcache msg count */
    mcacheSize: register.gauge({
      name: "gossipsub_mcache_size",
      help: "Current mcache msg count"
    }),
    mcacheNotValidatedCount: register.gauge({
      name: "gossipsub_mcache_not_validated_count",
      help: "Current mcache msg count not validated"
    }),
    fastMsgIdCacheCollision: register.gauge({
      name: "gossipsub_fastmsgid_cache_collision_total",
      help: "Total count of key collisions on fastmsgid cache put"
    }),
    newConnectionCount: register.gauge({
      name: "gossipsub_new_connection_total",
      help: "Total new connection by status",
      labelNames: ["status"]
    }),
    topicStrToLabel,
    toTopic(topicStr) {
      return this.topicStrToLabel.get(topicStr) ?? topicStr;
    },
    /** We joined a topic */
    onJoin(topicStr) {
      this.topicSubscriptionStatus.set({ topicStr }, 1);
      this.meshPeerCounts.set({ topicStr }, 0);
    },
    /** We left a topic */
    onLeave(topicStr) {
      this.topicSubscriptionStatus.set({ topicStr }, 0);
      this.meshPeerCounts.set({ topicStr }, 0);
    },
    /** Register the inclusion of peers in our mesh due to some reason. */
    onAddToMesh(topicStr, reason, count) {
      const topic = this.toTopic(topicStr);
      this.meshPeerInclusionEvents.inc({ topic, reason }, count);
    },
    /** Register the removal of peers in our mesh due to some reason */
    // - remove_peer_from_mesh()
    // - heartbeat() Churn::BadScore
    // - heartbeat() Churn::Excess
    // - on_disconnect() Churn::Ds
    onRemoveFromMesh(topicStr, reason, count) {
      const topic = this.toTopic(topicStr);
      this.meshPeerChurnEvents.inc({ topic, reason }, count);
    },
    onReportValidationMcacheHit(hit) {
      this.asyncValidationMcacheHit.inc({ hit: hit ? "hit" : "miss" });
    },
    onReportValidation(topicStr, acceptance) {
      const topic = this.toTopic(topicStr);
      this.asyncValidationResult.inc({ topic, acceptance });
    },
    /**
     * - in handle_graft() Penalty::GraftBackoff
     * - in apply_iwant_penalties() Penalty::BrokenPromise
     * - in metric_score() P3 Penalty::MessageDeficit
     * - in metric_score() P6 Penalty::IPColocation
     */
    onScorePenalty(penalty) {
      this.scoringPenalties.inc({ penalty }, 1);
    },
    onIhaveRcv(topicStr, ihave, idonthave) {
      const topic = this.toTopic(topicStr);
      this.ihaveRcvMsgids.inc({ topic }, ihave);
      this.ihaveRcvNotSeenMsgids.inc({ topic }, idonthave);
    },
    onIwantRcv(iwantByTopic, iwantDonthave) {
      for (const [topicStr, iwant] of iwantByTopic) {
        const topic = this.toTopic(topicStr);
        this.iwantRcvMsgids.inc({ topic }, iwant);
      }
      this.iwantRcvDonthaveMsgids.inc(iwantDonthave);
    },
    onForwardMsg(topicStr, tosendCount) {
      const topic = this.toTopic(topicStr);
      this.msgForwardCount.inc({ topic }, 1);
      this.msgForwardPeers.inc({ topic }, tosendCount);
    },
    onPublishMsg(topicStr, tosendGroupCount, tosendCount, dataLen) {
      const topic = this.toTopic(topicStr);
      this.msgPublishCount.inc({ topic }, 1);
      this.msgPublishBytes.inc({ topic }, tosendCount * dataLen);
      this.msgPublishPeers.inc({ topic }, tosendCount);
      this.msgPublishPeersByGroup.inc({ topic, peerGroup: "direct" }, tosendGroupCount.direct);
      this.msgPublishPeersByGroup.inc({ topic, peerGroup: "floodsub" }, tosendGroupCount.floodsub);
      this.msgPublishPeersByGroup.inc({ topic, peerGroup: "mesh" }, tosendGroupCount.mesh);
      this.msgPublishPeersByGroup.inc({ topic, peerGroup: "fanout" }, tosendGroupCount.fanout);
    },
    onMsgRecvPreValidation(topicStr) {
      const topic = this.toTopic(topicStr);
      this.msgReceivedPreValidation.inc({ topic }, 1);
    },
    onMsgRecvResult(topicStr, status) {
      const topic = this.toTopic(topicStr);
      this.msgReceivedStatus.inc({ topic, status });
    },
    onMsgRecvInvalid(topicStr, reason) {
      const topic = this.toTopic(topicStr);
      const error = reason.reason === RejectReason.Error ? reason.error : reason.reason;
      this.msgReceivedInvalid.inc({ topic, error }, 1);
    },
    onDuplicateMsgDelivery(topicStr, deliveryDelayMs, isLateDelivery) {
      this.duplicateMsgDeliveryDelay.observe(deliveryDelayMs / 1e3);
      if (isLateDelivery) {
        const topic = this.toTopic(topicStr);
        this.duplicateMsgLateDelivery.inc({ topic }, 1);
      }
    },
    onRpcRecv(rpc, rpcBytes) {
      this.rpcRecvBytes.inc(rpcBytes);
      this.rpcRecvCount.inc(1);
      if (rpc.subscriptions)
        this.rpcRecvSubscription.inc(rpc.subscriptions.length);
      if (rpc.messages)
        this.rpcRecvMessage.inc(rpc.messages.length);
      if (rpc.control) {
        this.rpcRecvControl.inc(1);
        if (rpc.control.ihave)
          this.rpcRecvIHave.inc(rpc.control.ihave.length);
        if (rpc.control.iwant)
          this.rpcRecvIWant.inc(rpc.control.iwant.length);
        if (rpc.control.graft)
          this.rpcRecvGraft.inc(rpc.control.graft.length);
        if (rpc.control.prune)
          this.rpcRecvPrune.inc(rpc.control.prune.length);
      }
    },
    onRpcSent(rpc, rpcBytes) {
      this.rpcSentBytes.inc(rpcBytes);
      this.rpcSentCount.inc(1);
      if (rpc.subscriptions)
        this.rpcSentSubscription.inc(rpc.subscriptions.length);
      if (rpc.messages)
        this.rpcSentMessage.inc(rpc.messages.length);
      if (rpc.control) {
        const ihave = rpc.control.ihave?.length ?? 0;
        const iwant = rpc.control.iwant?.length ?? 0;
        const graft = rpc.control.graft?.length ?? 0;
        const prune = rpc.control.prune?.length ?? 0;
        if (ihave > 0)
          this.rpcSentIHave.inc(ihave);
        if (iwant > 0)
          this.rpcSentIWant.inc(iwant);
        if (graft > 0)
          this.rpcSentGraft.inc(graft);
        if (prune > 0)
          this.rpcSentPrune.inc(prune);
        if (ihave > 0 || iwant > 0 || graft > 0 || prune > 0)
          this.rpcSentControl.inc(1);
      }
    },
    registerScores(scores, scoreThresholds) {
      let graylist = 0;
      let publish = 0;
      let gossip = 0;
      let mesh = 0;
      for (const score of scores) {
        if (score >= scoreThresholds.graylistThreshold)
          graylist++;
        if (score >= scoreThresholds.publishThreshold)
          publish++;
        if (score >= scoreThresholds.gossipThreshold)
          gossip++;
        if (score >= 0)
          mesh++;
      }
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.graylist }, graylist);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.publish }, publish);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.gossip }, gossip);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.mesh }, mesh);
      this.score.set(scores);
    },
    registerScoreWeights(sw) {
      for (const [topic, wsTopic] of sw.byTopic) {
        this.scoreWeights.set({ topic, p: "p1" }, wsTopic.p1w);
        this.scoreWeights.set({ topic, p: "p2" }, wsTopic.p2w);
        this.scoreWeights.set({ topic, p: "p3" }, wsTopic.p3w);
        this.scoreWeights.set({ topic, p: "p3b" }, wsTopic.p3bw);
        this.scoreWeights.set({ topic, p: "p4" }, wsTopic.p4w);
      }
      this.scoreWeights.set({ p: "p5" }, sw.p5w);
      this.scoreWeights.set({ p: "p6" }, sw.p6w);
      this.scoreWeights.set({ p: "p7" }, sw.p7w);
    },
    registerScorePerMesh(mesh, scoreByPeer) {
      const peersPerTopicLabel = /* @__PURE__ */ new Map();
      mesh.forEach((peers, topicStr) => {
        const topicLabel = this.topicStrToLabel.get(topicStr) ?? "unknown";
        let peersInMesh = peersPerTopicLabel.get(topicLabel);
        if (!peersInMesh) {
          peersInMesh = /* @__PURE__ */ new Set();
          peersPerTopicLabel.set(topicLabel, peersInMesh);
        }
        peers.forEach((p) => peersInMesh?.add(p));
      });
      for (const [topic, peers] of peersPerTopicLabel) {
        const meshScores = [];
        peers.forEach((peer) => {
          meshScores.push(scoreByPeer.get(peer) ?? 0);
        });
        this.scorePerMesh.set({ topic }, meshScores);
      }
    }
  };
}
__toESM(require_aes(), 1);
__toESM(require_forge(), 1);
__toESM(require_err_code(), 1);
var import_pbkdf2 = __toESM(require_pbkdf2(), 1);
var import_util6 = __toESM(require_util(), 1);
var import_err_code74 = __toESM(require_err_code(), 1);
var hashName = {
  sha1: "sha1",
  "sha2-256": "sha256",
  "sha2-512": "sha512"
};
function pbkdf2(password, salt, iterations, keySize, hash3) {
  if (hash3 !== "sha1" && hash3 !== "sha2-256" && hash3 !== "sha2-512") {
    const types2 = Object.keys(hashName).join(" / ");
    throw (0, import_err_code74.default)(new Error(`Hash '${hash3}' is unknown or not supported. Must be ${types2}`), "ERR_UNSUPPORTED_HASH_TYPE");
  }
  const hasher = hashName[hash3];
  const dek = (0, import_pbkdf2.default)(password, salt, iterations, keySize, hasher);
  return import_util6.default.encode64(dek, null);
}
var SignPrefix = fromString3("libp2p-pubsub:");
async function buildRawMessage(publishConfig, topic, originalData, transformedData) {
  switch (publishConfig.type) {
    case PublishConfigType.Signing: {
      const rpcMsg = {
        from: publishConfig.author.toBytes(),
        data: transformedData,
        seqno: randomBytes$1(8),
        topic,
        signature: void 0,
        key: void 0
        // Exclude key field for signing
      };
      const bytes2 = concat([SignPrefix, RPC.Message.encode(rpcMsg).finish()]);
      rpcMsg.signature = await publishConfig.privateKey.sign(bytes2);
      rpcMsg.key = publishConfig.key;
      const msg = {
        type: "signed",
        from: publishConfig.author,
        data: originalData,
        sequenceNumber: BigInt(`0x${toString3(rpcMsg.seqno, "base16")}`),
        topic,
        signature: rpcMsg.signature,
        key: rpcMsg.key
      };
      return {
        raw: rpcMsg,
        msg
      };
    }
    case PublishConfigType.Anonymous: {
      return {
        raw: {
          from: void 0,
          data: transformedData,
          seqno: void 0,
          topic,
          signature: void 0,
          key: void 0
        },
        msg: {
          type: "unsigned",
          data: originalData,
          topic
        }
      };
    }
  }
}
async function validateToRawMessage(signaturePolicy, msg) {
  switch (signaturePolicy) {
    case StrictNoSign:
      if (msg.signature != null)
        return { valid: false, error: ValidateError.SignaturePresent };
      if (msg.seqno != null)
        return { valid: false, error: ValidateError.SeqnoPresent };
      if (msg.key != null)
        return { valid: false, error: ValidateError.FromPresent };
      return { valid: true, message: { type: "unsigned", topic: msg.topic, data: msg.data ?? new Uint8Array(0) } };
    case StrictSign: {
      if (msg.seqno == null)
        return { valid: false, error: ValidateError.InvalidSeqno };
      if (msg.seqno.length !== 8) {
        return { valid: false, error: ValidateError.InvalidSeqno };
      }
      if (msg.signature == null)
        return { valid: false, error: ValidateError.InvalidSignature };
      if (msg.from == null)
        return { valid: false, error: ValidateError.InvalidPeerId };
      let fromPeerId;
      try {
        fromPeerId = peerIdFromBytes(msg.from);
      } catch (e) {
        return { valid: false, error: ValidateError.InvalidPeerId };
      }
      let publicKey;
      if (msg.key) {
        publicKey = unmarshalPublicKey2(msg.key);
        if (fromPeerId.publicKey !== void 0 && !equals(publicKey.bytes, fromPeerId.publicKey)) {
          return { valid: false, error: ValidateError.InvalidPeerId };
        }
      } else {
        if (fromPeerId.publicKey == null) {
          return { valid: false, error: ValidateError.InvalidPeerId };
        }
        publicKey = unmarshalPublicKey2(fromPeerId.publicKey);
      }
      const rpcMsgPreSign = {
        from: msg.from,
        data: msg.data,
        seqno: msg.seqno,
        topic: msg.topic,
        signature: void 0,
        key: void 0
        // Exclude key field for signing
      };
      const bytes2 = concat([SignPrefix, RPC.Message.encode(rpcMsgPreSign).finish()]);
      if (!await publicKey.verify(bytes2, msg.signature)) {
        return { valid: false, error: ValidateError.InvalidSignature };
      }
      return {
        valid: true,
        message: {
          type: "signed",
          from: fromPeerId,
          data: msg.data ?? new Uint8Array(0),
          sequenceNumber: BigInt(`0x${toString3(msg.seqno, "base16")}`),
          topic: msg.topic,
          signature: msg.signature,
          key: msg.key ?? marshalPublicKey2(publicKey)
        }
      };
    }
  }
}
__toESM(require_err_code());
var msgId = (key, seqno) => {
  const seqnoBytes = fromString3(seqno.toString(16).padStart(16, "0"), "base16");
  const msgId2 = new Uint8Array(key.length + seqnoBytes.length);
  msgId2.set(key, 0);
  msgId2.set(seqnoBytes, key.length);
  return msgId2;
};
function msgIdFnStrictSign(msg) {
  if (msg.type !== "signed") {
    throw new Error("expected signed message type");
  }
  if (msg.sequenceNumber == null)
    throw Error("missing seqno field");
  return msgId(msg.from.toBytes(), msg.sequenceNumber);
}
async function msgIdFnStrictNoSign(msg) {
  return await sha256.encode(msg.data);
}
function computeScoreWeights(peer, pstats, params, peerIPs, topicStrToLabel) {
  let score = 0;
  const byTopic = /* @__PURE__ */ new Map();
  Object.entries(pstats.topics).forEach(([topic, tstats]) => {
    const topicLabel = topicStrToLabel.get(topic) ?? "unknown";
    const topicParams = params.topics[topic];
    if (topicParams === void 0) {
      return;
    }
    let topicScores = byTopic.get(topicLabel);
    if (!topicScores) {
      topicScores = {
        p1w: 0,
        p2w: 0,
        p3w: 0,
        p3bw: 0,
        p4w: 0
      };
      byTopic.set(topicLabel, topicScores);
    }
    let p1w = 0;
    let p2w = 0;
    let p3w = 0;
    let p3bw = 0;
    let p4w = 0;
    if (tstats.inMesh) {
      const p1 = Math.max(tstats.meshTime / topicParams.timeInMeshQuantum, topicParams.timeInMeshCap);
      p1w += p1 * topicParams.timeInMeshWeight;
    }
    let p2 = tstats.firstMessageDeliveries;
    if (p2 > topicParams.firstMessageDeliveriesCap) {
      p2 = topicParams.firstMessageDeliveriesCap;
    }
    p2w += p2 * topicParams.firstMessageDeliveriesWeight;
    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
      const p3 = deficit * deficit;
      p3w += p3 * topicParams.meshMessageDeliveriesWeight;
    }
    const p3b = tstats.meshFailurePenalty;
    p3bw += p3b * topicParams.meshFailurePenaltyWeight;
    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
    p4w += p4 * topicParams.invalidMessageDeliveriesWeight;
    score += (p1w + p2w + p3w + p3bw + p4w) * topicParams.topicWeight;
    topicScores.p1w += p1w;
    topicScores.p2w += p2w;
    topicScores.p3w += p3w;
    topicScores.p3bw += p3bw;
    topicScores.p4w += p4w;
  });
  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
    score = params.topicScoreCap;
    const capF = params.topicScoreCap / score;
    for (const ws of byTopic.values()) {
      ws.p1w *= capF;
      ws.p2w *= capF;
      ws.p3w *= capF;
      ws.p3bw *= capF;
      ws.p4w *= capF;
    }
  }
  let p5w = 0;
  let p6w = 0;
  let p7w = 0;
  const p5 = params.appSpecificScore(peer);
  p5w += p5 * params.appSpecificWeight;
  pstats.knownIPs.forEach((ip) => {
    if (params.IPColocationFactorWhitelist.has(ip)) {
      return;
    }
    const peersInIP = peerIPs.get(ip);
    const numPeersInIP = peersInIP ? peersInIP.size : 0;
    if (numPeersInIP > params.IPColocationFactorThreshold) {
      const surplus = numPeersInIP - params.IPColocationFactorThreshold;
      const p6 = surplus * surplus;
      p6w += p6 * params.IPColocationFactorWeight;
    }
  });
  const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty;
  p7w += p7 * params.behaviourPenaltyWeight;
  score += p5w + p6w + p7w;
  return {
    byTopic,
    p5w,
    p6w,
    p7w,
    score
  };
}
function computeAllPeersScoreWeights(peerIdStrs, peerStats, params, peerIPs, topicStrToLabel) {
  const sw = {
    byTopic: /* @__PURE__ */ new Map(),
    p5w: [],
    p6w: [],
    p7w: [],
    score: []
  };
  for (const peerIdStr of peerIdStrs) {
    const pstats = peerStats.get(peerIdStr);
    if (pstats) {
      const swPeer = computeScoreWeights(peerIdStr, pstats, params, peerIPs, topicStrToLabel);
      for (const [topic, swPeerTopic] of swPeer.byTopic) {
        let swTopic = sw.byTopic.get(topic);
        if (!swTopic) {
          swTopic = {
            p1w: [],
            p2w: [],
            p3w: [],
            p3bw: [],
            p4w: []
          };
          sw.byTopic.set(topic, swTopic);
        }
        swTopic.p1w.push(swPeerTopic.p1w);
        swTopic.p2w.push(swPeerTopic.p2w);
        swTopic.p3w.push(swPeerTopic.p3w);
        swTopic.p3bw.push(swPeerTopic.p3bw);
        swTopic.p4w.push(swPeerTopic.p4w);
      }
      sw.p5w.push(swPeer.p5w);
      sw.p6w.push(swPeer.p6w);
      sw.p7w.push(swPeer.p7w);
      sw.score.push(swPeer.score);
    } else {
      sw.p5w.push(0);
      sw.p6w.push(0);
      sw.p7w.push(0);
      sw.score.push(0);
    }
  }
  return sw;
}
var AbortError5 = class extends Error {
  constructor(message2, code8) {
    super(message2 ?? "The operation was aborted");
    this.type = "aborted";
    this.code = code8 ?? "ABORT_ERR";
  }
};
function getIterator(obj) {
  if (obj != null) {
    if (typeof obj[Symbol.iterator] === "function") {
      return obj[Symbol.iterator]();
    }
    if (typeof obj[Symbol.asyncIterator] === "function") {
      return obj[Symbol.asyncIterator]();
    }
    if (typeof obj.next === "function") {
      return obj;
    }
  }
  throw new Error("argument is not an iterator or iterable");
}
function abortableSource(source, signal, options) {
  const opts = options ?? {};
  const iterator = getIterator(source);
  async function* abortable() {
    let nextAbortHandler;
    const abortHandler = () => {
      if (nextAbortHandler != null)
        nextAbortHandler();
    };
    signal.addEventListener("abort", abortHandler);
    while (true) {
      let result;
      try {
        if (signal.aborted) {
          const { abortMessage, abortCode } = opts;
          throw new AbortError5(abortMessage, abortCode);
        }
        const abort = new Promise((resolve7, reject) => {
          nextAbortHandler = () => {
            const { abortMessage, abortCode } = opts;
            reject(new AbortError5(abortMessage, abortCode));
          };
        });
        result = await Promise.race([abort, iterator.next()]);
        nextAbortHandler = null;
      } catch (err2) {
        signal.removeEventListener("abort", abortHandler);
        const isKnownAborter = err2.type === "aborted" && signal.aborted;
        if (isKnownAborter && opts.onAbort != null) {
          await opts.onAbort(source);
        }
        if (typeof iterator.return === "function") {
          try {
            const p = iterator.return();
            if (p instanceof Promise) {
              p.catch((err3) => {
                if (opts.onReturnError != null) {
                  opts.onReturnError(err3);
                }
              });
            }
          } catch (err3) {
            if (opts.onReturnError != null) {
              opts.onReturnError(err3);
            }
          }
        }
        if (isKnownAborter && opts.returnOnAbort === true) {
          return;
        }
        throw err2;
      }
      if (result.done === true) {
        break;
      }
      yield result.value;
    }
    signal.removeEventListener("abort", abortHandler);
  }
  return abortable();
}
function abortableSink(sink, signal, options) {
  return (source) => sink(abortableSource(source, signal, options));
}
function abortableDuplex(duplex, signal, options) {
  return {
    sink: abortableSink(duplex.sink, signal, {
      ...options,
      onAbort: void 0
    }),
    source: abortableSource(duplex.source, signal, options)
  };
}
function allocUnsafe2(len) {
  if (globalThis?.Buffer?.allocUnsafe != null) {
    return globalThis.Buffer.allocUnsafe(len);
  }
  return new Uint8Array(len);
}
var defaultEncoder = (length3) => {
  const lengthLength = unsigned.encodingLength(length3);
  const lengthBuf = allocUnsafe2(lengthLength);
  unsigned.encode(length3, lengthBuf);
  defaultEncoder.bytes = lengthLength;
  return lengthBuf;
};
defaultEncoder.bytes = 0;
function encode15(options) {
  options = options ?? {};
  const encodeLength = options.lengthEncoder ?? defaultEncoder;
  const encoder2 = async function* (source) {
    for await (const chunk of source) {
      const length3 = encodeLength(chunk.byteLength);
      if (length3 instanceof Uint8Array) {
        yield length3;
      } else {
        yield* length3;
      }
      if (chunk instanceof Uint8Array) {
        yield chunk;
      } else {
        yield* chunk;
      }
    }
  };
  return encoder2;
}
encode15.single = (chunk, options) => {
  options = options ?? {};
  const encodeLength = options.lengthEncoder ?? defaultEncoder;
  return new Uint8ArrayList(encodeLength(chunk.byteLength), chunk);
};
var import_err_code76 = __toESM(require_err_code(), 1);
var MAX_LENGTH_LENGTH = 8;
var MAX_DATA_LENGTH = 1024 * 1024 * 4;
var ReadMode;
(function(ReadMode2) {
  ReadMode2[ReadMode2["LENGTH"] = 0] = "LENGTH";
  ReadMode2[ReadMode2["DATA"] = 1] = "DATA";
})(ReadMode || (ReadMode = {}));
var defaultDecoder = (buf2) => {
  const length3 = unsigned.decode(buf2);
  defaultDecoder.bytes = unsigned.encodingLength(length3);
  return length3;
};
defaultDecoder.bytes = 0;
function decode14(options) {
  const decoder = async function* (source) {
    const buffer2 = new Uint8ArrayList();
    let mode = ReadMode.LENGTH;
    let dataLength = -1;
    const lengthDecoder = options?.lengthDecoder ?? defaultDecoder;
    const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH;
    const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;
    for await (const buf2 of source) {
      buffer2.append(buf2);
      while (buffer2.byteLength > 0) {
        if (mode === ReadMode.LENGTH) {
          try {
            dataLength = lengthDecoder(buffer2);
            if (dataLength < 0) {
              throw (0, import_err_code76.default)(new Error("invalid message length"), "ERR_INVALID_MSG_LENGTH");
            }
            if (dataLength > maxDataLength) {
              throw (0, import_err_code76.default)(new Error("message length too long"), "ERR_MSG_DATA_TOO_LONG");
            }
            const dataLengthLength = lengthDecoder.bytes;
            buffer2.consume(dataLengthLength);
            if (options?.onLength != null) {
              options.onLength(dataLength);
            }
            mode = ReadMode.DATA;
          } catch (err2) {
            if (err2 instanceof RangeError) {
              if (buffer2.byteLength > maxLengthLength) {
                throw (0, import_err_code76.default)(new Error("message length length too long"), "ERR_MSG_LENGTH_TOO_LONG");
              }
              break;
            }
            throw err2;
          }
        }
        if (mode === ReadMode.DATA) {
          if (buffer2.byteLength < dataLength) {
            break;
          }
          const data = buffer2.sublist(0, dataLength);
          buffer2.consume(dataLength);
          if (options?.onData != null) {
            options.onData(data);
          }
          yield data;
          mode = ReadMode.LENGTH;
        }
      }
    }
    if (buffer2.byteLength > 0) {
      throw (0, import_err_code76.default)(new Error("unexpected end of input"), "ERR_UNEXPECTED_EOF");
    }
  };
  return decoder;
}
decode14.fromReader = (reader3, options) => {
  let byteLength2 = 1;
  const varByteSource = async function* () {
    while (true) {
      try {
        const { done, value: value2 } = await reader3.next(byteLength2);
        if (done === true) {
          return;
        }
        if (value2 != null) {
          yield value2;
        }
      } catch (err2) {
        if (err2.code === "ERR_UNDER_READ") {
          return { done: true, value: null };
        }
        throw err2;
      } finally {
        byteLength2 = 1;
      }
    }
  }();
  const onLength = (l) => {
    byteLength2 = l;
  };
  return decode14({
    ...options ?? {},
    onLength
  })(varByteSource);
};
var OutboundStream = class {
  constructor(rawStream, errCallback, opts) {
    this.rawStream = rawStream;
    this.pushable = pushable({ objectMode: false });
    this.closeController = new AbortController();
    this.maxBufferSize = opts.maxBufferSize ?? Infinity;
    pipe(abortableSource(this.pushable, this.closeController.signal, { returnOnAbort: true }), encode15(), this.rawStream).catch(errCallback);
  }
  get protocol() {
    return this.rawStream.stat.protocol;
  }
  push(data) {
    if (this.pushable.readableLength > this.maxBufferSize) {
      throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);
    }
    this.pushable.push(data);
  }
  close() {
    this.closeController.abort();
    this.pushable.return();
    this.rawStream.close();
  }
};
var InboundStream = class {
  constructor(rawStream, opts = {}) {
    this.rawStream = rawStream;
    this.closeController = new AbortController();
    this.source = abortableSource(pipe(this.rawStream, decode14(opts)), this.closeController.signal, {
      returnOnAbort: true
    });
  }
  close() {
    this.closeController.abort();
    this.rawStream.close();
  }
};
var import_minimal10 = __toESM(require_minimal4(), 1);
var defaultDecodeRpcLimits = {
  maxSubscriptions: Infinity,
  maxMessages: Infinity,
  maxIhaveMessageIDs: Infinity,
  maxIwantMessageIDs: Infinity,
  maxControlMessages: Infinity,
  maxPeerInfos: Infinity
};
function decodeRpc(bytes2, opts) {
  opts = { ...opts };
  const r = import_minimal10.default.Reader.create(bytes2);
  const l = bytes2.length;
  const c = l === void 0 ? r.len : r.pos + l;
  const m = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        if (!(m.subscriptions && m.subscriptions.length))
          m.subscriptions = [];
        if (m.subscriptions.length < opts.maxSubscriptions)
          m.subscriptions.push(decodeSubOpts(r, r.uint32()));
        else
          r.skipType(t & 7);
        break;
      case 2:
        if (!(m.messages && m.messages.length))
          m.messages = [];
        if (m.messages.length < opts.maxMessages)
          m.messages.push(decodeMessage2(r, r.uint32()));
        else
          r.skipType(t & 7);
        break;
      case 3:
        m.control = decodeControlMessage(r, r.uint32(), opts);
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m;
}
function decodeSubOpts(r, l) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        m.subscribe = r.bool();
        break;
      case 2:
        m.topic = r.string();
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m;
}
function decodeMessage2(r, l) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        m.from = r.bytes();
        break;
      case 2:
        m.data = r.bytes();
        break;
      case 3:
        m.seqno = r.bytes();
        break;
      case 4:
        m.topic = r.string();
        break;
      case 5:
        m.signature = r.bytes();
        break;
      case 6:
        m.key = r.bytes();
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  if (!m.topic)
    throw Error("missing required 'topic'");
  return m;
}
function decodeControlMessage(r, l, opts) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        if (!(m.ihave && m.ihave.length))
          m.ihave = [];
        if (m.ihave.length < opts.maxControlMessages)
          m.ihave.push(decodeControlIHave(r, r.uint32(), opts));
        else
          r.skipType(t & 7);
        break;
      case 2:
        if (!(m.iwant && m.iwant.length))
          m.iwant = [];
        if (m.iwant.length < opts.maxControlMessages)
          m.iwant.push(decodeControlIWant(r, r.uint32(), opts));
        else
          r.skipType(t & 7);
        break;
      case 3:
        if (!(m.graft && m.graft.length))
          m.graft = [];
        if (m.graft.length < opts.maxControlMessages)
          m.graft.push(decodeControlGraft(r, r.uint32()));
        else
          r.skipType(t & 7);
        break;
      case 4:
        if (!(m.prune && m.prune.length))
          m.prune = [];
        if (m.prune.length < opts.maxControlMessages)
          m.prune.push(decodeControlPrune(r, r.uint32(), opts));
        else
          r.skipType(t & 7);
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m;
}
function decodeControlIHave(r, l, opts) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        m.topicID = r.string();
        break;
      case 2:
        if (!(m.messageIDs && m.messageIDs.length))
          m.messageIDs = [];
        if (opts.maxIhaveMessageIDs-- > 0)
          m.messageIDs.push(r.bytes());
        else
          r.skipType(t & 7);
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m;
}
function decodeControlIWant(r, l, opts) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        if (!(m.messageIDs && m.messageIDs.length))
          m.messageIDs = [];
        if (opts.maxIwantMessageIDs-- > 0)
          m.messageIDs.push(r.bytes());
        else
          r.skipType(t & 7);
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m;
}
function decodeControlGraft(r, l) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        m.topicID = r.string();
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m;
}
function decodeControlPrune(r, l, opts) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        m.topicID = r.string();
        break;
      case 2:
        if (!(m.peers && m.peers.length))
          m.peers = [];
        if (opts.maxPeerInfos-- > 0)
          m.peers.push(decodePeerInfo(r, r.uint32()));
        else
          r.skipType(t & 7);
        break;
      case 3:
        m.backoff = r.uint64();
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m;
}
function decodePeerInfo(r, l) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        m.peerID = r.bytes();
        break;
      case 2:
        m.signedPeerRecord = r.bytes();
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m;
}
var Protocol;
(function(Protocol2) {
  Protocol2[Protocol2["ip4"] = 4] = "ip4";
  Protocol2[Protocol2["ip6"] = 41] = "ip6";
})(Protocol || (Protocol = {}));
function multiaddrToIPStr(multiaddr2) {
  for (const tuple of multiaddr2.tuples()) {
    switch (tuple[0]) {
      case Protocol.ip4:
      case Protocol.ip6:
        return convertToString(tuple[0], tuple[1]);
    }
  }
  return null;
}
var GossipStatusCode;
(function(GossipStatusCode2) {
  GossipStatusCode2[GossipStatusCode2["started"] = 0] = "started";
  GossipStatusCode2[GossipStatusCode2["stopped"] = 1] = "stopped";
})(GossipStatusCode || (GossipStatusCode = {}));
var GossipSub = class extends EventEmitter2 {
  constructor(components, options = {}) {
    super();
    this.multicodecs = [GossipsubIDv11, GossipsubIDv10];
    this.peers = /* @__PURE__ */ new Set();
    this.streamsInbound = /* @__PURE__ */ new Map();
    this.streamsOutbound = /* @__PURE__ */ new Map();
    this.outboundInflightQueue = pushable({ objectMode: true });
    this.direct = /* @__PURE__ */ new Set();
    this.floodsubPeers = /* @__PURE__ */ new Set();
    this.acceptFromWhitelist = /* @__PURE__ */ new Map();
    this.topics = /* @__PURE__ */ new Map();
    this.subscriptions = /* @__PURE__ */ new Set();
    this.mesh = /* @__PURE__ */ new Map();
    this.fanout = /* @__PURE__ */ new Map();
    this.fanoutLastpub = /* @__PURE__ */ new Map();
    this.gossip = /* @__PURE__ */ new Map();
    this.control = /* @__PURE__ */ new Map();
    this.peerhave = /* @__PURE__ */ new Map();
    this.iasked = /* @__PURE__ */ new Map();
    this.backoff = /* @__PURE__ */ new Map();
    this.outbound = /* @__PURE__ */ new Map();
    this.topicValidators = /* @__PURE__ */ new Map();
    this.heartbeatTicks = 0;
    this.directPeerInitial = null;
    this.status = { code: GossipStatusCode.stopped };
    this.heartbeatTimer = null;
    this.runHeartbeat = () => {
      const timer = this.metrics?.heartbeatDuration.startTimer();
      this.heartbeat().catch((err2) => {
        this.log("Error running heartbeat", err2);
      }).finally(() => {
        if (timer != null) {
          timer();
        }
        if (this.status.code === GossipStatusCode.started) {
          clearTimeout(this.status.heartbeatTimeout);
          let msToNextHeartbeat = this.opts.heartbeatInterval - (Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval;
          if (msToNextHeartbeat < this.opts.heartbeatInterval * 0.25) {
            msToNextHeartbeat += this.opts.heartbeatInterval;
            this.metrics?.heartbeatSkipped.inc();
          }
          this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, msToNextHeartbeat);
        }
      });
    };
    const opts = {
      fallbackToFloodsub: true,
      floodPublish: true,
      doPX: false,
      directPeers: [],
      D: GossipsubD,
      Dlo: GossipsubDlo,
      Dhi: GossipsubDhi,
      Dscore: GossipsubDscore,
      Dout: GossipsubDout,
      Dlazy: GossipsubDlazy,
      heartbeatInterval: GossipsubHeartbeatInterval,
      fanoutTTL: GossipsubFanoutTTL,
      mcacheLength: GossipsubHistoryLength,
      mcacheGossip: GossipsubHistoryGossip,
      seenTTL: GossipsubSeenTTL,
      gossipsubIWantFollowupMs: GossipsubIWantFollowupTime,
      prunePeers: GossipsubPrunePeers,
      pruneBackoff: GossipsubPruneBackoff,
      graftFloodThreshold: GossipsubGraftFloodThreshold,
      opportunisticGraftPeers: GossipsubOpportunisticGraftPeers,
      opportunisticGraftTicks: GossipsubOpportunisticGraftTicks,
      directConnectTicks: GossipsubDirectConnectTicks,
      ...options,
      scoreParams: createPeerScoreParams(options.scoreParams),
      scoreThresholds: createPeerScoreThresholds(options.scoreThresholds)
    };
    this.components = components;
    this.decodeRpcLimits = opts.decodeRpcLimits ?? defaultDecodeRpcLimits;
    this.globalSignaturePolicy = opts.globalSignaturePolicy ?? StrictSign;
    if (opts.fallbackToFloodsub) {
      this.multicodecs.push(FloodsubID);
    }
    this.log = logger(opts.debugName ?? "libp2p:gossipsub");
    this.opts = opts;
    this.direct = new Set(opts.directPeers.map((p) => p.id.toString()));
    this.seenCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
    this.publishedMessageIds = new SimpleTimeCache({ validityMs: opts.seenTTL });
    if (options.msgIdFn) {
      this.msgIdFn = options.msgIdFn;
    } else {
      switch (this.globalSignaturePolicy) {
        case StrictSign:
          this.msgIdFn = msgIdFnStrictSign;
          break;
        case StrictNoSign:
          this.msgIdFn = msgIdFnStrictNoSign;
          break;
      }
    }
    if (options.fastMsgIdFn) {
      this.fastMsgIdFn = options.fastMsgIdFn;
      this.fastMsgIdCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
    }
    this.msgIdToStrFn = options.msgIdToStrFn ?? messageIdToString;
    this.mcache = options.messageCache || new MessageCache(opts.mcacheGossip, opts.mcacheLength, this.msgIdToStrFn);
    if (options.dataTransform) {
      this.dataTransform = options.dataTransform;
    }
    if (options.metricsRegister) {
      if (!options.metricsTopicStrToLabel) {
        throw Error("Must set metricsTopicStrToLabel with metrics");
      }
      const maxMeshMessageDeliveriesWindowMs = Math.max(...Object.values(opts.scoreParams.topics).map((topicParam) => topicParam.meshMessageDeliveriesWindow), DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS);
      const metrics = getMetrics(options.metricsRegister, options.metricsTopicStrToLabel, {
        gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1e3,
        behaviourPenaltyThreshold: opts.scoreParams.behaviourPenaltyThreshold,
        maxMeshMessageDeliveriesWindowSec: maxMeshMessageDeliveriesWindowMs / 1e3
      });
      metrics.mcacheSize.addCollect(() => this.onScrapeMetrics(metrics));
      for (const protocol4 of this.multicodecs) {
        metrics.protocolsEnabled.set({ protocol: protocol4 }, 1);
      }
      this.metrics = metrics;
    } else {
      this.metrics = null;
    }
    this.gossipTracer = new IWantTracer(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics);
    this.score = new PeerScore(this.opts.scoreParams, this.metrics, {
      scoreCacheValidityMs: opts.heartbeatInterval
    });
    this.maxInboundStreams = options.maxInboundStreams;
    this.maxOutboundStreams = options.maxOutboundStreams;
    this.allowedTopics = opts.allowedTopics ? new Set(opts.allowedTopics) : null;
  }
  getPeers() {
    return [...this.peers.keys()].map((str) => peerIdFromString(str));
  }
  isStarted() {
    return this.status.code === GossipStatusCode.started;
  }
  // LIFECYCLE METHODS
  /**
   * Mounts the gossipsub protocol onto the libp2p node and sends our
   * our subscriptions to every peer connected
   */
  async start() {
    if (this.isStarted()) {
      return;
    }
    this.log("starting");
    this.publishConfig = await getPublishConfigFromPeerId(this.globalSignaturePolicy, this.components.peerId);
    this.outboundInflightQueue = pushable({ objectMode: true });
    pipe(this.outboundInflightQueue, async (source) => {
      for await (const { peerId, connection } of source) {
        await this.createOutboundStream(peerId, connection);
      }
    }).catch((e) => this.log.error("outbound inflight queue error", e));
    await Promise.all(this.opts.directPeers.map(async (p) => {
      await this.components.peerStore.addressBook.add(p.id, p.addrs);
    }));
    const registrar = this.components.registrar;
    await Promise.all(this.multicodecs.map((multicodec) => registrar.handle(multicodec, this.onIncomingStream.bind(this), {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams
    })));
    const topology = createTopology({
      onConnect: this.onPeerConnected.bind(this),
      onDisconnect: this.onPeerDisconnected.bind(this)
    });
    const registrarTopologyIds = await Promise.all(this.multicodecs.map((multicodec) => registrar.register(multicodec, topology)));
    const heartbeatTimeout = setTimeout(this.runHeartbeat, GossipsubHeartbeatInitialDelay);
    this.status = {
      code: GossipStatusCode.started,
      registrarTopologyIds,
      heartbeatTimeout,
      hearbeatStartMs: Date.now() + GossipsubHeartbeatInitialDelay
    };
    this.score.start();
    this.directPeerInitial = setTimeout(() => {
      Promise.resolve().then(async () => {
        await Promise.all(Array.from(this.direct).map(async (id) => await this.connect(id)));
      }).catch((err2) => {
        this.log(err2);
      });
    }, GossipsubDirectConnectInitialDelay);
    this.log("started");
  }
  /**
   * Unmounts the gossipsub protocol and shuts down every connection
   */
  async stop() {
    this.log("stopping");
    if (this.status.code !== GossipStatusCode.started) {
      return;
    }
    const { registrarTopologyIds } = this.status;
    this.status = { code: GossipStatusCode.stopped };
    const registrar = this.components.registrar;
    registrarTopologyIds.forEach((id) => registrar.unregister(id));
    this.outboundInflightQueue.end();
    for (const outboundStream of this.streamsOutbound.values()) {
      outboundStream.close();
    }
    this.streamsOutbound.clear();
    for (const inboundStream of this.streamsInbound.values()) {
      inboundStream.close();
    }
    this.streamsInbound.clear();
    this.peers.clear();
    this.subscriptions.clear();
    if (this.heartbeatTimer) {
      this.heartbeatTimer.cancel();
      this.heartbeatTimer = null;
    }
    this.score.stop();
    this.mesh.clear();
    this.fanout.clear();
    this.fanoutLastpub.clear();
    this.gossip.clear();
    this.control.clear();
    this.peerhave.clear();
    this.iasked.clear();
    this.backoff.clear();
    this.outbound.clear();
    this.gossipTracer.clear();
    this.seenCache.clear();
    if (this.fastMsgIdCache)
      this.fastMsgIdCache.clear();
    if (this.directPeerInitial)
      clearTimeout(this.directPeerInitial);
    this.log("stopped");
  }
  /** FOR DEBUG ONLY - Dump peer stats for all peers. Data is cloned, safe to mutate */
  dumpPeerScoreStats() {
    return this.score.dumpPeerScoreStats();
  }
  /**
   * On an inbound stream opened
   */
  onIncomingStream({ stream, connection }) {
    if (!this.isStarted()) {
      return;
    }
    const peerId = connection.remotePeer;
    this.addPeer(peerId, connection.stat.direction, connection.remoteAddr);
    this.createInboundStream(peerId, stream);
    this.outboundInflightQueue.push({ peerId, connection });
  }
  /**
   * Registrar notifies an established connection with pubsub protocol
   */
  onPeerConnected(peerId, connection) {
    this.metrics?.newConnectionCount.inc({ status: connection.stat.status });
    if (!this.isStarted() || connection.stat.status !== "OPEN") {
      return;
    }
    this.addPeer(peerId, connection.stat.direction, connection.remoteAddr);
    this.outboundInflightQueue.push({ peerId, connection });
  }
  /**
   * Registrar notifies a closing connection with pubsub protocol
   */
  onPeerDisconnected(peerId) {
    this.log("connection ended %p", peerId);
    this.removePeer(peerId);
  }
  async createOutboundStream(peerId, connection) {
    if (!this.isStarted()) {
      return;
    }
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      return;
    }
    if (this.streamsOutbound.has(id)) {
      return;
    }
    try {
      const stream = new OutboundStream(await connection.newStream(this.multicodecs), (e) => this.log.error("outbound pipe error", e), { maxBufferSize: this.opts.maxOutboundBufferSize });
      this.log("create outbound stream %p", peerId);
      this.streamsOutbound.set(id, stream);
      const protocol4 = stream.protocol;
      if (protocol4 === FloodsubID) {
        this.floodsubPeers.add(id);
      }
      this.metrics?.peersPerProtocol.inc({ protocol: protocol4 }, 1);
      if (this.subscriptions.size > 0) {
        this.log("send subscriptions to", id);
        this.sendSubscriptions(id, Array.from(this.subscriptions), true);
      }
    } catch (e) {
      this.log.error("createOutboundStream error", e);
    }
  }
  async createInboundStream(peerId, stream) {
    if (!this.isStarted()) {
      return;
    }
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      return;
    }
    const priorInboundStream = this.streamsInbound.get(id);
    if (priorInboundStream !== void 0) {
      this.log("replacing existing inbound steam %s", id);
      priorInboundStream.close();
    }
    this.log("create inbound stream %s", id);
    const inboundStream = new InboundStream(stream, { maxDataLength: this.opts.maxInboundDataLength });
    this.streamsInbound.set(id, inboundStream);
    this.pipePeerReadStream(peerId, inboundStream.source).catch((err2) => this.log(err2));
  }
  /**
   * Add a peer to the router
   */
  addPeer(peerId, direction, addr) {
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      this.log("new peer %p", peerId);
      this.peers.add(id);
      this.score.addPeer(id);
      const currentIP = multiaddrToIPStr(addr);
      if (currentIP !== null) {
        this.score.addIP(id, currentIP);
      } else {
        this.log("Added peer has no IP in current address %s %s", id, addr.toString());
      }
      if (!this.outbound.has(id)) {
        this.outbound.set(id, direction === "outbound");
      }
    }
  }
  /**
   * Removes a peer from the router
   */
  removePeer(peerId) {
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      return;
    }
    this.log("delete peer %p", peerId);
    this.peers.delete(id);
    const outboundStream = this.streamsOutbound.get(id);
    const inboundStream = this.streamsInbound.get(id);
    if (outboundStream) {
      this.metrics?.peersPerProtocol.inc({ protocol: outboundStream.protocol }, -1);
    }
    outboundStream?.close();
    inboundStream?.close();
    this.streamsOutbound.delete(id);
    this.streamsInbound.delete(id);
    for (const peers of this.topics.values()) {
      peers.delete(id);
    }
    for (const [topicStr, peers] of this.mesh) {
      if (peers.delete(id) === true) {
        this.metrics?.onRemoveFromMesh(topicStr, ChurnReason.Dc, 1);
      }
    }
    for (const peers of this.fanout.values()) {
      peers.delete(id);
    }
    this.floodsubPeers.delete(id);
    this.gossip.delete(id);
    this.control.delete(id);
    this.outbound.delete(id);
    this.score.removePeer(id);
    this.acceptFromWhitelist.delete(id);
  }
  // API METHODS
  get started() {
    return this.status.code === GossipStatusCode.started;
  }
  /**
   * Get a the peer-ids in a topic mesh
   */
  getMeshPeers(topic) {
    const peersInTopic = this.mesh.get(topic);
    return peersInTopic ? Array.from(peersInTopic) : [];
  }
  /**
   * Get a list of the peer-ids that are subscribed to one topic.
   */
  getSubscribers(topic) {
    const peersInTopic = this.topics.get(topic);
    return (peersInTopic ? Array.from(peersInTopic) : []).map((str) => peerIdFromString(str));
  }
  /**
   * Get the list of topics which the peer is subscribed to.
   */
  getTopics() {
    return Array.from(this.subscriptions);
  }
  // TODO: Reviewing Pubsub API
  // MESSAGE METHODS
  /**
   * Responsible for processing each RPC message received by other peers.
   */
  async pipePeerReadStream(peerId, stream) {
    try {
      await pipe(stream, async (source) => {
        for await (const data of source) {
          try {
            const rpcBytes = data.subarray();
            const rpc = decodeRpc(rpcBytes, this.decodeRpcLimits);
            this.metrics?.onRpcRecv(rpc, rpcBytes.length);
            if (this.opts.awaitRpcHandler) {
              await this.handleReceivedRpc(peerId, rpc);
            } else {
              this.handleReceivedRpc(peerId, rpc).catch((err2) => this.log(err2));
            }
          } catch (e) {
            this.log(e);
          }
        }
      });
    } catch (err2) {
      this.handlePeerReadStreamError(err2, peerId);
    }
  }
  /**
   * Handle error when read stream pipe throws, less of the functional use but more
   * to for testing purposes to spy on the error handling
   * */
  handlePeerReadStreamError(err2, peerId) {
    this.log.error(err2);
    this.onPeerDisconnected(peerId);
  }
  /**
   * Handles an rpc request from a peer
   */
  async handleReceivedRpc(from3, rpc) {
    if (!this.acceptFrom(from3.toString())) {
      this.log("received message from unacceptable peer %p", from3);
      this.metrics?.rpcRecvNotAccepted.inc();
      return;
    }
    this.log("rpc from %p", from3);
    if (rpc.subscriptions && rpc.subscriptions.length > 0) {
      const subscriptions = [];
      rpc.subscriptions.forEach((subOpt) => {
        const topic = subOpt.topic;
        const subscribe = subOpt.subscribe === true;
        if (topic != null) {
          if (this.allowedTopics && !this.allowedTopics.has(topic)) {
            return;
          }
          this.handleReceivedSubscription(from3, topic, subscribe);
          subscriptions.push({ topic, subscribe });
        }
      });
      this.dispatchEvent(new CustomEvent2("subscription-change", {
        detail: { peerId: from3, subscriptions }
      }));
    }
    if (rpc.messages) {
      for (const message2 of rpc.messages) {
        if (this.allowedTopics && !this.allowedTopics.has(message2.topic)) {
          continue;
        }
        const handleReceivedMessagePromise = this.handleReceivedMessage(from3, message2).catch((err2) => this.log(err2));
        if (this.opts.awaitRpcMessageHandler) {
          await handleReceivedMessagePromise;
        }
      }
    }
    if (rpc.control) {
      await this.handleControlMessage(from3.toString(), rpc.control);
    }
  }
  /**
   * Handles a subscription change from a peer
   */
  handleReceivedSubscription(from3, topic, subscribe) {
    this.log("subscription update from %p topic %s", from3, topic);
    let topicSet = this.topics.get(topic);
    if (topicSet == null) {
      topicSet = /* @__PURE__ */ new Set();
      this.topics.set(topic, topicSet);
    }
    if (subscribe) {
      topicSet.add(from3.toString());
    } else {
      topicSet.delete(from3.toString());
    }
  }
  /**
   * Handles a newly received message from an RPC.
   * May forward to all peers in the mesh.
   */
  async handleReceivedMessage(from3, rpcMsg) {
    this.metrics?.onMsgRecvPreValidation(rpcMsg.topic);
    const validationResult = await this.validateReceivedMessage(from3, rpcMsg);
    this.metrics?.onMsgRecvResult(rpcMsg.topic, validationResult.code);
    switch (validationResult.code) {
      case MessageStatus.duplicate:
        this.score.duplicateMessage(from3.toString(), validationResult.msgIdStr, rpcMsg.topic);
        this.gossipTracer.deliverMessage(validationResult.msgIdStr, true);
        this.mcache.observeDuplicate(validationResult.msgIdStr, from3.toString());
        return;
      case MessageStatus.invalid:
        if (validationResult.msgIdStr) {
          const msgIdStr = validationResult.msgIdStr;
          this.score.rejectMessage(from3.toString(), msgIdStr, rpcMsg.topic, validationResult.reason);
          this.gossipTracer.rejectMessage(msgIdStr, validationResult.reason);
        } else {
          this.score.rejectInvalidMessage(from3.toString(), rpcMsg.topic);
        }
        this.metrics?.onMsgRecvInvalid(rpcMsg.topic, validationResult);
        return;
      case MessageStatus.valid:
        this.score.validateMessage(validationResult.messageId.msgIdStr);
        this.gossipTracer.deliverMessage(validationResult.messageId.msgIdStr);
        this.mcache.put(validationResult.messageId, rpcMsg, !this.opts.asyncValidation);
        if (this.subscriptions.has(rpcMsg.topic)) {
          const isFromSelf = this.components.peerId.equals(from3);
          if (!isFromSelf || this.opts.emitSelf) {
            super.dispatchEvent(new CustomEvent2("gossipsub:message", {
              detail: {
                propagationSource: from3,
                msgId: validationResult.messageId.msgIdStr,
                msg: validationResult.msg
              }
            }));
            super.dispatchEvent(new CustomEvent2("message", { detail: validationResult.msg }));
          }
        }
        if (!this.opts.asyncValidation) {
          this.forwardMessage(validationResult.messageId.msgIdStr, rpcMsg, from3.toString());
        }
    }
  }
  /**
   * Handles a newly received message from an RPC.
   * May forward to all peers in the mesh.
   */
  async validateReceivedMessage(propagationSource, rpcMsg) {
    const fastMsgIdStr = this.fastMsgIdFn?.(rpcMsg);
    const msgIdCached = fastMsgIdStr !== void 0 ? this.fastMsgIdCache?.get(fastMsgIdStr) : void 0;
    if (msgIdCached) {
      return { code: MessageStatus.duplicate, msgIdStr: msgIdCached };
    }
    const validationResult = await validateToRawMessage(this.globalSignaturePolicy, rpcMsg);
    if (!validationResult.valid) {
      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: validationResult.error };
    }
    const msg = validationResult.message;
    try {
      if (this.dataTransform) {
        msg.data = this.dataTransform.inboundTransform(rpcMsg.topic, msg.data);
      }
    } catch (e) {
      this.log("Invalid message, transform failed", e);
      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: ValidateError.TransformFailed };
    }
    const msgId2 = await this.msgIdFn(msg);
    const msgIdStr = this.msgIdToStrFn(msgId2);
    const messageId = { msgId: msgId2, msgIdStr };
    if (fastMsgIdStr !== void 0 && this.fastMsgIdCache) {
      const collision = this.fastMsgIdCache.put(fastMsgIdStr, msgIdStr);
      if (collision) {
        this.metrics?.fastMsgIdCacheCollision.inc();
      }
    }
    if (this.seenCache.has(msgIdStr)) {
      return { code: MessageStatus.duplicate, msgIdStr };
    } else {
      this.seenCache.put(msgIdStr);
    }
    const topicValidator = this.topicValidators.get(rpcMsg.topic);
    if (topicValidator != null) {
      let acceptance;
      try {
        acceptance = await topicValidator(propagationSource, msg);
      } catch (e) {
        const errCode107 = e.code;
        if (errCode107 === ERR_TOPIC_VALIDATOR_IGNORE)
          acceptance = TopicValidatorResult.Ignore;
        if (errCode107 === ERR_TOPIC_VALIDATOR_REJECT)
          acceptance = TopicValidatorResult.Reject;
        else
          acceptance = TopicValidatorResult.Ignore;
      }
      if (acceptance !== TopicValidatorResult.Accept) {
        return { code: MessageStatus.invalid, reason: rejectReasonFromAcceptance(acceptance), msgIdStr };
      }
    }
    return { code: MessageStatus.valid, messageId, msg };
  }
  /**
   * Return score of a peer.
   */
  getScore(peerId) {
    return this.score.score(peerId);
  }
  /**
   * Send an rpc object to a peer with subscriptions
   */
  sendSubscriptions(toPeer, topics, subscribe) {
    this.sendRpc(toPeer, {
      subscriptions: topics.map((topic) => ({ topic, subscribe }))
    });
  }
  /**
   * Handles an rpc control message from a peer
   */
  async handleControlMessage(id, controlMsg) {
    if (controlMsg === void 0) {
      return;
    }
    const iwant = controlMsg.ihave ? this.handleIHave(id, controlMsg.ihave) : [];
    const ihave = controlMsg.iwant ? this.handleIWant(id, controlMsg.iwant) : [];
    const prune = controlMsg.graft ? await this.handleGraft(id, controlMsg.graft) : [];
    controlMsg.prune && await this.handlePrune(id, controlMsg.prune);
    if (!iwant.length && !ihave.length && !prune.length) {
      return;
    }
    this.sendRpc(id, { messages: ihave, control: { iwant, prune } });
  }
  /**
   * Whether to accept a message from a peer
   */
  acceptFrom(id) {
    if (this.direct.has(id)) {
      return true;
    }
    const now = Date.now();
    const entry = this.acceptFromWhitelist.get(id);
    if (entry && entry.messagesAccepted < ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {
      entry.messagesAccepted += 1;
      return true;
    }
    const score = this.score.score(id);
    if (score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {
      this.acceptFromWhitelist.set(id, {
        messagesAccepted: 0,
        acceptUntil: now + ACCEPT_FROM_WHITELIST_DURATION_MS
      });
    } else {
      this.acceptFromWhitelist.delete(id);
    }
    return score >= this.opts.scoreThresholds.graylistThreshold;
  }
  /**
   * Handles IHAVE messages
   */
  handleIHave(id, ihave) {
    if (!ihave.length) {
      return [];
    }
    const score = this.score.score(id);
    if (score < this.opts.scoreThresholds.gossipThreshold) {
      this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]", id, score);
      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.LowScore });
      return [];
    }
    const peerhave = (this.peerhave.get(id) ?? 0) + 1;
    this.peerhave.set(id, peerhave);
    if (peerhave > GossipsubMaxIHaveMessages) {
      this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring", id, peerhave);
      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIhave });
      return [];
    }
    const iasked = this.iasked.get(id) ?? 0;
    if (iasked >= GossipsubMaxIHaveLength) {
      this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring", id, iasked);
      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIasked });
      return [];
    }
    const iwant = /* @__PURE__ */ new Map();
    ihave.forEach(({ topicID, messageIDs }) => {
      if (!topicID || !messageIDs || !this.mesh.has(topicID)) {
        return;
      }
      let idonthave = 0;
      messageIDs.forEach((msgId2) => {
        const msgIdStr = this.msgIdToStrFn(msgId2);
        if (!this.seenCache.has(msgIdStr)) {
          iwant.set(msgIdStr, msgId2);
          idonthave++;
        }
      });
      this.metrics?.onIhaveRcv(topicID, messageIDs.length, idonthave);
    });
    if (!iwant.size) {
      return [];
    }
    let iask = iwant.size;
    if (iask + iasked > GossipsubMaxIHaveLength) {
      iask = GossipsubMaxIHaveLength - iasked;
    }
    this.log("IHAVE: Asking for %d out of %d messages from %s", iask, iwant.size, id);
    let iwantList = Array.from(iwant.values());
    shuffle(iwantList);
    iwantList = iwantList.slice(0, iask);
    this.iasked.set(id, iasked + iask);
    this.gossipTracer.addPromise(id, iwantList);
    return [
      {
        messageIDs: iwantList
      }
    ];
  }
  /**
   * Handles IWANT messages
   * Returns messages to send back to peer
   */
  handleIWant(id, iwant) {
    if (!iwant.length) {
      return [];
    }
    const score = this.score.score(id);
    if (score < this.opts.scoreThresholds.gossipThreshold) {
      this.log("IWANT: ignoring peer %s with score below threshold [score = %d]", id, score);
      return [];
    }
    const ihave = /* @__PURE__ */ new Map();
    const iwantByTopic = /* @__PURE__ */ new Map();
    let iwantDonthave = 0;
    iwant.forEach(({ messageIDs }) => {
      messageIDs && messageIDs.forEach((msgId2) => {
        const msgIdStr = this.msgIdToStrFn(msgId2);
        const entry = this.mcache.getWithIWantCount(msgIdStr, id);
        if (entry == null) {
          iwantDonthave++;
          return;
        }
        iwantByTopic.set(entry.msg.topic, 1 + (iwantByTopic.get(entry.msg.topic) ?? 0));
        if (entry.count > GossipsubGossipRetransmission) {
          this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request", id, msgId2);
          return;
        }
        ihave.set(msgIdStr, entry.msg);
      });
    });
    this.metrics?.onIwantRcv(iwantByTopic, iwantDonthave);
    if (!ihave.size) {
      this.log("IWANT: Could not provide any wanted messages to %s", id);
      return [];
    }
    this.log("IWANT: Sending %d messages to %s", ihave.size, id);
    return Array.from(ihave.values());
  }
  /**
   * Handles Graft messages
   */
  async handleGraft(id, graft) {
    const prune = [];
    const score = this.score.score(id);
    const now = Date.now();
    let doPX = this.opts.doPX;
    graft.forEach(({ topicID }) => {
      if (!topicID) {
        return;
      }
      const peersInMesh = this.mesh.get(topicID);
      if (!peersInMesh) {
        doPX = false;
        return;
      }
      if (peersInMesh.has(id)) {
        return;
      }
      if (this.direct.has(id)) {
        this.log("GRAFT: ignoring request from direct peer %s", id);
        prune.push(topicID);
        doPX = false;
        return;
      }
      const expire = this.backoff.get(topicID)?.get(id);
      if (typeof expire === "number" && now < expire) {
        this.log("GRAFT: ignoring backed off peer %s", id);
        this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
        doPX = false;
        const floodCutoff = expire + this.opts.graftFloodThreshold - this.opts.pruneBackoff;
        if (now < floodCutoff) {
          this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
        }
        this.addBackoff(id, topicID);
        prune.push(topicID);
        return;
      }
      if (score < 0) {
        this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s", id, score, topicID);
        prune.push(topicID);
        doPX = false;
        this.addBackoff(id, topicID);
        return;
      }
      if (peersInMesh.size >= this.opts.Dhi && !this.outbound.get(id)) {
        prune.push(topicID);
        this.addBackoff(id, topicID);
        return;
      }
      this.log("GRAFT: Add mesh link from %s in %s", id, topicID);
      this.score.graft(id, topicID);
      peersInMesh.add(id);
      this.metrics?.onAddToMesh(topicID, InclusionReason.Subscribed, 1);
    });
    if (!prune.length) {
      return [];
    }
    return await Promise.all(prune.map((topic) => this.makePrune(id, topic, doPX)));
  }
  /**
   * Handles Prune messages
   */
  async handlePrune(id, prune) {
    const score = this.score.score(id);
    for (const { topicID, backoff, peers } of prune) {
      if (topicID == null) {
        continue;
      }
      const peersInMesh = this.mesh.get(topicID);
      if (!peersInMesh) {
        return;
      }
      this.log("PRUNE: Remove mesh link to %s in %s", id, topicID);
      this.score.prune(id, topicID);
      if (peersInMesh.has(id)) {
        peersInMesh.delete(id);
        this.metrics?.onRemoveFromMesh(topicID, ChurnReason.Unsub, 1);
      }
      if (typeof backoff === "number" && backoff > 0) {
        this.doAddBackoff(id, topicID, backoff * 1e3);
      } else {
        this.addBackoff(id, topicID);
      }
      if (peers && peers.length) {
        if (score < this.opts.scoreThresholds.acceptPXThreshold) {
          this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]", id, score, topicID);
          continue;
        }
        await this.pxConnect(peers);
      }
    }
  }
  /**
   * Add standard backoff log for a peer in a topic
   */
  addBackoff(id, topic) {
    this.doAddBackoff(id, topic, this.opts.pruneBackoff);
  }
  /**
   * Add backoff expiry interval for a peer in a topic
   *
   * @param id
   * @param topic
   * @param interval - backoff duration in milliseconds
   */
  doAddBackoff(id, topic, interval) {
    let backoff = this.backoff.get(topic);
    if (!backoff) {
      backoff = /* @__PURE__ */ new Map();
      this.backoff.set(topic, backoff);
    }
    const expire = Date.now() + interval;
    const existingExpire = backoff.get(id) ?? 0;
    if (existingExpire < expire) {
      backoff.set(id, expire);
    }
  }
  /**
   * Apply penalties from broken IHAVE/IWANT promises
   */
  applyIwantPenalties() {
    this.gossipTracer.getBrokenPromises().forEach((count, p) => {
      this.log("peer %s didn't follow up in %d IWANT requests; adding penalty", p, count);
      this.score.addPenalty(p, count, ScorePenalty.BrokenPromise);
    });
  }
  /**
   * Clear expired backoff expiries
   */
  clearBackoff() {
    if (this.heartbeatTicks % GossipsubPruneBackoffTicks !== 0) {
      return;
    }
    const now = Date.now();
    this.backoff.forEach((backoff, topic) => {
      backoff.forEach((expire, id) => {
        if (expire < now) {
          backoff.delete(id);
        }
      });
      if (backoff.size === 0) {
        this.backoff.delete(topic);
      }
    });
  }
  /**
   * Maybe reconnect to direct peers
   */
  async directConnect() {
    const toconnect = [];
    this.direct.forEach((id) => {
      if (!this.streamsOutbound.has(id)) {
        toconnect.push(id);
      }
    });
    await Promise.all(toconnect.map(async (id) => await this.connect(id)));
  }
  /**
   * Maybe attempt connection given signed peer records
   */
  async pxConnect(peers) {
    if (peers.length > this.opts.prunePeers) {
      shuffle(peers);
      peers = peers.slice(0, this.opts.prunePeers);
    }
    const toconnect = [];
    await Promise.all(peers.map(async (pi) => {
      if (!pi.peerID) {
        return;
      }
      const p = peerIdFromBytes(pi.peerID).toString();
      if (this.peers.has(p)) {
        return;
      }
      if (!pi.signedPeerRecord) {
        toconnect.push(p);
        return;
      }
      try {
        const envelope = await RecordEnvelope.openAndCertify(pi.signedPeerRecord, "libp2p-peer-record");
        const eid = envelope.peerId;
        if (!envelope.peerId.equals(p)) {
          this.log("bogus peer record obtained through px: peer ID %p doesn't match expected peer %p", eid, p);
          return;
        }
        if (!await this.components.peerStore.addressBook.consumePeerRecord(envelope)) {
          this.log("bogus peer record obtained through px: could not add peer record to address book");
          return;
        }
        toconnect.push(p);
      } catch (e) {
        this.log("bogus peer record obtained through px: invalid signature or not a peer record");
      }
    }));
    if (!toconnect.length) {
      return;
    }
    await Promise.all(toconnect.map(async (id) => await this.connect(id)));
  }
  /**
   * Connect to a peer using the gossipsub protocol
   */
  async connect(id) {
    this.log("Initiating connection with %s", id);
    const peerId = peerIdFromString(id);
    const connection = await this.components.connectionManager.openConnection(peerId);
    for (const multicodec of this.multicodecs) {
      for (const topology of this.components.registrar.getTopologies(multicodec)) {
        topology.onConnect(peerId, connection);
      }
    }
  }
  /**
   * Subscribes to a topic
   */
  subscribe(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Pubsub has not started");
    }
    if (!this.subscriptions.has(topic)) {
      this.subscriptions.add(topic);
      for (const peerId of this.peers.keys()) {
        this.sendSubscriptions(peerId, [topic], true);
      }
    }
    this.join(topic);
  }
  /**
   * Unsubscribe to a topic
   */
  unsubscribe(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Pubsub is not started");
    }
    const wasSubscribed = this.subscriptions.delete(topic);
    this.log("unsubscribe from %s - am subscribed %s", topic, wasSubscribed);
    if (wasSubscribed) {
      for (const peerId of this.peers.keys()) {
        this.sendSubscriptions(peerId, [topic], false);
      }
    }
    this.leave(topic);
  }
  /**
   * Join topic
   */
  join(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Gossipsub has not started");
    }
    if (this.mesh.has(topic)) {
      return;
    }
    this.log("JOIN %s", topic);
    this.metrics?.onJoin(topic);
    const toAdd = /* @__PURE__ */ new Set();
    const fanoutPeers = this.fanout.get(topic);
    if (fanoutPeers) {
      this.fanout.delete(topic);
      this.fanoutLastpub.delete(topic);
      fanoutPeers.forEach((id) => {
        if (!this.direct.has(id) && this.score.score(id) >= 0) {
          toAdd.add(id);
        }
      });
      this.metrics?.onAddToMesh(topic, InclusionReason.Fanout, toAdd.size);
    }
    if (toAdd.size < this.opts.D) {
      const fanoutCount = toAdd.size;
      const newPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => (
        // filter direct peers and peers with negative score
        !toAdd.has(id) && !this.direct.has(id) && this.score.score(id) >= 0
      ));
      newPeers.forEach((peer) => {
        toAdd.add(peer);
      });
      this.metrics?.onAddToMesh(topic, InclusionReason.Random, toAdd.size - fanoutCount);
    }
    this.mesh.set(topic, toAdd);
    toAdd.forEach((id) => {
      this.log("JOIN: Add mesh link to %s in %s", id, topic);
      this.sendGraft(id, topic);
    });
  }
  /**
   * Leave topic
   */
  leave(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Gossipsub has not started");
    }
    this.log("LEAVE %s", topic);
    this.metrics?.onLeave(topic);
    const meshPeers = this.mesh.get(topic);
    if (meshPeers) {
      Promise.all(Array.from(meshPeers).map(async (id) => {
        this.log("LEAVE: Remove mesh link to %s in %s", id, topic);
        return await this.sendPrune(id, topic);
      })).catch((err2) => {
        this.log("Error sending prunes to mesh peers", err2);
      });
      this.mesh.delete(topic);
    }
  }
  selectPeersToForward(topic, propagationSource, excludePeers) {
    const tosend = /* @__PURE__ */ new Set();
    const peersInTopic = this.topics.get(topic);
    if (peersInTopic) {
      this.direct.forEach((peer) => {
        if (peersInTopic.has(peer) && propagationSource !== peer && !excludePeers?.has(peer)) {
          tosend.add(peer);
        }
      });
      this.floodsubPeers.forEach((peer) => {
        if (peersInTopic.has(peer) && propagationSource !== peer && !excludePeers?.has(peer) && this.score.score(peer) >= this.opts.scoreThresholds.publishThreshold) {
          tosend.add(peer);
        }
      });
    }
    const meshPeers = this.mesh.get(topic);
    if (meshPeers && meshPeers.size > 0) {
      meshPeers.forEach((peer) => {
        if (propagationSource !== peer && !excludePeers?.has(peer)) {
          tosend.add(peer);
        }
      });
    }
    return tosend;
  }
  selectPeersToPublish(topic) {
    const tosend = /* @__PURE__ */ new Set();
    const tosendCount = {
      direct: 0,
      floodsub: 0,
      mesh: 0,
      fanout: 0
    };
    const peersInTopic = this.topics.get(topic);
    if (peersInTopic) {
      if (this.opts.floodPublish) {
        peersInTopic.forEach((id) => {
          if (this.direct.has(id)) {
            tosend.add(id);
            tosendCount.direct++;
          } else if (this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
            tosend.add(id);
            tosendCount.floodsub++;
          }
        });
      } else {
        this.direct.forEach((id) => {
          if (peersInTopic.has(id)) {
            tosend.add(id);
            tosendCount.direct++;
          }
        });
        this.floodsubPeers.forEach((id) => {
          if (peersInTopic.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
            tosend.add(id);
            tosendCount.floodsub++;
          }
        });
        const meshPeers = this.mesh.get(topic);
        if (meshPeers && meshPeers.size > 0) {
          meshPeers.forEach((peer) => {
            tosend.add(peer);
            tosendCount.mesh++;
          });
        } else {
          const fanoutPeers = this.fanout.get(topic);
          if (fanoutPeers && fanoutPeers.size > 0) {
            fanoutPeers.forEach((peer) => {
              tosend.add(peer);
              tosendCount.fanout++;
            });
          } else {
            const newFanoutPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => {
              return this.score.score(id) >= this.opts.scoreThresholds.publishThreshold;
            });
            if (newFanoutPeers.size > 0) {
              this.fanout.set(topic, newFanoutPeers);
              newFanoutPeers.forEach((peer) => {
                tosend.add(peer);
                tosendCount.fanout++;
              });
            }
          }
          this.fanoutLastpub.set(topic, Date.now());
        }
      }
    }
    return { tosend, tosendCount };
  }
  /**
   * Forwards a message from our peers.
   *
   * For messages published by us (the app layer), this class uses `publish`
   */
  forwardMessage(msgIdStr, rawMsg, propagationSource, excludePeers) {
    if (propagationSource) {
      this.score.deliverMessage(propagationSource, msgIdStr, rawMsg.topic);
    }
    const tosend = this.selectPeersToForward(rawMsg.topic, propagationSource, excludePeers);
    tosend.forEach((id) => {
      this.sendRpc(id, { messages: [rawMsg] });
    });
    this.metrics?.onForwardMsg(rawMsg.topic, tosend.size);
  }
  /**
   * App layer publishes a message to peers, return number of peers this message is published to
   * Note: `async` due to crypto only if `StrictSign`, otherwise it's a sync fn.
   *
   * For messages not from us, this class uses `forwardMessage`.
   */
  async publish(topic, data, opts) {
    const transformedData = this.dataTransform ? this.dataTransform.outboundTransform(topic, data) : data;
    if (this.publishConfig == null) {
      throw Error("PublishError.Uninitialized");
    }
    const { raw: rawMsg, msg } = await buildRawMessage(this.publishConfig, topic, data, transformedData);
    const msgId2 = await this.msgIdFn(msg);
    const msgIdStr = this.msgIdToStrFn(msgId2);
    if (this.seenCache.has(msgIdStr)) {
      throw Error("PublishError.Duplicate");
    }
    const { tosend, tosendCount } = this.selectPeersToPublish(topic);
    const willSendToSelf = this.opts.emitSelf === true && this.subscriptions.has(topic);
    const allowPublishToZeroPeers = opts?.allowPublishToZeroPeers ?? this.opts.allowPublishToZeroPeers;
    if (tosend.size === 0 && !allowPublishToZeroPeers && !willSendToSelf) {
      throw Error("PublishError.InsufficientPeers");
    }
    this.seenCache.put(msgIdStr);
    this.mcache.put({ msgId: msgId2, msgIdStr }, rawMsg, true);
    this.publishedMessageIds.put(msgIdStr);
    for (const id of tosend) {
      const sent = this.sendRpc(id, { messages: [rawMsg] });
      if (!sent) {
        tosend.delete(id);
      }
    }
    this.metrics?.onPublishMsg(topic, tosendCount, tosend.size, rawMsg.data != null ? rawMsg.data.length : 0);
    if (willSendToSelf) {
      tosend.add(this.components.peerId.toString());
      super.dispatchEvent(new CustomEvent2("gossipsub:message", {
        detail: {
          propagationSource: this.components.peerId,
          msgId: msgIdStr,
          msg
        }
      }));
      super.dispatchEvent(new CustomEvent2("message", { detail: msg }));
    }
    return {
      recipients: Array.from(tosend.values()).map((str) => peerIdFromString(str))
    };
  }
  /**
   * This function should be called when `asyncValidation` is `true` after
   * the message got validated by the caller. Messages are stored in the `mcache` and
   * validation is expected to be fast enough that the messages should still exist in the cache.
   * There are three possible validation outcomes and the outcome is given in acceptance.
   *
   * If acceptance = `MessageAcceptance.Accept` the message will get propagated to the
   * network. The `propagation_source` parameter indicates who the message was received by and
   * will not be forwarded back to that peer.
   *
   * If acceptance = `MessageAcceptance.Reject` the message will be deleted from the memcache
   * and the P₄ penalty will be applied to the `propagationSource`.
   *
   * If acceptance = `MessageAcceptance.Ignore` the message will be deleted from the memcache
   * but no P₄ penalty will be applied.
   *
   * This function will return true if the message was found in the cache and false if was not
   * in the cache anymore.
   *
   * This should only be called once per message.
   */
  reportMessageValidationResult(msgId2, propagationSource, acceptance) {
    if (acceptance === TopicValidatorResult.Accept) {
      const cacheEntry = this.mcache.validate(msgId2);
      this.metrics?.onReportValidationMcacheHit(cacheEntry !== null);
      if (cacheEntry != null) {
        const { message: rawMsg, originatingPeers } = cacheEntry;
        this.score.deliverMessage(propagationSource.toString(), msgId2, rawMsg.topic);
        this.forwardMessage(msgId2, cacheEntry.message, propagationSource.toString(), originatingPeers);
        this.metrics?.onReportValidation(rawMsg.topic, acceptance);
      }
    } else {
      const cacheEntry = this.mcache.remove(msgId2);
      this.metrics?.onReportValidationMcacheHit(cacheEntry !== null);
      if (cacheEntry) {
        const rejectReason = rejectReasonFromAcceptance(acceptance);
        const { message: rawMsg, originatingPeers } = cacheEntry;
        this.score.rejectMessage(propagationSource.toString(), msgId2, rawMsg.topic, rejectReason);
        for (const peer of originatingPeers) {
          this.score.rejectMessage(peer, msgId2, rawMsg.topic, rejectReason);
        }
        this.metrics?.onReportValidation(rawMsg.topic, acceptance);
      }
    }
  }
  /**
   * Sends a GRAFT message to a peer
   */
  sendGraft(id, topic) {
    const graft = [
      {
        topicID: topic
      }
    ];
    this.sendRpc(id, { control: { graft } });
  }
  /**
   * Sends a PRUNE message to a peer
   */
  async sendPrune(id, topic) {
    const prune = [await this.makePrune(id, topic, this.opts.doPX)];
    this.sendRpc(id, { control: { prune } });
  }
  /**
   * Send an rpc object to a peer
   */
  sendRpc(id, rpc) {
    const outboundStream = this.streamsOutbound.get(id);
    if (!outboundStream) {
      this.log(`Cannot send RPC to ${id} as there is no open stream to it available`);
      return false;
    }
    const ctrl = this.control.get(id);
    if (ctrl) {
      this.piggybackControl(id, rpc, ctrl);
      this.control.delete(id);
    }
    const ihave = this.gossip.get(id);
    if (ihave) {
      this.piggybackGossip(id, rpc, ihave);
      this.gossip.delete(id);
    }
    const rpcBytes = RPC.encode(rpc).finish();
    try {
      outboundStream.push(rpcBytes);
    } catch (e) {
      this.log.error(`Cannot send rpc to ${id}`, e);
      if (ctrl) {
        this.control.set(id, ctrl);
      }
      if (ihave) {
        this.gossip.set(id, ihave);
      }
      return false;
    }
    this.metrics?.onRpcSent(rpc, rpcBytes.length);
    return true;
  }
  /** Mutates `outRpc` adding graft and prune control messages */
  piggybackControl(id, outRpc, ctrl) {
    if (ctrl.graft) {
      if (!outRpc.control)
        outRpc.control = {};
      if (!outRpc.control.graft)
        outRpc.control.graft = [];
      for (const graft of ctrl.graft) {
        if (graft.topicID && this.mesh.get(graft.topicID)?.has(id)) {
          outRpc.control.graft.push(graft);
        }
      }
    }
    if (ctrl.prune) {
      if (!outRpc.control)
        outRpc.control = {};
      if (!outRpc.control.prune)
        outRpc.control.prune = [];
      for (const prune of ctrl.prune) {
        if (prune.topicID && !this.mesh.get(prune.topicID)?.has(id)) {
          outRpc.control.prune.push(prune);
        }
      }
    }
  }
  /** Mutates `outRpc` adding ihave control messages */
  piggybackGossip(id, outRpc, ihave) {
    if (!outRpc.control)
      outRpc.control = {};
    outRpc.control.ihave = ihave;
  }
  /**
   * Send graft and prune messages
   *
   * @param tograft - peer id => topic[]
   * @param toprune - peer id => topic[]
   */
  async sendGraftPrune(tograft, toprune, noPX) {
    const doPX = this.opts.doPX;
    for (const [id, topics] of tograft) {
      const graft = topics.map((topicID) => ({ topicID }));
      let prune = [];
      const pruning = toprune.get(id);
      if (pruning) {
        prune = await Promise.all(pruning.map(async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false))));
        toprune.delete(id);
      }
      this.sendRpc(id, { control: { graft, prune } });
    }
    for (const [id, topics] of toprune) {
      const prune = await Promise.all(topics.map(async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false))));
      this.sendRpc(id, { control: { prune } });
    }
  }
  /**
   * Emits gossip - Send IHAVE messages to a random set of gossip peers
   */
  emitGossip(peersToGossipByTopic) {
    const gossipIDsByTopic = this.mcache.getGossipIDs(new Set(peersToGossipByTopic.keys()));
    for (const [topic, peersToGossip] of peersToGossipByTopic) {
      this.doEmitGossip(topic, peersToGossip, gossipIDsByTopic.get(topic) ?? []);
    }
  }
  /**
   * Send gossip messages to GossipFactor peers above threshold with a minimum of D_lazy
   * Peers are randomly selected from the heartbeat which exclude mesh + fanout peers
   * We also exclude direct peers, as there is no reason to emit gossip to them
   * @param topic
   * @param candidateToGossip - peers to gossip
   * @param messageIDs - message ids to gossip
   */
  doEmitGossip(topic, candidateToGossip, messageIDs) {
    if (!messageIDs.length) {
      return;
    }
    shuffle(messageIDs);
    if (messageIDs.length > GossipsubMaxIHaveLength) {
      this.log("too many messages for gossip; will truncate IHAVE list (%d messages)", messageIDs.length);
    }
    if (!candidateToGossip.size)
      return;
    let target = this.opts.Dlazy;
    const factor = GossipsubGossipFactor * candidateToGossip.size;
    let peersToGossip = candidateToGossip;
    if (factor > target) {
      target = factor;
    }
    if (target > peersToGossip.size) {
      target = peersToGossip.size;
    } else {
      peersToGossip = shuffle(Array.from(peersToGossip)).slice(0, target);
    }
    peersToGossip.forEach((id) => {
      let peerMessageIDs = messageIDs;
      if (messageIDs.length > GossipsubMaxIHaveLength) {
        peerMessageIDs = shuffle(peerMessageIDs.slice()).slice(0, GossipsubMaxIHaveLength);
      }
      this.pushGossip(id, {
        topicID: topic,
        messageIDs: peerMessageIDs
      });
    });
  }
  /**
   * Flush gossip and control messages
   */
  flush() {
    for (const [peer, ihave] of this.gossip.entries()) {
      this.gossip.delete(peer);
      this.sendRpc(peer, { control: { ihave } });
    }
    for (const [peer, control] of this.control.entries()) {
      this.control.delete(peer);
      this.sendRpc(peer, { control: { graft: control.graft, prune: control.prune } });
    }
  }
  /**
   * Adds new IHAVE messages to pending gossip
   */
  pushGossip(id, controlIHaveMsgs) {
    this.log("Add gossip to %s", id);
    const gossip = this.gossip.get(id) || [];
    this.gossip.set(id, gossip.concat(controlIHaveMsgs));
  }
  /**
   * Make a PRUNE control message for a peer in a topic
   */
  async makePrune(id, topic, doPX) {
    this.score.prune(id, topic);
    if (this.streamsOutbound.get(id).protocol === GossipsubIDv10) {
      return {
        topicID: topic,
        peers: []
      };
    }
    const backoff = this.opts.pruneBackoff / 1e3;
    if (!doPX) {
      return {
        topicID: topic,
        peers: [],
        backoff
      };
    }
    const peers = this.getRandomGossipPeers(topic, this.opts.prunePeers, (xid) => {
      return xid !== id && this.score.score(xid) >= 0;
    });
    const px = await Promise.all(Array.from(peers).map(async (peerId) => {
      const id2 = peerIdFromString(peerId);
      return {
        peerID: id2.toBytes(),
        signedPeerRecord: await this.components.peerStore.addressBook.getRawEnvelope(id2)
      };
    }));
    return {
      topicID: topic,
      peers: px,
      backoff
    };
  }
  /**
   * Maintains the mesh and fanout maps in gossipsub.
   */
  async heartbeat() {
    const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.opts;
    this.heartbeatTicks++;
    const scores = /* @__PURE__ */ new Map();
    const getScore = (id) => {
      let s = scores.get(id);
      if (s === void 0) {
        s = this.score.score(id);
        scores.set(id, s);
      }
      return s;
    };
    const tograft = /* @__PURE__ */ new Map();
    const toprune = /* @__PURE__ */ new Map();
    const noPX = /* @__PURE__ */ new Map();
    this.clearBackoff();
    this.peerhave.clear();
    this.metrics?.cacheSize.set({ cache: "iasked" }, this.iasked.size);
    this.iasked.clear();
    this.applyIwantPenalties();
    if (this.heartbeatTicks % this.opts.directConnectTicks === 0) {
      await this.directConnect();
    }
    this.fastMsgIdCache?.prune();
    this.seenCache.prune();
    this.gossipTracer.prune();
    this.publishedMessageIds.prune();
    const peersToGossipByTopic = /* @__PURE__ */ new Map();
    this.mesh.forEach((peers, topic) => {
      const peersInTopic = this.topics.get(topic);
      const candidateMeshPeers = /* @__PURE__ */ new Set();
      const peersToGossip = /* @__PURE__ */ new Set();
      peersToGossipByTopic.set(topic, peersToGossip);
      if (peersInTopic) {
        const shuffledPeers = shuffle(Array.from(peersInTopic));
        const backoff = this.backoff.get(topic);
        for (const id of shuffledPeers) {
          const peerStreams = this.streamsOutbound.get(id);
          if (peerStreams && this.multicodecs.includes(peerStreams.protocol) && !peers.has(id) && !this.direct.has(id)) {
            const score = getScore(id);
            if ((!backoff || !backoff.has(id)) && score >= 0)
              candidateMeshPeers.add(id);
            if (score >= this.opts.scoreThresholds.gossipThreshold)
              peersToGossip.add(id);
          }
        }
      }
      const prunePeer = (id, reason) => {
        this.log("HEARTBEAT: Remove mesh link to %s in %s", id, topic);
        this.addBackoff(id, topic);
        peers.delete(id);
        if (getScore(id) >= this.opts.scoreThresholds.gossipThreshold)
          peersToGossip.add(id);
        this.metrics?.onRemoveFromMesh(topic, reason, 1);
        const topics = toprune.get(id);
        if (!topics) {
          toprune.set(id, [topic]);
        } else {
          topics.push(topic);
        }
      };
      const graftPeer = (id, reason) => {
        this.log("HEARTBEAT: Add mesh link to %s in %s", id, topic);
        this.score.graft(id, topic);
        peers.add(id);
        peersToGossip.delete(id);
        this.metrics?.onAddToMesh(topic, reason, 1);
        const topics = tograft.get(id);
        if (!topics) {
          tograft.set(id, [topic]);
        } else {
          topics.push(topic);
        }
      };
      peers.forEach((id) => {
        const score = getScore(id);
        if (score < 0) {
          this.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s", id, score, topic);
          prunePeer(id, ChurnReason.BadScore);
          noPX.set(id, true);
        }
      });
      if (peers.size < Dlo) {
        const ineed = D - peers.size;
        const newMeshPeers = removeFirstNItemsFromSet(candidateMeshPeers, ineed);
        newMeshPeers.forEach((p) => {
          graftPeer(p, InclusionReason.NotEnough);
        });
      }
      if (peers.size > Dhi) {
        let peersArray = Array.from(peers);
        peersArray.sort((a, b) => getScore(b) - getScore(a));
        peersArray = peersArray.slice(0, Dscore).concat(shuffle(peersArray.slice(Dscore)));
        let outbound = 0;
        peersArray.slice(0, D).forEach((p) => {
          if (this.outbound.get(p)) {
            outbound++;
          }
        });
        if (outbound < Dout) {
          const rotate = (i2) => {
            const p = peersArray[i2];
            for (let j = i2; j > 0; j--) {
              peersArray[j] = peersArray[j - 1];
            }
            peersArray[0] = p;
          };
          if (outbound > 0) {
            let ihave = outbound;
            for (let i2 = 1; i2 < D && ihave > 0; i2++) {
              if (this.outbound.get(peersArray[i2])) {
                rotate(i2);
                ihave--;
              }
            }
          }
          let ineed = D - outbound;
          for (let i2 = D; i2 < peersArray.length && ineed > 0; i2++) {
            if (this.outbound.get(peersArray[i2])) {
              rotate(i2);
              ineed--;
            }
          }
        }
        peersArray.slice(D).forEach((p) => {
          prunePeer(p, ChurnReason.Excess);
        });
      }
      if (peers.size >= Dlo) {
        let outbound = 0;
        peers.forEach((p) => {
          if (this.outbound.get(p)) {
            outbound++;
          }
        });
        if (outbound < Dout) {
          const ineed = Dout - outbound;
          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => this.outbound.get(id) === true);
          newMeshPeers.forEach((p) => {
            graftPeer(p, InclusionReason.Outbound);
          });
        }
      }
      if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && peers.size > 1) {
        const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));
        const medianIndex = Math.floor(peers.size / 2);
        const medianScore = getScore(peersList[medianIndex]);
        if (medianScore < this.opts.scoreThresholds.opportunisticGraftThreshold) {
          const ineed = this.opts.opportunisticGraftPeers;
          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => getScore(id) > medianScore);
          for (const id of newMeshPeers) {
            this.log("HEARTBEAT: Opportunistically graft peer %s on topic %s", id, topic);
            graftPeer(id, InclusionReason.Opportunistic);
          }
        }
      }
    });
    const now = Date.now();
    this.fanoutLastpub.forEach((lastpb, topic) => {
      if (lastpb + fanoutTTL < now) {
        this.fanout.delete(topic);
        this.fanoutLastpub.delete(topic);
      }
    });
    this.fanout.forEach((fanoutPeers, topic) => {
      const topicPeers = this.topics.get(topic);
      fanoutPeers.forEach((id) => {
        if (!topicPeers.has(id) || getScore(id) < this.opts.scoreThresholds.publishThreshold) {
          fanoutPeers.delete(id);
        }
      });
      const peersInTopic = this.topics.get(topic);
      const candidateFanoutPeers = [];
      const peersToGossip = /* @__PURE__ */ new Set();
      peersToGossipByTopic.set(topic, peersToGossip);
      if (peersInTopic) {
        const shuffledPeers = shuffle(Array.from(peersInTopic));
        for (const id of shuffledPeers) {
          const peerStreams = this.streamsOutbound.get(id);
          if (peerStreams && this.multicodecs.includes(peerStreams.protocol) && !fanoutPeers.has(id) && !this.direct.has(id)) {
            const score = getScore(id);
            if (score >= this.opts.scoreThresholds.publishThreshold)
              candidateFanoutPeers.push(id);
            if (score >= this.opts.scoreThresholds.gossipThreshold)
              peersToGossip.add(id);
          }
        }
      }
      if (fanoutPeers.size < D) {
        const ineed = D - fanoutPeers.size;
        candidateFanoutPeers.slice(0, ineed).forEach((id) => {
          fanoutPeers.add(id);
          peersToGossip?.delete(id);
        });
      }
    });
    this.emitGossip(peersToGossipByTopic);
    await this.sendGraftPrune(tograft, toprune, noPX);
    this.flush();
    this.mcache.shift();
    this.dispatchEvent(new CustomEvent2("gossipsub:heartbeat"));
  }
  /**
   * Given a topic, returns up to count peers subscribed to that topic
   * that pass an optional filter function
   *
   * @param topic
   * @param count
   * @param filter - a function to filter acceptable peers
   */
  getRandomGossipPeers(topic, count, filter32 = () => true) {
    const peersInTopic = this.topics.get(topic);
    if (!peersInTopic) {
      return /* @__PURE__ */ new Set();
    }
    let peers = [];
    peersInTopic.forEach((id) => {
      const peerStreams = this.streamsOutbound.get(id);
      if (!peerStreams) {
        return;
      }
      if (this.multicodecs.includes(peerStreams.protocol) && filter32(id)) {
        peers.push(id);
      }
    });
    peers = shuffle(peers);
    if (count > 0 && peers.length > count) {
      peers = peers.slice(0, count);
    }
    return new Set(peers);
  }
  onScrapeMetrics(metrics) {
    metrics.mcacheSize.set(this.mcache.size);
    metrics.mcacheNotValidatedCount.set(this.mcache.notValidatedCount);
    metrics.cacheSize.set({ cache: "direct" }, this.direct.size);
    metrics.cacheSize.set({ cache: "seenCache" }, this.seenCache.size);
    metrics.cacheSize.set({ cache: "fastMsgIdCache" }, this.fastMsgIdCache?.size ?? 0);
    metrics.cacheSize.set({ cache: "publishedMessageIds" }, this.publishedMessageIds.size);
    metrics.cacheSize.set({ cache: "mcache" }, this.mcache.size);
    metrics.cacheSize.set({ cache: "score" }, this.score.size);
    metrics.cacheSize.set({ cache: "gossipTracer.promises" }, this.gossipTracer.size);
    metrics.cacheSize.set({ cache: "gossipTracer.requests" }, this.gossipTracer.requestMsByMsgSize);
    metrics.cacheSize.set({ cache: "topics" }, this.topics.size);
    metrics.cacheSize.set({ cache: "subscriptions" }, this.subscriptions.size);
    metrics.cacheSize.set({ cache: "mesh" }, this.mesh.size);
    metrics.cacheSize.set({ cache: "fanout" }, this.fanout.size);
    metrics.cacheSize.set({ cache: "peers" }, this.peers.size);
    metrics.cacheSize.set({ cache: "streamsOutbound" }, this.streamsOutbound.size);
    metrics.cacheSize.set({ cache: "streamsInbound" }, this.streamsInbound.size);
    metrics.cacheSize.set({ cache: "acceptFromWhitelist" }, this.acceptFromWhitelist.size);
    metrics.cacheSize.set({ cache: "gossip" }, this.gossip.size);
    metrics.cacheSize.set({ cache: "control" }, this.control.size);
    metrics.cacheSize.set({ cache: "peerhave" }, this.peerhave.size);
    metrics.cacheSize.set({ cache: "outbound" }, this.outbound.size);
    let backoffSize = 0;
    for (const backoff of this.backoff.values()) {
      backoffSize += backoff.size;
    }
    metrics.cacheSize.set({ cache: "backoff" }, backoffSize);
    for (const [topicStr, peers] of this.topics) {
      metrics.topicPeersCount.set({ topicStr }, peers.size);
    }
    for (const [topicStr, peers] of this.mesh) {
      metrics.meshPeerCounts.set({ topicStr }, peers.size);
    }
    const scores = [];
    const scoreByPeer = /* @__PURE__ */ new Map();
    metrics.behaviourPenalty.reset();
    for (const peerIdStr of this.peers.keys()) {
      const score = this.score.score(peerIdStr);
      scores.push(score);
      scoreByPeer.set(peerIdStr, score);
      metrics.behaviourPenalty.observe(this.score.peerStats.get(peerIdStr)?.behaviourPenalty ?? 0);
    }
    metrics.registerScores(scores, this.opts.scoreThresholds);
    metrics.registerScorePerMesh(this.mesh, scoreByPeer);
    const sw = computeAllPeersScoreWeights(this.peers.keys(), this.score.peerStats, this.score.params, this.score.peerIPs, metrics.topicStrToLabel);
    metrics.registerScoreWeights(sw);
  }
};
GossipSub.multicodec = GossipsubIDv11;
function gossipsub(init = {}) {
  return (components) => new GossipSub(components, init);
}
var routers = () => ({
  gossipsub: gossipsub({
    fallbackToFloodsub: true,
    emitSelf: true,
    maxInboundStreams: 64,
    maxOutboundStreams: 128
  })
});
var import_err_code77 = __toESM(require_err_code());
var import_any_signal3 = __toESM(require_any_signal());
var log47 = logger("libp2p-delegated-peer-routing");
var DEFAULT_TIMEOUT = 3e4;
var CONCURRENT_HTTP_REQUESTS = 4;
var EventTypes;
(function(EventTypes3) {
  EventTypes3[EventTypes3["SENDING_QUERY"] = 0] = "SENDING_QUERY";
  EventTypes3[EventTypes3["PEER_RESPONSE"] = 1] = "PEER_RESPONSE";
  EventTypes3[EventTypes3["FINAL_PEER"] = 2] = "FINAL_PEER";
  EventTypes3[EventTypes3["QUERY_ERROR"] = 3] = "QUERY_ERROR";
  EventTypes3[EventTypes3["PROVIDER"] = 4] = "PROVIDER";
  EventTypes3[EventTypes3["VALUE"] = 5] = "VALUE";
  EventTypes3[EventTypes3["ADDING_PEER"] = 6] = "ADDING_PEER";
  EventTypes3[EventTypes3["DIALING_PEER"] = 7] = "DIALING_PEER";
})(EventTypes || (EventTypes = {}));
var MessageType;
(function(MessageType3) {
  MessageType3[MessageType3["PUT_VALUE"] = 0] = "PUT_VALUE";
  MessageType3[MessageType3["GET_VALUE"] = 1] = "GET_VALUE";
  MessageType3[MessageType3["ADD_PROVIDER"] = 2] = "ADD_PROVIDER";
  MessageType3[MessageType3["GET_PROVIDERS"] = 3] = "GET_PROVIDERS";
  MessageType3[MessageType3["FIND_NODE"] = 4] = "FIND_NODE";
  MessageType3[MessageType3["PING"] = 5] = "PING";
})(MessageType || (MessageType = {}));
var DelegatedPeerRouting = class {
  /**
   * Create a new DelegatedPeerRouting instance
   */
  constructor(client) {
    if (client == null) {
      throw new Error("missing ipfs http client");
    }
    this.client = client;
    this.started = false;
    this.abortController = new AbortController();
    this.httpQueue = new PQueue({
      concurrency: CONCURRENT_HTTP_REQUESTS
    });
    const { protocol: protocol4, host, port } = client.getEndpointConfig();
    log47(`enabled DelegatedPeerRouting via ${protocol4}://${host}:${port}`);
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  stop() {
    this.httpQueue.clear();
    this.abortController.abort();
    this.abortController = new AbortController();
    this.started = false;
  }
  /**
   * Attempts to find the given peer
   */
  async findPeer(id, options = {}) {
    log47("findPeer starts: %p", id);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT;
    options.signal = (0, import_any_signal3.default)([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return await onFinish.promise;
    });
    try {
      await onStart.promise;
      for await (const event of this.client.dht.findPeer(id, options)) {
        if (event.name === "FINAL_PEER") {
          const peerInfo = {
            id: event.peer.id,
            multiaddrs: event.peer.multiaddrs,
            protocols: []
          };
          return peerInfo;
        }
      }
    } catch (err2) {
      log47.error("findPeer errored: %o", err2);
      throw err2;
    } finally {
      onFinish.resolve();
      log47("findPeer finished: %p", id);
    }
    throw (0, import_err_code77.default)(new Error("Not found"), "ERR_NOT_FOUND");
  }
  /**
   * Attempt to find the closest peers on the network to the given key
   */
  async *getClosestPeers(key, options = {}) {
    let cidOrPeerId;
    const cid = CID.asCID(key);
    if (cid != null) {
      cidOrPeerId = cid;
    } else {
      cidOrPeerId = peerIdFromBytes(key);
    }
    log47("getClosestPeers starts: %s", cidOrPeerId);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT;
    options.signal = (0, import_any_signal3.default)([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return await onFinish.promise;
    });
    try {
      await onStart.promise;
      for await (const event of this.client.dht.query(cidOrPeerId, options)) {
        if (event.name === "PEER_RESPONSE") {
          yield* event.closer.map((closer) => ({
            id: closer.id,
            multiaddrs: closer.multiaddrs,
            protocols: []
          }));
        }
      }
    } catch (err2) {
      log47.error("getClosestPeers errored:", err2);
      throw err2;
    } finally {
      onFinish.resolve();
      log47("getClosestPeers finished: %b", key);
    }
  }
};
function delegatedPeerRouting(client) {
  return () => new DelegatedPeerRouting(client);
}
var import_err_code78 = __toESM(require_err_code());
var import_any_signal4 = __toESM(require_any_signal());
var log48 = logger("libp2p:delegated-content-routing");
var DEFAULT_TIMEOUT2 = 3e4;
var CONCURRENT_HTTP_REQUESTS2 = 4;
var CONCURRENT_HTTP_REFS_REQUESTS = 2;
var EventTypes2;
(function(EventTypes3) {
  EventTypes3[EventTypes3["SENDING_QUERY"] = 0] = "SENDING_QUERY";
  EventTypes3[EventTypes3["PEER_RESPONSE"] = 1] = "PEER_RESPONSE";
  EventTypes3[EventTypes3["FINAL_PEER"] = 2] = "FINAL_PEER";
  EventTypes3[EventTypes3["QUERY_ERROR"] = 3] = "QUERY_ERROR";
  EventTypes3[EventTypes3["PROVIDER"] = 4] = "PROVIDER";
  EventTypes3[EventTypes3["VALUE"] = 5] = "VALUE";
  EventTypes3[EventTypes3["ADDING_PEER"] = 6] = "ADDING_PEER";
  EventTypes3[EventTypes3["DIALING_PEER"] = 7] = "DIALING_PEER";
})(EventTypes2 || (EventTypes2 = {}));
var MessageType2;
(function(MessageType3) {
  MessageType3[MessageType3["PUT_VALUE"] = 0] = "PUT_VALUE";
  MessageType3[MessageType3["GET_VALUE"] = 1] = "GET_VALUE";
  MessageType3[MessageType3["ADD_PROVIDER"] = 2] = "ADD_PROVIDER";
  MessageType3[MessageType3["GET_PROVIDERS"] = 3] = "GET_PROVIDERS";
  MessageType3[MessageType3["FIND_NODE"] = 4] = "FIND_NODE";
  MessageType3[MessageType3["PING"] = 5] = "PING";
})(MessageType2 || (MessageType2 = {}));
var DelegatedContentRouting = class {
  /**
   * Create a new DelegatedContentRouting instance
   */
  constructor(client) {
    if (client == null) {
      throw new Error("missing ipfs http client");
    }
    this.client = client;
    this.started = false;
    this.abortController = new AbortController();
    this.httpQueue = new PQueue({
      concurrency: CONCURRENT_HTTP_REQUESTS2
    });
    this.httpQueueRefs = new PQueue({
      concurrency: CONCURRENT_HTTP_REFS_REQUESTS
    });
    const { protocol: protocol4, host, port } = client.getEndpointConfig();
    log48(`enabled DelegatedContentRouting via ${protocol4}://${host}:${port}`);
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  stop() {
    this.httpQueue.clear();
    this.httpQueueRefs.clear();
    this.abortController.abort();
    this.abortController = new AbortController();
    this.started = false;
  }
  /**
   * Search the dht for providers of the given CID.
   *
   * - call `findProviders` on the delegated node.
   */
  async *findProviders(key, options = {}) {
    log48("findProviders starts: %c", key);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT2;
    options.signal = (0, import_any_signal4.default)([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return await onFinish.promise;
    });
    try {
      await onStart.promise;
      for await (const event of this.client.dht.findProvs(key, options)) {
        if (event.name === "PROVIDER") {
          yield* event.providers.map((prov) => {
            const peerInfo = {
              id: prov.id,
              protocols: [],
              multiaddrs: prov.multiaddrs
            };
            return peerInfo;
          });
        }
      }
    } catch (err2) {
      log48.error("findProviders errored:", err2);
      throw err2;
    } finally {
      onFinish.resolve();
      log48("findProviders finished: %c", key);
    }
  }
  /**
   * Announce to the network that the delegated node can provide the given key.
   *
   * Currently this uses the following hack
   * - delegate is one of bootstrap nodes, so we are always connected to it
   * - call block stat on the delegated node, so it fetches the content
   * - call dht provide with the passed cid
   *
   * N.B. this must be called for every block in the dag you want provided otherwise
   * the delegate will only be able to supply the root block of the dag when asked
   * for the data by an interested peer.
   */
  async provide(key, options = {}) {
    log48("provide starts: %c", key);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT2;
    options.signal = (0, import_any_signal4.default)([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    await this.httpQueueRefs.add(async () => {
      await this.client.block.stat(key, options);
      await drain(this.client.dht.provide(key, options));
    });
    log48("provide finished: %c", key);
  }
  /**
   * Stores a value in the backing key/value store of the delegated content router.
   * This may fail if the delegated node's content routing implementation does not
   * use a key/value store, or if the delegated operation fails.
   */
  async put(key, value2, options = {}) {
    log48("put value start: %b", key);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT2;
    options.signal = (0, import_any_signal4.default)([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    await this.httpQueue.add(async () => {
      await drain(this.client.dht.put(key, value2, options));
    });
    log48("put value finished: %b", key);
  }
  /**
   * Fetches an value from the backing key/value store of the delegated content router.
   * This may fail if the delegated node's content routing implementation does not
   * use a key/value store, or if the delegated operation fails.
   */
  async get(key, options = {}) {
    log48("get value start: %b", key);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT2;
    options.signal = (0, import_any_signal4.default)([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    return await this.httpQueue.add(async () => {
      for await (const event of this.client.dht.get(key, options)) {
        if (event.name === "VALUE") {
          log48("get value finished: %b", key);
          return event.value;
        }
      }
      throw (0, import_err_code78.default)(new Error("Not found"), "ERR_NOT_FOUND");
    });
  }
};
function delegatedContentRouting(client) {
  return () => new DelegatedContentRouting(client);
}
var LOAD_BASE = (name9) => Promise.reject(new Error(`No base found for "${name9}"`));
var Multibases = class {
  /**
   * @param {object} options
   * @param {LoadBaseFn} [options.loadBase]
   * @param {MultibaseCodec[]} options.bases
   */
  constructor(options) {
    this._basesByName = {};
    this._basesByPrefix = {};
    this._loadBase = options.loadBase || LOAD_BASE;
    for (const base3 of options.bases) {
      this.addBase(base3);
    }
  }
  /**
   * Add support for a multibase codec
   *
   * @param {MultibaseCodec} base
   */
  addBase(base3) {
    if (this._basesByName[base3.name] || this._basesByPrefix[base3.prefix]) {
      throw new Error(`Codec already exists for codec "${base3.name}"`);
    }
    this._basesByName[base3.name] = base3;
    this._basesByPrefix[base3.prefix] = base3;
  }
  /**
   * Remove support for a multibase codec
   *
   * @param {MultibaseCodec} base
   */
  removeBase(base3) {
    delete this._basesByName[base3.name];
    delete this._basesByPrefix[base3.prefix];
  }
  /**
   * @param {string} nameOrPrefix
   */
  async getBase(nameOrPrefix) {
    if (this._basesByName[nameOrPrefix]) {
      return this._basesByName[nameOrPrefix];
    }
    if (this._basesByPrefix[nameOrPrefix]) {
      return this._basesByPrefix[nameOrPrefix];
    }
    const base3 = await this._loadBase(nameOrPrefix);
    if (this._basesByName[base3.name] == null && this._basesByPrefix[base3.prefix] == null) {
      this.addBase(base3);
    }
    return base3;
  }
  listBases() {
    return Object.values(this._basesByName);
  }
};
var LOAD_CODEC = (codeOrName) => Promise.reject(new Error(`No codec found for "${codeOrName}"`));
var Multicodecs = class {
  /**
   * @param {object} options
   * @param {LoadCodecFn} [options.loadCodec]
   * @param {BlockCodec[]} options.codecs
   */
  constructor(options) {
    this._codecsByName = {};
    this._codecsByCode = {};
    this._loadCodec = options.loadCodec || LOAD_CODEC;
    for (const codec of options.codecs) {
      this.addCodec(codec);
    }
  }
  /**
   * Add support for a block codec
   *
   * @param {BlockCodec} codec
   */
  addCodec(codec) {
    if (this._codecsByName[codec.name] || this._codecsByCode[codec.code]) {
      throw new Error(`Resolver already exists for codec "${codec.name}"`);
    }
    this._codecsByName[codec.name] = codec;
    this._codecsByCode[codec.code] = codec;
  }
  /**
   * Remove support for a block codec
   *
   * @param {BlockCodec} codec
   */
  removeCodec(codec) {
    delete this._codecsByName[codec.name];
    delete this._codecsByCode[codec.code];
  }
  /**
   * @param {number | string} code
   */
  async getCodec(code8) {
    const table2 = typeof code8 === "string" ? this._codecsByName : this._codecsByCode;
    if (table2[code8]) {
      return table2[code8];
    }
    const codec = await this._loadCodec(code8);
    if (table2[code8] == null) {
      this.addCodec(codec);
    }
    return codec;
  }
  listCodecs() {
    return Object.values(this._codecsByName);
  }
};
var LOAD_HASHER = (codeOrName) => Promise.reject(new Error(`No hasher found for "${codeOrName}"`));
var Multihashes = class {
  /**
   * @param {object} options
   * @param {LoadHasherFn} [options.loadHasher]
   * @param {MultihashHasher[]} options.hashers
   */
  constructor(options) {
    this._hashersByName = {};
    this._hashersByCode = {};
    this._loadHasher = options.loadHasher || LOAD_HASHER;
    for (const hasher of options.hashers) {
      this.addHasher(hasher);
    }
  }
  /**
   * Add support for a multibase hasher
   *
   * @param {MultihashHasher} hasher
   */
  addHasher(hasher) {
    if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {
      throw new Error(`Resolver already exists for codec "${hasher.name}"`);
    }
    this._hashersByName[hasher.name] = hasher;
    this._hashersByCode[hasher.code] = hasher;
  }
  /**
   * Remove support for a multibase hasher
   *
   * @param {MultihashHasher} hasher
   */
  removeHasher(hasher) {
    delete this._hashersByName[hasher.name];
    delete this._hashersByCode[hasher.code];
  }
  /**
   * @param {number | string} code
   */
  async getHasher(code8) {
    const table2 = typeof code8 === "string" ? this._hashersByName : this._hashersByCode;
    if (table2[code8]) {
      return table2[code8];
    }
    const hasher = await this._loadHasher(code8);
    if (table2[code8] == null) {
      this.addHasher(hasher);
    }
    return hasher;
  }
  listHashers() {
    return Object.values(this._hashersByName);
  }
};
var import_env = __toESM(require_env(), 1);
var import_http3 = __toESM(require_http(), 1);
function toUrlString(url2) {
  try {
    url2 = multiaddrToUri(multiaddr(url2));
  } catch (err2) {
  }
  url2 = url2.toString();
  return url2;
}
var agent_browser_default = () => {
};
var log49 = logger("ipfs-http-client:lib:error-handler");
var merge2 = merge_options_default.bind({ ignoreUndefined: true });
var DEFAULT_PROTOCOL = import_env.isBrowser || import_env.isWebWorker ? location.protocol : "http";
var DEFAULT_HOST = import_env.isBrowser || import_env.isWebWorker ? location.hostname : "localhost";
var DEFAULT_PORT = import_env.isBrowser || import_env.isWebWorker ? location.port : "5001";
var normalizeOptions = (options = {}) => {
  let url2;
  let opts = {};
  let agent;
  if (typeof options === "string" || isMultiaddr(options)) {
    url2 = new URL(toUrlString(options));
  } else if (options instanceof URL) {
    url2 = options;
  } else if (typeof options.url === "string" || isMultiaddr(options.url)) {
    url2 = new URL(toUrlString(options.url));
    opts = options;
  } else if (options.url instanceof URL) {
    url2 = options.url;
    opts = options;
  } else {
    opts = options || {};
    const protocol4 = (opts.protocol || DEFAULT_PROTOCOL).replace(":", "");
    const host = (opts.host || DEFAULT_HOST).split(":")[0];
    const port = opts.port || DEFAULT_PORT;
    url2 = new URL(`${protocol4}://${host}:${port}`);
  }
  if (opts.apiPath) {
    url2.pathname = opts.apiPath;
  } else if (url2.pathname === "/" || url2.pathname === void 0) {
    url2.pathname = "api/v0";
  }
  if (import_env.isNode) {
    const Agent = agent_browser_default();
    agent = opts.agent || new Agent({
      keepAlive: true,
      // Similar to browsers which limit connections to six per host
      maxSockets: 6
    });
  }
  return {
    ...opts,
    host: url2.host,
    protocol: url2.protocol.replace(":", ""),
    port: Number(url2.port),
    apiPath: url2.pathname,
    url: url2,
    agent
  };
};
var errorHandler = async (response) => {
  let msg;
  try {
    if ((response.headers.get("Content-Type") || "").startsWith("application/json")) {
      const data = await response.json();
      log49(data);
      msg = data.Message || data.message;
    } else {
      msg = await response.text();
    }
  } catch (err2) {
    log49("Failed to parse error response", err2);
    msg = err2.message;
  }
  let error = new import_http3.default.HTTPError(response);
  if (msg) {
    if (msg.includes("deadline has elapsed")) {
      error = new import_http3.default.TimeoutError();
    }
    if (msg && msg.includes("context deadline exceeded")) {
      error = new import_http3.default.TimeoutError();
    }
  }
  if (msg && msg.includes("request timed out")) {
    error = new import_http3.default.TimeoutError();
  }
  if (msg) {
    error.message = msg;
  }
  throw error;
};
var KEBAB_REGEX = /[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g;
var kebabCase = (str) => {
  return str.replace(KEBAB_REGEX, function(match) {
    return "-" + match.toLowerCase();
  });
};
var parseTimeout = (value2) => {
  return typeof value2 === "string" ? parse_duration_default(value2) : value2;
};
var Client = class extends import_http3.default {
  /**
   * @param {Options|URL|Multiaddr|string} [options]
   */
  constructor(options = {}) {
    const opts = normalizeOptions(options);
    super({
      timeout: parseTimeout(opts.timeout || 0) || void 0,
      headers: opts.headers,
      base: `${opts.url}`,
      handleError: errorHandler,
      transformSearchParams: (search) => {
        const out = new URLSearchParams();
        for (const [key, value2] of search) {
          if (value2 !== "undefined" && value2 !== "null" && key !== "signal") {
            out.append(kebabCase(key), value2);
          }
          if (key === "timeout" && !isNaN(value2)) {
            out.append(kebabCase(key), value2);
          }
        }
        return out;
      },
      // @ts-expect-error this can be a https agent or a http agent
      agent: opts.agent
    });
    delete this.get;
    delete this.put;
    delete this.delete;
    delete this.options;
    const fetch2 = this.fetch;
    this.fetch = (resource, options2 = {}) => {
      if (typeof resource === "string" && !resource.startsWith("/")) {
        resource = `${opts.url}/${resource}`;
      }
      return fetch2.call(this, resource, merge2(options2, {
        method: "POST"
      }));
    };
  }
};
import_http3.default.HTTPError;
var configure2 = (fn) => {
  return (options) => {
    return fn(new Client(options), options);
  };
};
function modeToString(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}
var import_err_code79 = __toESM(require_err_code(), 1);
function parseMtime2(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code79.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
function toUrlSearchParams({ arg, searchParams, hashAlg, mtime, mode, ...options } = {}) {
  if (searchParams) {
    options = {
      ...options,
      ...searchParams
    };
  }
  if (hashAlg) {
    options.hash = hashAlg;
  }
  if (mtime != null) {
    mtime = parseMtime2(mtime);
    options.mtime = mtime.secs;
    options.mtimeNsecs = mtime.nsecs;
  }
  if (mode != null) {
    options.mode = modeToString(mode);
  }
  if (options.timeout && !isNaN(options.timeout)) {
    options.timeout = `${options.timeout}ms`;
  }
  if (arg === void 0 || arg === null) {
    arg = [];
  } else if (!Array.isArray(arg)) {
    arg = [arg];
  }
  const urlSearchParams = new URLSearchParams(options);
  arg.forEach((arg2) => urlSearchParams.append("arg", arg2));
  return urlSearchParams;
}
var createWantlist2 = configure2((api) => {
  async function wantlist(options = {}) {
    const res = await (await api.post("bitswap/wantlist", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return (res.Keys || []).map((k) => CID.parse(k["/"]));
  }
  return wantlist;
});
var createWantlistForPeer2 = configure2((api) => {
  async function wantlistForPeer(peerId, options = {}) {
    const res = await (await api.post("bitswap/wantlist", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        peer: peerId.toString()
      }),
      headers: options.headers
    })).json();
    return (res.Keys || []).map((k) => CID.parse(k["/"]));
  }
  return wantlistForPeer;
});
var createStat6 = configure2((api) => {
  async function stat(options = {}) {
    const res = await api.post("bitswap/stat", {
      searchParams: toUrlSearchParams(options),
      signal: options.signal,
      headers: options.headers
    });
    return toCoreInterface(await res.json());
  }
  return stat;
});
function toCoreInterface(res) {
  return {
    provideBufLen: res.ProvideBufLen,
    wantlist: (res.Wantlist || []).map((k) => CID.parse(k["/"])),
    peers: (res.Peers || []).map((str) => peerIdFromString(str)),
    blocksReceived: BigInt(res.BlocksReceived),
    dataReceived: BigInt(res.DataReceived),
    blocksSent: BigInt(res.BlocksSent),
    dataSent: BigInt(res.DataSent),
    dupBlksReceived: BigInt(res.DupBlksReceived),
    dupDataReceived: BigInt(res.DupDataReceived)
  };
}
var createUnwant2 = configure2((api) => {
  async function unwant(cid, options = {}) {
    const res = await api.post("bitswap/unwant", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    return res.json();
  }
  return unwant;
});
function createBitswap(config2) {
  return {
    wantlist: createWantlist2(config2),
    wantlistForPeer: createWantlistForPeer2(config2),
    unwant: createUnwant2(config2),
    stat: createStat6(config2)
  };
}
var createGet5 = configure2((api) => {
  async function get3(cid, options = {}) {
    const res = await api.post("block/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    return new Uint8Array(await res.arrayBuffer());
  }
  return get3;
});
var import_err_code80 = __toESM(require_err_code(), 1);
async function normaliseContent2(input) {
  if (isBytes(input)) {
    return new Blob([input]);
  }
  if (typeof input === "string" || input instanceof String) {
    return new Blob([input.toString()]);
  }
  if (isBlob$1(input)) {
    return input;
  }
  if (isReadableStream(input)) {
    input = browserReadableStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = peekableIterator(input);
    const { value: value2, done } = await peekable.peek();
    if (done) {
      return itToBlob(peekable);
    }
    peekable.push(value2);
    if (Number.isInteger(value2)) {
      return new Blob([Uint8Array.from(await all(peekable))]);
    }
    if (isBytes(value2) || typeof value2 === "string" || value2 instanceof String) {
      return itToBlob(peekable);
    }
  }
  throw (0, import_err_code80.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
}
async function itToBlob(stream) {
  const parts2 = [];
  for await (const chunk of stream) {
    parts2.push(chunk);
  }
  return new Blob(parts2);
}
function normaliseInput4(input) {
  return normaliseCandidateMultiple(input, normaliseContent2);
}
function modeToString2(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}
async function multipartRequest(source, abortController, headers = {}) {
  const parts2 = [];
  const formData = new FormData();
  let index2 = 0;
  let total = 0;
  for await (const { content, path: path2, mode, mtime } of normaliseInput4(source)) {
    let fileSuffix = "";
    const type = content ? "file" : "dir";
    if (index2 > 0) {
      fileSuffix = `-${index2}`;
    }
    let fieldName = type + fileSuffix;
    const qs = [];
    if (mode !== null && mode !== void 0) {
      qs.push(`mode=${modeToString2(mode)}`);
    }
    if (mtime != null) {
      const { secs, nsecs } = mtime;
      qs.push(`mtime=${secs}`);
      if (nsecs != null) {
        qs.push(`mtime-nsecs=${nsecs}`);
      }
    }
    if (qs.length) {
      fieldName = `${fieldName}?${qs.join("&")}`;
    }
    if (content) {
      formData.set(fieldName, content, path2 != null ? encodeURIComponent(path2) : void 0);
      const end = total + content.size;
      parts2.push({ name: path2, start: total, end });
      total = end;
    } else if (path2 != null) {
      formData.set(fieldName, new File([""], encodeURIComponent(path2), { type: "application/x-directory" }));
    } else {
      throw new Error("path or content or both must be set");
    }
    index2++;
  }
  return {
    total,
    parts: parts2,
    headers,
    body: formData
  };
}
var import_any_signal5 = __toESM(require_any_signal(), 1);
function filter2(signals) {
  return signals.filter(Boolean);
}
function abortSignal(...signals) {
  return (0, import_any_signal5.anySignal)(filter2(signals));
}
var createPut4 = configure2((api) => {
  async function put(data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    let res;
    try {
      const response = await api.post("block/put", {
        signal,
        searchParams: toUrlSearchParams(options),
        ...await multipartRequest([data], controller, options.headers)
      });
      res = await response.json();
    } catch (err2) {
      if (options.format === "dag-pb") {
        return put(data, { ...options, format: "protobuf" });
      } else if (options.format === "dag-cbor") {
        return put(data, { ...options, format: "cbor" });
      }
      throw err2;
    }
    return CID.parse(res.Key);
  }
  return put;
});
var createRm6 = configure2((api) => {
  async function* rm(cid, options = {}) {
    if (!Array.isArray(cid)) {
      cid = [cid];
    }
    const res = await api.post("block/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.map((cid2) => cid2.toString()),
        "stream-channels": true,
        ...options
      }),
      headers: options.headers
    });
    for await (const removed of res.ndjson()) {
      yield toCoreInterface2(removed);
    }
  }
  return rm;
});
function toCoreInterface2(removed) {
  const out = {
    cid: CID.parse(removed.Hash)
  };
  if (removed.Error) {
    out.error = new Error(removed.Error);
  }
  return out;
}
var createStat7 = configure2((api) => {
  async function stat(cid, options = {}) {
    const res = await api.post("block/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return { cid: CID.parse(data.Key), size: data.Size };
  }
  return stat;
});
function createBlock(config2) {
  return {
    get: createGet5(config2),
    put: createPut4(config2),
    rm: createRm6(config2),
    stat: createStat7(config2)
  };
}
var createAdd4 = configure2((api) => {
  async function add(addr, options = {}) {
    const res = await api.post("bootstrap/add", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return add;
});
var createClear2 = configure2((api) => {
  async function clear(options = {}) {
    const res = await api.post("bootstrap/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        all: true
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return clear;
});
var createList3 = configure2((api) => {
  async function list(options = {}) {
    const res = await api.post("bootstrap/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return list;
});
var createReset2 = configure2((api) => {
  async function reset(options = {}) {
    const res = await api.post("bootstrap/add", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        default: true
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return reset;
});
var createRm7 = configure2((api) => {
  async function rm(addr, options = {}) {
    const res = await api.post("bootstrap/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return rm;
});
function createBootstrap(config2) {
  return {
    add: createAdd4(config2),
    clear: createClear2(config2),
    list: createList3(config2),
    reset: createReset2(config2),
    rm: createRm7(config2)
  };
}
var createApply = configure2((api) => {
  async function apply(profile, options = {}) {
    const res = await api.post("config/profile/apply", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: profile,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      original: data.OldCfg,
      updated: data.NewCfg
    };
  }
  return apply;
});
function objectToCamel(obj) {
  if (obj == null) {
    return obj;
  }
  const caps = /^[A-Z]+$/;
  const output = {};
  return Object.keys(obj).reduce((camelObj, k) => {
    if (caps.test(k)) {
      camelObj[k.toLowerCase()] = obj[k];
    } else if (caps.test(k[0])) {
      camelObj[k[0].toLowerCase() + k.slice(1)] = obj[k];
    } else {
      camelObj[k] = obj[k];
    }
    return camelObj;
  }, output);
}
var createList4 = configure2((api) => {
  async function list(options = {}) {
    const res = await api.post("config/profile/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.map((profile) => objectToCamel(profile));
  }
  return list;
});
function createProfiles(config2) {
  return {
    apply: createApply(config2),
    list: createList4(config2)
  };
}
var createGet6 = configure2((api) => {
  const get3 = async (key, options = {}) => {
    if (!key) {
      throw new Error("key argument is required");
    }
    const res = await api.post("config", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: key,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data.Value;
  };
  return get3;
});
var createGetAll = configure2((api) => {
  const getAll = async (options = {}) => {
    const res = await api.post("config/show", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data;
  };
  return getAll;
});
var createReplace = configure2((api) => {
  const replace = async (config2, options = {}) => {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("config/replace", {
      signal,
      searchParams: toUrlSearchParams(options),
      ...await multipartRequest([fromString3(JSON.stringify(config2))], controller, options.headers)
    });
    await res.text();
  };
  return replace;
});
var createSet = configure2((api) => {
  const set2 = async (key, value2, options = {}) => {
    if (typeof key !== "string") {
      throw new Error("Invalid key type");
    }
    const params = {
      ...options,
      ...encodeParam(key, value2)
    };
    const res = await api.post("config", {
      signal: options.signal,
      searchParams: toUrlSearchParams(params),
      headers: options.headers
    });
    await res.text();
  };
  return set2;
});
var encodeParam = (key, value2) => {
  switch (typeof value2) {
    case "boolean":
      return { arg: [key, value2.toString()], bool: true };
    case "string":
      return { arg: [key, value2] };
    default:
      return { arg: [key, JSON.stringify(value2)], json: true };
  }
};
function createConfig2(config2) {
  return {
    getAll: createGetAll(config2),
    get: createGet6(config2),
    set: createSet(config2),
    replace: createReplace(config2),
    profiles: createProfiles(config2)
  };
}
var createExport3 = configure2((api) => {
  async function* dagExport(root2, options = {}) {
    const res = await api.post("dag/export", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: root2.toString()
      }),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return dagExport;
});
var import_err_code81 = __toESM(require_err_code(), 1);
async function* resolve6(cid, path2, codecs2, getBlock, options) {
  const load = async (cid2) => {
    const codec = await codecs2.getCodec(cid2.code);
    const block = await getBlock(cid2, options);
    return codec.decode(block);
  };
  const parts2 = path2.split("/").filter(Boolean);
  let value2 = await load(cid);
  let lastCid = cid;
  while (parts2.length) {
    const key = parts2.shift();
    if (!key) {
      throw (0, import_err_code81.default)(new Error(`Could not resolve path "${path2}"`), "ERR_INVALID_PATH");
    }
    if (Object.prototype.hasOwnProperty.call(value2, key)) {
      value2 = value2[key];
      yield {
        value: value2,
        remainderPath: parts2.join("/")
      };
    } else {
      throw (0, import_err_code81.default)(new Error(`no link named "${key}" under ${lastCid}`), "ERR_NO_LINK");
    }
    const cid2 = CID.asCID(value2);
    if (cid2) {
      lastCid = cid2;
      value2 = await load(value2);
    }
  }
  yield {
    value: value2,
    remainderPath: ""
  };
}
var import_err_code82 = __toESM(require_err_code(), 1);
var createGet7 = (codecs2, options) => {
  const fn = configure2((api, opts) => {
    const getBlock = createGet5(opts);
    const get3 = async (cid, options2 = {}) => {
      if (options2.path) {
        const entry = options2.localResolve ? await first(resolve6(cid, options2.path, codecs2, getBlock, options2)) : await last(resolve6(cid, options2.path, codecs2, getBlock, options2));
        const result = entry;
        if (!result) {
          throw (0, import_err_code82.default)(new Error("Not found"), "ERR_NOT_FOUND");
        }
        return result;
      }
      const codec = await codecs2.getCodec(cid.code);
      const block = await getBlock(cid, options2);
      const node = codec.decode(block);
      return {
        value: node,
        remainderPath: ""
      };
    };
    return get3;
  });
  return fn(options);
};
var createImport3 = configure2((api) => {
  async function* dagImport(source, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const { headers, body } = await multipartRequest(source, controller, options.headers);
    const res = await api.post("dag/import", {
      signal,
      headers,
      body,
      searchParams: toUrlSearchParams({ "pin-roots": options.pinRoots })
    });
    for await (const { Root: Root2 } of res.ndjson()) {
      if (Root2 !== void 0) {
        const { Cid: { "/": Cid }, PinErrorMsg } = Root2;
        yield {
          root: {
            cid: CID.parse(Cid),
            pinErrorMsg: PinErrorMsg
          }
        };
      }
    }
  }
  return dagImport;
});
var createPut5 = (codecs2, options) => {
  const fn = configure2((api) => {
    const put = async (dagNode, options2 = {}) => {
      const settings = {
        storeCodec: "dag-cbor",
        hashAlg: "sha2-256",
        ...options2
      };
      let serialized;
      if (settings.inputCodec) {
        if (!(dagNode instanceof Uint8Array)) {
          throw new Error("Can only inputCodec on raw bytes that can be decoded");
        }
        serialized = dagNode;
      } else {
        const storeCodec = await codecs2.getCodec(settings.storeCodec);
        serialized = storeCodec.encode(dagNode);
        settings.inputCodec = settings.storeCodec;
      }
      const controller = new AbortController();
      const signal = abortSignal(controller.signal, settings.signal);
      const res = await api.post("dag/put", {
        timeout: settings.timeout,
        signal,
        searchParams: toUrlSearchParams(settings),
        ...await multipartRequest([serialized], controller, settings.headers)
      });
      const data = await res.json();
      return CID.parse(data.Cid["/"]);
    };
    return put;
  });
  return fn(options);
};
var createResolve4 = configure2((api) => {
  const resolve7 = async (ipfsPath3, options = {}) => {
    const res = await api.post("dag/resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${ipfsPath3}${options.path ? `/${options.path}`.replace(/\/[/]+/g, "/") : ""}`,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return { cid: CID.parse(data.Cid["/"]), remainderPath: data.RemPath };
  };
  return resolve7;
});
function createDag(codecs2, config2) {
  return {
    export: createExport3(config2),
    get: createGet7(codecs2, config2),
    import: createImport3(config2),
    put: createPut5(codecs2, config2),
    resolve: createResolve4(config2)
  };
}
var SendingQuery = 0;
var PeerResponse = 1;
var FinalPeer = 2;
var QueryError = 3;
var Provider = 4;
var Value = 5;
var AddingPeer = 6;
var DialingPeer = 7;
var mapEvent = (event) => {
  if (event.Type === SendingQuery) {
    return {
      name: "SENDING_QUERY",
      type: event.Type
    };
  }
  if (event.Type === PeerResponse) {
    return {
      from: peerIdFromString(event.ID),
      name: "PEER_RESPONSE",
      type: event.Type,
      // TODO: how to infer this from the go-ipfs response
      messageType: 0,
      // TODO: how to infer this from the go-ipfs response
      messageName: "PUT_VALUE",
      closer: (event.Responses || []).map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr) => multiaddr(addr)), protocols: [] })),
      providers: (event.Responses || []).map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr) => multiaddr(addr)), protocols: [] }))
      // TODO: how to infer this from the go-ipfs response
      // record: ???
    };
  }
  if (event.Type === FinalPeer) {
    let peer = {
      // @ts-expect-error go-ipfs does not return this
      id: event.ID ?? peerIdFromString(event.ID),
      /** @type {Multiaddr[]} */
      multiaddrs: [],
      protocols: []
    };
    if (event.Responses && event.Responses.length) {
      peer = {
        id: peerIdFromString(event.Responses[0].ID),
        multiaddrs: event.Responses[0].Addrs.map((addr) => multiaddr(addr)),
        protocols: []
      };
    }
    return {
      name: "FINAL_PEER",
      type: event.Type,
      peer
    };
  }
  if (event.Type === QueryError) {
    return {
      name: "QUERY_ERROR",
      type: event.Type,
      error: new Error(event.Extra)
    };
  }
  if (event.Type === Provider) {
    return {
      name: "PROVIDER",
      type: event.Type,
      providers: event.Responses.map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr) => multiaddr(addr)), protocols: [] }))
    };
  }
  if (event.Type === Value) {
    return {
      name: "VALUE",
      type: event.Type,
      value: fromString3(event.Extra, "base64pad")
    };
  }
  if (event.Type === AddingPeer) {
    const peers = event.Responses.map(({ ID }) => peerIdFromString(ID));
    if (!peers.length) {
      throw new Error("No peer found");
    }
    return {
      name: "ADDING_PEER",
      type: event.Type,
      peer: peers[0]
    };
  }
  if (event.Type === DialingPeer) {
    return {
      name: "DIALING_PEER",
      type: event.Type,
      peer: peerIdFromString(event.ID)
    };
  }
  throw new Error("Unknown DHT event type");
};
var createFindPeer = configure2((api) => {
  async function* findPeer2(peerId, options = {}) {
    const res = await api.post("dht/findpeer", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: peerId,
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return findPeer2;
});
var createFindProvs = configure2((api) => {
  async function* findProvs(cid, options = {}) {
    const res = await api.post("dht/findprovs", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return findProvs;
});
var createGet8 = configure2((api) => {
  async function* get3(key, options = {}) {
    const res = await api.post("dht/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        // arg: base36.encode(key),
        arg: key instanceof Uint8Array ? toString3(key) : key.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return get3;
});
var createProvide = configure2((api) => {
  async function* provide(cids, options = { recursive: false }) {
    const cidArr = Array.isArray(cids) ? cids : [cids];
    const res = await api.post("dht/provide", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cidArr.map((cid) => cid.toString()),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return provide;
});
var createPut6 = configure2((api) => {
  async function* put(key, value2, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("dht/put", {
      signal,
      searchParams: toUrlSearchParams({
        arg: key instanceof Uint8Array ? toString3(key) : key.toString(),
        ...options
      }),
      ...await multipartRequest([value2], controller, options.headers)
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return put;
});
var createQuery = configure2((api) => {
  async function* query(peerId, options = {}) {
    const res = await api.post("dht/query", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: peerId.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return query;
});
function createDht(config2) {
  return {
    findPeer: createFindPeer(config2),
    findProvs: createFindProvs(config2),
    get: createGet8(config2),
    provide: createProvide(config2),
    put: createPut6(config2),
    query: createQuery(config2)
  };
}
var createCmds = configure2((api) => {
  async function cmds(options = {}) {
    const res = await api.post("diag/cmds", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return cmds;
});
var createNet = configure2((api) => {
  async function net(options = {}) {
    const res = await api.post("diag/net", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return net;
});
var createSys = configure2((api) => {
  async function sys(options = {}) {
    const res = await api.post("diag/sys", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return sys;
});
function createDiag(config2) {
  return {
    cmds: createCmds(config2),
    net: createNet(config2),
    sys: createSys(config2)
  };
}
var createChmod2 = configure2((api) => {
  async function chmod(path2, mode, options = {}) {
    const res = await api.post("files/chmod", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        mode,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return chmod;
});
var createCp2 = configure2((api) => {
  async function cp(sources, destination, options = {}) {
    const sourceArr = Array.isArray(sources) ? sources : [sources];
    const res = await api.post("files/cp", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: sourceArr.concat(destination).map((src2) => CID.asCID(src2) ? `/ipfs/${src2}` : src2),
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return cp;
});
var createFlush2 = configure2((api) => {
  async function flush3(path2, options = {}) {
    if (!path2 || typeof path2 !== "string") {
      throw new Error("ipfs.files.flush requires a path");
    }
    const res = await api.post("files/flush", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return CID.parse(data.Cid);
  }
  return flush3;
});
function objectToCamelWithMetadata(entry) {
  const file = objectToCamel(entry);
  if (Object.prototype.hasOwnProperty.call(file, "mode")) {
    file.mode = parseInt(file.mode, 8);
  }
  if (Object.prototype.hasOwnProperty.call(file, "mtime")) {
    file.mtime = {
      secs: file.mtime,
      nsecs: file.mtimeNsecs || 0
    };
    delete file.mtimeNsecs;
  }
  return file;
}
var createLs4 = configure2((api) => {
  async function* ls(path2, options = {}) {
    if (!path2) {
      throw new Error("ipfs.files.ls requires a path");
    }
    const res = await api.post("files/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: CID.asCID(path2) ? `/ipfs/${path2}` : path2,
        // default long to true, diverges from go-ipfs where its false by default
        long: true,
        ...options,
        stream: true
      }),
      headers: options.headers
    });
    for await (const result of res.ndjson()) {
      if ("Entries" in result) {
        for (const entry of result.Entries || []) {
          yield toCoreInterface3(objectToCamelWithMetadata(entry));
        }
      } else {
        yield toCoreInterface3(objectToCamelWithMetadata(result));
      }
    }
  }
  return ls;
});
function toCoreInterface3(entry) {
  if (entry.hash) {
    entry.cid = CID.parse(entry.hash);
  }
  delete entry.hash;
  entry.type = entry.type === 1 ? "directory" : "file";
  return entry;
}
var createMkdir2 = configure2((api) => {
  async function mkdir(path2, options = {}) {
    const res = await api.post("files/mkdir", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return mkdir;
});
var createMv2 = configure2((api) => {
  async function mv(sources, destination, options = {}) {
    if (!Array.isArray(sources)) {
      sources = [sources];
    }
    const res = await api.post("files/mv", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: sources.concat(destination),
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return mv;
});
var import_source = __toESM(require_source(), 1);
var createRead2 = configure2((api) => {
  async function* read2(path2, options = {}) {
    const res = await api.post("files/read", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        count: options.length,
        ...options
      }),
      headers: options.headers
    });
    yield* (0, import_source.default)(res.body);
  }
  return read2;
});
var import_http4 = __toESM(require_http(), 1);
var createRm8 = configure2((api) => {
  async function rm(path2, options = {}) {
    const res = await api.post("files/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        ...options
      }),
      headers: options.headers
    });
    const body = await res.text();
    if (body !== "") {
      const error = new import_http4.default.HTTPError(res);
      error.message = body;
      throw error;
    }
  }
  return rm;
});
var createStat8 = configure2((api) => {
  async function stat(path2, options = {}) {
    const res = await api.post("files/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    data.WithLocality = data.WithLocality || false;
    return toCoreInterface4(objectToCamelWithMetadata(data));
  }
  return stat;
});
function toCoreInterface4(entry) {
  entry.cid = CID.parse(entry.hash);
  delete entry.hash;
  return entry;
}
var createTouch2 = configure2((api) => {
  async function touch(path2, options = {}) {
    const res = await api.post("files/touch", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return touch;
});
var createWrite2 = configure2((api) => {
  async function write3(path2, input, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("files/write", {
      signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        streamChannels: true,
        count: options.length,
        ...options
      }),
      ...await multipartRequest([{
        content: input,
        path: "arg",
        mode: modeToString(options.mode),
        mtime: parseMtime2(options.mtime)
      }], controller, options.headers)
    });
    await res.text();
  }
  return write3;
});
function createFiles2(config2) {
  return {
    chmod: createChmod2(config2),
    cp: createCp2(config2),
    flush: createFlush2(config2),
    ls: createLs4(config2),
    mkdir: createMkdir2(config2),
    mv: createMv2(config2),
    read: createRead2(config2),
    rm: createRm8(config2),
    stat: createStat8(config2),
    touch: createTouch2(config2),
    write: createWrite2(config2)
  };
}
var import_err_code83 = __toESM(require_err_code(), 1);
var createExport4 = configure2((api) => {
  const exportKey2 = async (name9, password, options = {}) => {
    throw (0, import_err_code83.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return exportKey2;
});
var createGen2 = configure2((api) => {
  async function gen(name9, options) {
    const opts = options ?? { type: "Ed25519" };
    const res = await api.post("key/gen", {
      signal: opts.signal,
      searchParams: toUrlSearchParams({
        arg: name9,
        ...opts
      }),
      headers: opts.headers
    });
    const data = await res.json();
    return objectToCamel(data);
  }
  return gen;
});
var createImport4 = configure2((api) => {
  async function importKey2(name9, pem, password, options = {}) {
    const res = await api.post("key/import", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name9,
        pem,
        password,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return objectToCamel(data);
  }
  return importKey2;
});
var import_err_code84 = __toESM(require_err_code(), 1);
var createInfo2 = configure2((api) => {
  const info = async (name9, options = {}) => {
    throw (0, import_err_code84.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return info;
});
var createList5 = configure2((api) => {
  async function list(options = {}) {
    const res = await api.post("key/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return (data.Keys || []).map((k) => objectToCamel(k));
  }
  return list;
});
var createRename2 = configure2((api) => {
  async function rename(oldName, newName, options = {}) {
    const res = await api.post("key/rename", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          oldName,
          newName
        ],
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return rename;
});
var createRm9 = configure2((api) => {
  async function rm(name9, options = {}) {
    const res = await api.post("key/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name9,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return objectToCamel(data.Keys[0]);
  }
  return rm;
});
function createKey(config2) {
  return {
    export: createExport4(config2),
    gen: createGen2(config2),
    import: createImport4(config2),
    info: createInfo2(config2),
    list: createList5(config2),
    rename: createRename2(config2),
    rm: createRm9(config2)
  };
}
var createLevel = configure2((api) => {
  async function level(subsystem, level2, options = {}) {
    const res = await api.post("log/level", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          subsystem,
          level2
        ],
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return level;
});
var createLs5 = configure2((api) => {
  async function ls(options = {}) {
    const res = await api.post("log/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.Strings;
  }
  return ls;
});
var createTail = configure2((api) => {
  async function* tail(options = {}) {
    const res = await api.post("log/tail", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    yield* res.ndjson();
  }
  return tail;
});
function createLog(config2) {
  return {
    level: createLevel(config2),
    ls: createLs5(config2),
    tail: createTail(config2)
  };
}
var createPublish2 = configure2((api) => {
  async function publish(path2, options = {}) {
    const res = await api.post("name/publish", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${path2}`,
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return publish;
});
var createResolve5 = configure2((api) => {
  async function* resolve7(path2, options = {}) {
    const res = await api.post("name/resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        stream: true,
        ...options
      }),
      headers: options.headers
    });
    for await (const result of res.ndjson()) {
      yield result.Path;
    }
  }
  return resolve7;
});
var createCancel2 = configure2((api) => {
  async function cancel(name9, options = {}) {
    const res = await api.post("name/pubsub/cancel", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name9,
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return cancel;
});
var createState2 = configure2((api) => {
  async function state(options = {}) {
    const res = await api.post("name/pubsub/state", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return state;
});
var createSubs2 = configure2((api) => {
  async function subs(options = {}) {
    const res = await api.post("name/pubsub/subs", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.Strings || [];
  }
  return subs;
});
function createPubsub(config2) {
  return {
    cancel: createCancel2(config2),
    state: createState2(config2),
    subs: createSubs2(config2)
  };
}
function createName(config2) {
  return {
    publish: createPublish2(config2),
    resolve: createResolve5(config2),
    pubsub: createPubsub(config2)
  };
}
var createData2 = configure2((api) => {
  async function data(cid, options = {}) {
    const res = await api.post("object/data", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
        ...options
      }),
      headers: options.headers
    });
    const data2 = await res.arrayBuffer();
    return new Uint8Array(data2, 0, data2.byteLength);
  }
  return data;
});
var createGet9 = configure2((api) => {
  async function get3(cid, options = {}) {
    const res = await api.post("object/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
        dataEncoding: "base64",
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      Data: fromString3(data.Data, "base64pad"),
      Links: (data.Links || []).map((link) => ({
        Name: link.Name,
        Hash: CID.parse(link.Hash),
        Tsize: link.Size
      }))
    };
  }
  return get3;
});
var createLinks2 = configure2((api) => {
  async function links3(cid, options = {}) {
    const res = await api.post("object/links", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return (data.Links || []).map((l) => ({
      Name: l.Name,
      Tsize: l.Size,
      Hash: CID.parse(l.Hash)
    }));
  }
  return links3;
});
var createNew2 = configure2((api) => {
  async function newObject(options = {}) {
    const res = await api.post("object/new", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: options.template,
        ...options
      }),
      headers: options.headers
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return newObject;
});
var createPut7 = (codecs2, options) => {
  const fn = configure2((api) => {
    const dagPut = createPut5(codecs2, options);
    async function put(obj, options2 = {}) {
      return dagPut(obj, {
        ...options2,
        storeCodec: "dag-pb",
        hashAlg: "sha2-256",
        version: 1
      });
    }
    return put;
  });
  return fn(options);
};
var createStat9 = configure2((api) => {
  async function stat(cid, options = {}) {
    const res = await api.post("object/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid}`,
        ...options
      }),
      headers: options.headers
    });
    const output = await res.json();
    return {
      ...output,
      Hash: CID.parse(output.Hash)
    };
  }
  return stat;
});
var createAddLink2 = configure2((api) => {
  async function addLink2(cid, dLink, options = {}) {
    const res = await api.post("object/patch/add-link", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`,
          // @ts-expect-error loose types
          dLink.Name || dLink.name || "",
          // @ts-expect-error loose types
          (dLink.Hash || dLink.cid || "").toString() || null
        ],
        ...options
      }),
      headers: options.headers
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return addLink2;
});
var createAppendData2 = configure2((api) => {
  async function appendData(cid, data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("object/patch/append-data", {
      signal,
      searchParams: toUrlSearchParams({
        arg: `${cid}`,
        ...options
      }),
      ...await multipartRequest([data], controller, options.headers)
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return appendData;
});
var createRmLink2 = configure2((api) => {
  async function rmLink(cid, dLink, options = {}) {
    const res = await api.post("object/patch/rm-link", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`,
          // @ts-expect-error loose types
          dLink.Name || dLink.name || null
        ],
        ...options
      }),
      headers: options.headers
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return rmLink;
});
var createSetData2 = configure2((api) => {
  async function setData(cid, data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("object/patch/set-data", {
      signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`
        ],
        ...options
      }),
      ...await multipartRequest([data], controller, options.headers)
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return setData;
});
function createPatch(config2) {
  return {
    addLink: createAddLink2(config2),
    appendData: createAppendData2(config2),
    rmLink: createRmLink2(config2),
    setData: createSetData2(config2)
  };
}
function createObject(codecs2, config2) {
  return {
    data: createData2(config2),
    get: createGet9(config2),
    links: createLinks2(config2),
    new: createNew2(config2),
    put: createPut7(codecs2, config2),
    stat: createStat9(config2),
    patch: createPatch(config2)
  };
}
var createAddAll3 = configure2((api) => {
  async function* addAll(source, options = {}) {
    for await (const { path: path2, recursive: recursive2, metadata } of normaliseInput(source)) {
      const res = await api.post("pin/add", {
        signal: options.signal,
        searchParams: toUrlSearchParams({
          ...options,
          arg: path2,
          recursive: recursive2,
          metadata: metadata ? JSON.stringify(metadata) : void 0,
          stream: true
        }),
        headers: options.headers
      });
      for await (const pin of res.ndjson()) {
        if (pin.Pins) {
          for (const cid of pin.Pins) {
            yield CID.parse(cid);
          }
          continue;
        }
        yield CID.parse(pin);
      }
    }
  }
  return addAll;
});
function createAdd5(config2) {
  const all32 = createAddAll3(config2);
  return configure2(() => {
    async function add(path2, options = {}) {
      return last(all32([{
        path: path2,
        ...options
      }], options));
    }
    return add;
  })(config2);
}
function toPin3(type, cid, metadata) {
  const pin = {
    type,
    cid: CID.parse(cid)
  };
  if (metadata) {
    pin.metadata = metadata;
  }
  return pin;
}
var createLs6 = configure2((api) => {
  async function* ls(options = {}) {
    let paths = [];
    if (options.paths) {
      paths = Array.isArray(options.paths) ? options.paths : [options.paths];
    }
    const res = await api.post("pin/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        arg: paths.map((path2) => `${path2}`),
        stream: true
      }),
      headers: options.headers
    });
    for await (const pin of res.ndjson()) {
      if (pin.Keys) {
        for (const cid of Object.keys(pin.Keys)) {
          yield toPin3(pin.Keys[cid].Type, cid, pin.Keys[cid].Metadata);
        }
        return;
      }
      yield toPin3(pin.Type, pin.Cid, pin.Metadata);
    }
  }
  return ls;
});
var createRmAll2 = configure2((api) => {
  async function* rmAll(source, options = {}) {
    for await (const { path: path2, recursive: recursive2 } of normaliseInput(source)) {
      const searchParams = new URLSearchParams(options.searchParams);
      searchParams.append("arg", `${path2}`);
      if (recursive2 != null)
        searchParams.set("recursive", String(recursive2));
      const res = await api.post("pin/rm", {
        signal: options.signal,
        headers: options.headers,
        searchParams: toUrlSearchParams({
          ...options,
          arg: `${path2}`,
          recursive: recursive2
        })
      });
      for await (const pin of res.ndjson()) {
        if (pin.Pins) {
          yield* pin.Pins.map((cid) => CID.parse(cid));
          continue;
        }
        yield CID.parse(pin);
      }
    }
  }
  return rmAll;
});
var createRm10 = (config2) => {
  const all32 = createRmAll2(config2);
  return configure2(() => {
    async function rm(path2, options = {}) {
      return last(all32([{
        path: path2,
        ...options
      }], options));
    }
    return rm;
  })(config2);
};
var decodePin = ({ Name: name9, Status: status, Cid: cid }) => {
  return {
    cid: CID.parse(cid),
    name: name9,
    status
  };
};
var encodeService = (service) => {
  if (typeof service === "string" && service !== "") {
    return service;
  } else {
    throw new TypeError("service name must be passed");
  }
};
var encodeCID = (cid) => {
  if (CID.asCID(cid)) {
    return cid.toString();
  } else {
    throw new TypeError(`CID instance expected instead of ${typeof cid}`);
  }
};
var encodeQuery = ({ service, cid, name: name9, status, all: all32 }) => {
  const query = toUrlSearchParams({
    service: encodeService(service),
    name: name9,
    force: all32 ? true : void 0
  });
  if (cid) {
    for (const value2 of cid) {
      query.append("cid", encodeCID(value2));
    }
  }
  if (status) {
    for (const value2 of status) {
      query.append("status", value2);
    }
  }
  return query;
};
var encodeAddParams = ({ cid, service, background, name: name9, origins }) => {
  const params = toUrlSearchParams({
    arg: encodeCID(cid),
    service: encodeService(service),
    name: name9,
    background: background ? true : void 0
  });
  if (origins) {
    for (const origin of origins) {
      params.append("origin", origin.toString());
    }
  }
  return params;
};
function createAdd6(client) {
  async function add(cid, { timeout, signal, headers, ...query }) {
    const response = await client.post("pin/remote/add", {
      timeout,
      signal,
      headers,
      searchParams: encodeAddParams({ cid, ...query })
    });
    return decodePin(await response.json());
  }
  return add;
}
function createLs7(client) {
  async function* ls({ timeout, signal, headers, ...query }) {
    const response = await client.post("pin/remote/ls", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery(query)
    });
    for await (const pin of response.ndjson()) {
      yield decodePin(pin);
    }
  }
  return ls;
}
function createRm11(client) {
  async function rm({ timeout, signal, headers, ...query }) {
    await client.post("pin/remote/rm", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: false
      })
    });
  }
  return rm;
}
function createRmAll3(client) {
  async function rmAll({ timeout, signal, headers, ...query }) {
    await client.post("pin/remote/rm", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: true
      })
    });
  }
  return rmAll;
}
function encodeEndpoint(url2) {
  const href = String(url2);
  if (href === "undefined") {
    throw Error("endpoint is required");
  }
  return href[href.length - 1] === "/" ? href.slice(0, -1) : href;
}
function decodeRemoteService(json) {
  return {
    service: json.Service,
    endpoint: new URL(json.ApiEndpoint),
    ...json.Stat && { stat: decodeStat(json.Stat) }
  };
}
function decodeStat(json) {
  switch (json.Status) {
    case "valid": {
      const { Pinning, Pinned, Queued, Failed } = json.PinCount;
      return {
        status: "valid",
        pinCount: {
          queued: Queued,
          pinning: Pinning,
          pinned: Pinned,
          failed: Failed
        }
      };
    }
    case "invalid": {
      return { status: "invalid" };
    }
    default: {
      return { status: json.Status };
    }
  }
}
function createAdd7(client) {
  async function add(name9, options) {
    const { endpoint, key, headers, timeout, signal } = options;
    await client.post("pin/remote/service/add", {
      timeout,
      signal,
      searchParams: toUrlSearchParams({
        arg: [name9, encodeEndpoint(endpoint), key]
      }),
      headers
    });
  }
  return add;
}
function createLs8(client) {
  async function ls(options = {}) {
    const { stat, headers, timeout, signal } = options;
    const response = await client.post("pin/remote/service/ls", {
      timeout,
      signal,
      headers,
      searchParams: stat === true ? toUrlSearchParams({ stat }) : void 0
    });
    const { RemoteServices } = await response.json();
    return RemoteServices.map(decodeRemoteService);
  }
  return ls;
}
function createRm12(client) {
  async function rm(name9, options = {}) {
    await client.post("pin/remote/service/rm", {
      signal: options.signal,
      headers: options.headers,
      searchParams: toUrlSearchParams({
        arg: name9
      })
    });
  }
  return rm;
}
function createService(config2) {
  const client = new Client(config2);
  return {
    add: createAdd7(client),
    ls: createLs8(client),
    rm: createRm12(client)
  };
}
function createRemote(config2) {
  const client = new Client(config2);
  return {
    add: createAdd6(client),
    ls: createLs7(client),
    rm: createRm11(client),
    rmAll: createRmAll3(client),
    service: createService(config2)
  };
}
function createPin(config2) {
  return {
    addAll: createAddAll3(config2),
    add: createAdd5(config2),
    ls: createLs6(config2),
    rmAll: createRmAll2(config2),
    rm: createRm10(config2),
    remote: createRemote(config2)
  };
}
var rpcArrayToTextArray = (strings2) => {
  if (Array.isArray(strings2)) {
    return strings2.map(rpcToText);
  }
  return strings2;
};
var rpcToText = (mb) => toString3(rpcToBytes(mb));
var rpcToBytes = (mb) => base64url.decode(mb);
var rpcToBigInt = (mb) => BigInt(`0x${toString3(base64url.decode(mb), "base16")}`);
var textToUrlSafeRpc = (text) => base64url.encode(fromString3(text));
var createLs9 = configure2((api) => {
  async function ls(options = {}) {
    const { Strings } = await (await api.post("pubsub/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return rpcArrayToTextArray(Strings) || [];
  }
  return ls;
});
var createPeers = configure2((api) => {
  async function peers(topic, options = {}) {
    const res = await api.post("pubsub/peers", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: textToUrlSafeRpc(topic),
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return peers;
});
var createPublish3 = configure2((api) => {
  async function publish(topic, data, options = {}) {
    const searchParams = toUrlSearchParams({
      arg: textToUrlSafeRpc(topic),
      ...options
    });
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("pubsub/pub", {
      signal,
      searchParams,
      ...await multipartRequest([data], controller, options.headers)
    });
    await res.text();
  }
  return publish;
});
var log50 = logger("ipfs-http-client:pubsub:subscribe");
var createSubscribe = (options, subsTracker) => {
  return configure2((api) => {
    async function subscribe(topic, handler, options2 = {}) {
      options2.signal = subsTracker.subscribe(topic, handler, options2.signal);
      let done;
      let fail;
      const result = new Promise((resolve7, reject) => {
        done = resolve7;
        fail = reject;
      });
      const ffWorkaround = setTimeout(() => done(), 1e3);
      api.post("pubsub/sub", {
        signal: options2.signal,
        searchParams: toUrlSearchParams({
          arg: textToUrlSafeRpc(topic),
          ...options2
        }),
        headers: options2.headers
      }).catch((err2) => {
        subsTracker.unsubscribe(topic, handler);
        fail(err2);
      }).then((response) => {
        clearTimeout(ffWorkaround);
        if (!response) {
          return;
        }
        readMessages(response, {
          onMessage: (message2) => {
            if (!handler) {
              return;
            }
            if (typeof handler === "function") {
              handler(message2);
              return;
            }
            if (typeof handler.handleEvent === "function") {
              handler.handleEvent(message2);
            }
          },
          onEnd: () => subsTracker.unsubscribe(topic, handler),
          onError: options2.onError
        });
        done();
      });
      return result;
    }
    return subscribe;
  })(options);
};
async function readMessages(response, { onMessage, onEnd, onError }) {
  onError = onError || log50;
  try {
    for await (const msg of response.ndjson()) {
      try {
        if (!msg.from) {
          continue;
        }
        if (msg.from != null && msg.seqno != null) {
          onMessage({
            type: "signed",
            from: peerIdFromString(msg.from),
            data: rpcToBytes(msg.data),
            sequenceNumber: rpcToBigInt(msg.seqno),
            topic: rpcToText(msg.topicIDs[0]),
            key: rpcToBytes(msg.key ?? "u"),
            signature: rpcToBytes(msg.signature ?? "u")
          });
        } else {
          onMessage({
            type: "unsigned",
            data: rpcToBytes(msg.data),
            topic: rpcToText(msg.topicIDs[0])
          });
        }
      } catch (err2) {
        err2.message = `Failed to parse pubsub message: ${err2.message}`;
        onError(err2, false, msg);
      }
    }
  } catch (err2) {
    if (!isAbortError(err2)) {
      onError(err2, true);
    }
  } finally {
    onEnd();
  }
}
var isAbortError = (error) => {
  switch (error.type) {
    case "aborted":
      return true;
    case "abort":
      return true;
    default:
      return error.name === "AbortError";
  }
};
var createUnsubscribe = (options, subsTracker) => {
  async function unsubscribe(topic, handler) {
    subsTracker.unsubscribe(topic, handler);
  }
  return unsubscribe;
};
var SubscriptionTracker = class {
  constructor() {
    this._subs = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} topic
   * @param {MessageHandlerFn} handler
   * @param {AbortSignal} [signal]
   */
  subscribe(topic, handler, signal) {
    const topicSubs = this._subs.get(topic) || [];
    if (topicSubs.find((s) => s.handler === handler)) {
      throw new Error(`Already subscribed to ${topic} with this handler`);
    }
    const controller = new AbortController();
    this._subs.set(topic, [{ handler, controller }].concat(topicSubs));
    if (signal) {
      signal.addEventListener("abort", () => this.unsubscribe(topic, handler));
    }
    return controller.signal;
  }
  /**
   * @param {string} topic
   * @param {MessageHandlerFn} [handler]
   */
  unsubscribe(topic, handler) {
    const subs = this._subs.get(topic) || [];
    let unsubs;
    if (handler) {
      this._subs.set(topic, subs.filter((s) => s.handler !== handler));
      unsubs = subs.filter((s) => s.handler === handler);
    } else {
      this._subs.set(topic, []);
      unsubs = subs;
    }
    if (!(this._subs.get(topic) || []).length) {
      this._subs.delete(topic);
    }
    unsubs.forEach((s) => s.controller.abort());
  }
};
function createPubsub2(config2) {
  const subscriptionTracker = new SubscriptionTracker();
  return {
    ls: createLs9(config2),
    peers: createPeers(config2),
    publish: createPublish3(config2),
    subscribe: createSubscribe(config2, subscriptionTracker),
    unsubscribe: createUnsubscribe(config2, subscriptionTracker)
  };
}
var createLocal2 = configure2((api) => {
  async function* refsLocal(options = {}) {
    const res = await api.post("refs/local", {
      signal: options.signal,
      transform: objectToCamel,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    yield* res.ndjson();
  }
  return refsLocal;
});
var createRefs2 = configure2((api, opts) => {
  const refs = async function* (args, options = {}) {
    const argsArr = Array.isArray(args) ? args : [args];
    const res = await api.post("refs", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: argsArr.map((arg) => `${arg instanceof Uint8Array ? CID.decode(arg) : arg}`),
        ...options
      }),
      headers: options.headers,
      transform: objectToCamel
    });
    yield* res.ndjson();
  };
  return Object.assign(refs, {
    local: createLocal2(opts)
  });
});
var createGc2 = configure2((api) => {
  async function* gc2(options = {}) {
    const res = await api.post("repo/gc", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers,
      transform: (res2) => {
        return {
          err: res2.Error ? new Error(res2.Error) : null,
          cid: (res2.Key || {})["/"] ? CID.parse(res2.Key["/"]) : null
        };
      }
    });
    yield* res.ndjson();
  }
  return gc2;
});
var createStat10 = configure2((api) => {
  async function stat(options = {}) {
    const res = await api.post("repo/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return {
      numObjects: BigInt(data.NumObjects),
      repoSize: BigInt(data.RepoSize),
      repoPath: data.RepoPath,
      version: data.Version,
      storageMax: BigInt(data.StorageMax)
    };
  }
  return stat;
});
var createVersion3 = configure2((api) => {
  async function version3(options = {}) {
    const res = await (await api.post("repo/version", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return res.Version;
  }
  return version3;
});
function createRepo3(config2) {
  return {
    gc: createGc2(config2),
    stat: createStat10(config2),
    version: createVersion3(config2)
  };
}
var createBw2 = configure2((api) => {
  async function* bw(options = {}) {
    const res = await api.post("stats/bw", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers,
      transform: (stats) => ({
        totalIn: BigInt(stats.TotalIn),
        totalOut: BigInt(stats.TotalOut),
        rateIn: parseFloat(stats.RateIn),
        rateOut: parseFloat(stats.RateOut)
      })
    });
    yield* res.ndjson();
  }
  return bw;
});
function createStats(config2) {
  return {
    bitswap: createStat6(config2),
    repo: createStat10(config2),
    bw: createBw2(config2)
  };
}
var createAddrs = configure2((api) => {
  async function addrs(options = {}) {
    const res = await api.post("swarm/addrs", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Addrs } = await res.json();
    return Object.keys(Addrs).map((id) => ({
      id: peerIdFromString(id),
      addrs: (Addrs[id] || []).map((a) => multiaddr(a))
    }));
  }
  return addrs;
});
var createConnect = configure2((api) => {
  async function connect2(addr, options = {}) {
    const res = await api.post("swarm/connect", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return connect2;
});
var createDisconnect = configure2((api) => {
  async function disconnect(addr, options = {}) {
    const res = await api.post("swarm/disconnect", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return disconnect;
});
var createLocalAddrs = configure2((api) => {
  async function localAddrs(options = {}) {
    const res = await api.post("swarm/addrs/local", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return (Strings || []).map((a) => multiaddr(a));
  }
  return localAddrs;
});
var createPeers2 = configure2((api) => {
  async function peers(options = {}) {
    const res = await api.post("swarm/peers", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return (Peers || []).map((peer) => {
      return {
        addr: multiaddr(peer.Addr),
        peer: peerIdFromString(peer.Peer),
        muxer: peer.Muxer,
        latency: peer.Latency,
        streams: peer.Streams,
        direction: peer.Direction == null ? void 0 : peer.Direction === 0 ? "inbound" : "outbound"
      };
    });
  }
  return peers;
});
function createSwarm(config2) {
  return {
    addrs: createAddrs(config2),
    connect: createConnect(config2),
    disconnect: createDisconnect(config2),
    localAddrs: createLocalAddrs(config2),
    peers: createPeers2(config2)
  };
}
var createAddAll4 = configure2((api) => {
  async function* addAll(source, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const { headers, body, total, parts: parts2 } = await multipartRequest(source, controller, options.headers);
    const [progressFn, onUploadProgress] = typeof options.progress === "function" ? createProgressHandler(total, parts2, options.progress) : [void 0, void 0];
    const res = await api.post("add", {
      searchParams: toUrlSearchParams({
        "stream-channels": true,
        ...options,
        progress: Boolean(progressFn)
      }),
      onUploadProgress,
      signal,
      headers,
      body
    });
    for await (let file of res.ndjson()) {
      file = objectToCamel(file);
      if (file.hash !== void 0) {
        yield toCoreInterface5(file);
      } else if (progressFn) {
        progressFn(file.bytes || 0, file.name);
      }
    }
  }
  return addAll;
});
var createProgressHandler = (total, parts2, progress) => parts2 ? [void 0, createOnUploadProgress(total, parts2, progress)] : [progress, void 0];
var createOnUploadProgress = (size, parts2, progress) => {
  let index2 = 0;
  const count = parts2.length;
  return ({ loaded, total }) => {
    const position = Math.floor(loaded / total * size);
    while (index2 < count) {
      const { start, end, name: name9 } = parts2[index2];
      if (position < end) {
        progress(position - start, name9);
        break;
      } else {
        progress(end - start, name9);
        index2 += 1;
      }
    }
  };
};
function toCoreInterface5({ name: name9, hash: hash3, size, mode, mtime, mtimeNsecs }) {
  const output = {
    path: name9,
    cid: CID.parse(hash3),
    size: parseInt(size)
  };
  if (mode != null) {
    output.mode = parseInt(mode, 8);
  }
  if (mtime != null) {
    output.mtime = {
      secs: mtime,
      nsecs: mtimeNsecs || 0
    };
  }
  return output;
}
function createAdd8(options) {
  const all32 = createAddAll4(options);
  return configure2(() => {
    async function add(input, options2 = {}) {
      return await last(all32(normaliseInput2(input), options2));
    }
    return add;
  })(options);
}
var createCat2 = configure2((api) => {
  async function* cat(path2, options = {}) {
    const res = await api.post("cat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2.toString(),
        ...options
      }),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return cat;
});
var createCommands = configure2((api) => {
  const commands = async (options = {}) => {
    const res = await api.post("commands", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  };
  return commands;
});
var createDns2 = configure2((api) => {
  const dns = async (domain, options = {}) => {
    const res = await api.post("dns", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: domain,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data.Path;
  };
  return dns;
});
var createGetEndpointConfig = configure2((api) => {
  return () => {
    const url2 = new URL(api.opts.base || "");
    return {
      host: url2.hostname,
      port: url2.port,
      protocol: url2.protocol,
      pathname: url2.pathname,
      "api-path": url2.pathname
    };
  };
});
var createGet10 = configure2((api) => {
  async function* get3(path2, options = {}) {
    const opts = {
      arg: `${path2 instanceof Uint8Array ? CID.decode(path2) : path2}`,
      ...options
    };
    if (opts.compressionLevel) {
      opts["compression-level"] = opts.compressionLevel;
      delete opts.compressionLevel;
    }
    const res = await api.post("get", {
      signal: options.signal,
      searchParams: toUrlSearchParams(opts),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return get3;
});
var createId2 = configure2((api) => {
  async function id(options = {}) {
    const res = await api.post("id", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: options.peerId ? options.peerId.toString() : void 0,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    const output = {
      ...objectToCamel(data)
    };
    output.id = peerIdFromString(output.id);
    if (output.addresses) {
      output.addresses = output.addresses.map((ma) => multiaddr(ma));
    }
    return output;
  }
  return id;
});
var createIsOnline2 = (options) => {
  const id = createId2(options);
  async function isOnline(options2 = {}) {
    const res = await id(options2);
    return Boolean(res && res.addresses && res.addresses.length);
  }
  return isOnline;
};
var createLs10 = configure2((api, opts) => {
  async function* ls(path2, options = {}) {
    const pathStr = `${path2 instanceof Uint8Array ? CID.decode(path2) : path2}`;
    async function mapLink(link) {
      let hash3 = link.Hash;
      if (hash3.includes("/")) {
        const ipfsPath3 = hash3.startsWith("/ipfs/") ? hash3 : `/ipfs/${hash3}`;
        const stats = await createStat8(opts)(ipfsPath3);
        hash3 = stats.cid;
      } else {
        hash3 = CID.parse(hash3);
      }
      const entry = {
        name: link.Name,
        path: pathStr + (link.Name ? `/${link.Name}` : ""),
        size: link.Size,
        cid: hash3,
        type: typeOf(link)
      };
      if (link.Mode) {
        entry.mode = parseInt(link.Mode, 8);
      }
      if (link.Mtime !== void 0 && link.Mtime !== null) {
        entry.mtime = {
          secs: link.Mtime
        };
        if (link.MtimeNsecs !== void 0 && link.MtimeNsecs !== null) {
          entry.mtime.nsecs = link.MtimeNsecs;
        }
      }
      return entry;
    }
    const res = await api.post("ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: pathStr,
        ...options
      }),
      headers: options.headers
    });
    for await (let result of res.ndjson()) {
      result = result.Objects;
      if (!result) {
        throw new Error("expected .Objects in results");
      }
      result = result[0];
      if (!result) {
        throw new Error("expected one array in results.Objects");
      }
      const links3 = result.Links;
      if (!Array.isArray(links3)) {
        throw new Error("expected one array in results.Objects[0].Links");
      }
      if (!links3.length) {
        yield mapLink(result);
        return;
      }
      yield* links3.map(mapLink);
    }
  }
  return ls;
});
function typeOf(link) {
  switch (link.Type) {
    case 1:
    case 5:
      return "dir";
    case 2:
      return "file";
    default:
      return "file";
  }
}
var createMount = configure2((api) => {
  async function mount(options = {}) {
    const res = await api.post("dns", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return mount;
});
var createPing = configure2((api) => {
  async function* ping(peerId, options = {}) {
    const res = await api.post("ping", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${peerId}`,
        ...options
      }),
      headers: options.headers,
      transform: objectToCamel
    });
    yield* res.ndjson();
  }
  return ping;
});
var createResolve6 = configure2((api) => {
  async function resolve7(path2, options = {}) {
    const res = await api.post("resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path2,
        ...options
      }),
      headers: options.headers
    });
    const { Path } = await res.json();
    return Path;
  }
  return resolve7;
});
var import_err_code85 = __toESM(require_err_code(), 1);
var createStart2 = configure2((api) => {
  const start = async (options = {}) => {
    throw (0, import_err_code85.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return start;
});
var createStop2 = configure2((api) => {
  async function stop2(options = {}) {
    const res = await api.post("shutdown", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    await res.text();
  }
  return stop2;
});
var createVersion4 = configure2((api) => {
  async function version3(options = {}) {
    const res = await api.post("version", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return {
      ...objectToCamel(await res.json()),
      "ipfs-http-client": "1.0.0"
    };
  }
  return version3;
});
__toESM(require_glob_source());
__toESM(require_url_source());
function create7(options = {}) {
  const id = {
    name: identity.name,
    code: identity.code,
    encode: (id2) => id2,
    decode: (id2) => id2
  };
  const multibaseCodecs = Object.values(bases);
  (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach((base3) => multibaseCodecs.push(base3));
  const multibases = new Multibases({
    bases: multibaseCodecs,
    loadBase: options.ipld && options.ipld.loadBase
  });
  const blockCodecs = Object.values(codecs);
  [src_exports, src_exports2, src_exports3, lib_exports, id].concat(options.ipld && options.ipld.codecs || []).forEach((codec) => blockCodecs.push(codec));
  const multicodecs = new Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  });
  const multihashHashers = Object.values(hashes);
  (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach((hasher) => multihashHashers.push(hasher));
  const multihashes = new Multihashes({
    hashers: multihashHashers,
    loadHasher: options.ipld && options.ipld.loadHasher
  });
  const client = {
    add: createAdd8(options),
    addAll: createAddAll4(options),
    bitswap: createBitswap(options),
    block: createBlock(options),
    bootstrap: createBootstrap(options),
    cat: createCat2(options),
    commands: createCommands(options),
    config: createConfig2(options),
    dag: createDag(multicodecs, options),
    dht: createDht(options),
    diag: createDiag(options),
    dns: createDns2(options),
    files: createFiles2(options),
    get: createGet10(options),
    getEndpointConfig: createGetEndpointConfig(options),
    id: createId2(options),
    isOnline: createIsOnline2(options),
    key: createKey(options),
    log: createLog(options),
    ls: createLs10(options),
    mount: createMount(options),
    name: createName(options),
    object: createObject(multicodecs, options),
    pin: createPin(options),
    ping: createPing(options),
    pubsub: createPubsub2(options),
    refs: createRefs2(options),
    repo: createRepo3(options),
    resolve: createResolve6(options),
    start: createStart2(options),
    stats: createStats(options),
    stop: createStop2(options),
    swarm: createSwarm(options),
    version: createVersion4(options),
    bases: multibases,
    codecs: multicodecs,
    hashers: multihashes
  };
  return client;
}
var import_err_code90 = __toESM(require_err_code(), 1);
var CODE_P2P = 421;
var CODE_CIRCUIT = 290;
var CLOSE_TIMEOUT = 2e3;
var import_err_code89 = __toESM(require_err_code(), 1);
var PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
var ERROR_PACKET = { type: "error", data: "parser error" };
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
var encodePacket = ({ type, data }, supportsBinary, callback) => {
  if (withNativeBlob && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type] + (data || ""));
};
var encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data);
};
var encodePacket_browser_default = encodePacket;
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i2 = 0; i2 < chars.length; i2++) {
  lookup[chars.charCodeAt(i2)] = i2;
}
var decode15 = (base642) => {
  let bufferLength = base642.length * 0.75, len = base642.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes2 = new Uint8Array(arraybuffer);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup[base642.charCodeAt(i2)];
    encoded2 = lookup[base642.charCodeAt(i2 + 1)];
    encoded3 = lookup[base642.charCodeAt(i2 + 2)];
    encoded4 = lookup[base642.charCodeAt(i2 + 3)];
    bytes2[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes2[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes2[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
var withNativeArrayBuffer2 = typeof ArrayBuffer === "function";
var decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
var decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer2) {
    const decoded = decode15(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
var mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      return data instanceof ArrayBuffer ? new Blob([data]) : data;
    case "arraybuffer":
    default:
      return data;
  }
};
var decodePacket_browser_default = decodePacket;
var SEPARATOR = String.fromCharCode(30);
var encodePayload = (packets, callback) => {
  const length3 = packets.length;
  const encodedPackets = new Array(length3);
  let count = 0;
  packets.forEach((packet, i2) => {
    encodePacket_browser_default(packet, false, (encodedPacket) => {
      encodedPackets[i2] = encodedPacket;
      if (++count === length3) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
var decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i2 = 0; i2 < encodedPackets.length; i2++) {
    const decodedPacket = decodePacket_browser_default(encodedPackets[i2], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
var protocol = 4;
function Emitter(obj) {
  if (obj)
    return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on2() {
    this.off(event, on2);
    fn.apply(this, arguments);
  }
  on2.fn = fn;
  this.on(event, on2);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks)
    return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i2 = 0; i2 < callbacks.length; i2++) {
    cb = callbacks[i2];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i2, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i2 = 1; i2 < arguments.length; i2++) {
    args[i2 - 1] = arguments[i2];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i2 = 0, len = callbacks.length; i2 < len; ++i2) {
      callbacks[i2].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};
var globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
function pick(obj, ...attr) {
  return attr.reduce((acc, k) => {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
}
var NATIVE_SET_TIMEOUT = setTimeout;
var NATIVE_CLEAR_TIMEOUT = clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = clearTimeout.bind(globalThisShim);
  }
}
var BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c = 0, length3 = 0;
  for (let i2 = 0, l = str.length; i2 < l; i2++) {
    c = str.charCodeAt(i2);
    if (c < 128) {
      length3 += 1;
    } else if (c < 2048) {
      length3 += 2;
    } else if (c < 55296 || c >= 57344) {
      length3 += 3;
    } else {
      i2++;
      length3 += 4;
    }
  }
  return length3;
}
var TransportError = class extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
};
var Transport = class extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} options.
   * @api private
   */
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.readyState = "";
    this.socket = opts.socket;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @api protected
   */
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  /**
   * Opens the transport.
   *
   * @api public
   */
  open() {
    if ("closed" === this.readyState || "" === this.readyState) {
      this.readyState = "opening";
      this.doOpen();
    }
    return this;
  }
  /**
   * Closes the transport.
   *
   * @api public
   */
  close() {
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   * @api public
   */
  send(packets) {
    if ("open" === this.readyState) {
      this.write(packets);
    }
  }
  /**
   * Called upon open
   *
   * @api protected
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @api protected
   */
  onData(data) {
    const packet = decodePacket_browser_default(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   *
   * @api protected
   */
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @api protected
   */
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
};
var alphabet2 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
var length2 = 64;
var map2 = {};
var seed = 0;
var i = 0;
var prev;
function encode16(num) {
  let encoded = "";
  do {
    encoded = alphabet2[num % length2] + encoded;
    num = Math.floor(num / length2);
  } while (num > 0);
  return encoded;
}
function yeast() {
  const now = encode16(+new Date());
  if (now !== prev)
    return seed = 0, prev = now;
  return now + "." + encode16(seed++);
}
for (; i < length2; i++)
  map2[alphabet2[i]] = i;
function encode17(obj) {
  let str = "";
  for (let i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i2) + "=" + encodeURIComponent(obj[i2]);
    }
  }
  return str;
}
function decode16(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i2 = 0, l = pairs.length; i2 < l; i2++) {
    let pair2 = pairs[i2].split("=");
    qry[decodeURIComponent(pair2[0])] = decodeURIComponent(pair2[1]);
  }
  return qry;
}
var value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err2) {
}
var hasCORS = value;
function XHR(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {
    }
  }
}
function empty() {
}
var hasXHR2 = function() {
  const xhr = new XHR({
    xdomain: false
  });
  return null != xhr.responseType;
}();
var Polling = class extends Transport {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @api public
   */
  constructor(opts) {
    super(opts);
    this.polling = false;
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
      this.xs = opts.secure !== isSSL;
    }
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }
  /**
   * Transport name.
   */
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @api private
   */
  doOpen() {
    this.poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} callback upon buffers are flushed and transport is paused
   * @api private
   */
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this.polling || !this.writable) {
      let total = 0;
      if (this.polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @api public
   */
  poll() {
    this.polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @api private
   */
  onData(data) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this.polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this.poll();
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @api private
   */
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} data packets
   * @param {Function} drain callback
   * @api private
   */
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @api private
   */
  uri() {
    let query = this.query || {};
    const schema = this.opts.secure ? "https" : "http";
    let port = "";
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    if (this.opts.port && ("https" === schema && Number(this.opts.port) !== 443 || "http" === schema && Number(this.opts.port) !== 80)) {
      port = ":" + this.opts.port;
    }
    const encodedQuery = encode17(query);
    const ipv6 = this.opts.hostname.indexOf(":") !== -1;
    return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
  }
  /**
   * Creates a request.
   *
   * @param {String} method
   * @api private
   */
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
    return new Request(this.uri(), opts);
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @api private
   */
  doWrite(data, fn) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @api private
   */
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
};
var Request = class extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @api public
   */
  constructor(uri, opts) {
    super();
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.method = opts.method || "GET";
    this.uri = uri;
    this.async = false !== opts.async;
    this.data = void 0 !== opts.data ? opts.data : null;
    this.create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @api private
   */
  create() {
    const opts = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this.opts.xd;
    opts.xscheme = !!this.opts.xs;
    const xhr = this.xhr = new XHR(opts);
    try {
      xhr.open(this.method, this.uri, this.async);
      try {
        if (this.opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i2 in this.opts.extraHeaders) {
            if (this.opts.extraHeaders.hasOwnProperty(i2)) {
              xhr.setRequestHeader(i2, this.opts.extraHeaders[i2]);
            }
          }
        }
      } catch (e) {
      }
      if ("POST" === this.method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e) {
      }
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this.opts.withCredentials;
      }
      if (this.opts.requestTimeout) {
        xhr.timeout = this.opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this.onLoad();
        } else {
          this.setTimeoutFn(() => {
            this.onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this.data);
    } catch (e) {
      this.setTimeoutFn(() => {
        this.onError(e);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this.index = Request.requestsCount++;
      Request.requests[this.index] = this;
    }
  }
  /**
   * Called upon error.
   *
   * @api private
   */
  onError(err2) {
    this.emitReserved("error", err2, this.xhr);
    this.cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @api private
   */
  cleanup(fromError) {
    if ("undefined" === typeof this.xhr || null === this.xhr) {
      return;
    }
    this.xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this.xhr.abort();
      } catch (e) {
      }
    }
    if (typeof document !== "undefined") {
      delete Request.requests[this.index];
    }
    this.xhr = null;
  }
  /**
   * Called upon load.
   *
   * @api private
   */
  onLoad() {
    const data = this.xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this.cleanup();
    }
  }
  /**
   * Aborts the request.
   *
   * @api public
   */
  abort() {
    this.cleanup();
  }
};
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i2 in Request.requests) {
    if (Request.requests.hasOwnProperty(i2)) {
      Request.requests[i2].abort();
    }
  }
}
var nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
var WebSocket2 = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
var usingBrowserWebSocket = true;
var defaultBinaryType = "arraybuffer";
var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
var WS = class extends Transport {
  /**
   * WebSocket transport constructor.
   *
   * @api {Object} connection options
   * @api public
   */
  constructor(opts) {
    super(opts);
    this.supportsBinary = !opts.forceBase64;
  }
  /**
   * Transport name.
   *
   * @api public
   */
  get name() {
    return "websocket";
  }
  /**
   * Opens socket.
   *
   * @api private
   */
  doOpen() {
    if (!this.check()) {
      return;
    }
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket2(uri, protocols) : new WebSocket2(uri) : new WebSocket2(uri, protocols, opts);
    } catch (err2) {
      return this.emitReserved("error", err2);
    }
    this.ws.binaryType = this.socket.binaryType || defaultBinaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @api private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  /**
   * Writes data to socket.
   *
   * @param {Array} array of packets.
   * @api private
   */
  write(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      encodePacket_browser_default(packet, this.supportsBinary, (data) => {
        const opts = {};
        try {
          if (usingBrowserWebSocket) {
            this.ws.send(data);
          }
        } catch (e) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  /**
   * Closes socket.
   *
   * @api private
   */
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @api private
   */
  uri() {
    let query = this.query || {};
    const schema = this.opts.secure ? "wss" : "ws";
    let port = "";
    if (this.opts.port && ("wss" === schema && Number(this.opts.port) !== 443 || "ws" === schema && Number(this.opts.port) !== 80)) {
      port = ":" + this.opts.port;
    }
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    const encodedQuery = encode17(query);
    const ipv6 = this.opts.hostname.indexOf(":") !== -1;
    return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
  }
  /**
   * Feature detection for WebSocket.
   *
   * @return {Boolean} whether this transport is available.
   * @api public
   */
  check() {
    return !!WebSocket2;
  }
};
var transports = {
  websocket: WS,
  polling: Polling
};
var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse3(str) {
  const src2 = str, b = str.indexOf("["), e = str.indexOf("]");
  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
  }
  let m = re.exec(str || ""), uri = {}, i2 = 14;
  while (i2--) {
    uri[parts[i2]] = m[i2] || "";
  }
  if (b != -1 && e != -1) {
    uri.source = src2;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path2) {
  const regx = /\/{2,9}/g, names3 = path2.replace(regx, "/").split("/");
  if (path2.slice(0, 1) == "/" || path2.length === 0) {
    names3.splice(0, 1);
  }
  if (path2.slice(-1) == "/") {
    names3.splice(names3.length - 1, 1);
  }
  return names3;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}
var Socket = class extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri or options
   * @param {Object} opts - options
   * @api public
   */
  constructor(uri, opts = {}) {
    super();
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      uri = parse3(uri);
      opts.hostname = uri.host;
      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
      opts.port = uri.port;
      if (uri.query)
        opts.query = uri.query;
    } else if (opts.host) {
      opts.hostname = parse3(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = opts.transports || ["polling", "websocket"];
    this.readyState = "";
    this.writeBuffer = [];
    this.prevBufferLen = 0;
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: true
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + "/";
    if (typeof this.opts.query === "string") {
      this.opts.query = decode16(this.opts.query);
    }
    this.id = null;
    this.upgrades = null;
    this.pingInterval = null;
    this.pingTimeout = null;
    this.pingTimeoutTimer = null;
    if (typeof addEventListener === "function") {
      if (this.opts.closeOnBeforeunload) {
        this.beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this.beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this.offlineEventListener = () => {
          this.onClose("transport close", {
            description: "network connection lost"
          });
        };
        addEventListener("offline", this.offlineEventListener, false);
      }
    }
    this.open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} transport name
   * @return {Transport}
   * @api private
   */
  createTransport(name9) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol;
    query.transport = name9;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts.transportOptions[name9], this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    });
    return new transports[name9](opts);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @api private
   */
  open() {
    let transport;
    if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
      transport = "websocket";
    } else if (0 === this.transports.length) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else {
      transport = this.transports[0];
    }
    this.readyState = "opening";
    try {
      transport = this.createTransport(transport);
    } catch (e) {
      this.transports.shift();
      this.open();
      return;
    }
    transport.open();
    this.setTransport(transport);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @api private
   */
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason) => this.onClose("transport close", reason));
  }
  /**
   * Probes a transport.
   *
   * @param {String} transport name
   * @api private
   */
  probe(name9) {
    let transport = this.createTransport(name9);
    let failed = false;
    Socket.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          Socket.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err2 = new Error("probe error");
          err2.transport = transport.name;
          this.emitReserved("upgradeError", err2);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err2) => {
      const error = new Error("probe error: " + err2);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    transport.open();
  }
  /**
   * Called when connection is deemed open.
   *
   * @api private
   */
  onOpen() {
    this.readyState = "open";
    Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
    if ("open" === this.readyState && this.opts.upgrade && this.transport.pause) {
      let i2 = 0;
      const l = this.upgrades.length;
      for (; i2 < l; i2++) {
        this.probe(this.upgrades[i2]);
      }
    }
  }
  /**
   * Handles a packet.
   *
   * @api private
   */
  onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this.resetPingTimeout();
          this.sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          break;
        case "error":
          const err2 = new Error("server error");
          err2.code = packet.data;
          this.onError(err2);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @api private
   */
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this.upgrades = this.filterUpgrades(data.upgrades);
    this.pingInterval = data.pingInterval;
    this.pingTimeout = data.pingTimeout;
    this.maxPayload = data.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this.resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @api private
   */
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer);
    this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout);
    if (this.opts.autoUnref) {
      this.pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @api private
   */
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen);
    this.prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @api private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this.getWritablePackets();
      this.transport.send(packets);
      this.prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  getWritablePackets() {
    const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i2 = 0; i2 < this.writeBuffer.length; i2++) {
      const data = this.writeBuffer[i2].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i2 > 0 && payloadSize > this.maxPayload) {
        return this.writeBuffer.slice(0, i2);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Sends a message.
   *
   * @param {String} message.
   * @param {Function} callback function.
   * @param {Object} options.
   * @return {Socket} for chaining.
   * @api public
   */
  write(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }
  send(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} callback function.
   * @api private
   */
  sendPacket(type, data, options, fn) {
    if ("function" === typeof data) {
      fn = data;
      data = void 0;
    }
    if ("function" === typeof options) {
      fn = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn)
      this.once("flush", fn);
    this.flush();
  }
  /**
   * Closes the connection.
   *
   * @api public
   */
  close() {
    const close = () => {
      this.onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @api private
   */
  onError(err2) {
    Socket.priorWebsocketSuccess = false;
    this.emitReserved("error", err2);
    this.onClose("transport error", err2);
  }
  /**
   * Called upon transport close.
   *
   * @api private
   */
  onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this.pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (typeof removeEventListener === "function") {
        removeEventListener("beforeunload", this.beforeunloadEventListener, false);
        removeEventListener("offline", this.offlineEventListener, false);
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this.prevBufferLen = 0;
    }
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} server upgrades
   * @api private
   *
   */
  filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    let i2 = 0;
    const j = upgrades.length;
    for (; i2 < j; i2++) {
      if (~this.transports.indexOf(upgrades[i2]))
        filteredUpgrades.push(upgrades[i2]);
    }
    return filteredUpgrades;
  }
};
Socket.protocol = protocol;
function url(uri, path2 = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse3(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path2;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
var esm_exports3 = {};
__export(esm_exports3, {
  Decoder: () => Decoder,
  Encoder: () => Encoder,
  PacketType: () => PacketType,
  protocol: () => protocol3
});
var withNativeArrayBuffer3 = typeof ArrayBuffer === "function";
var isView2 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
var toString6 = Object.prototype.toString;
var withNativeBlob2 = typeof Blob === "function" || typeof Blob !== "undefined" && toString6.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString6.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer3 && (obj instanceof ArrayBuffer || isView2(obj)) || withNativeBlob2 && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON2) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i2 = 0, l = obj.length; i2 < l; i2++) {
      if (hasBinary(obj[i2])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack2 = packet;
  pack2.data = _deconstructPacket(packetData, buffers);
  pack2.attachments = buffers.length;
  return { packet: pack2, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i2 = 0; i2 < data.length; i2++) {
      newData[i2] = _deconstructPacket(data[i2], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i2 = 0; i2 < data.length; i2++) {
      data[i2] = _reconstructPacket(data[i2], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}
var protocol3 = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
var Encoder = class {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(replacer) {
    this.replacer = replacer;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack2 = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack2);
    return buffers;
  }
};
var Decoder = class extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(str) {
    let i2 = 0;
    const p = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p.type] === void 0) {
      throw new Error("unknown packet type " + p.type);
    }
    if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
      const start = i2 + 1;
      while (str.charAt(++i2) !== "-" && i2 != str.length) {
      }
      const buf2 = str.substring(start, i2);
      if (buf2 != Number(buf2) || str.charAt(i2) !== "-") {
        throw new Error("Illegal attachments");
      }
      p.attachments = Number(buf2);
    }
    if ("/" === str.charAt(i2 + 1)) {
      const start = i2 + 1;
      while (++i2) {
        const c = str.charAt(i2);
        if ("," === c)
          break;
        if (i2 === str.length)
          break;
      }
      p.nsp = str.substring(start, i2);
    } else {
      p.nsp = "/";
    }
    const next = str.charAt(i2 + 1);
    if ("" !== next && Number(next) == next) {
      const start = i2 + 1;
      while (++i2) {
        const c = str.charAt(i2);
        if (null == c || Number(c) != c) {
          --i2;
          break;
        }
        if (i2 === str.length)
          break;
      }
      p.id = Number(str.substring(start, i2 + 1));
    }
    if (str.charAt(++i2)) {
      const payload = this.tryParse(str.substr(i2));
      if (Decoder.isPayloadValid(p.type, payload)) {
        p.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e) {
      return false;
    }
  }
  static isPayloadValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return typeof payload === "object";
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || typeof payload === "object";
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && payload.length > 0;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
};
var BinaryReconstructor = class {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
};
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}
var RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
var Socket2 = class extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(ev, ...args) {
    if (RESERVED_EVENTS.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
    if (discardPacket)
      ;
    else if (this.connected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * @private
   */
  _registerAckCallback(id, ack) {
    const timeout = this.flags.timeout;
    if (timeout === void 0) {
      this.acks[id] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i2 = 0; i2 < this.sendBuffer.length; i2++) {
        if (this.sendBuffer[i2].id === id) {
          this.sendBuffer.splice(i2, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    this.acks[id] = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, [null, ...args]);
    };
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this.packet({ type: PacketType.CONNECT, data });
      });
    } else {
      this.packet({ type: PacketType.CONNECT, data: this.auth });
    }
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err2) {
    if (!this.connected) {
      this.emitReserved("connect_error", err2);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          const id = packet.data.sid;
          this.onconnect(id);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err2 = new Error(packet.data.message);
        err2.data = packet.data.data;
        this.emitReserved("connect_error", err2);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowlegement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if ("function" === typeof ack) {
      ack.apply(this, packet.data);
      delete this.acks[packet.id];
    }
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id) {
    this.id = id;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i2 = 0; i2 < listeners.length; i2++) {
        if (listener === listeners[i2]) {
          listeners.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i2 = 0; i2 < listeners.length; i2++) {
        if (listener === listeners[i2]) {
          listeners.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
};
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff.prototype.setMax = function(max) {
  this.max = max;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};
var Manager = class extends Emitter {
  constructor(uri, opts) {
    var _a3;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a3 = opts.randomizationFactor) !== null && _a3 !== void 0 ? _a3 : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || esm_exports3;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v;
    return this;
  }
  reconnectionAttempts(v) {
    if (v === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v;
    return this;
  }
  reconnectionDelay(v) {
    var _a3;
    if (v === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v;
    (_a3 = this.backoff) === null || _a3 === void 0 ? void 0 : _a3.setMin(v);
    return this;
  }
  randomizationFactor(v) {
    var _a3;
    if (v === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v;
    (_a3 = this.backoff) === null || _a3 === void 0 ? void 0 : _a3.setJitter(v);
    return this;
  }
  reconnectionDelayMax(v) {
    var _a3;
    if (v === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v;
    (_a3 = this.backoff) === null || _a3 === void 0 ? void 0 : _a3.setMax(v);
    return this;
  }
  timeout(v) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket, "open", function() {
      self2.onopen();
      fn && fn();
    });
    const errorSub = on(socket, "error", (err2) => {
      self2.cleanup();
      self2._readyState = "closed";
      this.emitReserved("error", err2);
      if (fn) {
        fn(err2);
      } else {
        self2.maybeReconnectOnOpen();
      }
    });
    if (false !== this._timeout) {
      const timeout = this._timeout;
      if (timeout === 0) {
        openSubDestroy();
      }
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        socket.close();
        socket.emit("error", new Error("timeout"));
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(function subDestroy() {
        clearTimeout(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn) {
    return this.open(fn);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err2) {
    this.emitReserved("error", err2);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket;
    }
    return socket;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i2 = 0; i2 < encodedPackets.length; i2++) {
      this.engine.write(encodedPackets[i2], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
    if (this.engine)
      this.engine.close();
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called upon engine close.
   *
   * @private
   */
  onclose(reason, description) {
    this.cleanup();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay3 = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err2) => {
          if (err2) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err2);
          } else {
            self2.onreconnect();
          }
        });
      }, delay3);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(function subDestroy() {
        clearTimeout(timer);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
};
var cache2 = {};
function lookup2(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path2 = parsed.path;
  const sameNamespace = cache2[id] && path2 in cache2[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source, opts);
  } else {
    if (!cache2[id]) {
      cache2[id] = new Manager(source, opts);
    }
    io = cache2[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup2, {
  Manager,
  Socket: Socket2,
  io: lookup2,
  connect: lookup2
});
var import_err_code87 = __toESM(require_err_code(), 1);
var import_random = __toESM(require_random_browser(), 1);
var import_err_code86 = __toESM(require_err_code(), 1);
var MAX_BUFFERED_AMOUNT = 64 * 1024;
var CHANNEL_CLOSING_TIMEOUT = 5 * 1e3;
var WebRTCDataChannel = class {
  constructor(channel, opts) {
    this.label = channel.label;
    this.open = pDefer();
    this.channel = channel;
    this.channel.binaryType = "arraybuffer";
    this.log = opts.log;
    if (typeof this.channel.bufferedAmountLowThreshold === "number") {
      this.channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;
    }
    channel.addEventListener("message", (event) => {
      opts.onMessage(event);
    });
    channel.addEventListener("bufferedamountlow", () => {
      this.log("stop backpressure: bufferedAmount %d", this.channel.bufferedAmount);
      this.open.resolve();
    });
    channel.addEventListener("open", () => {
      this.open.resolve();
      opts.onOpen();
    });
    channel.addEventListener("close", () => {
      opts.onClose();
    });
    channel.addEventListener("error", (event) => {
      if (event.error?.message === "Transport channel closed") {
        return this.close();
      }
      opts.log.error('channel encounter an error in state "%s" message: "%s" detail: "%s', channel.readyState, event.error?.message, event.error?.errorDetail);
      const err2 = event.error instanceof Error ? event.error : new Error(`datachannel error: ${event.error?.message} ${event.error?.errorDetail}`);
      opts.onError((0, import_err_code86.default)(err2, "ERR_DATA_CHANNEL"));
    });
    let isClosing = false;
    this.closingInterval = setInterval(() => {
      if (channel.readyState === "closing") {
        if (isClosing) {
          opts.onClose();
        }
        isClosing = true;
      } else {
        isClosing = false;
      }
    }, CHANNEL_CLOSING_TIMEOUT);
  }
  async send(data) {
    await this.open.promise;
    this.channel.send(data);
    if (this.channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
      this.log("start backpressure: bufferedAmount %d", this.channel.bufferedAmount);
      this.open = pDefer();
    }
  }
  close() {
    clearInterval(this.closingInterval);
    this.channel.close();
  }
  get bufferedAmount() {
    return this.channel.bufferedAmount;
  }
};
var import_delay = __toESM(require_delay(), 1);
var DEFAULT_PEER_CONNECTION_CONFIG = {
  iceServers: [{
    urls: [
      "stun:stun.l.google.com:19302",
      "stun:globalThis.stun.twilio.com:3478"
    ]
  }]
};
function getBrowserRTC() {
  if (typeof globalThis === "undefined") {
    throw (0, import_err_code87.default)(new Error("No WebRTC support detected"), "ERR_WEBRTC_SUPPORT");
  }
  const wrtc = {
    // @ts-expect-error browser-specific properties
    RTCPeerConnection: globalThis.RTCPeerConnection ?? globalThis.mozRTCPeerConnection ?? globalThis.webkitRTCPeerConnection,
    // @ts-expect-error browser-specific properties
    RTCSessionDescription: globalThis.RTCSessionDescription ?? globalThis.mozRTCSessionDescription ?? globalThis.webkitRTCSessionDescription,
    // @ts-expect-error browser-specific properties
    RTCIceCandidate: globalThis.RTCIceCandidate ?? globalThis.mozRTCIceCandidate ?? globalThis.webkitRTCIceCandidate
  };
  if (wrtc.RTCPeerConnection == null) {
    throw (0, import_err_code87.default)(new Error("No WebRTC support detected"), "ERR_WEBRTC_SUPPORT");
  }
  return wrtc;
}
var WebRTCPeer = class extends EventEmitter2 {
  constructor(opts) {
    super();
    this.id = opts.id ?? toString3((0, import_random.default)(4), "hex").slice(0, 7);
    this.log = logger(`libp2p:webrtc-peer:${opts.logPrefix}:${this.id}`);
    this.wrtc = opts.wrtc ?? getBrowserRTC();
    this.peerConnection = new this.wrtc.RTCPeerConnection(Object.assign({}, DEFAULT_PEER_CONNECTION_CONFIG, opts.peerConnectionConfig));
    this.closed = false;
    this.connected = pDefer();
    this.source = pushable();
    this.sink = async (source) => {
      await this.connected.promise;
      if (this.channel == null) {
        throw (0, import_err_code87.default)(new Error("Connected but no channel?!"), "ERR_DATA_CHANNEL");
      }
      for await (const buf2 of source) {
        await this.channel.send(buf2);
      }
      await this.close();
    };
  }
  handleDataChannelEvent(event) {
    const dataChannel = event.channel;
    if (dataChannel == null) {
      this.close((0, import_err_code87.default)(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL")).catch((err2) => {
        this.log("Error closing after event channel was found to be null", err2);
      });
      return;
    }
    this.channel = new WebRTCDataChannel(dataChannel, {
      log: this.log,
      onMessage: (event2) => {
        this.source.push(new Uint8Array(event2.data));
      },
      onOpen: () => {
        this.connected.resolve();
        this.dispatchEvent(new CustomEvent2("ready"));
      },
      onClose: () => {
        this.close().catch((err2) => {
          this.log("error closing connection after channel close", err2);
        });
      },
      onError: (err2) => {
        this.close(err2).catch((err3) => {
          this.log("error closing connection after channel error", err3);
        });
      }
    });
  }
  async close(err2) {
    this.closed = true;
    if (err2 == null && this.channel != null) {
      while (this.channel.bufferedAmount > 0) {
        await (0, import_delay.default)(100);
      }
    }
    this.channel?.close();
    this.peerConnection.close();
    this.source.end(err2);
    this.dispatchEvent(new CustomEvent2("close"));
  }
};
var import_err_code88 = __toESM(require_err_code(), 1);
var WebRTCHandshake = class extends EventEmitter2 {
  constructor(options) {
    super();
    this.log = options.log;
    this.peerConnection = options.peerConnection;
    this.wrtc = options.wrtc;
    this.status = "idle";
    this.peerConnection.addEventListener("negotiationneeded", () => {
      this.log("peer connection negotiation needed");
      this.handleRenegotiate({ type: "renegotiate" }).catch((err2) => {
        this.log.error("could not renegotiate %o", err2);
      });
    });
  }
  async handleSignal(signal) {
    this.log('incoming signal "%s"', signal.type);
    if (signal.type === "offer") {
      return await this.handleOffer(signal);
    } else if (signal.type === "answer") {
      return await this.handleAnswer(signal);
    } else if (signal.type === "candidate") {
      return await this.handleCandidate(signal);
    } else if (signal.type === "renegotiate") {
      return await this.handleRenegotiate(signal);
    } else if (signal.type === "goodbye") {
      return await this.handleGoodye(signal);
    } else {
      this.log(`Unknown signal type ${signal.type}`);
    }
  }
  async handleOffer(signal) {
  }
  async handleAnswer(signal) {
  }
  async handleRenegotiate(signal) {
  }
  async handleGoodye(signal) {
    this.peerConnection.close();
  }
  async handleCandidate(signal) {
    const iceCandidate = new this.wrtc.RTCIceCandidate(signal.candidate);
    try {
      await this.peerConnection.addIceCandidate(iceCandidate);
    } catch (err2) {
      if (iceCandidate.address == null || iceCandidate.address.endsWith(".local")) {
        this.log("ignoring unsupported ICE candidate.");
      } else {
        throw (0, import_err_code88.default)(err2, "ERR_ADD_ICE_CANDIDATE");
      }
    }
  }
};
var log51 = logger("libp2p:webrtc-peer:receiver");
var WebRTCReceiver = class extends WebRTCPeer {
  constructor(opts = {}) {
    super({
      ...opts,
      logPrefix: "receiver"
    });
    this.handshake = new WebRTCReceiverHandshake({
      log: this.log,
      peerConnection: this.peerConnection,
      wrtc: this.wrtc,
      answerOptions: opts.answerOptions
    });
    this.handshake.addEventListener("signal", (event) => this.dispatchEvent(new CustomEvent2("signal", {
      detail: event.detail
    })));
    this.peerConnection.addEventListener("datachannel", (event) => {
      this.handleDataChannelEvent(event);
    });
  }
  handleSignal(signal) {
    this.handshake.handleSignal(signal).catch((err2) => {
      this.log("error handling signal %o %o", signal, err2);
    });
  }
};
var WebRTCReceiverHandshake = class extends WebRTCHandshake {
  constructor(options) {
    super(options);
    this.options = options;
    this.status = "idle";
    this.iceCandidates = [];
  }
  async handleRenegotiate() {
    log51.trace("renegotiate");
    this.dispatchEvent(new CustomEvent2("signal", {
      detail: {
        type: "renegotiate"
      }
    }));
  }
  async handleOffer(signal) {
    await this.peerConnection.setRemoteDescription(new this.wrtc.RTCSessionDescription(signal));
    for (const candidate of this.iceCandidates) {
      await this.handleCandidate(candidate);
    }
    this.iceCandidates = [];
    const answer = await this.peerConnection.createAnswer(this.options.answerOptions);
    await this.peerConnection.setLocalDescription(answer);
    log51.trace("handle offer", this.peerConnection.localDescription);
    this.dispatchEvent(new CustomEvent2("signal", {
      detail: this.peerConnection.localDescription ?? answer
    }));
  }
  async handleCandidate(signal) {
    if (this.peerConnection.remoteDescription == null || this.peerConnection.remoteDescription.type == null) {
      this.iceCandidates.push(signal);
      return;
    }
    await super.handleCandidate(signal);
  }
};
var import_random2 = __toESM(require_random_browser(), 1);
var TimeoutError4 = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "TimeoutError";
  }
};
var AbortError6 = class extends Error {
  constructor(message2) {
    super();
    this.name = "AbortError";
    this.message = message2;
  }
};
var getDOMException3 = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError6(errorMessage) : new DOMException(errorMessage);
var getAbortedReason3 = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException3("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException3(reason);
};
function pTimeout3(promise, milliseconds, fallback, options) {
  let timer;
  const cancelablePromise = new Promise((resolve7, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve7(promise);
      return;
    }
    options = {
      customTimers: { setTimeout, clearTimeout },
      ...options
    };
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason3(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason3(signal));
      });
    }
    timer = options.customTimers.setTimeout.call(void 0, () => {
      if (typeof fallback === "function") {
        try {
          resolve7(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const message2 = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError2 = fallback instanceof Error ? fallback : new TimeoutError4(message2);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError2);
    }, milliseconds);
    (async () => {
      try {
        resolve7(await promise);
      } catch (error) {
        reject(error);
      } finally {
        options.customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    clearTimeout(timer);
    timer = void 0;
  };
  return cancelablePromise;
}
var normalizeEmitter = (emitter) => {
  const addListener = emitter.on || emitter.addListener || emitter.addEventListener;
  const removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;
  if (!addListener || !removeListener) {
    throw new TypeError("Emitter is not compatible");
  }
  return {
    addListener: addListener.bind(emitter),
    removeListener: removeListener.bind(emitter)
  };
};
function pEventMultiple(emitter, event, options) {
  let cancel;
  const returnValue = new Promise((resolve7, reject) => {
    options = {
      rejectionEvents: ["error"],
      multiArgs: false,
      resolveImmediately: false,
      ...options
    };
    if (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) {
      throw new TypeError("The `count` option should be at least 0 or more");
    }
    const events2 = [event].flat();
    const items = [];
    const { addListener, removeListener } = normalizeEmitter(emitter);
    const onItem = (...arguments_) => {
      const value2 = options.multiArgs ? arguments_ : arguments_[0];
      if (options.filter && !options.filter(value2)) {
        return;
      }
      items.push(value2);
      if (options.count === items.length) {
        cancel();
        resolve7(items);
      }
    };
    const rejectHandler = (error) => {
      cancel();
      reject(error);
    };
    cancel = () => {
      for (const event2 of events2) {
        removeListener(event2, onItem);
      }
      for (const rejectionEvent of options.rejectionEvents) {
        removeListener(rejectionEvent, rejectHandler);
      }
    };
    for (const event2 of events2) {
      addListener(event2, onItem);
    }
    for (const rejectionEvent of options.rejectionEvents) {
      addListener(rejectionEvent, rejectHandler);
    }
    if (options.resolveImmediately) {
      resolve7(items);
    }
  });
  returnValue.cancel = cancel;
  if (typeof options.timeout === "number") {
    const timeout = pTimeout3(returnValue, options.timeout);
    timeout.cancel = cancel;
    return timeout;
  }
  return returnValue;
}
function pEvent(emitter, event, options) {
  if (typeof options === "function") {
    options = { filter: options };
  }
  options = {
    ...options,
    count: 1,
    resolveImmediately: false
  };
  const arrayPromise = pEventMultiple(emitter, event, options);
  const promise = arrayPromise.then((array) => array[0]);
  promise.cancel = arrayPromise.cancel;
  return promise;
}
var import_delay2 = __toESM(require_delay(), 1);
var log52 = logger("libp2p:webrtc-peer:initator");
var ICECOMPLETE_TIMEOUT = 1e3;
var WebRTCInitiator = class extends WebRTCPeer {
  constructor(opts = {}) {
    super({
      ...opts,
      logPrefix: "initiator"
    });
    this.handleDataChannelEvent({
      channel: this.peerConnection.createDataChannel(opts.dataChannelLabel ?? toString3((0, import_random2.default)(20), "hex").slice(0, 7), opts.dataChannelInit)
    });
    this.handshake = new WebRTCInitiatorHandshake({
      log: this.log,
      peerConnection: this.peerConnection,
      wrtc: this.wrtc,
      offerOptions: opts.offerOptions
    });
    this.handshake.addEventListener("signal", (event) => {
      this.dispatchEvent(new CustomEvent2("signal", { detail: event.detail }));
    });
  }
  handleSignal(signal) {
    this.handshake.handleSignal(signal).catch((err2) => {
      this.log("error handling signal %o %o", signal, err2);
    });
  }
};
var WebRTCInitiatorHandshake = class extends WebRTCHandshake {
  constructor(options) {
    super(options);
    this.options = options;
    this.status = "idle";
    this.peerConnection.addEventListener("icecandidate", (event) => {
      if (event.candidate == null) {
        return;
      }
      const signal = {
        type: "candidate",
        candidate: {
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid
        }
      };
      log52.trace("create candidate", signal);
      this.dispatchEvent(new CustomEvent2("signal", {
        detail: signal
      }));
      this.dispatchEvent(new CustomEvent2("ice-candidate"));
    });
  }
  async handleRenegotiate() {
    if (this.status === "negotiating") {
      this.log("already negotiating, queueing");
      return;
    }
    this.status = "negotiating";
    const offer = await this.peerConnection.createOffer(this.options.offerOptions);
    await this.peerConnection.setLocalDescription(offer);
    await pEvent(this, "ice-candidate");
    await (0, import_delay2.default)(ICECOMPLETE_TIMEOUT);
    log52.trace("renegotiate", this.peerConnection.localDescription);
    this.dispatchEvent(new CustomEvent2("signal", {
      detail: this.peerConnection.localDescription ?? offer
    }));
  }
  async handleAnswer(signal) {
    log52.trace("handle answer", signal);
    await this.peerConnection.setRemoteDescription(new this.wrtc.RTCSessionDescription(signal));
    this.status = "idle";
  }
};
var log53 = logger("libp2p:webrtc-star:socket");
function toMultiaddrConnection(socket, options) {
  const { sink, source } = socket;
  const maConn = {
    remoteAddr: options.remoteAddr,
    async sink(source2) {
      if (options.signal != null) {
        source2 = abortableSource(source2, options.signal);
      }
      try {
        await sink(source2);
      } catch (err2) {
        if (err2.type !== "aborted") {
          log53.error(err2);
        }
      }
    },
    source: options.signal != null ? abortableSource(source, options.signal) : source,
    timeline: { open: Date.now() },
    async close() {
      if (socket.closed) {
        return;
      }
      const start = Date.now();
      const timeout = setTimeout(() => {
        if (maConn.remoteAddr != null) {
          const { host, port } = maConn.remoteAddr.toOptions();
          log53("timeout closing socket to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
        }
        if (!socket.closed) {
          socket.close().catch((err2) => {
            log53.error("could not close socket", err2);
          });
        }
      }, CLOSE_TIMEOUT);
      try {
        await socket.close();
      } finally {
        clearTimeout(timeout);
      }
    }
  };
  socket.addEventListener("close", () => {
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }, {
    once: true
  });
  return maConn;
}
function cleanUrlSIO(ma) {
  const maStrSplit = ma.toString().split("/");
  const tcpProto = ma.protos()[1].name;
  const wsProto = ma.protos()[2].name;
  const tcpPort = ma.stringTuples()[1][1];
  if (tcpProto !== "tcp" || wsProto !== "ws" && wsProto !== "wss") {
    throw new Error(`invalid multiaddr: ${ma.toString()}`);
  }
  if (!isName(ma)) {
    return `http://${maStrSplit[2]}:${maStrSplit[4]}`;
  }
  if (wsProto === "ws") {
    return `http://${maStrSplit[2]}${tcpPort == null || tcpPort === "80" ? "" : `:${tcpPort}`}`;
  }
  if (wsProto === "wss") {
    return `https://${maStrSplit[2]}${tcpPort == null || tcpPort === "443" ? "" : `:${tcpPort}`}`;
  }
  throw new Error("invalid multiaddr: " + ma.toString());
}
function cleanMultiaddr(maStr) {
  const legacy = "/libp2p-webrtc-star";
  if (maStr.startsWith(legacy)) {
    maStr = maStr.substring(legacy.length, maStr.length);
    let ma = multiaddr(maStr);
    const tuppleIPFS = ma.stringTuples().filter((tupple) => {
      return tupple[0] === 421;
    })[0];
    if (tuppleIPFS[1] == null) {
      throw new Error("invalid multiaddr: " + maStr);
    }
    ma = ma.decapsulate("p2p");
    ma = ma.encapsulate("/p2p-webrtc-star");
    ma = ma.encapsulate(`/p2p/${tuppleIPFS[1]}`);
    maStr = ma.toString();
  }
  return maStr;
}
var log54 = logger("libp2p:webrtc-star:listener");
var sioOptions = {
  transports: ["websocket"],
  path: "/socket.io-next/"
  // This should be removed when socket.io@2 support is removed
};
var SigServer = class extends EventEmitter2 {
  constructor(signallingUrl, signallingAddr, upgrader, handler, channelOptions) {
    super();
    this.signallingAddr = signallingAddr;
    this.socket = lookup2(signallingUrl, sioOptions);
    this.connections = [];
    this.channels = /* @__PURE__ */ new Map();
    this.pendingSignals = /* @__PURE__ */ new Map();
    this.upgrader = upgrader;
    this.handler = handler;
    this.channelOptions = channelOptions;
    this.handleWsHandshake = this.handleWsHandshake.bind(this);
    let previouslyConnected = false;
    this.socket.on("connect_error", (err2) => {
      if (previouslyConnected && err2.type === "TransportError") {
        return;
      }
      this.dispatchEvent(new CustomEvent2("error", {
        detail: err2
      }));
    });
    this.socket.on("error", (err2) => {
      this.dispatchEvent(new CustomEvent2("error", {
        detail: err2
      }));
    });
    this.socket.on("ws-handshake", this.handleWsHandshake);
    this.socket.on("ws-peer", (maStr) => {
      this.dispatchEvent(new CustomEvent2("peer", {
        detail: maStr
      }));
    });
    this.socket.on("connect", () => {
      this.socket.emit("ss-join", this.signallingAddr.toString());
      if (previouslyConnected) {
        this.dispatchEvent(new CustomEvent2("reconnect"));
      }
    });
    this.socket.once("connect", () => {
      previouslyConnected = true;
      this.dispatchEvent(new CustomEvent2("listening"));
    });
    this.socket.on("disconnect", () => {
      this.dispatchEvent(new CustomEvent2("disconnect"));
    });
  }
  _createChannel(intentId, srcMultiaddr, dstMultiaddr) {
    const channelOptions = {
      ...this.channelOptions
    };
    const channel = new WebRTCReceiver(channelOptions);
    const onError = (evt) => {
      const err2 = evt.detail;
      log54.error("incoming connection errored", err2);
    };
    channel.addEventListener("error", onError);
    channel.addEventListener("close", () => {
      channel.removeEventListener("error", onError);
    }, {
      once: true
    });
    channel.addEventListener("signal", (evt) => {
      const signal = evt.detail;
      this.socket.emit("ss-handshake", {
        intentId,
        srcMultiaddr,
        dstMultiaddr,
        answer: true,
        signal
      });
    });
    channel.addEventListener("ready", () => {
      const maConn = toMultiaddrConnection(channel, { remoteAddr: this.signallingAddr });
      log54("new inbound connection %s", maConn.remoteAddr);
      try {
        this.upgrader.upgradeInbound(maConn).then((conn) => {
          log54("inbound connection %s upgraded", maConn.remoteAddr);
          this.connections.push(maConn);
          const untrackConn = () => {
            this.connections = this.connections.filter((c) => c !== maConn);
            this.channels.delete(intentId);
            this.pendingSignals.delete(intentId);
          };
          channel.addEventListener("close", untrackConn, {
            once: true
          });
          this.dispatchEvent(new CustomEvent2("connection", {
            detail: conn
          }));
          this.handler(conn);
        }).catch((err2) => {
          log54.error("inbound connection failed to upgrade", err2);
          maConn.close().catch((err3) => {
            log54.error("inbound connection failed to close after failing to upgrade", err3);
          });
        });
      } catch (err2) {
        log54.error("inbound connection failed to upgrade", err2);
        maConn.close().catch((err3) => {
          log54.error("inbound connection failed to close after failing to upgrade", err3);
        });
      }
    }, {
      once: true
    });
    return channel;
  }
  handleWsHandshake(offer) {
    log54('incoming handshake. signal type "%s" is answer %s', offer.signal.type, offer.answer);
    if (offer.answer === true || offer.err != null || offer.intentId == null) {
      return;
    }
    const intentId = offer.intentId;
    let pendingSignals = this.pendingSignals.get(intentId);
    if (pendingSignals == null) {
      pendingSignals = [];
      this.pendingSignals.set(intentId, pendingSignals);
    }
    pendingSignals.push(offer);
    let channel = this.channels.get(intentId);
    if (channel == null) {
      if (offer.signal.type !== "offer") {
        log54("handshake is not an offer and channel does not exist, buffering until we receive an offer");
        return;
      }
      log54("creating new channel to handle offer handshake");
      channel = this._createChannel(offer.intentId, offer.srcMultiaddr, offer.dstMultiaddr);
      this.channels.set(intentId, channel);
    } else {
      log54("channel already exists, using it to handle handshake");
    }
    while (pendingSignals.length > 0) {
      const handshake2 = pendingSignals.shift();
      if (handshake2?.signal != null) {
        channel.handleSignal(handshake2.signal);
      }
    }
  }
  async close() {
    this.socket.emit("ss-leave", this.signallingAddr.toString());
    this.socket.removeAllListeners();
    this.socket.close();
    await Promise.all([
      ...this.connections.map(async (maConn) => await maConn.close()),
      ...Array.from(this.channels.values()).map(async (channel) => await channel.close())
    ]);
    this.dispatchEvent(new CustomEvent2("close"));
  }
};
var WebRTCListener = class extends EventEmitter2 {
  constructor(upgrader, handler, peerId, transport, options) {
    super();
    this.upgrader = upgrader;
    this.handler = handler;
    this.peerId = peerId;
    this.transport = transport;
    this.options = options;
  }
  async listen(ma) {
    if (this.listeningAddr != null) {
      throw (0, import_err_code89.default)(new Error("listener already in use"), "ERR_ALREADY_LISTENING");
    }
    const defer = pDefer();
    this.listeningAddr = ma;
    let signallingAddr;
    if (!ma.protoCodes().includes(CODE_P2P)) {
      signallingAddr = ma.encapsulate(`/p2p/${this.peerId.toString()}`);
    } else {
      signallingAddr = ma;
    }
    const signallingUrl = this.signallingUrl = cleanUrlSIO(ma);
    log54("connecting to signalling server on: %s", this.signallingUrl);
    const server = new SigServer(this.signallingUrl, signallingAddr, this.upgrader, this.handler, this.options.channelOptions);
    server.addEventListener("error", (evt) => {
      const err2 = evt.detail;
      log54("error connecting to signalling server %o", err2);
      server.close().catch((err3) => {
        log54.error("error closing server after error", err3);
      });
      defer.reject(err2);
    });
    server.addEventListener("listening", () => {
      log54("connected to signalling server");
      this.dispatchEvent(new CustomEvent2("listening"));
      defer.resolve();
    });
    server.addEventListener("peer", (evt) => {
      this.transport.peerDiscovered(evt.detail);
    });
    server.addEventListener("connection", (evt) => {
      const conn = evt.detail;
      if (conn.remoteAddr == null) {
        try {
          conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(`/p2p/${conn.remotePeer.toString()}`);
        } catch (err2) {
          log54.error("could not determine remote address", err2);
        }
      }
      this.dispatchEvent(new CustomEvent2("connection", {
        detail: conn
      }));
    });
    server.addEventListener("disconnect", () => {
      this.transport.sigServers.delete(signallingUrl);
    });
    server.addEventListener("reconnect", () => {
      this.transport.sigServers.set(signallingUrl, server);
    });
    this.transport.sigServers.set(this.signallingUrl, server);
    return await defer.promise;
  }
  async close() {
    if (this.signallingUrl != null) {
      const server = this.transport.sigServers.get(this.signallingUrl);
      if (server != null) {
        await server.close();
        this.transport.sigServers.delete(this.signallingUrl);
      }
    }
    this.dispatchEvent(new CustomEvent2("close"));
    this.listeningAddr = void 0;
  }
  getAddrs() {
    if (this.listeningAddr != null) {
      return [
        this.listeningAddr
      ];
    }
    return [];
  }
};
function createListener(upgrader, handler, peerId, transport, options) {
  return new WebRTCListener(upgrader, handler, peerId, transport, options);
}
var import_random3 = __toESM(require_random_browser(), 1);
function xor(a, b) {
  if (a.length !== b.length) {
    throw new Error("Inputs should have the same length");
  }
  const result = allocUnsafe(a.length);
  for (let i2 = 0; i2 < a.length; i2++) {
    result[i2] = a[i2] ^ b[i2];
  }
  return asUint8Array(result);
}
var symbol4 = Symbol.for("@libp2p/transport");
var FaultTolerance;
(function(FaultTolerance2) {
  FaultTolerance2[FaultTolerance2["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance2[FaultTolerance2["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance || (FaultTolerance = {}));
var symbol5 = Symbol.for("@libp2p/peer-discovery");
var webrtcSupport = "RTCPeerConnection" in globalThis;
var log55 = logger("libp2p:webrtc-star");
var noop3 = () => {
};
var WebRTCStarDiscovery = class extends EventEmitter2 {
  constructor() {
    super(...arguments);
    this.started = false;
  }
  get [symbol5]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/webrtc-star-discovery";
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  dispatchEvent(event) {
    if (!this.isStarted()) {
      return false;
    }
    return super.dispatchEvent(event);
  }
};
var WebRTCStar2 = class {
  constructor(init) {
    if (init?.wrtc != null) {
      this.wrtc = init.wrtc;
    }
    this.sigServers = /* @__PURE__ */ new Map();
    this._discovery = new WebRTCStarDiscovery();
    this.discovery = () => this._discovery;
    this.peerDiscovered = this.peerDiscovered.bind(this);
  }
  get [symbol4]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/webrtc-star";
  }
  async dial(ma, options) {
    const rawConn = await this._connect(ma, options);
    const maConn = toMultiaddrConnection(rawConn, { remoteAddr: ma, signal: options.signal });
    log55("new outbound connection %s", maConn.remoteAddr);
    const conn = await options.upgrader.upgradeOutbound(maConn);
    log55("outbound connection %s upgraded", maConn.remoteAddr);
    return conn;
  }
  async _connect(ma, options) {
    if (options.signal?.aborted === true) {
      throw new AbortError5();
    }
    const channelOptions = {
      ...options.channelOptions ?? {}
    };
    if (this.wrtc != null) {
      channelOptions.wrtc = this.wrtc;
    }
    const cOpts = ma.toOptions();
    const intentId = toString3((0, import_random3.default)(36), "hex");
    return await new Promise((resolve7, reject) => {
      const sio = this.sigServers.get(cleanUrlSIO(ma));
      if (sio?.socket == null) {
        return reject((0, import_err_code90.default)(new Error("unknown signal server to use"), "ERR_UNKNOWN_SIGNAL_SERVER"));
      }
      let connected = false;
      log55("dialing %s:%s", cOpts.host, cOpts.port);
      const channel = new WebRTCInitiator(channelOptions);
      const onError = (evt) => {
        const err2 = evt.detail;
        if (!connected) {
          const msg = `connection error ${cOpts.host}:${cOpts.port}: ${err2.message}`;
          log55.error(msg);
          done(err2);
        }
      };
      const onReady = () => {
        connected = true;
        log55("connection opened %s:%s", cOpts.host, cOpts.port);
        done();
      };
      const onAbort = () => {
        log55.error("connection aborted %s:%s", cOpts.host, cOpts.port);
        channel.close().finally(() => {
          done(new AbortError5());
        });
      };
      const done = (err2) => {
        channel.removeEventListener("ready", onReady);
        options.signal?.removeEventListener("abort", onAbort);
        if (err2 == null) {
          resolve7(channel);
        } else {
          reject(err2);
        }
      };
      channel.addEventListener("ready", onReady, {
        once: true
      });
      channel.addEventListener("close", () => {
        channel.removeEventListener("error", onError);
      });
      options.signal?.addEventListener("abort", onAbort);
      channel.addEventListener("signal", (evt) => {
        const signal = evt.detail;
        sio.socket.emit("ss-handshake", {
          intentId,
          srcMultiaddr: sio.signallingAddr.toString(),
          dstMultiaddr: ma.toString(),
          signal
        });
      });
      sio.socket.on("ws-handshake", (offer) => {
        if (offer.intentId === intentId && offer.err != null) {
          channel.close().finally(() => {
            reject((0, import_err_code90.default)(new Error(offer.err), "ERR_SIGNALLING_FAILED"));
          });
        }
        if (offer.intentId !== intentId || offer.answer == null || channel.closed) {
          return;
        }
        channel.handleSignal(offer.signal);
      });
    });
  }
  /**
   * Creates a WebrtcStar listener. The provided `handler` function will be called
   * anytime a new incoming Connection has been successfully upgraded via
   * `upgrader.upgradeInbound`.
   */
  createListener(options) {
    if (!webrtcSupport && this.wrtc == null) {
      throw (0, import_err_code90.default)(new Error("no WebRTC support"), "ERR_NO_WEBRTC_SUPPORT");
    }
    options.channelOptions = options.channelOptions ?? {};
    if (this.wrtc != null) {
      options.channelOptions.wrtc = this.wrtc;
    }
    if (this.peerId == null) {
      throw (0, import_err_code90.default)(new Error("PeerId not set"), "ERR_MISSING_PEER_ID");
    }
    return createListener(options.upgrader, options.handler ?? noop3, this.peerId, this, options);
  }
  /**
   * Takes a list of `Multiaddr`s and returns only valid TCP addresses
   */
  filter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      if (ma.protoCodes().includes(CODE_CIRCUIT)) {
        return false;
      }
      return WebRTCStar.matches(ma);
    });
  }
  peerDiscovered(maStr) {
    log55("peer discovered: %s", maStr);
    maStr = cleanMultiaddr(maStr);
    const ma = multiaddr(maStr);
    const peerIdStr = ma.getPeerId();
    if (peerIdStr == null) {
      return;
    }
    const peerId = peerIdFromString(peerIdStr);
    this._discovery.dispatchEvent(new CustomEvent2("peer", {
      detail: {
        id: peerId,
        multiaddrs: [ma],
        protocols: []
      }
    }));
  }
};
function webRTCStar(init = {}) {
  const transport = new WebRTCStar2(init);
  return {
    transport: (components) => {
      transport.peerId = components.peerId;
      return transport;
    },
    discovery: transport.discovery
  };
}
function libp2pConfig() {
  const webRtcStar = webRTCStar();
  const options = {
    transports: [
      webRtcStar.transport
    ],
    peerDiscovery: [
      webRtcStar.discovery
    ],
    connectionManager: {
      maxParallelDials: 150,
      // 150 total parallel multiaddr dials
      maxDialsPerPeer: 4,
      // Allow 4 multiaddrs to be dialed per peer in parallel
      dialTimeout: 1e4,
      // 10 second dial timeout per peer dial
      autoDial: true
    },
    nat: {
      enabled: false
    }
  };
  return options;
}
function isStartable(obj) {
  return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
}
var import_err_code92 = __toESM(require_err_code(), 1);
var messages2;
(function(messages3) {
  messages3["NOT_STARTED_YET"] = "The libp2p node is not started yet";
  messages3["DHT_DISABLED"] = "DHT is not available";
  messages3["PUBSUB_DISABLED"] = "PubSub is not available";
  messages3["CONN_ENCRYPTION_REQUIRED"] = "At least one connection encryption module is required";
  messages3["ERR_TRANSPORTS_REQUIRED"] = "At least one transport module is required";
  messages3["ERR_PROTECTOR_REQUIRED"] = "Private network is enforced, but no protector was provided";
  messages3["NOT_FOUND"] = "Not found";
})(messages2 || (messages2 = {}));
var codes4;
(function(codes6) {
  codes6["DHT_DISABLED"] = "ERR_DHT_DISABLED";
  codes6["ERR_PUBSUB_DISABLED"] = "ERR_PUBSUB_DISABLED";
  codes6["PUBSUB_NOT_STARTED"] = "ERR_PUBSUB_NOT_STARTED";
  codes6["DHT_NOT_STARTED"] = "ERR_DHT_NOT_STARTED";
  codes6["CONN_ENCRYPTION_REQUIRED"] = "ERR_CONN_ENCRYPTION_REQUIRED";
  codes6["ERR_TRANSPORTS_REQUIRED"] = "ERR_TRANSPORTS_REQUIRED";
  codes6["ERR_PROTECTOR_REQUIRED"] = "ERR_PROTECTOR_REQUIRED";
  codes6["ERR_PEER_DIAL_INTERCEPTED"] = "ERR_PEER_DIAL_INTERCEPTED";
  codes6["ERR_CONNECTION_INTERCEPTED"] = "ERR_CONNECTION_INTERCEPTED";
  codes6["ERR_INVALID_PROTOCOLS_FOR_STREAM"] = "ERR_INVALID_PROTOCOLS_FOR_STREAM";
  codes6["ERR_CONNECTION_ENDED"] = "ERR_CONNECTION_ENDED";
  codes6["ERR_CONNECTION_FAILED"] = "ERR_CONNECTION_FAILED";
  codes6["ERR_NODE_NOT_STARTED"] = "ERR_NODE_NOT_STARTED";
  codes6["ERR_ALREADY_ABORTED"] = "ERR_ALREADY_ABORTED";
  codes6["ERR_TOO_MANY_ADDRESSES"] = "ERR_TOO_MANY_ADDRESSES";
  codes6["ERR_NO_VALID_ADDRESSES"] = "ERR_NO_VALID_ADDRESSES";
  codes6["ERR_RELAYED_DIAL"] = "ERR_RELAYED_DIAL";
  codes6["ERR_DIALED_SELF"] = "ERR_DIALED_SELF";
  codes6["ERR_DISCOVERED_SELF"] = "ERR_DISCOVERED_SELF";
  codes6["ERR_DUPLICATE_TRANSPORT"] = "ERR_DUPLICATE_TRANSPORT";
  codes6["ERR_ENCRYPTION_FAILED"] = "ERR_ENCRYPTION_FAILED";
  codes6["ERR_HOP_REQUEST_FAILED"] = "ERR_HOP_REQUEST_FAILED";
  codes6["ERR_INVALID_KEY"] = "ERR_INVALID_KEY";
  codes6["ERR_INVALID_MESSAGE"] = "ERR_INVALID_MESSAGE";
  codes6["ERR_INVALID_PARAMETERS"] = "ERR_INVALID_PARAMETERS";
  codes6["ERR_INVALID_PEER"] = "ERR_INVALID_PEER";
  codes6["ERR_MUXER_UNAVAILABLE"] = "ERR_MUXER_UNAVAILABLE";
  codes6["ERR_NOT_FOUND"] = "ERR_NOT_FOUND";
  codes6["ERR_TIMEOUT"] = "ERR_TIMEOUT";
  codes6["ERR_TRANSPORT_UNAVAILABLE"] = "ERR_TRANSPORT_UNAVAILABLE";
  codes6["ERR_TRANSPORT_DIAL_FAILED"] = "ERR_TRANSPORT_DIAL_FAILED";
  codes6["ERR_UNSUPPORTED_PROTOCOL"] = "ERR_UNSUPPORTED_PROTOCOL";
  codes6["ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED"] = "ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED";
  codes6["ERR_INVALID_MULTIADDR"] = "ERR_INVALID_MULTIADDR";
  codes6["ERR_SIGNATURE_NOT_VALID"] = "ERR_SIGNATURE_NOT_VALID";
  codes6["ERR_FIND_SELF"] = "ERR_FIND_SELF";
  codes6["ERR_NO_ROUTERS_AVAILABLE"] = "ERR_NO_ROUTERS_AVAILABLE";
  codes6["ERR_CONNECTION_NOT_MULTIPLEXED"] = "ERR_CONNECTION_NOT_MULTIPLEXED";
  codes6["ERR_NO_DIAL_TOKENS"] = "ERR_NO_DIAL_TOKENS";
  codes6["ERR_KEYCHAIN_REQUIRED"] = "ERR_KEYCHAIN_REQUIRED";
  codes6["ERR_INVALID_CMS"] = "ERR_INVALID_CMS";
  codes6["ERR_MISSING_KEYS"] = "ERR_MISSING_KEYS";
  codes6["ERR_NO_KEY"] = "ERR_NO_KEY";
  codes6["ERR_INVALID_KEY_NAME"] = "ERR_INVALID_KEY_NAME";
  codes6["ERR_INVALID_KEY_TYPE"] = "ERR_INVALID_KEY_TYPE";
  codes6["ERR_KEY_ALREADY_EXISTS"] = "ERR_KEY_ALREADY_EXISTS";
  codes6["ERR_INVALID_KEY_SIZE"] = "ERR_INVALID_KEY_SIZE";
  codes6["ERR_KEY_NOT_FOUND"] = "ERR_KEY_NOT_FOUND";
  codes6["ERR_OLD_KEY_NAME_INVALID"] = "ERR_OLD_KEY_NAME_INVALID";
  codes6["ERR_NEW_KEY_NAME_INVALID"] = "ERR_NEW_KEY_NAME_INVALID";
  codes6["ERR_PASSWORD_REQUIRED"] = "ERR_PASSWORD_REQUIRED";
  codes6["ERR_PEM_REQUIRED"] = "ERR_PEM_REQUIRED";
  codes6["ERR_CANNOT_READ_KEY"] = "ERR_CANNOT_READ_KEY";
  codes6["ERR_MISSING_PRIVATE_KEY"] = "ERR_MISSING_PRIVATE_KEY";
  codes6["ERR_MISSING_PUBLIC_KEY"] = "ERR_MISSING_PUBLIC_KEY";
  codes6["ERR_INVALID_OLD_PASS_TYPE"] = "ERR_INVALID_OLD_PASS_TYPE";
  codes6["ERR_INVALID_NEW_PASS_TYPE"] = "ERR_INVALID_NEW_PASS_TYPE";
  codes6["ERR_INVALID_PASS_LENGTH"] = "ERR_INVALID_PASS_LENGTH";
  codes6["ERR_NOT_IMPLEMENTED"] = "ERR_NOT_IMPLEMENTED";
  codes6["ERR_WRONG_PING_ACK"] = "ERR_WRONG_PING_ACK";
  codes6["ERR_INVALID_RECORD"] = "ERR_INVALID_RECORD";
  codes6["ERR_ALREADY_SUCCEEDED"] = "ERR_ALREADY_SUCCEEDED";
  codes6["ERR_NO_HANDLER_FOR_PROTOCOL"] = "ERR_NO_HANDLER_FOR_PROTOCOL";
  codes6["ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS";
  codes6["ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS";
  codes6["ERR_CONNECTION_DENIED"] = "ERR_CONNECTION_DENIED";
})(codes4 || (codes4 = {}));
var import_err_code91 = __toESM(require_err_code(), 1);
async function* storeAddresses(source, peerStore) {
  yield* map(source, async (peer) => {
    await peerStore.addressBook.add(peer.id, peer.multiaddrs);
    return peer;
  });
}
function uniquePeers(source) {
  const seen = /* @__PURE__ */ new Set();
  return filter(source, (peer) => {
    if (seen.has(peer.id.toString())) {
      return false;
    }
    seen.add(peer.id.toString());
    return true;
  });
}
async function* requirePeers(source, min = 1) {
  let seen = 0;
  for await (const peer of source) {
    seen++;
    yield peer;
  }
  if (seen < min) {
    throw (0, import_err_code91.default)(new Error("not found"), "NOT_FOUND");
  }
}
var import_timeout_abort_controller4 = __toESM(require_timeout_abort_controller(), 1);
var import_set_delayed_interval = __toESM(require_src3(), 1);
var import_events8 = __toESM(require_events(), 1);
var log56 = logger("libp2p:peer-routing");
var DefaultPeerRouting = class {
  constructor(components, init) {
    this.components = components;
    this.routers = init.routers ?? [];
    this.refreshManagerInit = init.refreshManager ?? {};
    this.started = false;
    this._findClosestPeersTask = this._findClosestPeersTask.bind(this);
  }
  isStarted() {
    return this.started;
  }
  /**
   * Start peer routing service.
   */
  async start() {
    if (this.started || this.routers.length === 0 || this.timeoutId != null || this.refreshManagerInit.enabled === false) {
      return;
    }
    this.timeoutId = (0, import_set_delayed_interval.setDelayedInterval)(this._findClosestPeersTask, this.refreshManagerInit.interval, this.refreshManagerInit.bootDelay);
    this.started = true;
  }
  /**
   * Recurrent task to find closest peers and add their addresses to the Address Book.
   */
  async _findClosestPeersTask() {
    if (this.abortController != null) {
      return;
    }
    try {
      this.abortController = new import_timeout_abort_controller4.TimeoutController(this.refreshManagerInit.timeout ?? 1e4);
      try {
        (0, import_events8.setMaxListeners)?.(Infinity, this.abortController.signal);
      } catch {
      }
      await drain(this.getClosestPeers(this.components.peerId.toBytes(), { signal: this.abortController.signal }));
    } catch (err2) {
      log56.error(err2);
    } finally {
      this.abortController?.clear();
      this.abortController = void 0;
    }
  }
  /**
   * Stop peer routing service.
   */
  async stop() {
    (0, import_set_delayed_interval.clearDelayedInterval)(this.timeoutId);
    this.abortController?.abort();
    this.started = false;
  }
  /**
   * Iterates over all peer routers in parallel to find the given peer
   */
  async findPeer(id, options) {
    if (this.routers.length === 0) {
      throw (0, import_err_code92.default)(new Error("No peer routers available"), codes4.ERR_NO_ROUTERS_AVAILABLE);
    }
    if (id.toString() === this.components.peerId.toString()) {
      throw (0, import_err_code92.default)(new Error("Should not try to find self"), codes4.ERR_FIND_SELF);
    }
    const output = await pipe(merge$1(...this.routers.map((router) => async function* () {
      try {
        yield await router.findPeer(id, options);
      } catch (err2) {
        log56.error(err2);
      }
    }())), (source) => filter(source, Boolean), (source) => storeAddresses(source, this.components.peerStore), async (source) => await first(source));
    if (output != null) {
      return output;
    }
    throw (0, import_err_code92.default)(new Error(messages2.NOT_FOUND), codes4.ERR_NOT_FOUND);
  }
  /**
   * Attempt to find the closest peers on the network to the given key
   */
  async *getClosestPeers(key, options) {
    if (this.routers.length === 0) {
      throw (0, import_err_code92.default)(new Error("No peer routers available"), codes4.ERR_NO_ROUTERS_AVAILABLE);
    }
    yield* pipe(merge$1(...this.routers.map((router) => router.getClosestPeers(key, options))), (source) => storeAddresses(source, this.components.peerStore), (source) => uniquePeers(source), (source) => requirePeers(source));
  }
};
var import_err_code93 = __toESM(require_err_code(), 1);
var CompoundContentRouting = class {
  constructor(components, init) {
    this.routers = init.routers ?? [];
    this.started = false;
    this.components = components;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  /**
   * Iterates over all content routers in parallel to find providers of the given key
   */
  async *findProviders(key, options = {}) {
    if (this.routers.length === 0) {
      throw (0, import_err_code93.default)(new Error("No content this.routers available"), codes4.ERR_NO_ROUTERS_AVAILABLE);
    }
    yield* pipe(merge$1(...this.routers.map((router) => router.findProviders(key, options))), (source) => storeAddresses(source, this.components.peerStore), (source) => uniquePeers(source), (source) => requirePeers(source));
  }
  /**
   * Iterates over all content routers in parallel to notify it is
   * a provider of the given key
   */
  async provide(key, options = {}) {
    if (this.routers.length === 0) {
      throw (0, import_err_code93.default)(new Error("No content routers available"), codes4.ERR_NO_ROUTERS_AVAILABLE);
    }
    await Promise.all(this.routers.map(async (router) => await router.provide(key, options)));
  }
  /**
   * Store the given key/value pair in the available content routings
   */
  async put(key, value2, options) {
    if (!this.isStarted()) {
      throw (0, import_err_code93.default)(new Error(messages2.NOT_STARTED_YET), codes4.DHT_NOT_STARTED);
    }
    const dht = this.components.dht;
    if (dht != null) {
      await drain(dht.put(key, value2, options));
    }
  }
  /**
   * Get the value to the given key.
   * Times out after 1 minute by default.
   */
  async get(key, options) {
    if (!this.isStarted()) {
      throw (0, import_err_code93.default)(new Error(messages2.NOT_STARTED_YET), codes4.DHT_NOT_STARTED);
    }
    const dht = this.components.dht;
    if (dht != null) {
      for await (const event of dht.get(key, options)) {
        if (event.name === "VALUE") {
          return event.value;
        }
      }
    }
    throw (0, import_err_code93.default)(new Error(messages2.NOT_FOUND), codes4.ERR_NOT_FOUND);
  }
  /**
   * Get the `n` values to the given key without sorting
   */
  async *getMany(key, nVals, options) {
    if (!this.isStarted()) {
      throw (0, import_err_code93.default)(new Error(messages2.NOT_STARTED_YET), codes4.DHT_NOT_STARTED);
    }
    if (nVals == null || nVals === 0) {
      return;
    }
    let gotValues = 0;
    const dht = this.components.dht;
    if (dht != null) {
      for await (const event of dht.get(key, options)) {
        if (event.name === "VALUE") {
          yield { from: event.from, val: event.value };
          gotValues++;
          if (gotValues === nVals) {
            break;
          }
        }
      }
    }
    if (gotValues === 0) {
      throw (0, import_err_code93.default)(new Error(messages2.NOT_FOUND), codes4.ERR_NOT_FOUND);
    }
  }
};
var defaultAddressFilter = (addrs) => addrs;
var DefaultAddressManager = class extends EventEmitter2 {
  /**
   * Responsible for managing the peer addresses.
   * Peers can specify their listen and announce addresses.
   * The listen addresses will be used by the libp2p transports to listen for new connections,
   * while the announce addresses will be used for the peer addresses' to other peers in the network.
   */
  constructor(components, init) {
    super();
    const { listen = [], announce = [] } = init;
    this.components = components;
    this.listen = listen.map((ma) => ma.toString());
    this.announce = new Set(announce.map((ma) => ma.toString()));
    this.observed = /* @__PURE__ */ new Set();
    this.announceFilter = init.announceFilter ?? defaultAddressFilter;
  }
  /**
   * Get peer listen multiaddrs
   */
  getListenAddrs() {
    return Array.from(this.listen).map((a) => multiaddr(a));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAnnounceAddrs() {
    return Array.from(this.announce).map((a) => multiaddr(a));
  }
  /**
   * Get observed multiaddrs
   */
  getObservedAddrs() {
    return Array.from(this.observed).map((a) => multiaddr(a));
  }
  /**
   * Add peer observed addresses
   * Signal that we have confidence an observed multiaddr is publicly dialable -
   * this will make it appear in the output of getAddresses()
   */
  confirmObservedAddr(addr) {
  }
  /**
   * Signal that we do not have confidence an observed multiaddr is publicly dialable -
   * this will remove it from the output of getObservedAddrs()
   */
  removeObservedAddr(addr) {
  }
  /**
   * Add peer observed addresses
   */
  addObservedAddr(addr) {
    let ma = multiaddr(addr);
    const remotePeer = ma.getPeerId();
    if (remotePeer != null) {
      const remotePeerId = peerIdFromString(remotePeer);
      if (remotePeerId.equals(this.components.peerId)) {
        ma = ma.decapsulate(multiaddr(`/p2p/${this.components.peerId.toString()}`));
      }
    }
    const addrString = ma.toString();
    if (this.observed.has(addrString)) {
      return;
    }
    this.observed.add(addrString);
    this.dispatchEvent(new CustomEvent2("change:addresses"));
  }
  getAddresses() {
    let addrs = this.getAnnounceAddrs().map((ma) => ma.toString());
    if (addrs.length === 0) {
      addrs = this.components.transportManager.getAddrs().map((ma) => ma.toString());
    }
    addrs = addrs.concat(this.getObservedAddrs().map((ma) => ma.toString()));
    const addrSet = new Set(addrs);
    return this.announceFilter(Array.from(addrSet).map((str) => multiaddr(str))).map((ma) => {
      if (ma.protos().pop()?.path === true) {
        return ma;
      }
      if (ma.getPeerId() === this.components.peerId.toString()) {
        return ma;
      }
      return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);
    });
  }
};
var import_err_code95 = __toESM(require_err_code(), 1);
var log57 = logger("libp2p:connection-manager:latency-monitor:visibility-change-emitter");
var VisibilityChangeEmitter = class extends EventEmitter2 {
  constructor() {
    super();
    this.hidden = "hidden";
    this.visibilityChange = "visibilityChange";
    if (globalThis.document != null) {
      this._initializeVisibilityVarNames();
      this._addVisibilityChangeListener();
    }
  }
  /**
   * document.hidden and document.visibilityChange are the two variables we need to check for;
   * Since these variables are named differently in different browsers, this function sets
   * the appropriate name based on the browser being used. Once executed, tha actual names of
   * document.hidden and document.visibilityChange are found in this._hidden and this._visibilityChange
   * respectively
   *
   * @private
   */
  _initializeVisibilityVarNames() {
    let hidden = "hidden";
    let visibilityChange = "visibilitychange";
    if (typeof globalThis.document.hidden !== "undefined") {
      hidden = "hidden";
      visibilityChange = "visibilitychange";
    } else if (typeof globalThis.document.mozHidden !== "undefined") {
      hidden = "mozHidden";
      visibilityChange = "mozvisibilitychange";
    } else if (typeof globalThis.document.msHidden !== "undefined") {
      hidden = "msHidden";
      visibilityChange = "msvisibilitychange";
    } else if (typeof globalThis.document.webkitHidden !== "undefined") {
      hidden = "webkitHidden";
      visibilityChange = "webkitvisibilitychange";
    }
    this.hidden = hidden;
    this.visibilityChange = visibilityChange;
  }
  /**
   * Adds an event listener on the document that listens to changes in document.visibilityChange
   * (or whatever name by which the visibilityChange variable is known in the browser)
   *
   * @private
   */
  _addVisibilityChangeListener() {
    if (typeof globalThis.document.addEventListener === "undefined" || typeof document[this.hidden] === "undefined") {
      log57("Checking page visibility requires a browser that supports the Page Visibility API.");
    } else {
      globalThis.document.addEventListener(this.visibilityChange, this._handleVisibilityChange.bind(this), false);
    }
  }
  /**
   * The function returns ```true``` if the page is visible or ```false``` if the page is not visible and
   * ```undefined``` if the page visibility API is not supported by the browser.
   */
  isVisible() {
    if (this.hidden === void 0 || document[this.hidden] === void 0) {
      return void 0;
    }
    return document[this.hidden] == null;
  }
  /**
   * The function that is called when document.visibilityChange has changed
   * It emits an event called visibilityChange and sends the value of document.hidden as a
   * parameter
   *
   * @private
   */
  _handleVisibilityChange() {
    const visible = globalThis.document[this.hidden] === false;
    log57(visible ? "Page Visible" : "Page Hidden");
    this.dispatchEvent(new CustomEvent2("visibilityChange", {
      detail: visible
    }));
  }
};
var log58 = logger("libp2p:connection-manager:latency-monitor");
var LatencyMonitor = class extends EventEmitter2 {
  constructor(init = {}) {
    super();
    const { latencyCheckIntervalMs, dataEmitIntervalMs, asyncTestFn, latencyRandomPercentage } = init;
    this.latencyCheckIntervalMs = latencyCheckIntervalMs ?? 500;
    this.latencyRandomPercentage = latencyRandomPercentage ?? 10;
    this.latencyCheckMultiply = 2 * (this.latencyRandomPercentage / 100) * this.latencyCheckIntervalMs;
    this.latencyCheckSubtract = this.latencyCheckMultiply / 2;
    this.dataEmitIntervalMs = dataEmitIntervalMs === null || dataEmitIntervalMs === 0 ? void 0 : dataEmitIntervalMs ?? 5 * 1e3;
    log58("latencyCheckIntervalMs: %s dataEmitIntervalMs: %s", this.latencyCheckIntervalMs, this.dataEmitIntervalMs);
    if (this.dataEmitIntervalMs != null) {
      log58("Expecting ~%s events per summary", this.latencyCheckIntervalMs / this.dataEmitIntervalMs);
    } else {
      log58("Not emitting summaries");
    }
    this.asyncTestFn = asyncTestFn;
    if (globalThis.process?.hrtime != null) {
      log58("Using process.hrtime for timing");
      this.now = globalThis.process.hrtime;
      this.getDeltaMS = (startTime) => {
        const hrtime = this.now(startTime);
        return hrtime[0] * 1e3 + hrtime[1] / 1e6;
      };
    } else if (typeof window !== "undefined" && window.performance?.now != null) {
      log58("Using performance.now for timing");
      this.now = window.performance.now.bind(window.performance);
      this.getDeltaMS = (startTime) => Math.round(this.now() - startTime);
    } else {
      log58("Using Date.now for timing");
      this.now = Date.now;
      this.getDeltaMS = (startTime) => this.now() - startTime;
    }
    this.latencyData = this.initLatencyData();
  }
  start() {
    if (isBrowser2()) {
      this.visibilityChangeEmitter = new VisibilityChangeEmitter();
      this.visibilityChangeEmitter.addEventListener("visibilityChange", (evt) => {
        const { detail: pageInFocus } = evt;
        if (pageInFocus) {
          this._startTimers();
        } else {
          this._emitSummary();
          this._stopTimers();
        }
      });
    }
    if (this.visibilityChangeEmitter?.isVisible() === true) {
      this._startTimers();
    }
  }
  stop() {
    this._stopTimers();
  }
  /**
   * Start internal timers
   *
   * @private
   */
  _startTimers() {
    if (this.checkLatencyID != null) {
      return;
    }
    this.checkLatency();
    if (this.dataEmitIntervalMs != null) {
      this.emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs);
      if (typeof this.emitIntervalID.unref === "function") {
        this.emitIntervalID.unref();
      }
    }
  }
  /**
   * Stop internal timers
   *
   * @private
   */
  _stopTimers() {
    if (this.checkLatencyID != null) {
      clearTimeout(this.checkLatencyID);
      this.checkLatencyID = void 0;
    }
    if (this.emitIntervalID != null) {
      clearInterval(this.emitIntervalID);
      this.emitIntervalID = void 0;
    }
  }
  /**
   * Emit summary only if there were events. It might not have any events if it was forced via a page hidden/show
   *
   * @private
   */
  _emitSummary() {
    const summary = this.getSummary();
    if (summary.events > 0) {
      this.dispatchEvent(new CustomEvent2("data", {
        detail: summary
      }));
    }
  }
  /**
   * Calling this function will end the collection period. If a timing event was already fired and somewhere in the queue,
   * it will not count for this time period
   */
  getSummary() {
    const latency = {
      events: this.latencyData.events,
      minMs: this.latencyData.minMs,
      maxMs: this.latencyData.maxMs,
      avgMs: this.latencyData.events > 0 ? this.latencyData.totalMs / this.latencyData.events : Number.POSITIVE_INFINITY,
      lengthMs: this.getDeltaMS(this.latencyData.startTime)
    };
    this.latencyData = this.initLatencyData();
    log58.trace("Summary: %O", latency);
    return latency;
  }
  /**
   * Randomly calls an async fn every roughly latencyCheckIntervalMs (plus some randomness). If no async fn is found,
   * it will simply report on event loop latency.
   */
  checkLatency() {
    const randomness = Math.random() * this.latencyCheckMultiply - this.latencyCheckSubtract;
    const localData = {
      deltaOffset: Math.ceil(this.latencyCheckIntervalMs + randomness),
      startTime: this.now()
    };
    const cb = () => {
      if (this.checkLatencyID == null) {
        return;
      }
      const deltaMS = this.getDeltaMS(localData.startTime) - localData.deltaOffset;
      this.checkLatency();
      this.latencyData.events++;
      this.latencyData.minMs = Math.min(this.latencyData.minMs, deltaMS);
      this.latencyData.maxMs = Math.max(this.latencyData.maxMs, deltaMS);
      this.latencyData.totalMs += deltaMS;
      log58.trace("MS: %s Data: %O", deltaMS, this.latencyData);
    };
    log58.trace("localData: %O", localData);
    this.checkLatencyID = setTimeout(() => {
      if (this.asyncTestFn != null) {
        localData.deltaOffset = 0;
        localData.startTime = this.now();
        this.asyncTestFn(cb);
      } else {
        localData.deltaOffset -= 1;
        cb();
      }
    }, localData.deltaOffset);
    if (typeof this.checkLatencyID.unref === "function") {
      this.checkLatencyID.unref();
    }
  }
  initLatencyData() {
    return {
      startTime: this.now(),
      minMs: Number.POSITIVE_INFINITY,
      maxMs: Number.NEGATIVE_INFINITY,
      events: 0,
      totalMs: 0
    };
  }
};
function isBrowser2() {
  return typeof globalThis.window !== "undefined";
}
var import_events13 = __toESM(require_events(), 1);
var OPEN = "OPEN";
var CLOSING = "CLOSING";
var CLOSED = "CLOSED";
function mapIterable(iter, map4) {
  const iterator = {
    [Symbol.iterator]: () => {
      return iterator;
    },
    next: () => {
      const next = iter.next();
      const val = next.value;
      if (next.done === true || val == null) {
        const result = {
          done: true,
          value: void 0
        };
        return result;
      }
      return {
        done: false,
        value: map4(val)
      };
    }
  };
  return iterator;
}
var PeerMap = class {
  constructor(map4) {
    this.map = /* @__PURE__ */ new Map();
    if (map4 != null) {
      for (const [key, value2] of map4.entries()) {
        this.map.set(key.toString(), value2);
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  clear() {
    this.map.clear();
  }
  delete(peer) {
    this.map.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.map.entries(), (val) => {
      return [peerIdFromString(val[0]), val[1]];
    });
  }
  forEach(fn) {
    this.map.forEach((value2, key) => {
      fn(value2, peerIdFromString(key), this);
    });
  }
  get(peer) {
    return this.map.get(peer.toString());
  }
  has(peer) {
    return this.map.has(peer.toString());
  }
  set(peer, value2) {
    this.map.set(peer.toString(), value2);
  }
  keys() {
    return mapIterable(this.map.keys(), (val) => {
      return peerIdFromString(val);
    });
  }
  values() {
    return this.map.values();
  }
  get size() {
    return this.map.size;
  }
};
var PeerSet = class {
  constructor(set2) {
    this.set = /* @__PURE__ */ new Set();
    if (set2 != null) {
      for (const key of set2) {
        this.set.add(key.toString());
      }
    }
  }
  get size() {
    return this.set.size;
  }
  [Symbol.iterator]() {
    return this.values();
  }
  add(peer) {
    this.set.add(peer.toString());
  }
  clear() {
    this.set.clear();
  }
  delete(peer) {
    this.set.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.set.entries(), (val) => {
      const peerId = peerIdFromString(val[0]);
      return [peerId, peerId];
    });
  }
  forEach(predicate) {
    this.set.forEach((str) => {
      const id = peerIdFromString(str);
      predicate(id, id, this);
    });
  }
  has(peer) {
    return this.set.has(peer.toString());
  }
  values() {
    return mapIterable(this.set.values(), (val) => {
      return peerIdFromString(val);
    });
  }
  intersection(other) {
    const output = new PeerSet();
    for (const peerId of other) {
      if (this.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  difference(other) {
    const output = new PeerSet();
    for (const peerId of this) {
      if (!other.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  union(other) {
    const output = new PeerSet();
    for (const peerId of other) {
      output.add(peerId);
    }
    for (const peerId of this) {
      output.add(peerId);
    }
    return output;
  }
};
var import_timeout_abort_controller5 = __toESM(require_timeout_abort_controller(), 1);
var KEEP_ALIVE = "keep-alive";
var import_rate_limiter_flexible = __toESM(require_rate_limiter_flexible(), 1);
var import_err_code94 = __toESM(require_err_code(), 1);
function getPeerAddress(peer) {
  if (isPeerId(peer)) {
    return {
      peerId: peer
    };
  }
  if (isMultiaddr(peer)) {
    const peerId = peer.getPeerId();
    return {
      multiaddr: peer,
      peerId: peerId == null ? void 0 : peerIdFromString(peerId)
    };
  }
  throw (0, import_err_code94.default)(
    new Error(`${peer} is not a PeerId or a Multiaddr`),
    // eslint-disable-line @typescript-eslint/restrict-template-expressions
    codes4.ERR_INVALID_MULTIADDR
  );
}
var log59 = logger("libp2p:connection-manager");
var defaultOptions16 = {
  maxConnections: Infinity,
  minConnections: 0,
  maxEventLoopDelay: Infinity,
  pollInterval: 2e3,
  autoDialInterval: 1e4,
  inboundConnectionThreshold: 5,
  maxIncomingPendingConnections: 10
};
var STARTUP_RECONNECT_TIMEOUT = 6e4;
var DefaultConnectionManager = class extends EventEmitter2 {
  constructor(components, init) {
    super();
    this.opts = merge_options_default.call({ ignoreUndefined: true }, defaultOptions16, init);
    if (this.opts.maxConnections < this.opts.minConnections) {
      throw (0, import_err_code95.default)(new Error("Connection Manager maxConnections must be greater than minConnections"), codes4.ERR_INVALID_PARAMETERS);
    }
    log59("options: %o", this.opts);
    this.components = components;
    this.connections = /* @__PURE__ */ new Map();
    this.started = false;
    if (init.maxEventLoopDelay != null && init.maxEventLoopDelay > 0 && init.maxEventLoopDelay !== Infinity) {
      this.latencyMonitor = new LatencyMonitor({
        latencyCheckIntervalMs: init.pollInterval,
        dataEmitIntervalMs: init.pollInterval
      });
    }
    try {
      (0, import_events13.setMaxListeners)?.(Infinity, this);
    } catch {
    }
    this.onConnect = this.onConnect.bind(this);
    this.onDisconnect = this.onDisconnect.bind(this);
    this.startupReconnectTimeout = init.startupReconnectTimeout ?? STARTUP_RECONNECT_TIMEOUT;
    this.dialTimeout = init.dialTimeout ?? 3e4;
    this.allow = (init.allow ?? []).map((ma) => multiaddr(ma));
    this.deny = (init.deny ?? []).map((ma) => multiaddr(ma));
    this.inboundConnectionRateLimiter = new import_rate_limiter_flexible.RateLimiterMemory({
      points: this.opts.inboundConnectionThreshold,
      duration: 1
    });
    this.incomingPendingConnections = 0;
  }
  isStarted() {
    return this.started;
  }
  /**
   * Starts the Connection Manager. If Metrics are not enabled on libp2p
   * only event loop and connection limits will be monitored.
   */
  async start() {
    this.components.metrics?.registerMetricGroup("libp2p_connection_manager_connections", {
      calculate: () => {
        const metric = {
          inbound: 0,
          outbound: 0
        };
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            if (conn.stat.direction === "inbound") {
              metric.inbound++;
            } else {
              metric.outbound++;
            }
          }
        }
        return metric;
      }
    });
    this.components.metrics?.registerMetricGroup("libp2p_protocol_streams_total", {
      label: "protocol",
      calculate: () => {
        const metric = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            for (const stream of conn.streams) {
              const key = `${stream.stat.direction} ${stream.stat.protocol ?? "unnegotiated"}`;
              metric[key] = (metric[key] ?? 0) + 1;
            }
          }
        }
        return metric;
      }
    });
    this.components.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile", {
      label: "protocol",
      calculate: () => {
        const allStreams = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            const streams = {};
            for (const stream of conn.streams) {
              const key = `${stream.stat.direction} ${stream.stat.protocol ?? "unnegotiated"}`;
              streams[key] = (streams[key] ?? 0) + 1;
            }
            for (const [protocol4, count] of Object.entries(streams)) {
              allStreams[protocol4] = allStreams[protocol4] ?? [];
              allStreams[protocol4].push(count);
            }
          }
        }
        const metric = {};
        for (let [protocol4, counts] of Object.entries(allStreams)) {
          counts = counts.sort((a, b) => a - b);
          const index2 = Math.floor(counts.length * 0.9);
          metric[protocol4] = counts[index2];
        }
        return metric;
      }
    });
    this.latencyMonitor?.start();
    this._onLatencyMeasure = this._onLatencyMeasure.bind(this);
    this.latencyMonitor?.addEventListener("data", this._onLatencyMeasure);
    this.started = true;
    log59("started");
  }
  async afterStart() {
    this.components.upgrader.addEventListener("connection", this.onConnect);
    this.components.upgrader.addEventListener("connectionEnd", this.onDisconnect);
    void Promise.resolve().then(async () => {
      const keepAlivePeers = [];
      for (const peer of await this.components.peerStore.all()) {
        const tags = await this.components.peerStore.getTags(peer.id);
        const hasKeepAlive = tags.filter((tag) => tag.name === KEEP_ALIVE).length > 0;
        if (hasKeepAlive) {
          keepAlivePeers.push(peer.id);
        }
      }
      this.connectOnStartupController?.clear();
      this.connectOnStartupController = new import_timeout_abort_controller5.TimeoutController(this.startupReconnectTimeout);
      try {
        (0, import_events13.setMaxListeners)?.(Infinity, this.connectOnStartupController.signal);
      } catch {
      }
      await Promise.all(keepAlivePeers.map(async (peer) => {
        await this.openConnection(peer, {
          signal: this.connectOnStartupController?.signal
        }).catch((err2) => {
          log59.error(err2);
        });
      }));
    }).catch((err2) => {
      log59.error(err2);
    }).finally(() => {
      this.connectOnStartupController?.clear();
    });
  }
  async beforeStop() {
    this.connectOnStartupController?.abort();
    this.components.upgrader.removeEventListener("connection", this.onConnect);
    this.components.upgrader.removeEventListener("connectionEnd", this.onDisconnect);
  }
  /**
   * Stops the Connection Manager
   */
  async stop() {
    this.latencyMonitor?.removeEventListener("data", this._onLatencyMeasure);
    this.latencyMonitor?.stop();
    this.started = false;
    await this._close();
    log59("stopped");
  }
  /**
   * Cleans up the connections
   */
  async _close() {
    const tasks = [];
    for (const connectionList of this.connections.values()) {
      for (const connection of connectionList) {
        tasks.push((async () => {
          try {
            await connection.close();
          } catch (err2) {
            log59.error(err2);
          }
        })());
      }
    }
    log59("closing %d connections", tasks.length);
    await Promise.all(tasks);
    this.connections.clear();
  }
  onConnect(evt) {
    void this._onConnect(evt).catch((err2) => {
      log59.error(err2);
    });
  }
  /**
   * Tracks the incoming connection and check the connection limit
   */
  async _onConnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      await connection.close();
      return;
    }
    const peerId = connection.remotePeer;
    const peerIdStr = peerId.toString();
    const storedConns = this.connections.get(peerIdStr);
    if (storedConns != null) {
      storedConns.push(connection);
    } else {
      this.connections.set(peerIdStr, [connection]);
    }
    if (peerId.publicKey != null) {
      await this.components.peerStore.keyBook.set(peerId, peerId.publicKey);
    }
    const numConnections = this.getConnections().length;
    const toPrune = numConnections - this.opts.maxConnections;
    await this._checkMaxLimit("maxConnections", numConnections, toPrune);
    this.dispatchEvent(new CustomEvent2("peer:connect", { detail: connection }));
  }
  /**
   * Removes the connection from tracking
   */
  onDisconnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      return;
    }
    const peerId = connection.remotePeer.toString();
    let storedConn = this.connections.get(peerId);
    if (storedConn != null && storedConn.length > 1) {
      storedConn = storedConn.filter((conn) => conn.id !== connection.id);
      this.connections.set(peerId, storedConn);
    } else if (storedConn != null) {
      this.connections.delete(peerId);
      this.dispatchEvent(new CustomEvent2("peer:disconnect", { detail: connection }));
    }
  }
  getConnections(peerId) {
    if (peerId != null) {
      return this.connections.get(peerId.toString()) ?? [];
    }
    let conns = [];
    for (const c of this.connections.values()) {
      conns = conns.concat(c);
    }
    return conns;
  }
  async openConnection(peerIdOrMultiaddr, options = {}) {
    const { peerId, multiaddr: multiaddr2 } = getPeerAddress(peerIdOrMultiaddr);
    if (peerId == null && multiaddr2 == null) {
      throw (0, import_err_code95.default)(new TypeError("Can only open connections to PeerIds or Multiaddrs"), codes4.ERR_INVALID_PARAMETERS);
    }
    if (peerId != null) {
      log59("dial to", peerId);
      const existingConnections = this.getConnections(peerId);
      if (existingConnections.length > 0) {
        log59("had an existing connection to %p", peerId);
        return existingConnections[0];
      }
    }
    let timeoutController;
    if (options?.signal == null) {
      timeoutController = new import_timeout_abort_controller5.TimeoutController(this.dialTimeout);
      options.signal = timeoutController.signal;
      try {
        (0, import_events13.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      const connection = await this.components.dialer.dial(peerIdOrMultiaddr, options);
      let peerConnections = this.connections.get(connection.remotePeer.toString());
      if (peerConnections == null) {
        peerConnections = [];
        this.connections.set(connection.remotePeer.toString(), peerConnections);
      }
      let trackedConnection = false;
      for (const conn of peerConnections) {
        if (conn.id === connection.id) {
          trackedConnection = true;
        }
      }
      if (!trackedConnection) {
        peerConnections.push(connection);
      }
      return connection;
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
    }
  }
  async closeConnections(peerId) {
    const connections = this.connections.get(peerId.toString()) ?? [];
    await Promise.all(connections.map(async (connection) => {
      return await connection.close();
    }));
  }
  /**
   * Get all open connections with a peer
   */
  getAll(peerId) {
    if (!isPeerId(peerId)) {
      throw (0, import_err_code95.default)(new Error("peerId must be an instance of peer-id"), codes4.ERR_INVALID_PARAMETERS);
    }
    const id = peerId.toString();
    const connections = this.connections.get(id);
    if (connections != null) {
      return connections.filter((connection) => connection.stat.status === OPEN);
    }
    return [];
  }
  /**
   * If the event loop is slow, maybe close a connection
   */
  _onLatencyMeasure(evt) {
    const { detail: summary } = evt;
    this._checkMaxLimit("maxEventLoopDelay", summary.avgMs, 1).catch((err2) => {
      log59.error(err2);
    });
  }
  /**
   * If the `value` of `name` has exceeded its limit, maybe close a connection
   */
  async _checkMaxLimit(name9, value2, toPrune = 1) {
    const limit = this.opts[name9];
    if (limit == null) {
      log59.trace("limit %s was not set so it cannot be applied", name9);
      return;
    }
    log59.trace("checking limit of %s. current value: %d of %d", name9, value2, limit);
    if (value2 > limit) {
      log59("%s: limit exceeded: %p, %d/%d, pruning %d connection(s)", this.components.peerId, name9, value2, limit, toPrune);
      await this._pruneConnections(toPrune);
    }
  }
  /**
   * If we have more connections than our maximum, select some excess connections
   * to prune based on peer value
   */
  async _pruneConnections(toPrune) {
    const connections = this.getConnections();
    const peerValues = new PeerMap();
    for (const connection of connections) {
      const remotePeer = connection.remotePeer;
      if (peerValues.has(remotePeer)) {
        continue;
      }
      const tags = await this.components.peerStore.getTags(remotePeer);
      peerValues.set(remotePeer, tags.reduce((acc, curr) => {
        return acc + curr.value;
      }, 0));
    }
    const sortedConnections = connections.sort((a, b) => {
      const peerAValue = peerValues.get(a.remotePeer) ?? 0;
      const peerBValue = peerValues.get(b.remotePeer) ?? 0;
      if (peerAValue > peerBValue) {
        return 1;
      }
      if (peerAValue < peerBValue) {
        return -1;
      }
      const connectionALifespan = a.stat.timeline.open;
      const connectionBLifespan = b.stat.timeline.open;
      if (connectionALifespan < connectionBLifespan) {
        return 1;
      }
      if (connectionALifespan > connectionBLifespan) {
        return -1;
      }
      return 0;
    });
    const toClose = [];
    for (const connection of sortedConnections) {
      log59("too many connections open - closing a connection to %p", connection.remotePeer);
      toClose.push(connection);
      if (toClose.length === toPrune) {
        break;
      }
    }
    await Promise.all(toClose.map(async (connection) => {
      try {
        await connection.close();
      } catch (err2) {
        log59.error(err2);
      }
      this.onDisconnect(new CustomEvent2("connectionEnd", {
        detail: connection
      }));
    }));
  }
  async acceptIncomingConnection(maConn) {
    const denyConnection = this.deny.some((ma) => {
      return maConn.remoteAddr.toString().startsWith(ma.toString());
    });
    if (denyConnection) {
      log59("connection from %s refused - connection remote address was in deny list", maConn.remoteAddr);
      return false;
    }
    const allowConnection = this.allow.some((ma) => {
      return maConn.remoteAddr.toString().startsWith(ma.toString());
    });
    if (allowConnection) {
      this.incomingPendingConnections++;
      return true;
    }
    if (this.incomingPendingConnections === this.opts.maxIncomingPendingConnections) {
      log59("connection from %s refused - incomingPendingConnections exceeded by peer %s", maConn.remoteAddr);
      return false;
    }
    if (maConn.remoteAddr.isThinWaistAddress()) {
      const host = maConn.remoteAddr.nodeAddress().address;
      try {
        await this.inboundConnectionRateLimiter.consume(host, 1);
      } catch {
        log59("connection from %s refused - inboundConnectionThreshold exceeded by host %s", host, maConn.remoteAddr);
        return false;
      }
    }
    if (this.getConnections().length < this.opts.maxConnections) {
      this.incomingPendingConnections++;
      return true;
    }
    log59("connection from %s refused - maxConnections exceeded", maConn.remoteAddr);
    return false;
  }
  afterUpgradeInbound() {
    this.incomingPendingConnections--;
  }
};
var import_retimer = __toESM(require_retimer(), 1);
var log60 = logger("libp2p:connection-manager:auto-dialler");
var defaultOptions17 = {
  enabled: true,
  minConnections: 0,
  autoDialInterval: 1e4
};
var AutoDialler = class {
  /**
   * Proactively tries to connect to known peers stored in the PeerStore.
   * It will keep the number of connections below the upper limit and sort
   * the peers to connect based on wether we know their keys and protocols.
   */
  constructor(components, init) {
    this.components = components;
    this.options = merge_options_default.call({ ignoreUndefined: true }, defaultOptions17, init);
    this.running = false;
    this._autoDial = this._autoDial.bind(this);
    log60("options: %j", this.options);
  }
  isStarted() {
    return this.running;
  }
  /**
   * Starts the auto dialer
   */
  async start() {
    if (!this.options.enabled) {
      log60("not enabled");
      return;
    }
    this.running = true;
    void this._autoDial().catch((err2) => {
      log60.error("could start autodial", err2);
    });
    log60("started");
  }
  /**
   * Stops the auto dialler
   */
  async stop() {
    if (!this.options.enabled) {
      log60("not enabled");
      return;
    }
    this.running = false;
    if (this.autoDialTimeout != null) {
      this.autoDialTimeout.clear();
    }
    log60("stopped");
  }
  async _autoDial() {
    if (this.autoDialTimeout != null) {
      this.autoDialTimeout.clear();
    }
    const minConnections = this.options.minConnections;
    if (this.components.connectionManager.getConnections().length >= minConnections) {
      this.autoDialTimeout = (0, import_retimer.default)(this._autoDial, this.options.autoDialInterval);
      return;
    }
    const allPeers = await this.components.peerStore.all();
    const peers = await pipe(
      // shuffle the peers
      allPeers.sort(() => Math.random() > 0.5 ? 1 : -1),
      (source) => filter(source, (peer) => !peer.id.equals(this.components.peerId)),
      (source) => sort(source, (a, b) => {
        if (b.protocols.length > a.protocols.length) {
          return 1;
        } else if (b.id.publicKey != null && a.id.publicKey == null) {
          return 1;
        }
        return -1;
      }),
      async (source) => await all(source)
    );
    for (let i2 = 0; this.running && i2 < peers.length && this.components.connectionManager.getConnections().length < minConnections; i2++) {
      if (!this.running) {
        return;
      }
      const peer = peers[i2];
      if (this.components.connectionManager.getConnections(peer.id).length === 0) {
        log60("connecting to a peerStore stored peer %p", peer.id);
        try {
          await this.components.connectionManager.openConnection(peer.id);
        } catch (err2) {
          log60.error("could not connect to peerStore stored peer", err2);
        }
      }
    }
    if (!this.running) {
      return;
    }
    this.autoDialTimeout = (0, import_retimer.default)(this._autoDial, this.options.autoDialInterval);
  }
};
var import_err_code97 = __toESM(require_err_code(), 1);
var CircuitRelay;
(function(CircuitRelay2) {
  (function(Status2) {
    Status2["SUCCESS"] = "SUCCESS";
    Status2["HOP_SRC_ADDR_TOO_LONG"] = "HOP_SRC_ADDR_TOO_LONG";
    Status2["HOP_DST_ADDR_TOO_LONG"] = "HOP_DST_ADDR_TOO_LONG";
    Status2["HOP_SRC_MULTIADDR_INVALID"] = "HOP_SRC_MULTIADDR_INVALID";
    Status2["HOP_DST_MULTIADDR_INVALID"] = "HOP_DST_MULTIADDR_INVALID";
    Status2["HOP_NO_CONN_TO_DST"] = "HOP_NO_CONN_TO_DST";
    Status2["HOP_CANT_DIAL_DST"] = "HOP_CANT_DIAL_DST";
    Status2["HOP_CANT_OPEN_DST_STREAM"] = "HOP_CANT_OPEN_DST_STREAM";
    Status2["HOP_CANT_SPEAK_RELAY"] = "HOP_CANT_SPEAK_RELAY";
    Status2["HOP_CANT_RELAY_TO_SELF"] = "HOP_CANT_RELAY_TO_SELF";
    Status2["STOP_SRC_ADDR_TOO_LONG"] = "STOP_SRC_ADDR_TOO_LONG";
    Status2["STOP_DST_ADDR_TOO_LONG"] = "STOP_DST_ADDR_TOO_LONG";
    Status2["STOP_SRC_MULTIADDR_INVALID"] = "STOP_SRC_MULTIADDR_INVALID";
    Status2["STOP_DST_MULTIADDR_INVALID"] = "STOP_DST_MULTIADDR_INVALID";
    Status2["STOP_RELAY_REFUSED"] = "STOP_RELAY_REFUSED";
    Status2["MALFORMED_MESSAGE"] = "MALFORMED_MESSAGE";
  })(CircuitRelay2.Status || (CircuitRelay2.Status = {}));
  let __StatusValues;
  (function(__StatusValues2) {
    __StatusValues2[__StatusValues2["SUCCESS"] = 100] = "SUCCESS";
    __StatusValues2[__StatusValues2["HOP_SRC_ADDR_TOO_LONG"] = 220] = "HOP_SRC_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["HOP_DST_ADDR_TOO_LONG"] = 221] = "HOP_DST_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["HOP_SRC_MULTIADDR_INVALID"] = 250] = "HOP_SRC_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["HOP_DST_MULTIADDR_INVALID"] = 251] = "HOP_DST_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["HOP_NO_CONN_TO_DST"] = 260] = "HOP_NO_CONN_TO_DST";
    __StatusValues2[__StatusValues2["HOP_CANT_DIAL_DST"] = 261] = "HOP_CANT_DIAL_DST";
    __StatusValues2[__StatusValues2["HOP_CANT_OPEN_DST_STREAM"] = 262] = "HOP_CANT_OPEN_DST_STREAM";
    __StatusValues2[__StatusValues2["HOP_CANT_SPEAK_RELAY"] = 270] = "HOP_CANT_SPEAK_RELAY";
    __StatusValues2[__StatusValues2["HOP_CANT_RELAY_TO_SELF"] = 280] = "HOP_CANT_RELAY_TO_SELF";
    __StatusValues2[__StatusValues2["STOP_SRC_ADDR_TOO_LONG"] = 320] = "STOP_SRC_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["STOP_DST_ADDR_TOO_LONG"] = 321] = "STOP_DST_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["STOP_SRC_MULTIADDR_INVALID"] = 350] = "STOP_SRC_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["STOP_DST_MULTIADDR_INVALID"] = 351] = "STOP_DST_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["STOP_RELAY_REFUSED"] = 390] = "STOP_RELAY_REFUSED";
    __StatusValues2[__StatusValues2["MALFORMED_MESSAGE"] = 400] = "MALFORMED_MESSAGE";
  })(__StatusValues || (__StatusValues = {}));
  (function(Status2) {
    Status2.codec = () => {
      return enumeration(__StatusValues);
    };
  })(CircuitRelay2.Status || (CircuitRelay2.Status = {}));
  (function(Type3) {
    Type3["HOP"] = "HOP";
    Type3["STOP"] = "STOP";
    Type3["STATUS"] = "STATUS";
    Type3["CAN_HOP"] = "CAN_HOP";
  })(CircuitRelay2.Type || (CircuitRelay2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["HOP"] = 1] = "HOP";
    __TypeValues2[__TypeValues2["STOP"] = 2] = "STOP";
    __TypeValues2[__TypeValues2["STATUS"] = 3] = "STATUS";
    __TypeValues2[__TypeValues2["CAN_HOP"] = 4] = "CAN_HOP";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type3) {
    Type3.codec = () => {
      return enumeration(__TypeValues);
    };
  })(CircuitRelay2.Type || (CircuitRelay2.Type = {}));
  (function(Peer4) {
    let _codec2;
    Peer4.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (opts.writeDefaults === true || obj.id != null && obj.id.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.id);
          }
          if (obj.addrs != null) {
            for (const value2 of obj.addrs) {
              w.uint32(18);
              w.bytes(value2);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader3, length3) => {
          const obj = {
            id: new Uint8Array(0),
            addrs: []
          };
          const end = length3 == null ? reader3.len : reader3.pos + length3;
          while (reader3.pos < end) {
            const tag = reader3.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.id = reader3.bytes();
                break;
              case 2:
                obj.addrs.push(reader3.bytes());
                break;
              default:
                reader3.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer4.encode = (obj) => {
      return encodeMessage(obj, Peer4.codec());
    };
    Peer4.decode = (buf2) => {
      return decodeMessage(buf2, Peer4.codec());
    };
  })(CircuitRelay2.Peer || (CircuitRelay2.Peer = {}));
  let _codec;
  CircuitRelay2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          CircuitRelay2.Type.codec().encode(obj.type, w);
        }
        if (obj.srcPeer != null) {
          w.uint32(18);
          CircuitRelay2.Peer.codec().encode(obj.srcPeer, w, {
            writeDefaults: false
          });
        }
        if (obj.dstPeer != null) {
          w.uint32(26);
          CircuitRelay2.Peer.codec().encode(obj.dstPeer, w, {
            writeDefaults: false
          });
        }
        if (obj.code != null) {
          w.uint32(32);
          CircuitRelay2.Status.codec().encode(obj.code, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {};
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = CircuitRelay2.Type.codec().decode(reader3);
              break;
            case 2:
              obj.srcPeer = CircuitRelay2.Peer.codec().decode(reader3, reader3.uint32());
              break;
            case 3:
              obj.dstPeer = CircuitRelay2.Peer.codec().decode(reader3, reader3.uint32());
              break;
            case 4:
              obj.code = CircuitRelay2.Status.codec().decode(reader3);
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  CircuitRelay2.encode = (obj) => {
    return encodeMessage(obj, CircuitRelay2.codec());
  };
  CircuitRelay2.decode = (buf2) => {
    return decodeMessage(buf2, CircuitRelay2.codec());
  };
})(CircuitRelay || (CircuitRelay = {}));
var log61 = logger("libp2p:stream:converter");
function streamToMaConnection(props, options = {}) {
  const { stream, remoteAddr } = props;
  const { sink, source } = stream;
  const mapSource = async function* () {
    for await (const list of source) {
      yield* list;
    }
  }();
  const maConn = {
    async sink(source2) {
      if (options.signal != null) {
        source2 = abortableSource(source2, options.signal);
      }
      try {
        await sink(source2);
        await close();
      } catch (err2) {
        if (err2.type !== "aborted") {
          log61(err2);
        }
      }
    },
    source: options.signal != null ? abortableSource(mapSource, options.signal) : mapSource,
    remoteAddr,
    /** @type {Timeline} */
    timeline: { open: Date.now(), close: void 0 },
    async close() {
      await sink(async function* () {
        yield new Uint8Array(0);
      }());
      await close();
    }
  };
  async function close() {
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
    return await Promise.resolve();
  }
  return maConn;
}
var RELAY_CODEC = "/libp2p/circuit/relay/0.1.0";
function createListener2(options) {
  const listeningAddrs = /* @__PURE__ */ new Map();
  async function listen(addr) {
    const addrString = addr.toString().split("/p2p-circuit").find((a) => a !== "");
    const ma = multiaddr(addrString);
    const relayPeerStr = ma.getPeerId();
    if (relayPeerStr == null) {
      throw new Error("Could not determine relay peer from multiaddr");
    }
    const relayPeerId = peerIdFromString(relayPeerStr);
    await options.peerStore.addressBook.add(relayPeerId, [ma]);
    const relayConn = await options.connectionManager.openConnection(relayPeerId);
    const relayedAddr = relayConn.remoteAddr.encapsulate("/p2p-circuit");
    listeningAddrs.set(relayConn.remotePeer.toString(), relayedAddr);
    listener.dispatchEvent(new CustomEvent2("listening"));
  }
  function getAddrs() {
    const addrs = [];
    for (const addr of listeningAddrs.values()) {
      addrs.push(addr);
    }
    return addrs;
  }
  const listener = Object.assign(new EventEmitter2(), {
    close: async () => await Promise.resolve(),
    listen,
    getAddrs
  });
  options.connectionManager.addEventListener("peer:disconnect", (evt) => {
    const { detail: connection } = evt;
    const deleted = listeningAddrs.delete(connection.remotePeer.toString());
    if (deleted) {
      listener.dispatchEvent(new CustomEvent2("close"));
    }
  });
  return listener;
}
var import_err_code96 = __toESM(require_err_code(), 1);
function writeResponse(streamHandler, status) {
  streamHandler.write({
    type: CircuitRelay.Type.STATUS,
    code: status
  });
}
function validateAddrs(msg, streamHandler) {
  try {
    if (msg.dstPeer?.addrs != null) {
      msg.dstPeer.addrs.forEach((addr) => {
        return multiaddr(addr);
      });
    }
  } catch (err2) {
    writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID : CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID);
    throw err2;
  }
  try {
    if (msg.srcPeer?.addrs != null) {
      msg.srcPeer.addrs.forEach((addr) => {
        return multiaddr(addr);
      });
    }
  } catch (err2) {
    writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID : CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID);
    throw err2;
  }
}
function handshake(stream) {
  const writer2 = pushable();
  const source = reader2(stream.source);
  const sourcePromise = pDefer();
  let sinkErr;
  const sinkPromise = stream.sink(async function* () {
    yield* writer2;
    const source2 = await sourcePromise.promise;
    yield* source2;
  }());
  sinkPromise.catch((err2) => {
    sinkErr = err2;
  });
  const rest = {
    sink: async (source2) => {
      if (sinkErr != null) {
        return await Promise.reject(sinkErr);
      }
      sourcePromise.resolve(source2);
      return await sinkPromise;
    },
    source
  };
  return {
    reader: source,
    writer: writer2,
    stream: rest,
    rest: () => writer2.end(),
    write: writer2.push,
    read: async () => {
      const res = await source.next();
      if (res.value != null) {
        return res.value;
      }
    }
  };
}
var log62 = logger("libp2p:circuit:stream-handler");
var StreamHandler = class {
  constructor(options) {
    const { stream, maxLength = 4096 } = options;
    this.stream = stream;
    this.shake = handshake(this.stream);
    this.decoder = decode14.fromReader(this.shake.reader, { maxDataLength: maxLength });
  }
  /**
   * Read and decode message
   */
  async read() {
    const msg = await this.decoder.next();
    if (msg.value != null) {
      const value2 = CircuitRelay.decode(msg.value);
      log62("read message type", value2.type);
      return value2;
    }
    log62("read received no value, closing stream");
    this.close();
  }
  /**
   * Encode and write array of buffers
   */
  write(msg) {
    log62("write message type %s", msg.type);
    this.shake.write(encode15.single(CircuitRelay.encode(msg)));
  }
  /**
   * Return the handshake rest stream and invalidate handler
   */
  rest() {
    this.shake.rest();
    return this.shake.stream;
  }
  /**
   * @param {CircuitRelay} msg - An unencoded CircuitRelay protobuf message
   */
  end(msg) {
    this.write(msg);
    this.close();
  }
  /**
   * Close the stream
   */
  close() {
    log62("closing the stream");
    void this.rest().sink([]).catch((err2) => {
      log62.error(err2);
    });
  }
};
var log63 = logger("libp2p:circuit:stop");
function handleStop(options) {
  const { connection, request: request2, streamHandler } = options;
  try {
    validateAddrs(request2, streamHandler);
  } catch (err2) {
    log63.error("invalid stop request via peer %p %o", connection.remotePeer, err2);
    return;
  }
  log63("stop request is valid");
  streamHandler.write({
    type: CircuitRelay.Type.STATUS,
    code: CircuitRelay.Status.SUCCESS
  });
  return streamHandler.rest();
}
async function stop(options) {
  const { connection, request: request2, signal } = options;
  const stream = await connection.newStream(RELAY_CODEC, {
    signal
  });
  log63("starting stop request to %p", connection.remotePeer);
  const streamHandler = new StreamHandler({ stream });
  streamHandler.write(request2);
  const response = await streamHandler.read();
  if (response == null) {
    streamHandler.close();
    return;
  }
  if (response.code === CircuitRelay.Status.SUCCESS) {
    log63("stop request to %p was successful", connection.remotePeer);
    return streamHandler.rest();
  }
  log63("stop request failed with code %d", response.code);
  streamHandler.close();
}
var log64 = logger("libp2p:circuit:hop");
async function handleHop(hopRequest) {
  const { connection, request: request2, streamHandler, circuit, connectionManager } = hopRequest;
  if (!circuit.hopEnabled()) {
    log64("HOP request received but we are not acting as a relay");
    return streamHandler.end({
      type: CircuitRelay.Type.STATUS,
      code: CircuitRelay.Status.HOP_CANT_SPEAK_RELAY
    });
  }
  try {
    validateAddrs(request2, streamHandler);
  } catch (err2) {
    log64.error("invalid hop request via peer %p %o", connection.remotePeer, err2);
    return;
  }
  if (request2.dstPeer == null) {
    log64("HOP request received but we do not receive a dstPeer");
    return;
  }
  const destinationPeer = peerIdFromBytes(request2.dstPeer.id);
  const destinationConnections = connectionManager.getConnections(destinationPeer);
  if (destinationConnections.length === 0 && !circuit.hopActive()) {
    log64("HOP request received but we are not connected to the destination peer");
    return streamHandler.end({
      type: CircuitRelay.Type.STATUS,
      code: CircuitRelay.Status.HOP_NO_CONN_TO_DST
    });
  }
  if (destinationConnections.length === 0) {
    log64("did not have connection to remote peer");
    return streamHandler.end({
      type: CircuitRelay.Type.STATUS,
      code: CircuitRelay.Status.HOP_NO_CONN_TO_DST
    });
  }
  const stopRequest = {
    type: CircuitRelay.Type.STOP,
    dstPeer: request2.dstPeer,
    srcPeer: request2.srcPeer
  };
  let destinationStream;
  try {
    log64("performing STOP request");
    const result = await stop({
      connection: destinationConnections[0],
      request: stopRequest
    });
    if (result == null) {
      throw new Error("Could not stop");
    }
    destinationStream = result;
  } catch (err2) {
    log64.error(err2);
    return;
  }
  log64("hop request from %p is valid", connection.remotePeer);
  streamHandler.write({
    type: CircuitRelay.Type.STATUS,
    code: CircuitRelay.Status.SUCCESS
  });
  const sourceStream = streamHandler.rest();
  log64("creating related connections");
  return await pipe(sourceStream, destinationStream, sourceStream);
}
async function hop(options) {
  const { connection, request: request2, signal } = options;
  const stream = await connection.newStream(RELAY_CODEC, {
    signal
  });
  const streamHandler = new StreamHandler({ stream });
  streamHandler.write(request2);
  const response = await streamHandler.read();
  if (response == null) {
    throw (0, import_err_code96.default)(new Error("HOP request had no response"), codes4.ERR_HOP_REQUEST_FAILED);
  }
  if (response.code === CircuitRelay.Status.SUCCESS) {
    log64("hop request was successful");
    return streamHandler.rest();
  }
  log64("hop request failed with code %d, closing stream", response.code);
  streamHandler.close();
  throw (0, import_err_code96.default)(new Error(`HOP request failed with code "${response.code ?? "unknown"}"`), codes4.ERR_HOP_REQUEST_FAILED);
}
async function canHop(options) {
  const { connection, signal } = options;
  const stream = await connection.newStream(RELAY_CODEC, {
    signal
  });
  const streamHandler = new StreamHandler({ stream });
  streamHandler.write({
    type: CircuitRelay.Type.CAN_HOP
  });
  const response = await streamHandler.read();
  await streamHandler.close();
  if (response == null || response.code !== CircuitRelay.Status.SUCCESS) {
    return false;
  }
  return true;
}
function handleCanHop(options) {
  const { connection, streamHandler, circuit } = options;
  const canHop2 = circuit.hopEnabled();
  log64("can hop (%s) request from %p", canHop2, connection.remotePeer);
  streamHandler.end({
    type: CircuitRelay.Type.STATUS,
    code: canHop2 ? CircuitRelay.Status.SUCCESS : CircuitRelay.Status.HOP_CANT_SPEAK_RELAY
  });
}
var import_timeout_abort_controller6 = __toESM(require_timeout_abort_controller(), 1);
var import_events15 = __toESM(require_events(), 1);
var log65 = logger("libp2p:circuit");
var Circuit2 = class {
  constructor(components, init) {
    this._init = init;
    this.components = components;
    this._started = false;
  }
  isStarted() {
    return this._started;
  }
  async start() {
    if (this._started) {
      return;
    }
    this._started = true;
    await this.components.registrar.handle(RELAY_CODEC, (data) => {
      void this._onProtocol(data).catch((err2) => {
        log65.error(err2);
      });
    }, { ...this._init }).catch((err2) => {
      log65.error(err2);
    });
  }
  async stop() {
    await this.components.registrar.unhandle(RELAY_CODEC);
  }
  hopEnabled() {
    return true;
  }
  hopActive() {
    return true;
  }
  get [symbol4]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "libp2p/circuit-relay-v1";
  }
  async _onProtocol(data) {
    const { connection, stream } = data;
    const controller = new import_timeout_abort_controller6.TimeoutController(this._init.hop.timeout);
    try {
      (0, import_events15.setMaxListeners)?.(Infinity, controller.signal);
    } catch {
    }
    try {
      const source = abortableDuplex(stream, controller.signal);
      const streamHandler = new StreamHandler({
        stream: {
          ...stream,
          ...source
        }
      });
      const request2 = await streamHandler.read();
      if (request2 == null) {
        log65("request was invalid, could not read from stream");
        streamHandler.write({
          type: CircuitRelay.Type.STATUS,
          code: CircuitRelay.Status.MALFORMED_MESSAGE
        });
        streamHandler.close();
        return;
      }
      let virtualConnection;
      switch (request2.type) {
        case CircuitRelay.Type.CAN_HOP: {
          log65("received CAN_HOP request from %p", connection.remotePeer);
          await handleCanHop({ circuit: this, connection, streamHandler });
          break;
        }
        case CircuitRelay.Type.HOP: {
          log65("received HOP request from %p", connection.remotePeer);
          await handleHop({
            connection,
            request: request2,
            streamHandler,
            circuit: this,
            connectionManager: this.components.connectionManager
          });
          break;
        }
        case CircuitRelay.Type.STOP: {
          log65("received STOP request from %p", connection.remotePeer);
          virtualConnection = await handleStop({
            connection,
            request: request2,
            streamHandler
          });
          break;
        }
        default: {
          log65("Request of type %s not supported", request2.type);
          streamHandler.write({
            type: CircuitRelay.Type.STATUS,
            code: CircuitRelay.Status.MALFORMED_MESSAGE
          });
          streamHandler.close();
          return;
        }
      }
      if (virtualConnection != null) {
        const remoteAddr = connection.remoteAddr.encapsulate("/p2p-circuit").encapsulate(multiaddr(request2.dstPeer?.addrs[0]));
        const localAddr = multiaddr(request2.srcPeer?.addrs[0]);
        const maConn = streamToMaConnection({
          stream: virtualConnection,
          remoteAddr,
          localAddr
        });
        const type = request2.type === CircuitRelay.Type.HOP ? "relay" : "inbound";
        log65("new %s connection %s", type, maConn.remoteAddr);
        const conn = await this.components.upgrader.upgradeInbound(maConn);
        log65("%s connection %s upgraded", type, maConn.remoteAddr);
        if (this.handler != null) {
          this.handler(conn);
        }
      }
    } finally {
      controller.clear();
    }
  }
  /**
   * Dial a peer over a relay
   */
  async dial(ma, options = {}) {
    const addrs = ma.toString().split("/p2p-circuit");
    const relayAddr = multiaddr(addrs[0]);
    const destinationAddr = multiaddr(addrs[addrs.length - 1]);
    const relayId = relayAddr.getPeerId();
    const destinationId = destinationAddr.getPeerId();
    if (relayId == null || destinationId == null) {
      const errMsg = "Circuit relay dial failed as addresses did not have peer id";
      log65.error(errMsg);
      throw (0, import_err_code97.default)(new Error(errMsg), codes4.ERR_RELAYED_DIAL);
    }
    const relayPeer = peerIdFromString(relayId);
    const destinationPeer = peerIdFromString(destinationId);
    let disconnectOnFailure = false;
    const relayConnections = this.components.connectionManager.getConnections(relayPeer);
    let relayConnection = relayConnections[0];
    if (relayConnection == null) {
      await this.components.peerStore.addressBook.add(relayPeer, [relayAddr]);
      relayConnection = await this.components.connectionManager.openConnection(relayPeer, options);
      disconnectOnFailure = true;
    }
    try {
      const virtualConnection = await hop({
        ...options,
        connection: relayConnection,
        request: {
          type: CircuitRelay.Type.HOP,
          srcPeer: {
            id: this.components.peerId.toBytes(),
            addrs: this.components.addressManager.getAddresses().map((addr) => addr.bytes)
          },
          dstPeer: {
            id: destinationPeer.toBytes(),
            addrs: [multiaddr(destinationAddr).bytes]
          }
        }
      });
      const localAddr = relayAddr.encapsulate(`/p2p-circuit/p2p/${this.components.peerId.toString()}`);
      const maConn = streamToMaConnection({
        stream: virtualConnection,
        remoteAddr: ma,
        localAddr
      });
      log65("new outbound connection %s", maConn.remoteAddr);
      return await this.components.upgrader.upgradeOutbound(maConn);
    } catch (err2) {
      log65.error("Circuit relay dial failed", err2);
      disconnectOnFailure && await relayConnection.close();
      throw err2;
    }
  }
  /**
   * Create a listener
   */
  createListener(options) {
    this.handler = options.handler;
    return createListener2({
      connectionManager: this.components.connectionManager,
      peerStore: this.components.peerStore
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial on
   *
   * @param {Multiaddr[]} multiaddrs
   * @returns {Multiaddr[]}
   */
  filter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return Circuit.matches(ma);
    });
  }
};
var import_set_delayed_interval2 = __toESM(require_src3(), 1);
async function namespaceToCid(namespace3) {
  const bytes2 = new TextEncoder().encode(namespace3);
  const hash3 = await sha256.digest(bytes2);
  return CID.createV0(hash3);
}
var minute3 = 60 * 1e3;
var ADVERTISE_BOOT_DELAY = 15 * minute3;
var ADVERTISE_TTL = 30 * minute3;
var CIRCUIT_PROTO_CODE = 290;
var HOP_METADATA_KEY = "hop_relay";
var HOP_METADATA_VALUE = "true";
var RELAY_RENDEZVOUS_NS = "/libp2p/relay";
var import_netmask = __toESM(require_netmask(), 1);
var word = "[a-fA-F\\d:]";
var boundry = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
var v6segment = "[a-fA-F\\d]{1,4}";
var v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
var v4exact = new RegExp(`^${v4}$`);
var v6exact = new RegExp(`^${v6}$`);
var ipRegex = (options) => options && options.exact ? v46Exact : new RegExp(`(?:${boundry(options)}${v4}${boundry(options)})|(?:${boundry(options)}${v6}${boundry(options)})`, "g");
ipRegex.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${boundry(options)}${v4}${boundry(options)}`, "g");
ipRegex.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${boundry(options)}${v6}${boundry(options)}`, "g");
var ip_regex_default = ipRegex;
var import_ipaddr = __toESM(require_ipaddr(), 1);
var { isValid: is_valid, parse: parse4 } = import_ipaddr.default;
var PRIVATE_IP_RANGES = [
  "0.0.0.0/8",
  "10.0.0.0/8",
  "100.64.0.0/10",
  "127.0.0.0/8",
  "169.254.0.0/16",
  "172.16.0.0/12",
  "192.0.0.0/24",
  "192.0.0.0/29",
  "192.0.0.8/32",
  "192.0.0.9/32",
  "192.0.0.10/32",
  "192.0.0.170/32",
  "192.0.0.171/32",
  "192.0.2.0/24",
  "192.31.196.0/24",
  "192.52.193.0/24",
  "192.88.99.0/24",
  "192.168.0.0/16",
  "192.175.48.0/24",
  "198.18.0.0/15",
  "198.51.100.0/24",
  "203.0.113.0/24",
  "240.0.0.0/4",
  "255.255.255.255/32"
];
var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ip_range) => new import_netmask.Netmask(ip_range));
function ipv4_check(ip_addr) {
  for (let r of NETMASK_RANGES) {
    if (r.contains(ip_addr))
      return true;
  }
  return false;
}
function ipv6_check(ip_addr) {
  return /^::$/.test(ip_addr) || /^::1$/.test(ip_addr) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ip_addr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ip_addr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ip_addr);
}
var lib_default = (ip) => {
  if (is_valid(ip)) {
    const parsed = parse4(ip);
    if (parsed.kind() === "ipv4")
      return ipv4_check(parsed.toNormalizedString());
    else if (parsed.kind() === "ipv6")
      return ipv6_check(ip);
  } else if (isIP(ip) && ip_regex_default.v6().test(ip))
    return ipv6_check(ip);
  return void 0;
};
var private_ip_default = lib_default;
function isPrivate(ma) {
  const { address } = ma.nodeAddress();
  return Boolean(private_ip_default(address));
}
function publicAddressesFirst(a, b) {
  const isAPrivate = isPrivate(a.multiaddr);
  const isBPrivate = isPrivate(b.multiaddr);
  if (isAPrivate && !isBPrivate) {
    return 1;
  } else if (!isAPrivate && isBPrivate) {
    return -1;
  }
  if (a.isCertified && !b.isCertified) {
    return -1;
  } else if (!a.isCertified && b.isCertified) {
    return 1;
  }
  return 0;
}
var log66 = logger("libp2p:auto-relay");
var noop4 = () => {
};
var AutoRelay = class {
  constructor(components, init) {
    this.components = components;
    this.addressSorter = init.addressSorter ?? publicAddressesFirst;
    this.maxListeners = init.maxListeners ?? 1;
    this.listenRelays = /* @__PURE__ */ new Set();
    this.onError = init.onError ?? noop4;
    this._onProtocolChange = this._onProtocolChange.bind(this);
    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);
    this.components.peerStore.addEventListener("change:protocols", (evt) => {
      void this._onProtocolChange(evt).catch((err2) => {
        log66.error(err2);
      });
    });
    this.components.connectionManager.addEventListener("peer:disconnect", this._onPeerDisconnected);
  }
  /**
   * Check if a peer supports the relay protocol.
   * If the protocol is not supported, check if it was supported before and remove it as a listen relay.
   * If the protocol is supported, check if the peer supports **HOP** and add it as a listener if
   * inside the threshold.
   */
  async _onProtocolChange(evt) {
    const { peerId, protocols } = evt.detail;
    const id = peerId.toString();
    const hasProtocol = protocols.find((protocol4) => protocol4 === RELAY_CODEC);
    if (hasProtocol == null) {
      if (this.listenRelays.has(id)) {
        await this._removeListenRelay(id);
      }
      return;
    }
    if (this.listenRelays.has(id)) {
      return;
    }
    try {
      const connections = this.components.connectionManager.getConnections(peerId);
      if (connections.length === 0) {
        return;
      }
      const connection = connections[0];
      if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {
        log66(`relayed connection to ${id} will not be used to hop on`);
        return;
      }
      const supportsHop = await canHop({ connection });
      if (supportsHop) {
        await this.components.peerStore.metadataBook.setValue(peerId, HOP_METADATA_KEY, fromString3(HOP_METADATA_VALUE));
        await this._addListenRelay(connection, id);
      }
    } catch (err2) {
      this.onError(err2);
    }
  }
  /**
   * Peer disconnects
   */
  _onPeerDisconnected(evt) {
    const connection = evt.detail;
    const peerId = connection.remotePeer;
    const id = peerId.toString();
    if (!this.listenRelays.has(id)) {
      return;
    }
    this._removeListenRelay(id).catch((err2) => {
      log66.error(err2);
    });
  }
  /**
   * Attempt to listen on the given relay connection
   */
  async _addListenRelay(connection, id) {
    try {
      if (this.listenRelays.size >= this.maxListeners) {
        return;
      }
      const remoteAddrs = await pipe(await this.components.peerStore.addressBook.get(connection.remotePeer), (source) => sort(source, this.addressSorter), async (source) => await all(source));
      const result = await Promise.all(remoteAddrs.map(async (addr) => {
        try {
          let multiaddr2 = addr.multiaddr;
          if (multiaddr2.getPeerId() == null) {
            multiaddr2 = multiaddr2.encapsulate(`/p2p/${connection.remotePeer.toString()}`);
          }
          multiaddr2 = multiaddr2.encapsulate("/p2p-circuit");
          await this.components.transportManager.listen([multiaddr2]);
          return true;
        } catch (err2) {
          log66.error("error listening on circuit address", err2);
          this.onError(err2);
        }
        return false;
      }));
      if (result.includes(true)) {
        this.listenRelays.add(id);
      }
    } catch (err2) {
      this.onError(err2);
      this.listenRelays.delete(id);
    }
  }
  /**
   * Remove listen relay
   */
  async _removeListenRelay(id) {
    if (this.listenRelays.delete(id)) {
      await this._listenOnAvailableHopRelays([id]);
    }
  }
  /**
   * Try to listen on available hop relay connections.
   * The following order will happen while we do not have enough relays.
   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected.
   * 2. Dial and try to listen on the peers we know that support hop but are not connected.
   * 3. Search the network.
   */
  async _listenOnAvailableHopRelays(peersToIgnore = []) {
    if (this.listenRelays.size >= this.maxListeners) {
      return;
    }
    const knownHopsToDial = [];
    const peers = await this.components.peerStore.all();
    for (const { id, metadata } of peers) {
      const idStr = id.toString();
      if (this.listenRelays.has(idStr)) {
        continue;
      }
      if (peersToIgnore.includes(idStr)) {
        continue;
      }
      const supportsHop = metadata.get(HOP_METADATA_KEY);
      if (supportsHop == null || toString3(supportsHop) !== HOP_METADATA_VALUE) {
        continue;
      }
      const connections = this.components.connectionManager.getConnections(id);
      if (connections.length === 0) {
        knownHopsToDial.push(id);
        continue;
      }
      await this._addListenRelay(connections[0], idStr);
      if (this.listenRelays.size >= this.maxListeners) {
        return;
      }
    }
    for (const peerId of knownHopsToDial) {
      await this._tryToListenOnRelay(peerId);
      if (this.listenRelays.size >= this.maxListeners) {
        return;
      }
    }
    try {
      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
      for await (const provider of this.components.contentRouting.findProviders(cid)) {
        if (provider.multiaddrs.length === 0) {
          continue;
        }
        const peerId = provider.id;
        if (peerId.equals(this.components.peerId)) {
          continue;
        }
        await this.components.peerStore.addressBook.add(peerId, provider.multiaddrs);
        await this._tryToListenOnRelay(peerId);
        if (this.listenRelays.size >= this.maxListeners) {
          return;
        }
      }
    } catch (err2) {
      this.onError(err2);
    }
  }
  async _tryToListenOnRelay(peerId) {
    try {
      const connection = await this.components.connectionManager.openConnection(peerId);
      await this._addListenRelay(connection, peerId.toString());
    } catch (err2) {
      log66.error("Could not use %p as relay", peerId, err2);
      this.onError(err2, `could not connect and listen on known hop relay ${peerId.toString()}`);
    }
  }
};
var log67 = logger("libp2p:relay");
var Relay = class {
  /**
   * Creates an instance of Relay
   */
  constructor(components, init) {
    this.components = components;
    this.autoRelay = init.autoRelay?.enabled !== false ? new AutoRelay(components, {
      addressSorter: init.addressSorter,
      ...init.autoRelay
    }) : void 0;
    this.started = false;
    this.init = init;
    this._advertiseService = this._advertiseService.bind(this);
  }
  isStarted() {
    return this.started;
  }
  /**
   * Start Relay service
   */
  async start() {
    if (this.init.hop.enabled !== false && this.init.advertise.enabled !== false) {
      this.timeout = (0, import_set_delayed_interval2.setDelayedInterval)(this._advertiseService, this.init.advertise.ttl, this.init.advertise.bootDelay);
    }
    this.started = true;
  }
  /**
   * Stop Relay service
   */
  async stop() {
    if (this.timeout != null) {
      (0, import_set_delayed_interval2.clearDelayedInterval)(this.timeout);
    }
    this.started = false;
  }
  /**
   * Advertise hop relay service in the network.
   */
  async _advertiseService() {
    try {
      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
      await this.components.contentRouting.provide(cid);
    } catch (err2) {
      if (err2.code === codes4.ERR_NO_ROUTERS_AVAILABLE) {
        log67.error("a content router, such as a DHT, must be provided in order to advertise the relay service", err2);
        await this.stop();
      } else {
        log67.error(err2);
      }
    }
  }
};
var import_sanitize_filename = __toESM(require_sanitize_filename(), 1);
__toESM(require_pkcs7(), 1);
__toESM(require_pbe(), 1);
var import_forge8 = __toESM(require_forge(), 1);
__toESM(require_x509(), 1);
var import_forge7 = __toESM(require_forge(), 1);
var pki = import_forge7.default.pki;
var certificateForKey = (key, privateKey) => {
  const publicKey = pki.rsa.setPublicKey(privateKey.n, privateKey.e);
  const cert = pki.createCertificate();
  cert.publicKey = publicKey;
  cert.serialNumber = "01";
  cert.validity.notBefore = new Date();
  cert.validity.notAfter = new Date();
  cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 10);
  const attrs = [{
    name: "organizationName",
    value: "ipfs"
  }, {
    shortName: "OU",
    value: "keystore"
  }, {
    name: "commonName",
    value: key.id
  }];
  cert.setSubject(attrs);
  cert.setIssuer(attrs);
  cert.setExtensions([{
    name: "basicConstraints",
    cA: true
  }, {
    name: "keyUsage",
    keyCertSign: true,
    digitalSignature: true,
    nonRepudiation: true,
    keyEncipherment: true,
    dataEncipherment: true
  }, {
    name: "extKeyUsage",
    serverAuth: true,
    clientAuth: true,
    codeSigning: true,
    emailProtection: true,
    timeStamping: true
  }, {
    name: "nsCertType",
    client: true,
    server: true,
    email: true,
    objsign: true,
    sslCA: true,
    emailCA: true,
    objCA: true
  }]);
  cert.sign(privateKey);
  return cert;
};
async function findAsync(array, asyncCompare) {
  const promises = array.map(asyncCompare);
  const results = await Promise.all(promises);
  const index2 = results.findIndex((result) => result);
  return array[index2];
}
var import_err_code98 = __toESM(require_err_code(), 1);
var log68 = logger("libp2p:keychain:cms");
var privates = /* @__PURE__ */ new WeakMap();
var CMS = class {
  /**
   * Creates a new instance with a keychain
   */
  constructor(keychain, dek) {
    if (keychain == null) {
      throw (0, import_err_code98.default)(new Error("keychain is required"), codes4.ERR_KEYCHAIN_REQUIRED);
    }
    this.keychain = keychain;
    privates.set(this, { dek });
  }
  /**
   * Creates some protected data.
   *
   * The output Uint8Array contains the PKCS #7 message in DER.
   */
  async encrypt(name9, plain) {
    if (!(plain instanceof Uint8Array)) {
      throw (0, import_err_code98.default)(new Error("Plain data must be a Uint8Array"), codes4.ERR_INVALID_PARAMETERS);
    }
    const key = await this.keychain.findKeyByName(name9);
    const pem = await this.keychain.getPrivateKey(name9);
    const cached = privates.get(this);
    if (cached == null) {
      throw (0, import_err_code98.default)(new Error("dek missing"), codes4.ERR_INVALID_PARAMETERS);
    }
    const dek = cached.dek;
    const privateKey = import_forge8.default.pki.decryptRsaPrivateKey(pem, dek);
    const certificate = await certificateForKey(key, privateKey);
    const p7 = import_forge8.default.pkcs7.createEnvelopedData();
    p7.addRecipient(certificate);
    p7.content = import_forge8.default.util.createBuffer(plain);
    p7.encrypt();
    const der = import_forge8.default.asn1.toDer(p7.toAsn1()).getBytes();
    return fromString3(der, "ascii");
  }
  /**
   * Reads some protected data.
   *
   * The keychain must contain one of the keys used to encrypt the data.  If none of the keys
   * exists, an Error is returned with the property 'missingKeys'.  It is array of key ids.
   */
  async decrypt(cmsData) {
    if (!(cmsData instanceof Uint8Array)) {
      throw (0, import_err_code98.default)(new Error("CMS data is required"), codes4.ERR_INVALID_PARAMETERS);
    }
    let cms;
    try {
      const buf2 = import_forge8.default.util.createBuffer(toString3(cmsData, "ascii"));
      const obj = import_forge8.default.asn1.fromDer(buf2);
      cms = import_forge8.default.pkcs7.messageFromAsn1(obj);
    } catch (err2) {
      log68.error(err2);
      throw (0, import_err_code98.default)(new Error("Invalid CMS"), codes4.ERR_INVALID_CMS);
    }
    const recipients = cms.recipients.filter((r2) => r2.issuer.find((a) => a.shortName === "O" && a.value === "ipfs")).filter((r2) => r2.issuer.find((a) => a.shortName === "CN")).map((r2) => {
      return {
        recipient: r2,
        // @ts-expect-error cms types not defined
        keyId: r2.issuer.find((a) => a.shortName === "CN").value
      };
    });
    const r = await findAsync(recipients, async (recipient) => {
      try {
        const key2 = await this.keychain.findKeyById(recipient.keyId);
        if (key2 != null) {
          return true;
        }
      } catch (err2) {
        return false;
      }
      return false;
    });
    if (r == null) {
      const missingKeys = recipients.map((r2) => r2.keyId);
      throw (0, import_err_code98.default)(new Error(`Decryption needs one of the key(s): ${missingKeys.join(", ")}`), codes4.ERR_MISSING_KEYS, {
        missingKeys
      });
    }
    const key = await this.keychain.findKeyById(r.keyId);
    if (key == null) {
      throw (0, import_err_code98.default)(new Error("No key available to decrypto"), codes4.ERR_NO_KEY);
    }
    const pem = await this.keychain.getPrivateKey(key.name);
    const cached = privates.get(this);
    if (cached == null) {
      throw (0, import_err_code98.default)(new Error("dek missing"), codes4.ERR_INVALID_PARAMETERS);
    }
    const dek = cached.dek;
    const privateKey = import_forge8.default.pki.decryptRsaPrivateKey(pem, dek);
    cms.decrypt(r.recipient, privateKey);
    return fromString3(cms.content.getBytes(), "ascii");
  }
};
var import_err_code99 = __toESM(require_err_code(), 1);
var log69 = logger("libp2p:keychain");
var keyPrefix = "/pkcs8/";
var infoPrefix = "/info/";
var privates2 = /* @__PURE__ */ new WeakMap();
var NIST = {
  minKeyLength: 112 / 8,
  minSaltLength: 128 / 8,
  minIterationCount: 1e3
};
var defaultOptions18 = {
  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/
  dek: {
    keyLength: 512 / 8,
    iterationCount: 1e4,
    salt: "you should override this value with a crypto secure random number",
    hash: "sha2-512"
  }
};
function validateKeyName(name9) {
  if (name9 == null) {
    return false;
  }
  if (typeof name9 !== "string") {
    return false;
  }
  return name9 === (0, import_sanitize_filename.default)(name9.trim()) && name9.length > 0;
}
async function randomDelay() {
  const min = 200;
  const max = 1e3;
  const delay3 = Math.random() * (max - min) + min;
  await new Promise((resolve7) => setTimeout(resolve7, delay3));
}
function DsName(name9) {
  return new Key(keyPrefix + name9);
}
function DsInfoName(name9) {
  return new Key(infoPrefix + name9);
}
var KeyChain = class {
  /**
   * Creates a new instance of a key chain
   */
  constructor(components, init) {
    this.components = components;
    this.init = merge_options_default(defaultOptions18, init);
    if (this.init.pass != null && this.init.pass?.length < 20) {
      throw new Error("pass must be least 20 characters");
    }
    if (this.init.dek?.keyLength != null && this.init.dek.keyLength < NIST.minKeyLength) {
      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);
    }
    if (this.init.dek?.salt?.length != null && this.init.dek.salt.length < NIST.minSaltLength) {
      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);
    }
    if (this.init.dek?.iterationCount != null && this.init.dek.iterationCount < NIST.minIterationCount) {
      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);
    }
    const dek = this.init.pass != null && this.init.dek?.salt != null ? pbkdf2(this.init.pass, this.init.dek?.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
    privates2.set(this, { dek });
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    const dsname = DsInfoName("self");
    if (!await this.components.datastore.has(dsname)) {
      await this.importPeer("self", this.components.peerId);
    }
    this.started = true;
  }
  stop() {
    this.started = false;
  }
  /**
   * Gets an object that can encrypt/decrypt protected data
   * using the Cryptographic Message Syntax (CMS).
   *
   * CMS describes an encapsulation syntax for data protection. It
   * is used to digitally sign, digest, authenticate, or encrypt
   * arbitrary message content
   */
  get cms() {
    const cached = privates2.get(this);
    if (cached == null) {
      throw (0, import_err_code99.default)(new Error("dek missing"), codes4.ERR_INVALID_PARAMETERS);
    }
    const dek = cached.dek;
    return new CMS(this, dek);
  }
  /**
   * Generates the options for a keychain.  A random salt is produced.
   *
   * @returns {object}
   */
  static generateOptions() {
    const options = Object.assign({}, defaultOptions18);
    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3;
    options.dek.salt = toString3(randomBytes$1(saltLength), "base64");
    return options;
  }
  /**
   * Gets an object that can encrypt/decrypt protected data.
   * The default options for a keychain.
   *
   * @returns {object}
   */
  static get options() {
    return defaultOptions18;
  }
  /**
   * Create a new key.
   *
   * @param {string} name - The local key name; cannot already exist.
   * @param {string} type - One of the key types; 'rsa'.
   * @param {number} [size = 2048] - The key size in bits. Used for rsa keys only
   */
  async createKey(name9, type, size = 2048) {
    if (!validateKeyName(name9) || name9 === "self") {
      await randomDelay();
      throw (0, import_err_code99.default)(new Error("Invalid key name"), codes4.ERR_INVALID_KEY_NAME);
    }
    if (typeof type !== "string") {
      await randomDelay();
      throw (0, import_err_code99.default)(new Error("Invalid key type"), codes4.ERR_INVALID_KEY_TYPE);
    }
    const dsname = DsName(name9);
    const exists2 = await this.components.datastore.has(dsname);
    if (exists2) {
      await randomDelay();
      throw (0, import_err_code99.default)(new Error("Key name already exists"), codes4.ERR_KEY_ALREADY_EXISTS);
    }
    switch (type.toLowerCase()) {
      case "rsa":
        if (!Number.isSafeInteger(size) || size < 2048) {
          await randomDelay();
          throw (0, import_err_code99.default)(new Error("Invalid RSA key size"), codes4.ERR_INVALID_KEY_SIZE);
        }
        break;
    }
    let keyInfo;
    try {
      const keypair = await generateKeyPair4(type, size);
      const kid = await keypair.id();
      const cached = privates2.get(this);
      if (cached == null) {
        throw (0, import_err_code99.default)(new Error("dek missing"), codes4.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const pem = await keypair.export(dek);
      keyInfo = {
        name: name9,
        id: kid
      };
      const batch2 = this.components.datastore.batch();
      batch2.put(dsname, fromString3(pem));
      batch2.put(DsInfoName(name9), fromString3(JSON.stringify(keyInfo)));
      await batch2.commit();
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
    return keyInfo;
  }
  /**
   * List all the keys.
   *
   * @returns {Promise<KeyInfo[]>}
   */
  async listKeys() {
    const query = {
      prefix: infoPrefix
    };
    const info = [];
    for await (const value2 of this.components.datastore.query(query)) {
      info.push(JSON.parse(toString3(value2.value)));
    }
    return info;
  }
  /**
   * Find a key by it's id
   */
  async findKeyById(id) {
    try {
      const keys = await this.listKeys();
      return keys.find((k) => k.id === id);
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
  }
  /**
   * Find a key by it's name.
   *
   * @param {string} name - The local key name.
   * @returns {Promise<KeyInfo>}
   */
  async findKeyByName(name9) {
    if (!validateKeyName(name9)) {
      await randomDelay();
      throw (0, import_err_code99.default)(new Error(`Invalid key name '${name9}'`), codes4.ERR_INVALID_KEY_NAME);
    }
    const dsname = DsInfoName(name9);
    try {
      const res = await this.components.datastore.get(dsname);
      return JSON.parse(toString3(res));
    } catch (err2) {
      await randomDelay();
      log69.error(err2);
      throw (0, import_err_code99.default)(new Error(`Key '${name9}' does not exist.`), codes4.ERR_KEY_NOT_FOUND);
    }
  }
  /**
   * Remove an existing key.
   *
   * @param {string} name - The local key name; must already exist.
   * @returns {Promise<KeyInfo>}
   */
  async removeKey(name9) {
    if (!validateKeyName(name9) || name9 === "self") {
      await randomDelay();
      throw (0, import_err_code99.default)(new Error(`Invalid key name '${name9}'`), codes4.ERR_INVALID_KEY_NAME);
    }
    const dsname = DsName(name9);
    const keyInfo = await this.findKeyByName(name9);
    const batch2 = this.components.datastore.batch();
    batch2.delete(dsname);
    batch2.delete(DsInfoName(name9));
    await batch2.commit();
    return keyInfo;
  }
  /**
   * Rename a key
   *
   * @param {string} oldName - The old local key name; must already exist.
   * @param {string} newName - The new local key name; must not already exist.
   * @returns {Promise<KeyInfo>}
   */
  async renameKey(oldName, newName) {
    if (!validateKeyName(oldName) || oldName === "self") {
      await randomDelay();
      throw (0, import_err_code99.default)(new Error(`Invalid old key name '${oldName}'`), codes4.ERR_OLD_KEY_NAME_INVALID);
    }
    if (!validateKeyName(newName) || newName === "self") {
      await randomDelay();
      throw (0, import_err_code99.default)(new Error(`Invalid new key name '${newName}'`), codes4.ERR_NEW_KEY_NAME_INVALID);
    }
    const oldDsname = DsName(oldName);
    const newDsname = DsName(newName);
    const oldInfoName = DsInfoName(oldName);
    const newInfoName = DsInfoName(newName);
    const exists2 = await this.components.datastore.has(newDsname);
    if (exists2) {
      await randomDelay();
      throw (0, import_err_code99.default)(new Error(`Key '${newName}' already exists`), codes4.ERR_KEY_ALREADY_EXISTS);
    }
    try {
      const pem = await this.components.datastore.get(oldDsname);
      const res = await this.components.datastore.get(oldInfoName);
      const keyInfo = JSON.parse(toString3(res));
      keyInfo.name = newName;
      const batch2 = this.components.datastore.batch();
      batch2.put(newDsname, pem);
      batch2.put(newInfoName, fromString3(JSON.stringify(keyInfo)));
      batch2.delete(oldDsname);
      batch2.delete(oldInfoName);
      await batch2.commit();
      return keyInfo;
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
  }
  /**
   * Export an existing key as a PEM encrypted PKCS #8 string
   */
  async exportKey(name9, password) {
    if (!validateKeyName(name9)) {
      await randomDelay();
      throw (0, import_err_code99.default)(new Error(`Invalid key name '${name9}'`), codes4.ERR_INVALID_KEY_NAME);
    }
    if (password == null) {
      await randomDelay();
      throw (0, import_err_code99.default)(new Error("Password is required"), codes4.ERR_PASSWORD_REQUIRED);
    }
    const dsname = DsName(name9);
    try {
      const res = await this.components.datastore.get(dsname);
      const pem = toString3(res);
      const cached = privates2.get(this);
      if (cached == null) {
        throw (0, import_err_code99.default)(new Error("dek missing"), codes4.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const privateKey = await importKey(pem, dek);
      return await privateKey.export(password);
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
  }
  /**
   * Export an existing key as a PeerId
   */
  async exportPeerId(name9) {
    const password = "temporary-password";
    const pem = await this.exportKey(name9, password);
    const privateKey = await importKey(pem, password);
    return await peerIdFromKeys(privateKey.public.bytes, privateKey.bytes);
  }
  /**
   * Import a new key from a PEM encoded PKCS #8 string
   *
   * @param {string} name - The local key name; must not already exist.
   * @param {string} pem - The PEM encoded PKCS #8 string
   * @param {string} password - The password.
   * @returns {Promise<KeyInfo>}
   */
  async importKey(name9, pem, password) {
    if (!validateKeyName(name9) || name9 === "self") {
      await randomDelay();
      throw (0, import_err_code99.default)(new Error(`Invalid key name '${name9}'`), codes4.ERR_INVALID_KEY_NAME);
    }
    if (pem == null) {
      await randomDelay();
      throw (0, import_err_code99.default)(new Error("PEM encoded key is required"), codes4.ERR_PEM_REQUIRED);
    }
    const dsname = DsName(name9);
    const exists2 = await this.components.datastore.has(dsname);
    if (exists2) {
      await randomDelay();
      throw (0, import_err_code99.default)(new Error(`Key '${name9}' already exists`), codes4.ERR_KEY_ALREADY_EXISTS);
    }
    let privateKey;
    try {
      privateKey = await importKey(pem, password);
    } catch (err2) {
      await randomDelay();
      throw (0, import_err_code99.default)(new Error("Cannot read the key, most likely the password is wrong"), codes4.ERR_CANNOT_READ_KEY);
    }
    let kid;
    try {
      kid = await privateKey.id();
      const cached = privates2.get(this);
      if (cached == null) {
        throw (0, import_err_code99.default)(new Error("dek missing"), codes4.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      pem = await privateKey.export(dek);
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
    const keyInfo = {
      name: name9,
      id: kid
    };
    const batch2 = this.components.datastore.batch();
    batch2.put(dsname, fromString3(pem));
    batch2.put(DsInfoName(name9), fromString3(JSON.stringify(keyInfo)));
    await batch2.commit();
    return keyInfo;
  }
  /**
   * Import a peer key
   */
  async importPeer(name9, peer) {
    try {
      if (!validateKeyName(name9)) {
        throw (0, import_err_code99.default)(new Error(`Invalid key name '${name9}'`), codes4.ERR_INVALID_KEY_NAME);
      }
      if (peer == null) {
        throw (0, import_err_code99.default)(new Error("PeerId is required"), codes4.ERR_MISSING_PRIVATE_KEY);
      }
      if (peer.privateKey == null) {
        throw (0, import_err_code99.default)(new Error("PeerId.privKey is required"), codes4.ERR_MISSING_PRIVATE_KEY);
      }
      const privateKey = await unmarshalPrivateKey3(peer.privateKey);
      const dsname = DsName(name9);
      const exists2 = await this.components.datastore.has(dsname);
      if (exists2) {
        await randomDelay();
        throw (0, import_err_code99.default)(new Error(`Key '${name9}' already exists`), codes4.ERR_KEY_ALREADY_EXISTS);
      }
      const cached = privates2.get(this);
      if (cached == null) {
        throw (0, import_err_code99.default)(new Error("dek missing"), codes4.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const pem = await privateKey.export(dek);
      const keyInfo = {
        name: name9,
        id: peer.toString()
      };
      const batch2 = this.components.datastore.batch();
      batch2.put(dsname, fromString3(pem));
      batch2.put(DsInfoName(name9), fromString3(JSON.stringify(keyInfo)));
      await batch2.commit();
      return keyInfo;
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
  }
  /**
   * Gets the private key as PEM encoded PKCS #8 string
   */
  async getPrivateKey(name9) {
    if (!validateKeyName(name9)) {
      await randomDelay();
      throw (0, import_err_code99.default)(new Error(`Invalid key name '${name9}'`), codes4.ERR_INVALID_KEY_NAME);
    }
    try {
      const dsname = DsName(name9);
      const res = await this.components.datastore.get(dsname);
      return toString3(res);
    } catch (err2) {
      await randomDelay();
      log69.error(err2);
      throw (0, import_err_code99.default)(new Error(`Key '${name9}' does not exist.`), codes4.ERR_KEY_NOT_FOUND);
    }
  }
  /**
   * Rotate keychain password and re-encrypt all associated keys
   */
  async rotateKeychainPass(oldPass, newPass) {
    if (typeof oldPass !== "string") {
      await randomDelay();
      throw (0, import_err_code99.default)(new Error(`Invalid old pass type '${typeof oldPass}'`), codes4.ERR_INVALID_OLD_PASS_TYPE);
    }
    if (typeof newPass !== "string") {
      await randomDelay();
      throw (0, import_err_code99.default)(new Error(`Invalid new pass type '${typeof newPass}'`), codes4.ERR_INVALID_NEW_PASS_TYPE);
    }
    if (newPass.length < 20) {
      await randomDelay();
      throw (0, import_err_code99.default)(new Error(`Invalid pass length ${newPass.length}`), codes4.ERR_INVALID_PASS_LENGTH);
    }
    log69("recreating keychain");
    const cached = privates2.get(this);
    if (cached == null) {
      throw (0, import_err_code99.default)(new Error("dek missing"), codes4.ERR_INVALID_PARAMETERS);
    }
    const oldDek = cached.dek;
    this.init.pass = newPass;
    const newDek = newPass != null && this.init.dek?.salt != null ? pbkdf2(newPass, this.init.dek.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
    privates2.set(this, { dek: newDek });
    const keys = await this.listKeys();
    for (const key of keys) {
      const res = await this.components.datastore.get(DsName(key.name));
      const pem = toString3(res);
      const privateKey = await importKey(pem, oldDek);
      const password = newDek.toString();
      const keyAsPEM = await privateKey.export(password);
      const batch2 = this.components.datastore.batch();
      const keyInfo = {
        name: key.name,
        id: key.id
      };
      batch2.put(DsName(key.name), fromString3(keyAsPEM));
      batch2.put(DsInfoName(key.name), fromString3(JSON.stringify(keyInfo)));
      await batch2.commit();
    }
    log69("keychain reconstructed");
  }
};
async function pReflect(promise) {
  try {
    const value2 = await promise;
    return {
      status: "fulfilled",
      value: value2,
      isFulfilled: true,
      isRejected: false
    };
  } catch (error) {
    return {
      status: "rejected",
      reason: error,
      isFulfilled: false,
      isRejected: true
    };
  }
}
var Node = class {
  constructor(value2) {
    __publicField(this, "value");
    __publicField(this, "next");
    this.value = value2;
  }
};
var _head, _tail, _size;
var Queue4 = class {
  constructor() {
    __privateAdd(this, _head, void 0);
    __privateAdd(this, _tail, void 0);
    __privateAdd(this, _size, void 0);
    this.clear();
  }
  enqueue(value2) {
    const node = new Node(value2);
    if (__privateGet(this, _head)) {
      __privateGet(this, _tail).next = node;
      __privateSet(this, _tail, node);
    } else {
      __privateSet(this, _head, node);
      __privateSet(this, _tail, node);
    }
    __privateWrapper(this, _size)._++;
  }
  dequeue() {
    const current = __privateGet(this, _head);
    if (!current) {
      return;
    }
    __privateSet(this, _head, __privateGet(this, _head).next);
    __privateWrapper(this, _size)._--;
    return current.value;
  }
  clear() {
    __privateSet(this, _head, void 0);
    __privateSet(this, _tail, void 0);
    __privateSet(this, _size, 0);
  }
  get size() {
    return __privateGet(this, _size);
  }
  *[Symbol.iterator]() {
    let current = __privateGet(this, _head);
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
};
_head = /* @__PURE__ */ new WeakMap();
_tail = /* @__PURE__ */ new WeakMap();
_size = /* @__PURE__ */ new WeakMap();
function pLimit(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  }
  const queue = new Queue4();
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue.size > 0) {
      queue.dequeue()();
    }
  };
  const run = async (fn, resolve7, args) => {
    activeCount++;
    const result = (async () => fn(...args))();
    resolve7(result);
    try {
      await result;
    } catch {
    }
    next();
  };
  const enqueue = (fn, resolve7, args) => {
    queue.enqueue(run.bind(void 0, fn, resolve7, args));
    (async () => {
      await Promise.resolve();
      if (activeCount < concurrency && queue.size > 0) {
        queue.dequeue()();
      }
    })();
  };
  const generator = (fn, ...args) => new Promise((resolve7) => {
    enqueue(fn, resolve7, args);
  });
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.size
    },
    clearQueue: {
      value: () => {
        queue.clear();
      }
    }
  });
  return generator;
}
async function pSettle(array, options = {}) {
  const { concurrency = Number.POSITIVE_INFINITY } = options;
  const limit = pLimit(concurrency);
  return Promise.all(array.map((element) => {
    if (element && typeof element.then === "function") {
      return pReflect(element);
    }
    if (typeof element === "function") {
      return pReflect(limit(() => element()));
    }
    return pReflect(Promise.resolve(element));
  }));
}
var import_err_code100 = __toESM(require_err_code(), 1);
var TrackedMap = class extends Map {
  constructor(init) {
    super();
    const { name: name9, metrics } = init;
    this.metric = metrics.registerMetric(name9);
    this.updateComponentMetric();
  }
  set(key, value2) {
    super.set(key, value2);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metric.update(this.size);
  }
};
function trackedMap(config2) {
  const { name: name9, metrics } = config2;
  let map4;
  if (metrics != null) {
    map4 = new TrackedMap({ name: name9, metrics });
  } else {
    map4 = /* @__PURE__ */ new Map();
  }
  return map4;
}
var log70 = logger("libp2p:transports");
var DefaultTransportManager = class extends EventEmitter2 {
  constructor(components, init = {}) {
    super();
    this.components = components;
    this.started = false;
    this.transports = /* @__PURE__ */ new Map();
    this.listeners = trackedMap({
      name: "libp2p_transport_manager_listeners",
      metrics: this.components.metrics
    });
    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;
  }
  /**
   * Adds a `Transport` to the manager
   */
  add(transport) {
    const tag = transport[Symbol.toStringTag];
    if (tag == null) {
      throw (0, import_err_code100.default)(new Error("Transport must have a valid tag"), codes4.ERR_INVALID_KEY);
    }
    if (this.transports.has(tag)) {
      throw (0, import_err_code100.default)(new Error("There is already a transport with this tag"), codes4.ERR_DUPLICATE_TRANSPORT);
    }
    log70("adding transport %s", tag);
    this.transports.set(tag, transport);
    if (!this.listeners.has(tag)) {
      this.listeners.set(tag, []);
    }
  }
  isStarted() {
    return this.started;
  }
  async start() {
    const addrs = this.components.addressManager.getListenAddrs();
    await this.listen(addrs);
    this.started = true;
  }
  /**
   * Stops all listeners
   */
  async stop() {
    const tasks = [];
    for (const [key, listeners] of this.listeners) {
      log70("closing listeners for %s", key);
      while (listeners.length > 0) {
        const listener = listeners.pop();
        if (listener == null) {
          continue;
        }
        tasks.push(listener.close());
      }
    }
    await Promise.all(tasks);
    log70("all listeners closed");
    for (const key of this.listeners.keys()) {
      this.listeners.set(key, []);
    }
    this.started = false;
  }
  /**
   * Dials the given Multiaddr over it's supported transport
   */
  async dial(ma, options) {
    const transport = this.transportForMultiaddr(ma);
    if (transport == null) {
      throw (0, import_err_code100.default)(new Error(`No transport available for address ${String(ma)}`), codes4.ERR_TRANSPORT_UNAVAILABLE);
    }
    try {
      return await transport.dial(ma, {
        ...options,
        upgrader: this.components.upgrader
      });
    } catch (err2) {
      if (err2.code == null) {
        err2.code = codes4.ERR_TRANSPORT_DIAL_FAILED;
      }
      throw err2;
    }
  }
  /**
   * Returns all Multiaddr's the listeners are using
   */
  getAddrs() {
    let addrs = [];
    for (const listeners of this.listeners.values()) {
      for (const listener of listeners) {
        addrs = [...addrs, ...listener.getAddrs()];
      }
    }
    return addrs;
  }
  /**
   * Returns all the transports instances
   */
  getTransports() {
    return Array.of(...this.transports.values());
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  transportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.filter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Starts listeners for each listen Multiaddr
   */
  async listen(addrs) {
    if (addrs == null || addrs.length === 0) {
      log70("no addresses were provided for listening, this node is dial only");
      return;
    }
    const couldNotListen = [];
    for (const [key, transport] of this.transports.entries()) {
      const supportedAddrs = transport.filter(addrs);
      const tasks = [];
      for (const addr of supportedAddrs) {
        log70("creating listener for %s on %s", key, addr);
        const listener = transport.createListener({
          upgrader: this.components.upgrader
        });
        let listeners = this.listeners.get(key);
        if (listeners == null) {
          listeners = [];
          this.listeners.set(key, listeners);
        }
        listeners.push(listener);
        listener.addEventListener("listening", () => {
          this.dispatchEvent(new CustomEvent2("listener:listening", {
            detail: listener
          }));
        });
        listener.addEventListener("close", () => {
          this.dispatchEvent(new CustomEvent2("listener:close", {
            detail: listener
          }));
        });
        tasks.push(listener.listen(addr));
      }
      if (tasks.length === 0) {
        couldNotListen.push(key);
        continue;
      }
      const results = await pSettle(tasks);
      const isListening = results.find((r) => r.isFulfilled);
      if (isListening == null && this.faultTolerance !== FaultTolerance.NO_FATAL) {
        throw (0, import_err_code100.default)(new Error(`Transport (${key}) could not listen on any available address`), codes4.ERR_NO_VALID_ADDRESSES);
      }
    }
    if (couldNotListen.length === this.transports.size) {
      const message2 = `no valid addresses were provided for transports [${couldNotListen.join(", ")}]`;
      if (this.faultTolerance === FaultTolerance.FATAL_ALL) {
        throw (0, import_err_code100.default)(new Error(message2), codes4.ERR_NO_VALID_ADDRESSES);
      }
      log70(`libp2p in dial mode only: ${message2}`);
    }
  }
  /**
   * Removes the given transport from the manager.
   * If a transport has any running listeners, they will be closed.
   */
  async remove(key) {
    log70("removing %s", key);
    for (const listener of this.listeners.get(key) ?? []) {
      await listener.close();
    }
    this.transports.delete(key);
    this.listeners.delete(key);
  }
  /**
   * Removes all transports from the manager.
   * If any listeners are running, they will be closed.
   *
   * @async
   */
  async removeAll() {
    const tasks = [];
    for (const key of this.transports.keys()) {
      tasks.push(this.remove(key));
    }
    await Promise.all(tasks);
  }
};
var import_err_code105 = __toESM(require_err_code(), 1);
var PROTOCOL_ID = "/multistream/1.0.0";
var MAX_PROTOCOL_LENGTH = 1024;
var import_err_code102 = __toESM(require_err_code(), 1);
var import_err_code101 = __toESM(require_err_code(), 1);
var log71 = logger("libp2p:mss");
var NewLine = fromString3("\n");
function encode18(buffer2) {
  const list = new Uint8ArrayList(buffer2, NewLine);
  return encode15.single(list);
}
function write2(writer2, buffer2, options = {}) {
  const encoded = encode18(buffer2);
  if (options.writeBytes === true) {
    writer2.push(encoded.subarray());
  } else {
    writer2.push(encoded);
  }
}
function writeAll(writer2, buffers, options = {}) {
  const list = new Uint8ArrayList();
  for (const buf2 of buffers) {
    list.append(encode18(buf2));
  }
  if (options.writeBytes === true) {
    writer2.push(list.subarray());
  } else {
    writer2.push(list);
  }
}
async function read(reader3, options) {
  let byteLength2 = 1;
  const varByteSource = {
    [Symbol.asyncIterator]: () => varByteSource,
    next: async () => await reader3.next(byteLength2)
  };
  let input = varByteSource;
  if (options?.signal != null) {
    input = abortableSource(varByteSource, options.signal);
  }
  const onLength = (l) => {
    byteLength2 = l;
  };
  const buf2 = await pipe(input, decode14({ onLength, maxDataLength: MAX_PROTOCOL_LENGTH }), async (source) => await first(source));
  if (buf2 == null || buf2.length === 0) {
    throw (0, import_err_code101.default)(new Error("no buffer returned"), "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
  }
  if (buf2.get(buf2.byteLength - 1) !== NewLine[0]) {
    log71.error("Invalid mss message - missing newline - %s", buf2.subarray());
    throw (0, import_err_code101.default)(new Error("missing newline"), "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
  }
  return buf2.sublist(0, -1);
}
async function readString(reader3, options) {
  const buf2 = await read(reader3, options);
  return toString3(buf2.subarray());
}
var log72 = logger("libp2p:mss:select");
async function select(stream, protocols, options = {}) {
  protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
  const { reader: reader3, writer: writer2, rest, stream: shakeStream } = handshake(stream);
  const protocol4 = protocols.shift();
  if (protocol4 == null) {
    throw new Error("At least one protocol must be specified");
  }
  log72('select: write ["%s", "%s"]', PROTOCOL_ID, protocol4);
  const p1 = fromString3(PROTOCOL_ID);
  const p2 = fromString3(protocol4);
  writeAll(writer2, [p1, p2], options);
  let response = await readString(reader3, options);
  log72('select: read "%s"', response);
  if (response === PROTOCOL_ID) {
    response = await readString(reader3, options);
    log72('select: read "%s"', response);
  }
  if (response === protocol4) {
    rest();
    return { stream: shakeStream, protocol: protocol4 };
  }
  for (const protocol5 of protocols) {
    log72('select: write "%s"', protocol5);
    write2(writer2, fromString3(protocol5), options);
    const response2 = await readString(reader3, options);
    log72('select: read "%s" for "%s"', response2, protocol5);
    if (response2 === protocol5) {
      rest();
      return { stream: shakeStream, protocol: protocol5 };
    }
  }
  rest();
  throw (0, import_err_code102.default)(new Error("protocol selection failed"), "ERR_UNSUPPORTED_PROTOCOL");
}
var log73 = logger("libp2p:mss:handle");
async function handle(stream, protocols, options) {
  protocols = Array.isArray(protocols) ? protocols : [protocols];
  const { writer: writer2, reader: reader3, rest, stream: shakeStream } = handshake(stream);
  while (true) {
    const protocol4 = await readString(reader3, options);
    log73('read "%s"', protocol4);
    if (protocol4 === PROTOCOL_ID) {
      log73('respond with "%s" for "%s"', PROTOCOL_ID, protocol4);
      write2(writer2, fromString3(PROTOCOL_ID), options);
      continue;
    }
    if (protocols.includes(protocol4)) {
      write2(writer2, fromString3(protocol4), options);
      log73('respond with "%s" for "%s"', protocol4, protocol4);
      rest();
      return { stream: shakeStream, protocol: protocol4 };
    }
    if (protocol4 === "ls") {
      write2(writer2, new Uint8ArrayList(...protocols.map((p) => encode18(fromString3(p)))), options);
      log73('respond with "%s" for %s', protocols, protocol4);
      continue;
    }
    write2(writer2, fromString3("na"), options);
    log73('respond with "na" for "%s"', protocol4);
  }
}
var import_err_code103 = __toESM(require_err_code(), 1);
var symbol6 = Symbol.for("@libp2p/connection");
var log74 = logger("libp2p:connection");
var ConnectionImpl = class {
  /**
   * An implementation of the js-libp2p connection.
   * Any libp2p transport should use an upgrader to return this connection.
   */
  constructor(init) {
    const { remoteAddr, remotePeer, newStream, close, getStreams, stat } = init;
    this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
    this.remoteAddr = remoteAddr;
    this.remotePeer = remotePeer;
    this.stat = {
      ...stat,
      status: OPEN
    };
    this._newStream = newStream;
    this._close = close;
    this._getStreams = getStreams;
    this.tags = [];
    this._closing = false;
  }
  get [Symbol.toStringTag]() {
    return "Connection";
  }
  get [symbol6]() {
    return true;
  }
  /**
   * Get all the streams of the muxer
   */
  get streams() {
    return this._getStreams();
  }
  /**
   * Create a new stream from this connection
   */
  async newStream(protocols, options) {
    if (this.stat.status === CLOSING) {
      throw (0, import_err_code103.default)(new Error("the connection is being closed"), "ERR_CONNECTION_BEING_CLOSED");
    }
    if (this.stat.status === CLOSED) {
      throw (0, import_err_code103.default)(new Error("the connection is closed"), "ERR_CONNECTION_CLOSED");
    }
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    const stream = await this._newStream(protocols, options);
    stream.stat.direction = "outbound";
    return stream;
  }
  /**
   * Add a stream when it is opened to the registry
   */
  addStream(stream) {
    stream.stat.direction = "inbound";
  }
  /**
   * Remove stream registry after it is closed
   */
  removeStream(id) {
  }
  /**
   * Close the connection
   */
  async close() {
    if (this.stat.status === CLOSED || this._closing) {
      return;
    }
    this.stat.status = CLOSING;
    try {
      this.streams.forEach((s) => s.close());
    } catch (err2) {
      log74.error(err2);
    }
    this._closing = true;
    await this._close();
    this._closing = false;
    this.stat.timeline.close = Date.now();
    this.stat.status = CLOSED;
  }
};
function createConnection(init) {
  return new ConnectionImpl(init);
}
var import_err_code104 = __toESM(require_err_code(), 1);
var log75 = logger("libp2p:registrar");
var DEFAULT_MAX_INBOUND_STREAMS = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS = 64;
var DefaultRegistrar = class {
  constructor(components) {
    this.topologies = /* @__PURE__ */ new Map();
    this.handlers = /* @__PURE__ */ new Map();
    this.components = components;
    this._onDisconnect = this._onDisconnect.bind(this);
    this._onProtocolChange = this._onProtocolChange.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this.components.connectionManager.addEventListener("peer:disconnect", this._onDisconnect);
    this.components.connectionManager.addEventListener("peer:connect", this._onConnect);
    this.components.peerStore.addEventListener("change:protocols", this._onProtocolChange);
  }
  getProtocols() {
    return Array.from(/* @__PURE__ */ new Set([
      ...this.topologies.keys(),
      ...this.handlers.keys()
    ])).sort();
  }
  getHandler(protocol4) {
    const handler = this.handlers.get(protocol4);
    if (handler == null) {
      throw (0, import_err_code104.default)(new Error(`No handler registered for protocol ${protocol4}`), codes4.ERR_NO_HANDLER_FOR_PROTOCOL);
    }
    return handler;
  }
  getTopologies(protocol4) {
    const topologies = this.topologies.get(protocol4);
    if (topologies == null) {
      return [];
    }
    return [
      ...topologies.values()
    ];
  }
  /**
   * Registers the `handler` for each protocol
   */
  async handle(protocol4, handler, opts) {
    if (this.handlers.has(protocol4)) {
      throw (0, import_err_code104.default)(new Error(`Handler already registered for protocol ${protocol4}`), codes4.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);
    }
    const options = merge_options_default.bind({ ignoreUndefined: true })({
      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,
      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS
    }, opts);
    this.handlers.set(protocol4, {
      handler,
      options
    });
    await this.components.peerStore.protoBook.add(this.components.peerId, [protocol4]);
  }
  /**
   * Removes the handler for each protocol. The protocol
   * will no longer be supported on streams.
   */
  async unhandle(protocols) {
    const protocolList = Array.isArray(protocols) ? protocols : [protocols];
    protocolList.forEach((protocol4) => {
      this.handlers.delete(protocol4);
    });
    await this.components.peerStore.protoBook.remove(this.components.peerId, protocolList);
  }
  /**
   * Register handlers for a set of multicodecs given
   */
  async register(protocol4, topology) {
    if (!isTopology(topology)) {
      log75.error("topology must be an instance of interfaces/topology");
      throw (0, import_err_code104.default)(new Error("topology must be an instance of interfaces/topology"), codes4.ERR_INVALID_PARAMETERS);
    }
    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
    let topologies = this.topologies.get(protocol4);
    if (topologies == null) {
      topologies = /* @__PURE__ */ new Map();
      this.topologies.set(protocol4, topologies);
    }
    topologies.set(id, topology);
    await topology.setRegistrar(this);
    return id;
  }
  /**
   * Unregister topology
   */
  unregister(id) {
    for (const [protocol4, topologies] of this.topologies.entries()) {
      if (topologies.has(id)) {
        topologies.delete(id);
        if (topologies.size === 0) {
          this.topologies.delete(protocol4);
        }
      }
    }
  }
  /**
   * Remove a disconnected peer from the record
   */
  _onDisconnect(evt) {
    const connection = evt.detail;
    void this.components.peerStore.protoBook.get(connection.remotePeer).then((peerProtocols) => {
      for (const protocol4 of peerProtocols) {
        const topologies = this.topologies.get(protocol4);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          topology.onDisconnect(connection.remotePeer);
        }
      }
    }).catch((err2) => {
      log75.error(err2);
    });
  }
  /**
   * On peer connected if we already have their protocols. Usually used for reconnects
   * as change:protocols event won't be emitted due to identical protocols.
   */
  _onConnect(evt) {
    const connection = evt.detail;
    void this.components.peerStore.protoBook.get(connection.remotePeer).then((peerProtocols) => {
      for (const protocol4 of peerProtocols) {
        const topologies = this.topologies.get(protocol4);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          topology.onConnect(connection.remotePeer, connection);
        }
      }
    }).catch((err2) => {
      log75.error(err2);
    });
  }
  /**
   * Check if a new peer support the multicodecs for this topology
   */
  _onProtocolChange(evt) {
    const { peerId, protocols, oldProtocols } = evt.detail;
    const removed = oldProtocols.filter((protocol4) => !protocols.includes(protocol4));
    const added = protocols.filter((protocol4) => !oldProtocols.includes(protocol4));
    for (const protocol4 of removed) {
      const topologies = this.topologies.get(protocol4);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        topology.onDisconnect(peerId);
      }
    }
    for (const protocol4 of added) {
      const topologies = this.topologies.get(protocol4);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        const connection = this.components.connectionManager.getConnections(peerId)[0];
        if (connection == null) {
          continue;
        }
        topology.onConnect(peerId, connection);
      }
    }
  }
};
var import_timeout_abort_controller7 = __toESM(require_timeout_abort_controller(), 1);
var import_events18 = __toESM(require_events(), 1);
var log76 = logger("libp2p:upgrader");
function findIncomingStreamLimit(protocol4, registrar) {
  try {
    const { options } = registrar.getHandler(protocol4);
    return options.maxInboundStreams;
  } catch (err2) {
    if (err2.code !== codes4.ERR_NO_HANDLER_FOR_PROTOCOL) {
      throw err2;
    }
  }
  return DEFAULT_MAX_INBOUND_STREAMS;
}
function findOutgoingStreamLimit(protocol4, registrar) {
  try {
    const { options } = registrar.getHandler(protocol4);
    return options.maxOutboundStreams;
  } catch (err2) {
    if (err2.code !== codes4.ERR_NO_HANDLER_FOR_PROTOCOL) {
      throw err2;
    }
  }
  return DEFAULT_MAX_OUTBOUND_STREAMS;
}
function countStreams(protocol4, direction, connection) {
  let streamCount = 0;
  connection.streams.forEach((stream) => {
    if (stream.stat.direction === direction && stream.stat.protocol === protocol4) {
      streamCount++;
    }
  });
  return streamCount;
}
var DefaultUpgrader = class extends EventEmitter2 {
  constructor(components, init) {
    super();
    this.components = components;
    this.connectionEncryption = /* @__PURE__ */ new Map();
    init.connectionEncryption.forEach((encrypter) => {
      this.connectionEncryption.set(encrypter.protocol, encrypter);
    });
    this.muxers = /* @__PURE__ */ new Map();
    init.muxers.forEach((muxer) => {
      this.muxers.set(muxer.protocol, muxer);
    });
    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout;
  }
  /**
   * Upgrades an inbound connection
   */
  async upgradeInbound(maConn, opts) {
    const accept = await this.components.connectionManager.acceptIncomingConnection(maConn);
    if (!accept) {
      throw (0, import_err_code105.default)(new Error("connection denied"), codes4.ERR_CONNECTION_DENIED);
    }
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let muxerFactory;
    let cryptoProtocol;
    const timeoutController = new import_timeout_abort_controller7.TimeoutController(this.inboundUpgradeTimeout);
    try {
      (0, import_events18.setMaxListeners)?.(Infinity, timeoutController.signal);
    } catch {
    }
    try {
      const abortableStream = abortableDuplex(maConn, timeoutController.signal);
      maConn.source = abortableStream.source;
      maConn.sink = abortableStream.sink;
      if (await this.components.connectionGater.denyInboundConnection(maConn)) {
        throw (0, import_err_code105.default)(new Error("The multiaddr connection is blocked by gater.acceptConnection"), codes4.ERR_CONNECTION_INTERCEPTED);
      }
      this.components.metrics?.trackMultiaddrConnection(maConn);
      log76("starting the inbound connection upgrade");
      let protectedConn = maConn;
      if (opts?.skipProtection !== true) {
        const protector = this.components.connectionProtector;
        if (protector != null) {
          log76("protecting the inbound connection");
          protectedConn = await protector.protect(maConn);
        }
      }
      try {
        encryptedConn = protectedConn;
        if (opts?.skipEncryption !== true) {
          ({
            conn: encryptedConn,
            remotePeer,
            protocol: cryptoProtocol
          } = await this._encryptInbound(protectedConn));
          if (await this.components.connectionGater.denyInboundEncryptedConnection(remotePeer, {
            ...protectedConn,
            ...encryptedConn
          })) {
            throw (0, import_err_code105.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes4.ERR_CONNECTION_INTERCEPTED);
          }
        } else {
          const idStr = maConn.remoteAddr.getPeerId();
          if (idStr == null) {
            throw (0, import_err_code105.default)(new Error("inbound connection that skipped encryption must have a peer id"), codes4.ERR_INVALID_MULTIADDR);
          }
          const remotePeerId = peerIdFromString(idStr);
          cryptoProtocol = "native";
          remotePeer = remotePeerId;
        }
        upgradedConn = encryptedConn;
        if (opts?.muxerFactory != null) {
          muxerFactory = opts.muxerFactory;
        } else if (this.muxers.size > 0) {
          const multiplexed = await this._multiplexInbound({
            ...protectedConn,
            ...encryptedConn
          }, this.muxers);
          muxerFactory = multiplexed.muxerFactory;
          upgradedConn = multiplexed.stream;
        }
      } catch (err2) {
        log76.error("Failed to upgrade inbound connection", err2);
        throw err2;
      }
      if (await this.components.connectionGater.denyInboundUpgradedConnection(remotePeer, {
        ...protectedConn,
        ...encryptedConn
      })) {
        throw (0, import_err_code105.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes4.ERR_CONNECTION_INTERCEPTED);
      }
      log76("Successfully upgraded inbound connection");
      return this._createConnection({
        cryptoProtocol,
        direction: "inbound",
        maConn,
        upgradedConn,
        muxerFactory,
        remotePeer
      });
    } finally {
      this.components.connectionManager.afterUpgradeInbound();
      timeoutController.clear();
    }
  }
  /**
   * Upgrades an outbound connection
   */
  async upgradeOutbound(maConn, opts) {
    const idStr = maConn.remoteAddr.getPeerId();
    let remotePeerId;
    if (idStr != null) {
      remotePeerId = peerIdFromString(idStr);
      if (await this.components.connectionGater.denyOutboundConnection(remotePeerId, maConn)) {
        throw (0, import_err_code105.default)(new Error("The multiaddr connection is blocked by connectionGater.denyOutboundConnection"), codes4.ERR_CONNECTION_INTERCEPTED);
      }
    }
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let cryptoProtocol;
    let muxerFactory;
    this.components.metrics?.trackMultiaddrConnection(maConn);
    log76("Starting the outbound connection upgrade");
    let protectedConn = maConn;
    if (opts?.skipProtection !== true) {
      const protector = this.components.connectionProtector;
      if (protector != null) {
        protectedConn = await protector.protect(maConn);
      }
    }
    try {
      encryptedConn = protectedConn;
      if (opts?.skipEncryption !== true) {
        ({
          conn: encryptedConn,
          remotePeer,
          protocol: cryptoProtocol
        } = await this._encryptOutbound(protectedConn, remotePeerId));
        if (await this.components.connectionGater.denyOutboundEncryptedConnection(remotePeer, {
          ...protectedConn,
          ...encryptedConn
        })) {
          throw (0, import_err_code105.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes4.ERR_CONNECTION_INTERCEPTED);
        }
      } else {
        if (remotePeerId == null) {
          throw (0, import_err_code105.default)(new Error("Encryption was skipped but no peer id was passed"), codes4.ERR_INVALID_PEER);
        }
        cryptoProtocol = "native";
        remotePeer = remotePeerId;
      }
      upgradedConn = encryptedConn;
      if (opts?.muxerFactory != null) {
        muxerFactory = opts.muxerFactory;
      } else if (this.muxers.size > 0) {
        const multiplexed = await this._multiplexOutbound({
          ...protectedConn,
          ...encryptedConn
        }, this.muxers);
        muxerFactory = multiplexed.muxerFactory;
        upgradedConn = multiplexed.stream;
      }
    } catch (err2) {
      log76.error("Failed to upgrade outbound connection", err2);
      await maConn.close(err2);
      throw err2;
    }
    if (await this.components.connectionGater.denyOutboundUpgradedConnection(remotePeer, {
      ...protectedConn,
      ...encryptedConn
    })) {
      throw (0, import_err_code105.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes4.ERR_CONNECTION_INTERCEPTED);
    }
    log76("Successfully upgraded outbound connection");
    return this._createConnection({
      cryptoProtocol,
      direction: "outbound",
      maConn,
      upgradedConn,
      muxerFactory,
      remotePeer
    });
  }
  /**
   * A convenience method for generating a new `Connection`
   */
  _createConnection(opts) {
    const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory } = opts;
    let muxer;
    let newStream;
    let connection;
    if (muxerFactory != null) {
      muxer = muxerFactory.createStreamMuxer({
        direction,
        // Run anytime a remote stream is created
        onIncomingStream: (muxedStream) => {
          if (connection == null) {
            return;
          }
          void Promise.resolve().then(async () => {
            const protocols = this.components.registrar.getProtocols();
            const { stream, protocol: protocol4 } = await handle(muxedStream, protocols);
            log76("%s: incoming stream opened on %s", direction, protocol4);
            if (connection == null) {
              return;
            }
            const incomingLimit = findIncomingStreamLimit(protocol4, this.components.registrar);
            const streamCount = countStreams(protocol4, "inbound", connection);
            if (streamCount === incomingLimit) {
              muxedStream.abort((0, import_err_code105.default)(new Error(`Too many inbound protocol streams for protocol "${protocol4}" - limit ${incomingLimit}`), codes4.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS));
              return;
            }
            muxedStream.source = stream.source;
            muxedStream.sink = stream.sink;
            muxedStream.stat.protocol = protocol4;
            this.components.peerStore.protoBook.add(remotePeer, [protocol4]).catch((err2) => log76.error(err2));
            connection.addStream(muxedStream);
            this.components.metrics?.trackProtocolStream(muxedStream, connection);
            this._onStream({ connection, stream: muxedStream, protocol: protocol4 });
          }).catch((err2) => {
            log76.error(err2);
            if (muxedStream.stat.timeline.close == null) {
              muxedStream.close();
            }
          });
        },
        // Run anytime a stream closes
        onStreamEnd: (muxedStream) => {
          connection?.removeStream(muxedStream.id);
        }
      });
      newStream = async (protocols, options = {}) => {
        if (muxer == null) {
          throw (0, import_err_code105.default)(new Error("Stream is not multiplexed"), codes4.ERR_MUXER_UNAVAILABLE);
        }
        log76("%s: starting new stream on %s", direction, protocols);
        const muxedStream = await muxer.newStream();
        let controller;
        try {
          if (options.signal == null) {
            log76("No abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols);
            controller = new import_timeout_abort_controller7.TimeoutController(3e4);
            options.signal = controller.signal;
            try {
              (0, import_events18.setMaxListeners)?.(Infinity, controller.signal);
            } catch {
            }
          }
          const { stream, protocol: protocol4 } = await select(muxedStream, protocols, options);
          const outgoingLimit = findOutgoingStreamLimit(protocol4, this.components.registrar);
          const streamCount = countStreams(protocol4, "outbound", connection);
          if (streamCount === outgoingLimit) {
            const err2 = (0, import_err_code105.default)(new Error(`Too many outbound protocol streams for protocol "${protocol4}" - limit ${outgoingLimit}`), codes4.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);
            muxedStream.abort(err2);
            throw err2;
          }
          this.components.peerStore.protoBook.add(remotePeer, [protocol4]).catch((err2) => log76.error(err2));
          muxedStream.source = stream.source;
          muxedStream.sink = stream.sink;
          muxedStream.stat.protocol = protocol4;
          this.components.metrics?.trackProtocolStream(muxedStream, connection);
          return muxedStream;
        } catch (err2) {
          log76.error("could not create new stream", err2);
          if (muxedStream.stat.timeline.close == null) {
            muxedStream.close();
          }
          if (err2.code != null) {
            throw err2;
          }
          throw (0, import_err_code105.default)(err2, codes4.ERR_UNSUPPORTED_PROTOCOL);
        } finally {
          if (controller != null) {
            controller.clear();
          }
        }
      };
      void Promise.all([
        muxer.sink(upgradedConn.source),
        upgradedConn.sink(muxer.source)
      ]).catch((err2) => {
        log76.error(err2);
      });
    }
    const _timeline = maConn.timeline;
    maConn.timeline = new Proxy(_timeline, {
      set: (...args) => {
        if (connection != null && args[1] === "close" && args[2] != null && _timeline.close == null) {
          (async () => {
            try {
              if (connection.stat.status === "OPEN") {
                await connection.close();
              }
            } catch (err2) {
              log76.error(err2);
            } finally {
              this.dispatchEvent(new CustomEvent2("connectionEnd", {
                detail: connection
              }));
            }
          })().catch((err2) => {
            log76.error(err2);
          });
        }
        return Reflect.set(...args);
      }
    });
    maConn.timeline.upgraded = Date.now();
    const errConnectionNotMultiplexed = () => {
      throw (0, import_err_code105.default)(new Error("connection is not multiplexed"), codes4.ERR_CONNECTION_NOT_MULTIPLEXED);
    };
    connection = createConnection({
      remoteAddr: maConn.remoteAddr,
      remotePeer,
      stat: {
        status: "OPEN",
        direction,
        timeline: maConn.timeline,
        multiplexer: muxer?.protocol,
        encryption: cryptoProtocol
      },
      newStream: newStream ?? errConnectionNotMultiplexed,
      getStreams: () => muxer != null ? muxer.streams : errConnectionNotMultiplexed(),
      close: async () => {
        await maConn.close();
        if (muxer != null) {
          muxer.close();
        }
      }
    });
    this.dispatchEvent(new CustomEvent2("connection", {
      detail: connection
    }));
    return connection;
  }
  /**
   * Routes incoming streams to the correct handler
   */
  _onStream(opts) {
    const { connection, stream, protocol: protocol4 } = opts;
    const { handler } = this.components.registrar.getHandler(protocol4);
    handler({ connection, stream });
  }
  /**
   * Attempts to encrypt the incoming `connection` with the provided `cryptos`
   */
  async _encryptInbound(connection) {
    const protocols = Array.from(this.connectionEncryption.keys());
    log76("handling inbound crypto protocol selection", protocols);
    try {
      const { stream, protocol: protocol4 } = await handle(connection, protocols, {
        writeBytes: true
      });
      const encrypter = this.connectionEncryption.get(protocol4);
      if (encrypter == null) {
        throw new Error(`no crypto module found for ${protocol4}`);
      }
      log76("encrypting inbound connection...");
      return {
        ...await encrypter.secureInbound(this.components.peerId, stream),
        protocol: protocol4
      };
    } catch (err2) {
      throw (0, import_err_code105.default)(err2, codes4.ERR_ENCRYPTION_FAILED);
    }
  }
  /**
   * Attempts to encrypt the given `connection` with the provided connection encrypters.
   * The first `ConnectionEncrypter` module to succeed will be used
   */
  async _encryptOutbound(connection, remotePeerId) {
    const protocols = Array.from(this.connectionEncryption.keys());
    log76("selecting outbound crypto protocol", protocols);
    try {
      const { stream, protocol: protocol4 } = await select(connection, protocols, {
        writeBytes: true
      });
      const encrypter = this.connectionEncryption.get(protocol4);
      if (encrypter == null) {
        throw new Error(`no crypto module found for ${protocol4}`);
      }
      log76("encrypting outbound connection to %p", remotePeerId);
      return {
        ...await encrypter.secureOutbound(this.components.peerId, stream, remotePeerId),
        protocol: protocol4
      };
    } catch (err2) {
      throw (0, import_err_code105.default)(err2, codes4.ERR_ENCRYPTION_FAILED);
    }
  }
  /**
   * Selects one of the given muxers via multistream-select. That
   * muxer will be used for all future streams on the connection.
   */
  async _multiplexOutbound(connection, muxers) {
    const protocols = Array.from(muxers.keys());
    log76("outbound selecting muxer %s", protocols);
    try {
      const { stream, protocol: protocol4 } = await select(connection, protocols, {
        writeBytes: true
      });
      log76("%s selected as muxer protocol", protocol4);
      const muxerFactory = muxers.get(protocol4);
      return { stream, muxerFactory };
    } catch (err2) {
      log76.error("error multiplexing outbound stream", err2);
      throw (0, import_err_code105.default)(err2, codes4.ERR_MUXER_UNAVAILABLE);
    }
  }
  /**
   * Registers support for one of the given muxers via multistream-select. The
   * selected muxer will be used for all future streams on the connection.
   */
  async _multiplexInbound(connection, muxers) {
    const protocols = Array.from(muxers.keys());
    log76("inbound handling muxers %s", protocols);
    try {
      const { stream, protocol: protocol4 } = await handle(connection, protocols, {
        writeBytes: true
      });
      const muxerFactory = muxers.get(protocol4);
      return { stream, muxerFactory };
    } catch (err2) {
      log76.error("error multiplexing inbound stream", err2);
      throw (0, import_err_code105.default)(err2, codes4.ERR_MUXER_UNAVAILABLE);
    }
  }
};
var import_err_code106 = __toESM(require_err_code(), 1);
var Identify;
(function(Identify2) {
  let _codec;
  Identify2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.protocolVersion != null) {
          w.uint32(42);
          w.string(obj.protocolVersion);
        }
        if (obj.agentVersion != null) {
          w.uint32(50);
          w.string(obj.agentVersion);
        }
        if (obj.publicKey != null) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.listenAddrs != null) {
          for (const value2 of obj.listenAddrs) {
            w.uint32(18);
            w.bytes(value2);
          }
        }
        if (obj.observedAddr != null) {
          w.uint32(34);
          w.bytes(obj.observedAddr);
        }
        if (obj.protocols != null) {
          for (const value2 of obj.protocols) {
            w.uint32(26);
            w.string(value2);
          }
        }
        if (obj.signedPeerRecord != null) {
          w.uint32(66);
          w.bytes(obj.signedPeerRecord);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {
          listenAddrs: [],
          protocols: []
        };
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 5:
              obj.protocolVersion = reader3.string();
              break;
            case 6:
              obj.agentVersion = reader3.string();
              break;
            case 1:
              obj.publicKey = reader3.bytes();
              break;
            case 2:
              obj.listenAddrs.push(reader3.bytes());
              break;
            case 4:
              obj.observedAddr = reader3.bytes();
              break;
            case 3:
              obj.protocols.push(reader3.string());
              break;
            case 8:
              obj.signedPeerRecord = reader3.bytes();
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Identify2.encode = (obj) => {
    return encodeMessage(obj, Identify2.codec());
  };
  Identify2.decode = (buf2) => {
    return decodeMessage(buf2, Identify2.codec());
  };
})(Identify || (Identify = {}));
var version2 = "0.0.0";
var name8 = "libp2p";
var AGENT_VERSION = `js-libp2p/${version2}`;
var IDENTIFY_PROTOCOL_VERSION = "0.1.0";
var MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
var MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";
var import_timeout_abort_controller8 = __toESM(require_timeout_abort_controller(), 1);
var import_events19 = __toESM(require_events(), 1);
var log77 = logger("libp2p:identify");
var MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
var IdentifyService = class {
  constructor(components, init) {
    this.components = components;
    this.started = false;
    this.init = init;
    this.identifyProtocolStr = `/${init.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`;
    this.identifyPushProtocolStr = `/${init.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`;
    this.host = {
      protocolVersion: `${init.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
      ...init.host
    };
    this.components.connectionManager.addEventListener("peer:connect", (evt) => {
      const connection = evt.detail;
      this.identify(connection).catch(log77.error);
    });
    this.components.peerStore.addEventListener("change:multiaddrs", (evt) => {
      const { peerId } = evt.detail;
      if (this.components.peerId.equals(peerId)) {
        void this.pushToPeerStore().catch((err2) => log77.error(err2));
      }
    });
    this.components.peerStore.addEventListener("change:protocols", (evt) => {
      const { peerId } = evt.detail;
      if (this.components.peerId.equals(peerId)) {
        void this.pushToPeerStore().catch((err2) => log77.error(err2));
      }
    });
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.components.peerStore.metadataBook.setValue(this.components.peerId, "AgentVersion", fromString3(this.host.agentVersion));
    await this.components.peerStore.metadataBook.setValue(this.components.peerId, "ProtocolVersion", fromString3(this.host.protocolVersion));
    await this.components.registrar.handle(this.identifyProtocolStr, (data) => {
      void this._handleIdentify(data).catch((err2) => {
        log77.error(err2);
      });
    }, {
      maxInboundStreams: this.init.maxInboundStreams,
      maxOutboundStreams: this.init.maxOutboundStreams
    });
    await this.components.registrar.handle(this.identifyPushProtocolStr, (data) => {
      void this._handlePush(data).catch((err2) => {
        log77.error(err2);
      });
    }, {
      maxInboundStreams: this.init.maxPushIncomingStreams,
      maxOutboundStreams: this.init.maxPushOutgoingStreams
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.identifyProtocolStr);
    await this.components.registrar.unhandle(this.identifyPushProtocolStr);
    this.started = false;
  }
  /**
   * Send an Identify Push update to the list of connections
   */
  async push(connections) {
    const signedPeerRecord = await this.components.peerStore.addressBook.getRawEnvelope(this.components.peerId);
    const listenAddrs = this.components.addressManager.getAddresses().map((ma) => ma.bytes);
    const protocols = await this.components.peerStore.protoBook.get(this.components.peerId);
    const pushes = connections.map(async (connection) => {
      let stream;
      const timeoutController = new import_timeout_abort_controller8.TimeoutController(this.init.timeout);
      try {
        (0, import_events19.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
      try {
        stream = await connection.newStream([this.identifyPushProtocolStr], {
          signal: timeoutController.signal
        });
        const source = abortableDuplex(stream, timeoutController.signal);
        await source.sink(pipe([Identify.encode({
          listenAddrs,
          signedPeerRecord,
          protocols
        })], encode15()));
      } catch (err2) {
        log77.error("could not push identify update to peer", err2);
      } finally {
        if (stream != null) {
          stream.close();
        }
        timeoutController.clear();
      }
    });
    await Promise.all(pushes);
  }
  /**
   * Calls `push` on all peer connections
   */
  async pushToPeerStore() {
    if (!this.isStarted()) {
      return;
    }
    const connections = [];
    for (const conn of this.components.connectionManager.getConnections()) {
      const peerId = conn.remotePeer;
      const peer = await this.components.peerStore.get(peerId);
      if (!peer.protocols.includes(this.identifyPushProtocolStr)) {
        continue;
      }
      connections.push(conn);
    }
    await this.push(connections);
  }
  async _identify(connection, options = {}) {
    let timeoutController;
    let signal = options.signal;
    let stream;
    if (signal == null) {
      timeoutController = new import_timeout_abort_controller8.TimeoutController(this.init.timeout);
      signal = timeoutController.signal;
      try {
        (0, import_events19.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      stream = await connection.newStream([this.identifyProtocolStr], {
        signal
      });
      const source = abortableDuplex(stream, signal);
      const data = await pipe([], source, decode14({
        maxDataLength: this.init.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
      }), async (source2) => await first(source2));
      if (data == null) {
        throw (0, import_err_code106.default)(new Error("No data could be retrieved"), codes4.ERR_CONNECTION_ENDED);
      }
      try {
        return Identify.decode(data);
      } catch (err2) {
        throw (0, import_err_code106.default)(err2, codes4.ERR_INVALID_MESSAGE);
      }
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
      if (stream != null) {
        stream.close();
      }
    }
  }
  /**
   * Requests the `Identify` message from peer associated with the given `connection`.
   * If the identified peer does not match the `PeerId` associated with the connection,
   * an error will be thrown.
   */
  async identify(connection, options = {}) {
    const message2 = await this._identify(connection, options);
    const { publicKey, listenAddrs, protocols, observedAddr, signedPeerRecord, agentVersion, protocolVersion } = message2;
    if (publicKey == null) {
      throw (0, import_err_code106.default)(new Error("public key was missing from identify message"), codes4.ERR_MISSING_PUBLIC_KEY);
    }
    const id = await peerIdFromKeys(publicKey);
    if (!connection.remotePeer.equals(id)) {
      throw (0, import_err_code106.default)(new Error("identified peer does not match the expected peer"), codes4.ERR_INVALID_PEER);
    }
    if (this.components.peerId.equals(id)) {
      throw (0, import_err_code106.default)(new Error("identified peer is our own peer id?"), codes4.ERR_INVALID_PEER);
    }
    const cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr);
    if (signedPeerRecord != null) {
      log77("received signed peer record from %p", id);
      try {
        const envelope = await RecordEnvelope.openAndCertify(signedPeerRecord, PeerRecord3.DOMAIN);
        if (!envelope.peerId.equals(id)) {
          throw (0, import_err_code106.default)(new Error("identified peer does not match the expected peer"), codes4.ERR_INVALID_PEER);
        }
        if (await this.components.peerStore.addressBook.consumePeerRecord(envelope)) {
          await this.components.peerStore.protoBook.set(id, protocols);
          if (agentVersion != null) {
            await this.components.peerStore.metadataBook.setValue(id, "AgentVersion", fromString3(agentVersion));
          }
          if (protocolVersion != null) {
            await this.components.peerStore.metadataBook.setValue(id, "ProtocolVersion", fromString3(protocolVersion));
          }
          log77("identify completed for peer %p and protocols %o", id, protocols);
          return;
        }
      } catch (err2) {
        log77("received invalid envelope, discard it and fallback to listenAddrs is available", err2);
      }
    } else {
      log77("no signed peer record received from %p", id);
    }
    log77("falling back to legacy addresses from %p", id);
    try {
      await this.components.peerStore.addressBook.set(id, listenAddrs.map((addr) => multiaddr(addr)));
    } catch (err2) {
      log77.error("received invalid addrs", err2);
    }
    await this.components.peerStore.protoBook.set(id, protocols);
    if (agentVersion != null) {
      await this.components.peerStore.metadataBook.setValue(id, "AgentVersion", fromString3(agentVersion));
    }
    if (protocolVersion != null) {
      await this.components.peerStore.metadataBook.setValue(id, "ProtocolVersion", fromString3(protocolVersion));
    }
    log77("identify completed for peer %p and protocols %o", id, protocols);
    log77("received observed address of %s", cleanObservedAddr?.toString());
  }
  /**
   * Sends the `Identify` response with the Signed Peer Record
   * to the requesting peer over the given `connection`
   */
  async _handleIdentify(data) {
    const { connection, stream } = data;
    const timeoutController = new import_timeout_abort_controller8.TimeoutController(this.init.timeout);
    try {
      (0, import_events19.setMaxListeners)?.(Infinity, timeoutController.signal);
    } catch {
    }
    try {
      const publicKey = this.components.peerId.publicKey ?? new Uint8Array(0);
      const peerData = await this.components.peerStore.get(this.components.peerId);
      const multiaddrs = this.components.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code));
      let signedPeerRecord = peerData.peerRecordEnvelope;
      if (multiaddrs.length > 0 && signedPeerRecord == null) {
        const peerRecord = new PeerRecord3({
          peerId: this.components.peerId,
          multiaddrs
        });
        const envelope = await RecordEnvelope.seal(peerRecord, this.components.peerId);
        await this.components.peerStore.addressBook.consumePeerRecord(envelope);
        signedPeerRecord = envelope.marshal().subarray();
      }
      const message2 = Identify.encode({
        protocolVersion: this.host.protocolVersion,
        agentVersion: this.host.agentVersion,
        publicKey,
        listenAddrs: multiaddrs.map((addr) => addr.bytes),
        signedPeerRecord,
        observedAddr: connection.remoteAddr.bytes,
        protocols: peerData.protocols
      });
      const source = abortableDuplex(stream, timeoutController.signal);
      const msgWithLenPrefix = pipe([message2], encode15());
      await source.sink(msgWithLenPrefix);
    } catch (err2) {
      log77.error("could not respond to identify request", err2);
    } finally {
      stream.close();
      timeoutController.clear();
    }
  }
  /**
   * Reads the Identify Push message from the given `connection`
   */
  async _handlePush(data) {
    const { connection, stream } = data;
    const timeoutController = new import_timeout_abort_controller8.TimeoutController(this.init.timeout);
    try {
      (0, import_events19.setMaxListeners)?.(Infinity, timeoutController.signal);
    } catch {
    }
    let message2;
    try {
      const source = abortableDuplex(stream, timeoutController.signal);
      const data2 = await pipe([], source, decode14({
        maxDataLength: this.init.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
      }), async (source2) => await first(source2));
      if (data2 != null) {
        message2 = Identify.decode(data2);
      }
    } catch (err2) {
      return log77.error("received invalid message", err2);
    } finally {
      stream.close();
      timeoutController.clear();
    }
    if (message2 == null) {
      return log77.error("received invalid message");
    }
    const id = connection.remotePeer;
    if (this.components.peerId.equals(id)) {
      log77("received push from ourselves?");
      return;
    }
    log77("received push from %p", id);
    if (message2.signedPeerRecord != null) {
      log77("received signedPeerRecord in push");
      try {
        const envelope = await RecordEnvelope.openAndCertify(message2.signedPeerRecord, PeerRecord3.DOMAIN);
        if (await this.components.peerStore.addressBook.consumePeerRecord(envelope)) {
          log77("consumed signedPeerRecord sent in push");
          await this.components.peerStore.protoBook.set(id, message2.protocols);
          return;
        } else {
          log77("failed to consume signedPeerRecord sent in push");
        }
      } catch (err2) {
        log77("received invalid envelope, discard it and fallback to listenAddrs is available", err2);
      }
    } else {
      log77("did not receive signedPeerRecord in push");
    }
    try {
      await this.components.peerStore.addressBook.set(id, message2.listenAddrs.map((addr) => multiaddr(addr)));
    } catch (err2) {
      log77.error("received invalid addrs", err2);
    }
    try {
      await this.components.peerStore.protoBook.set(id, message2.protocols);
    } catch (err2) {
      log77.error("received invalid protocols", err2);
    }
    log77("handled push from %p", id);
  }
  /**
   * Takes the `addr` and converts it to a Multiaddr if possible
   */
  static getCleanMultiaddr(addr) {
    if (addr != null && addr.length > 0) {
      try {
        return multiaddr(addr);
      } catch {
      }
    }
  }
};
var import_err_code107 = __toESM(require_err_code(), 1);
var FetchRequest;
(function(FetchRequest2) {
  let _codec;
  FetchRequest2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.identifier !== "") {
          w.uint32(10);
          w.string(obj.identifier);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {
          identifier: ""
        };
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.identifier = reader3.string();
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  FetchRequest2.encode = (obj) => {
    return encodeMessage(obj, FetchRequest2.codec());
  };
  FetchRequest2.decode = (buf2) => {
    return decodeMessage(buf2, FetchRequest2.codec());
  };
})(FetchRequest || (FetchRequest = {}));
var FetchResponse;
(function(FetchResponse2) {
  let StatusCode;
  (function(StatusCode2) {
    StatusCode2["OK"] = "OK";
    StatusCode2["NOT_FOUND"] = "NOT_FOUND";
    StatusCode2["ERROR"] = "ERROR";
  })(StatusCode = FetchResponse2.StatusCode || (FetchResponse2.StatusCode = {}));
  let __StatusCodeValues;
  (function(__StatusCodeValues2) {
    __StatusCodeValues2[__StatusCodeValues2["OK"] = 0] = "OK";
    __StatusCodeValues2[__StatusCodeValues2["NOT_FOUND"] = 1] = "NOT_FOUND";
    __StatusCodeValues2[__StatusCodeValues2["ERROR"] = 2] = "ERROR";
  })(__StatusCodeValues || (__StatusCodeValues = {}));
  (function(StatusCode2) {
    StatusCode2.codec = () => {
      return enumeration(__StatusCodeValues);
    };
  })(StatusCode = FetchResponse2.StatusCode || (FetchResponse2.StatusCode = {}));
  let _codec;
  FetchResponse2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.status != null && __StatusCodeValues[obj.status] !== 0) {
          w.uint32(8);
          FetchResponse2.StatusCode.codec().encode(obj.status, w);
        }
        if (opts.writeDefaults === true || obj.data != null && obj.data.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {
          status: StatusCode.OK,
          data: new Uint8Array(0)
        };
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.status = FetchResponse2.StatusCode.codec().decode(reader3);
              break;
            case 2:
              obj.data = reader3.bytes();
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  FetchResponse2.encode = (obj) => {
    return encodeMessage(obj, FetchResponse2.codec());
  };
  FetchResponse2.decode = (buf2) => {
    return decodeMessage(buf2, FetchResponse2.codec());
  };
})(FetchResponse || (FetchResponse = {}));
var PROTOCOL_VERSION = "0.0.1";
var PROTOCOL_NAME = "fetch";
var import_timeout_abort_controller9 = __toESM(require_timeout_abort_controller(), 1);
var import_events20 = __toESM(require_events(), 1);
var log78 = logger("libp2p:fetch");
var FetchService = class {
  constructor(components, init) {
    this.started = false;
    this.components = components;
    this.protocol = `/${init.protocolPrefix ?? "libp2p"}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
    this.lookupFunctions = /* @__PURE__ */ new Map();
    this.handleMessage = this.handleMessage.bind(this);
    this.init = init;
  }
  async start() {
    await this.components.registrar.handle(this.protocol, (data) => {
      void this.handleMessage(data).catch((err2) => {
        log78.error(err2);
      }).finally(() => {
        data.stream.close();
      });
    }, {
      maxInboundStreams: this.init.maxInboundStreams,
      maxOutboundStreams: this.init.maxOutboundStreams
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  /**
   * Sends a request to fetch the value associated with the given key from the given peer
   */
  async fetch(peer, key, options = {}) {
    log78("dialing %s to %p", this.protocol, peer);
    const connection = await this.components.connectionManager.openConnection(peer, options);
    let timeoutController;
    let signal = options.signal;
    let stream;
    if (signal == null) {
      log78("using default timeout of %d ms", this.init.timeout);
      timeoutController = new import_timeout_abort_controller9.TimeoutController(this.init.timeout);
      signal = timeoutController.signal;
      try {
        (0, import_events20.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      stream = await connection.newStream(this.protocol, {
        signal
      });
      const source = abortableDuplex(stream, signal);
      log78("fetch %s", key);
      const result = await pipe([FetchRequest.encode({ identifier: key })], encode15(), source, decode14(), async function(source2) {
        const buf2 = await first(source2);
        if (buf2 == null) {
          throw (0, import_err_code107.default)(new Error("No data received"), codes4.ERR_INVALID_MESSAGE);
        }
        const response = FetchResponse.decode(buf2);
        switch (response.status) {
          case FetchResponse.StatusCode.OK: {
            log78("received status for %s ok", key);
            return response.data;
          }
          case FetchResponse.StatusCode.NOT_FOUND: {
            log78("received status for %s not found", key);
            return null;
          }
          case FetchResponse.StatusCode.ERROR: {
            log78("received status for %s error", key);
            const errmsg = toString3(response.data);
            throw (0, import_err_code107.default)(new Error("Error in fetch protocol response: " + errmsg), codes4.ERR_INVALID_PARAMETERS);
          }
          default: {
            log78("received status for %s unknown", key);
            throw (0, import_err_code107.default)(new Error("Unknown response status"), codes4.ERR_INVALID_MESSAGE);
          }
        }
      });
      return result ?? null;
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
      if (stream != null) {
        stream.close();
      }
    }
  }
  /**
   * Invoked when a fetch request is received.  Reads the request message off the given stream and
   * responds based on looking up the key in the request via the lookup callback that corresponds
   * to the key's prefix.
   */
  async handleMessage(data) {
    const { stream } = data;
    const self2 = this;
    await pipe(stream, decode14(), async function* (source) {
      const buf2 = await first(source);
      if (buf2 == null) {
        throw (0, import_err_code107.default)(new Error("No data received"), codes4.ERR_INVALID_MESSAGE);
      }
      const request2 = FetchRequest.decode(buf2);
      let response;
      const lookup3 = self2._getLookupFunction(request2.identifier);
      if (lookup3 != null) {
        log78("look up data with identifier %s", request2.identifier);
        const data2 = await lookup3(request2.identifier);
        if (data2 != null) {
          log78("sending status for %s ok", request2.identifier);
          response = { status: FetchResponse.StatusCode.OK, data: data2 };
        } else {
          log78("sending status for %s not found", request2.identifier);
          response = { status: FetchResponse.StatusCode.NOT_FOUND, data: new Uint8Array(0) };
        }
      } else {
        log78("sending status for %s error", request2.identifier);
        const errmsg = fromString3(`No lookup function registered for key: ${request2.identifier}`);
        response = { status: FetchResponse.StatusCode.ERROR, data: errmsg };
      }
      yield FetchResponse.encode(response);
    }, encode15(), stream);
  }
  /**
   * Given a key, finds the appropriate function for looking up its corresponding value, based on
   * the key's prefix.
   */
  _getLookupFunction(key) {
    for (const prefix of this.lookupFunctions.keys()) {
      if (key.startsWith(prefix)) {
        return this.lookupFunctions.get(prefix);
      }
    }
  }
  /**
   * Registers a new lookup callback that can map keys to values, for a given set of keys that
   * share the same prefix
   *
   * @example
   *
   * ```js
   * // ...
   * libp2p.fetchService.registerLookupFunction('/prefix', (key) => { ... })
   * ```
   */
  registerLookupFunction(prefix, lookup3) {
    if (this.lookupFunctions.has(prefix)) {
      throw (0, import_err_code107.default)(new Error("Fetch protocol handler for key prefix '" + prefix + "' already registered"), codes4.ERR_KEY_ALREADY_EXISTS);
    }
    this.lookupFunctions.set(prefix, lookup3);
  }
  /**
   * Registers a new lookup callback that can map keys to values, for a given set of keys that
   * share the same prefix.
   *
   * @example
   *
   * ```js
   * // ...
   * libp2p.fetchService.unregisterLookupFunction('/prefix')
   * ```
   */
  unregisterLookupFunction(prefix, lookup3) {
    if (lookup3 != null) {
      const existingLookup = this.lookupFunctions.get(prefix);
      if (existingLookup !== lookup3) {
        return;
      }
    }
    this.lookupFunctions.delete(prefix);
  }
};
var import_err_code108 = __toESM(require_err_code(), 1);
var PING_LENGTH = 32;
var PROTOCOL_VERSION2 = "1.0.0";
var PROTOCOL_NAME2 = "ping";
var import_timeout_abort_controller10 = __toESM(require_timeout_abort_controller(), 1);
var import_events21 = __toESM(require_events(), 1);
var log79 = logger("libp2p:ping");
var PingService = class {
  constructor(components, init) {
    this.components = components;
    this.started = false;
    this.protocol = `/${init.protocolPrefix}/${PROTOCOL_NAME2}/${PROTOCOL_VERSION2}`;
    this.init = init;
  }
  async start() {
    await this.components.registrar.handle(this.protocol, this.handleMessage, {
      maxInboundStreams: this.init.maxInboundStreams,
      maxOutboundStreams: this.init.maxOutboundStreams
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  /**
   * A handler to register with Libp2p to process ping messages
   */
  handleMessage(data) {
    const { stream } = data;
    void pipe(stream, stream).catch((err2) => {
      log79.error(err2);
    });
  }
  /**
   * Ping a given peer and wait for its response, getting the operation latency.
   *
   * @param {PeerId|Multiaddr} peer
   * @returns {Promise<number>}
   */
  async ping(peer, options = {}) {
    log79("dialing %s to %p", this.protocol, peer);
    const start = Date.now();
    const data = randomBytes$1(PING_LENGTH);
    const connection = await this.components.connectionManager.openConnection(peer, options);
    let timeoutController;
    let signal = options.signal;
    let stream;
    if (signal == null) {
      timeoutController = new import_timeout_abort_controller10.TimeoutController(this.init.timeout);
      signal = timeoutController.signal;
      try {
        (0, import_events21.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      stream = await connection.newStream([this.protocol], {
        signal
      });
      const source = abortableDuplex(stream, signal);
      const result = await pipe([data], source, async (source2) => await first(source2));
      const end = Date.now();
      if (result == null || !equals(data, result.subarray())) {
        throw (0, import_err_code108.default)(new Error("Received wrong ping ack"), codes4.ERR_WRONG_PING_ACK);
      }
      return end - start;
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
      if (stream != null) {
        stream.close();
      }
    }
  }
};
async function upnpNat() {
  throw new Error("Not supported in browsers");
}
var import_is_electron = __toESM(require_is_electron());
var isEnvWithDom = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
var isElectron = (0, import_is_electron.default)();
var isBrowser3 = isEnvWithDom && !isElectron;
var isElectronMain = isElectron && !isEnvWithDom;
var isElectronRenderer = isElectron && isEnvWithDom;
var isNode2 = typeof globalThis.process !== "undefined" && typeof globalThis.process.release !== "undefined" && globalThis.process.release.name === "node" && !isElectron;
var isWebWorker2 = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
typeof globalThis.process !== "undefined" && typeof globalThis.process.env !== "undefined" && globalThis.process.env["NODE" + (() => "_")() + "ENV"] === "test";
var isReactNative2 = typeof navigator !== "undefined" && navigator.product === "ReactNative";
var import_err_code109 = __toESM(require_err_code(), 1);
function isLoopbackAddr(ip) {
  return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip) || /^::1$/.test(ip);
}
function isLoopback(ma) {
  const { address } = ma.nodeAddress();
  return isLoopbackAddr(address);
}
var log80 = logger("libp2p:nat");
var DEFAULT_TTL = 7200;
function highPort(min = 1024, max = 65535) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
var NatManager = class {
  constructor(components, init) {
    this.components = components;
    this.started = false;
    this.enabled = init.enabled;
    this.externalAddress = init.externalAddress;
    this.localAddress = init.localAddress;
    this.description = init.description ?? `${name8}@${version2} ${this.components.peerId.toString()}`;
    this.ttl = init.ttl ?? DEFAULT_TTL;
    this.keepAlive = init.keepAlive ?? true;
    this.gateway = init.gateway;
    if (this.ttl < DEFAULT_TTL) {
      throw (0, import_err_code109.default)(new Error(`NatManager ttl should be at least ${DEFAULT_TTL} seconds`), codes4.ERR_INVALID_PARAMETERS);
    }
  }
  isStarted() {
    return this.started;
  }
  start() {
  }
  /**
   * Attempt to use uPnP to configure port mapping using the current gateway.
   *
   * Run after start to ensure the transport manager has all addresses configured.
   */
  afterStart() {
    if (isBrowser3 || !this.enabled || this.started) {
      return;
    }
    this.started = true;
    void this._start().catch((err2) => {
      log80.error(err2);
    });
  }
  async _start() {
    const addrs = this.components.transportManager.getAddrs();
    for (const addr of addrs) {
      const { family, host, port, transport } = addr.toOptions();
      if (!addr.isThinWaistAddress() || transport !== "tcp") {
        continue;
      }
      if (isLoopback(addr)) {
        continue;
      }
      if (family !== 4) {
        continue;
      }
      const client = await this._getClient();
      const publicIp = this.externalAddress ?? await client.externalIp();
      const isPrivate2 = private_ip_default(publicIp);
      if (isPrivate2 === true) {
        throw new Error(`${publicIp} is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT`);
      }
      if (isPrivate2 == null) {
        throw new Error(`${publicIp} is not an IP address`);
      }
      const publicPort = highPort();
      log80(`opening uPnP connection from ${publicIp}:${publicPort} to ${host}:${port}`);
      await client.map({
        publicPort,
        localPort: port,
        localAddress: this.localAddress,
        protocol: transport.toUpperCase() === "TCP" ? "TCP" : "UDP"
      });
      this.components.addressManager.addObservedAddr(fromNodeAddress({
        family: 4,
        address: publicIp,
        port: publicPort
      }, transport));
    }
  }
  async _getClient() {
    if (this.client != null) {
      return this.client;
    }
    this.client = await upnpNat({
      description: this.description,
      ttl: this.ttl,
      keepAlive: this.keepAlive,
      gateway: this.gateway
    });
    return this.client;
  }
  /**
   * Stops the NAT manager
   */
  async stop() {
    if (isBrowser3 || this.client == null) {
      return;
    }
    try {
      await this.client.close();
      this.client = void 0;
    } catch (err2) {
      log80.error(err2);
    }
  }
};
var log81 = logger("libp2p:peer-record-updater");
var PeerRecordUpdater = class {
  constructor(components) {
    this.components = components;
    this.started = false;
    this.update = this.update.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
    this.components.transportManager.addEventListener("listener:listening", this.update);
    this.components.transportManager.addEventListener("listener:close", this.update);
    this.components.addressManager.addEventListener("change:addresses", this.update);
  }
  async stop() {
    this.started = false;
    this.components.transportManager.removeEventListener("listener:listening", this.update);
    this.components.transportManager.removeEventListener("listener:close", this.update);
    this.components.addressManager.removeEventListener("change:addresses", this.update);
  }
  /**
   * Create (or update if existing) self peer record and store it in the AddressBook.
   */
  update() {
    Promise.resolve().then(async () => {
      const peerRecord = new PeerRecord3({
        peerId: this.components.peerId,
        multiaddrs: this.components.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code))
      });
      const envelope = await RecordEnvelope.seal(peerRecord, this.components.peerId);
      await this.components.peerStore.addressBook.consumePeerRecord(envelope);
    }).catch((err2) => {
      log81.error("Could not update self peer record: %o", err2);
    });
  }
};
var import_err_code110 = __toESM(require_err_code(), 1);
var DHTPeerRouting = class {
  constructor(dht) {
    this.dht = dht;
  }
  async findPeer(peerId, options = {}) {
    for await (const event of this.dht.findPeer(peerId, options)) {
      if (event.name === "FINAL_PEER") {
        return event.peer;
      }
    }
    throw (0, import_err_code110.default)(new Error(messages2.NOT_FOUND), codes4.ERR_NOT_FOUND);
  }
  async *getClosestPeers(key, options = {}) {
    for await (const event of this.dht.getClosestPeers(key, options)) {
      if (event.name === "FINAL_PEER") {
        yield event.peer;
      }
    }
  }
};
var import_err_code111 = __toESM(require_err_code(), 1);
var codes5 = {
  ERR_INVALID_PARAMETERS: "ERR_INVALID_PARAMETERS",
  ERR_NOT_FOUND: "ERR_NOT_FOUND"
};
async function* forEach$1(source, fn) {
  for await (const thing of source) {
    await fn(thing);
    yield thing;
  }
}
var log82 = logger("libp2p:peer-store:address-book");
var EVENT_NAME = "change:multiaddrs";
async function allowAll() {
  return true;
}
var PeerStoreAddressBook = class {
  constructor(dispatchEvent, store, addressFilter) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
    this.addressFilter = addressFilter ?? allowAll;
  }
  /**
   * ConsumePeerRecord adds addresses from a signed peer record contained in a record envelope.
   * This will return a boolean that indicates if the record was successfully processed and added
   * into the AddressBook.
   */
  async consumePeerRecord(envelope) {
    log82.trace("consumePeerRecord await write lock");
    const release = await this.store.lock.writeLock();
    log82.trace("consumePeerRecord got write lock");
    let peerId;
    let peer;
    let updatedPeer;
    try {
      let peerRecord;
      try {
        peerRecord = PeerRecord3.createFromProtobuf(envelope.payload);
      } catch (err2) {
        log82.error("invalid peer record received");
        return false;
      }
      peerId = peerRecord.peerId;
      const multiaddrs = peerRecord.multiaddrs;
      if (!peerId.equals(envelope.peerId)) {
        log82("signing key does not match PeerId in the PeerRecord");
        return false;
      }
      if (multiaddrs == null || multiaddrs.length === 0) {
        return false;
      }
      if (await this.store.has(peerId)) {
        peer = await this.store.load(peerId);
        if (peer.peerRecordEnvelope != null) {
          const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
          const storedRecord = PeerRecord3.createFromProtobuf(storedEnvelope.payload);
          if (storedRecord.seqNumber >= peerRecord.seqNumber) {
            log82("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
            return false;
          }
        }
      }
      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter, true);
      updatedPeer = await this.store.patchOrCreate(peerId, {
        addresses,
        peerRecordEnvelope: envelope.marshal().subarray()
      });
      log82("stored provided peer record for %p", peerRecord.peerId);
    } finally {
      log82.trace("consumePeerRecord release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent2(EVENT_NAME, {
      detail: {
        peerId,
        multiaddrs: updatedPeer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2),
        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      }
    }));
    return true;
  }
  async getRawEnvelope(peerId) {
    log82.trace("getRawEnvelope await read lock");
    const release = await this.store.lock.readLock();
    log82.trace("getRawEnvelope got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.peerRecordEnvelope;
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log82.trace("getRawEnvelope release read lock");
      release();
    }
  }
  /**
   * Get an Envelope containing a PeerRecord for the given peer.
   * Returns undefined if no record exists.
   */
  async getPeerRecord(peerId) {
    const raw = await this.getRawEnvelope(peerId);
    if (raw == null) {
      return void 0;
    }
    return await RecordEnvelope.createFromProtobuf(raw);
  }
  async get(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log82.trace("get wait for read lock");
    const release = await this.store.lock.readLock();
    log82.trace("get got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.addresses;
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log82.trace("get release read lock");
      release();
    }
    return [];
  }
  async set(peerId, multiaddrs) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(multiaddrs)) {
      log82.error("multiaddrs must be an array of Multiaddrs");
      throw (0, import_err_code111.default)(new Error("multiaddrs must be an array of Multiaddrs"), codes5.ERR_INVALID_PARAMETERS);
    }
    log82.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log82.trace("set got write lock");
    let hasPeer = false;
    let peer;
    let updatedPeer;
    try {
      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter);
      if (addresses.length === 0) {
        return;
      }
      try {
        peer = await this.store.load(peerId);
        hasPeer = true;
        if ((/* @__PURE__ */ new Set([
          ...addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()),
          ...peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString())
        ])).size === peer.addresses.length && addresses.length === peer.addresses.length) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.patchOrCreate(peerId, { addresses });
      log82("set multiaddrs for %p", peerId);
    } finally {
      log82.trace("set multiaddrs for %p", peerId);
      log82("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent2(EVENT_NAME, {
      detail: {
        peerId,
        multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      }
    }));
    if (!hasPeer) {
      this.dispatchEvent(new CustomEvent2("peer", {
        detail: {
          id: peerId,
          multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
          protocols: updatedPeer.protocols
        }
      }));
    }
  }
  async add(peerId, multiaddrs) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(multiaddrs)) {
      log82.error("multiaddrs must be an array of Multiaddrs");
      throw (0, import_err_code111.default)(new Error("multiaddrs must be an array of Multiaddrs"), codes5.ERR_INVALID_PARAMETERS);
    }
    log82.trace("add await write lock");
    const release = await this.store.lock.writeLock();
    log82.trace("add got write lock");
    let hasPeer;
    let peer;
    let updatedPeer;
    try {
      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter);
      if (addresses.length === 0) {
        return;
      }
      try {
        peer = await this.store.load(peerId);
        hasPeer = true;
        if ((/* @__PURE__ */ new Set([
          ...addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()),
          ...peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString())
        ])).size === peer.addresses.length) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.mergeOrCreate(peerId, { addresses });
      log82("added multiaddrs for %p", peerId);
    } finally {
      log82.trace("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent2(EVENT_NAME, {
      detail: {
        peerId,
        multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      }
    }));
    if (hasPeer === true) {
      this.dispatchEvent(new CustomEvent2("peer", {
        detail: {
          id: peerId,
          multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
          protocols: updatedPeer.protocols
        }
      }));
    }
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log82.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log82.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.patchOrCreate(peerId, {
        addresses: []
      });
    } finally {
      log82.trace("delete release write lock");
      release();
    }
    if (peer != null) {
      this.dispatchEvent(new CustomEvent2(EVENT_NAME, {
        detail: {
          peerId,
          multiaddrs: [],
          oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
        }
      }));
    }
  }
};
async function filterMultiaddrs(peerId, multiaddrs, addressFilter, isCertified = false) {
  return await pipe(multiaddrs, (source) => forEach$1(source, (multiaddr2) => {
    if (!isMultiaddr(multiaddr2)) {
      log82.error("multiaddr must be an instance of Multiaddr");
      throw (0, import_err_code111.default)(new Error("multiaddr must be an instance of Multiaddr"), codes5.ERR_INVALID_PARAMETERS);
    }
  }), (source) => filter(source, async (multiaddr2) => await addressFilter(peerId, multiaddr2)), (source) => map(source, (multiaddr2) => {
    return {
      multiaddr: multiaddr2,
      isCertified
    };
  }), async (source) => await all(source));
}
var import_err_code112 = __toESM(require_err_code(), 1);
var log83 = logger("libp2p:peer-store:key-book");
var EVENT_NAME2 = "change:pubkey";
var PeerStoreKeyBook = class {
  /**
   * The KeyBook is responsible for keeping the known public keys of a peer
   */
  constructor(dispatchEvent, store) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
  }
  /**
   * Set the Peer public key
   */
  async set(peerId, publicKey) {
    peerId = peerIdFromPeerId(peerId);
    if (!(publicKey instanceof Uint8Array)) {
      log83.error("publicKey must be an instance of Uint8Array to store data");
      throw (0, import_err_code112.default)(new Error("publicKey must be an instance of PublicKey"), codes5.ERR_INVALID_PARAMETERS);
    }
    log83.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log83.trace("set got write lock");
    let updatedKey = false;
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
        if (peer.pubKey != null && equals(peer.pubKey, publicKey)) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.patchOrCreate(peerId, {
        pubKey: publicKey
      });
      updatedKey = true;
    } finally {
      log83.trace("set release write lock");
      release();
    }
    if (updatedKey) {
      this.dispatchEvent(new CustomEvent2(EVENT_NAME2, {
        detail: {
          peerId,
          publicKey,
          oldPublicKey: peer == null ? void 0 : peer.pubKey
        }
      }));
    }
  }
  /**
   * Get Public key of the given PeerId, if stored
   */
  async get(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log83.trace("get await write lock");
    const release = await this.store.lock.readLock();
    log83.trace("get got write lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.pubKey;
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log83("get release write lock");
      release();
    }
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log83.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log83.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.patchOrCreate(peerId, {
        pubKey: void 0
      });
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log83.trace("delete release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent2(EVENT_NAME2, {
      detail: {
        peerId,
        publicKey: void 0,
        oldPublicKey: peer == null ? void 0 : peer.pubKey
      }
    }));
  }
};
var import_err_code113 = __toESM(require_err_code(), 1);
var log84 = logger("libp2p:peer-store:metadata-book");
var EVENT_NAME3 = "change:metadata";
var PeerStoreMetadataBook = class {
  /**
   * The MetadataBook is responsible for keeping metadata
   * about known peers
   */
  constructor(dispatchEvent, store) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
  }
  /**
   * Get the known data of a provided peer
   */
  async get(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log84.trace("get await read lock");
    const release = await this.store.lock.readLock();
    log84.trace("get got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.metadata;
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log84.trace("get release read lock");
      release();
    }
    return /* @__PURE__ */ new Map();
  }
  /**
   * Get specific metadata value, if it exists
   */
  async getValue(peerId, key) {
    peerId = peerIdFromPeerId(peerId);
    log84.trace("getValue await read lock");
    const release = await this.store.lock.readLock();
    log84.trace("getValue got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.metadata.get(key);
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log84.trace("getValue release write lock");
      release();
    }
  }
  async set(peerId, metadata) {
    peerId = peerIdFromPeerId(peerId);
    if (!(metadata instanceof Map)) {
      log84.error("valid metadata must be provided to store data");
      throw (0, import_err_code113.default)(new Error("valid metadata must be provided"), codes5.ERR_INVALID_PARAMETERS);
    }
    log84.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log84.trace("set got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.mergeOrCreate(peerId, {
        metadata
      });
    } finally {
      log84.trace("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent2(EVENT_NAME3, {
      detail: {
        peerId,
        metadata,
        oldMetadata: peer == null ? /* @__PURE__ */ new Map() : peer.metadata
      }
    }));
  }
  /**
   * Set metadata key and value of a provided peer
   */
  async setValue(peerId, key, value2) {
    peerId = peerIdFromPeerId(peerId);
    if (typeof key !== "string" || !(value2 instanceof Uint8Array)) {
      log84.error("valid key and value must be provided to store data");
      throw (0, import_err_code113.default)(new Error("valid key and value must be provided"), codes5.ERR_INVALID_PARAMETERS);
    }
    log84.trace("setValue await write lock");
    const release = await this.store.lock.writeLock();
    log84.trace("setValue got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        const existingValue = peer.metadata.get(key);
        if (existingValue != null && equals(value2, existingValue)) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.mergeOrCreate(peerId, {
        metadata: /* @__PURE__ */ new Map([[key, value2]])
      });
    } finally {
      log84.trace("setValue release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent2(EVENT_NAME3, {
      detail: {
        peerId,
        metadata: updatedPeer.metadata,
        oldMetadata: peer == null ? /* @__PURE__ */ new Map() : peer.metadata
      }
    }));
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log84.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log84.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      if (peer != null) {
        await this.store.patch(peerId, {
          metadata: /* @__PURE__ */ new Map()
        });
      }
    } finally {
      log84.trace("delete release write lock");
      release();
    }
    if (peer != null) {
      this.dispatchEvent(new CustomEvent2(EVENT_NAME3, {
        detail: {
          peerId,
          metadata: /* @__PURE__ */ new Map(),
          oldMetadata: peer.metadata
        }
      }));
    }
  }
  async deleteValue(peerId, key) {
    peerId = peerIdFromPeerId(peerId);
    log84.trace("deleteValue await write lock");
    const release = await this.store.lock.writeLock();
    log84.trace("deleteValue got write lock");
    let metadata;
    let peer;
    try {
      peer = await this.store.load(peerId);
      metadata = peer.metadata;
      metadata.delete(key);
      await this.store.patch(peerId, {
        metadata
      });
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log84.trace("deleteValue release write lock");
      release();
    }
    if (metadata != null) {
      this.dispatchEvent(new CustomEvent2(EVENT_NAME3, {
        detail: {
          peerId,
          metadata,
          oldMetadata: peer == null ? /* @__PURE__ */ new Map() : peer.metadata
        }
      }));
    }
  }
};
var import_err_code114 = __toESM(require_err_code(), 1);
var log85 = logger("libp2p:peer-store:proto-book");
var EVENT_NAME4 = "change:protocols";
var PeerStoreProtoBook = class {
  /**
   * The ProtoBook is responsible for keeping the known supported
   * protocols of a peer
   */
  constructor(dispatchEvent, store) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
  }
  async get(peerId) {
    log85.trace("get wait for read lock");
    const release = await this.store.lock.readLock();
    log85.trace("get got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.protocols;
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log85.trace("get release read lock");
      release();
    }
    return [];
  }
  async set(peerId, protocols) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(protocols)) {
      log85.error("protocols must be provided to store data");
      throw (0, import_err_code114.default)(new Error("protocols must be provided"), codes5.ERR_INVALID_PARAMETERS);
    }
    log85.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log85.trace("set got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        if ((/* @__PURE__ */ new Set([
          ...protocols
        ])).size === peer.protocols.length) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.patchOrCreate(peerId, {
        protocols
      });
      log85("stored provided protocols for %p", peerId);
    } finally {
      log85.trace("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent2(EVENT_NAME4, {
      detail: {
        peerId,
        protocols: updatedPeer.protocols,
        oldProtocols: peer == null ? [] : peer.protocols
      }
    }));
  }
  async add(peerId, protocols) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(protocols)) {
      log85.error("protocols must be provided to store data");
      throw (0, import_err_code114.default)(new Error("protocols must be provided"), codes5.ERR_INVALID_PARAMETERS);
    }
    log85.trace("add await write lock");
    const release = await this.store.lock.writeLock();
    log85.trace("add got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        if ((/* @__PURE__ */ new Set([
          ...peer.protocols,
          ...protocols
        ])).size === peer.protocols.length) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.mergeOrCreate(peerId, {
        protocols
      });
      log85("added provided protocols for %p", peerId);
    } finally {
      log85.trace("add release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent2(EVENT_NAME4, {
      detail: {
        peerId,
        protocols: updatedPeer.protocols,
        oldProtocols: peer == null ? [] : peer.protocols
      }
    }));
  }
  async remove(peerId, protocols) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(protocols)) {
      log85.error("protocols must be provided to store data");
      throw (0, import_err_code114.default)(new Error("protocols must be provided"), codes5.ERR_INVALID_PARAMETERS);
    }
    log85.trace("remove await write lock");
    const release = await this.store.lock.writeLock();
    log85.trace("remove got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        const protocolSet = new Set(peer.protocols);
        for (const protocol4 of protocols) {
          protocolSet.delete(protocol4);
        }
        if (peer.protocols.length === protocolSet.size) {
          return;
        }
        protocols = Array.from(protocolSet);
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.patchOrCreate(peerId, {
        protocols
      });
    } finally {
      log85.trace("remove release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent2(EVENT_NAME4, {
      detail: {
        peerId,
        protocols: updatedPeer.protocols,
        oldProtocols: peer == null ? [] : peer.protocols
      }
    }));
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log85.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log85.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes5.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.patchOrCreate(peerId, {
        protocols: []
      });
    } finally {
      log85.trace("delete release write lock");
      release();
    }
    if (peer != null) {
      this.dispatchEvent(new CustomEvent2(EVENT_NAME4, {
        detail: {
          peerId,
          protocols: [],
          oldProtocols: peer.protocols
        }
      }));
    }
  }
};
var import_err_code115 = __toESM(require_err_code(), 1);
var Peer2;
(function(Peer3) {
  let _codec;
  Peer3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.addresses != null) {
          for (const value2 of obj.addresses) {
            w.uint32(10);
            Address2.codec().encode(value2, w, {
              writeDefaults: true
            });
          }
        }
        if (obj.protocols != null) {
          for (const value2 of obj.protocols) {
            w.uint32(18);
            w.string(value2);
          }
        }
        if (obj.metadata != null) {
          for (const value2 of obj.metadata) {
            w.uint32(26);
            Metadata3.codec().encode(value2, w, {
              writeDefaults: true
            });
          }
        }
        if (obj.pubKey != null) {
          w.uint32(34);
          w.bytes(obj.pubKey);
        }
        if (obj.peerRecordEnvelope != null) {
          w.uint32(42);
          w.bytes(obj.peerRecordEnvelope);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {
          addresses: [],
          protocols: [],
          metadata: []
        };
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.addresses.push(Address2.codec().decode(reader3, reader3.uint32()));
              break;
            case 2:
              obj.protocols.push(reader3.string());
              break;
            case 3:
              obj.metadata.push(Metadata3.codec().decode(reader3, reader3.uint32()));
              break;
            case 4:
              obj.pubKey = reader3.bytes();
              break;
            case 5:
              obj.peerRecordEnvelope = reader3.bytes();
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer3.encode = (obj) => {
    return encodeMessage(obj, Peer3.codec());
  };
  Peer3.decode = (buf2) => {
    return decodeMessage(buf2, Peer3.codec());
  };
})(Peer2 || (Peer2 = {}));
var Address2;
(function(Address3) {
  let _codec;
  Address3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.multiaddr);
        }
        if (obj.isCertified != null) {
          w.uint32(16);
          w.bool(obj.isCertified);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {
          multiaddr: new Uint8Array(0)
        };
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.multiaddr = reader3.bytes();
              break;
            case 2:
              obj.isCertified = reader3.bool();
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Address3.encode = (obj) => {
    return encodeMessage(obj, Address3.codec());
  };
  Address3.decode = (buf2) => {
    return decodeMessage(buf2, Address3.codec());
  };
})(Address2 || (Address2 = {}));
var Metadata3;
(function(Metadata4) {
  let _codec;
  Metadata4.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.key !== "") {
          w.uint32(10);
          w.string(obj.key);
        }
        if (opts.writeDefaults === true || obj.value != null && obj.value.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.value);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {
          key: "",
          value: new Uint8Array(0)
        };
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.key = reader3.string();
              break;
            case 2:
              obj.value = reader3.bytes();
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Metadata4.encode = (obj) => {
    return encodeMessage(obj, Metadata4.codec());
  };
  Metadata4.decode = (buf2) => {
    return decodeMessage(buf2, Metadata4.codec());
  };
})(Metadata3 || (Metadata3 = {}));
var log86 = logger("libp2p:peer-store:store");
var NAMESPACE_COMMON = "/peers/";
var PersistentStore = class {
  constructor(components) {
    this.components = components;
    this.lock = createMortice({
      name: "peer-store",
      singleProcess: true
    });
  }
  _peerIdToDatastoreKey(peerId) {
    if (peerId.type == null) {
      log86.error("peerId must be an instance of peer-id to store data");
      throw (0, import_err_code115.default)(new Error("peerId must be an instance of peer-id"), codes5.ERR_INVALID_PARAMETERS);
    }
    const b32key = peerId.toCID().toString();
    return new Key(`${NAMESPACE_COMMON}${b32key}`);
  }
  async has(peerId) {
    return await this.components.datastore.has(this._peerIdToDatastoreKey(peerId));
  }
  async delete(peerId) {
    await this.components.datastore.delete(this._peerIdToDatastoreKey(peerId));
  }
  async load(peerId) {
    const buf2 = await this.components.datastore.get(this._peerIdToDatastoreKey(peerId));
    const peer = Peer2.decode(buf2);
    const metadata = /* @__PURE__ */ new Map();
    for (const meta of peer.metadata) {
      metadata.set(meta.key, meta.value);
    }
    return {
      ...peer,
      id: peerId,
      addresses: peer.addresses.map(({ multiaddr: ma, isCertified }) => {
        return {
          multiaddr: multiaddr(ma),
          isCertified: isCertified ?? false
        };
      }),
      metadata,
      pubKey: peer.pubKey ?? void 0,
      peerRecordEnvelope: peer.peerRecordEnvelope ?? void 0
    };
  }
  async save(peer) {
    if (peer.pubKey != null && peer.id.publicKey != null && !equals(peer.pubKey, peer.id.publicKey)) {
      log86.error("peer publicKey bytes do not match peer id publicKey bytes");
      throw (0, import_err_code115.default)(new Error("publicKey bytes do not match peer id publicKey bytes"), codes5.ERR_INVALID_PARAMETERS);
    }
    const addressSet = /* @__PURE__ */ new Set();
    const addresses = peer.addresses.filter((address) => {
      if (addressSet.has(address.multiaddr.toString())) {
        return false;
      }
      addressSet.add(address.multiaddr.toString());
      return true;
    }).sort((a, b) => {
      return a.multiaddr.toString().localeCompare(b.multiaddr.toString());
    }).map(({ multiaddr: multiaddr2, isCertified }) => ({
      multiaddr: multiaddr2.bytes,
      isCertified
    }));
    const metadata = [];
    [...peer.metadata.keys()].sort().forEach((key) => {
      const value2 = peer.metadata.get(key);
      if (value2 != null) {
        metadata.push({ key, value: value2 });
      }
    });
    const buf2 = Peer2.encode({
      addresses,
      protocols: peer.protocols.sort(),
      pubKey: peer.pubKey,
      metadata,
      peerRecordEnvelope: peer.peerRecordEnvelope
    });
    await this.components.datastore.put(this._peerIdToDatastoreKey(peer.id), buf2.subarray());
    return await this.load(peer.id);
  }
  async patch(peerId, data) {
    const peer = await this.load(peerId);
    return await this._patch(peerId, data, peer);
  }
  async patchOrCreate(peerId, data) {
    let peer;
    try {
      peer = await this.load(peerId);
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
      peer = { id: peerId, addresses: [], protocols: [], metadata: /* @__PURE__ */ new Map() };
    }
    return await this._patch(peerId, data, peer);
  }
  async _patch(peerId, data, peer) {
    return await this.save({
      ...peer,
      ...data,
      id: peerId
    });
  }
  async merge(peerId, data) {
    const peer = await this.load(peerId);
    return await this._merge(peerId, data, peer);
  }
  async mergeOrCreate(peerId, data) {
    let peer;
    try {
      peer = await this.load(peerId);
    } catch (err2) {
      if (err2.code !== codes5.ERR_NOT_FOUND) {
        throw err2;
      }
      peer = { id: peerId, addresses: [], protocols: [], metadata: /* @__PURE__ */ new Map() };
    }
    return await this._merge(peerId, data, peer);
  }
  async _merge(peerId, data, peer) {
    const addresses = /* @__PURE__ */ new Map();
    peer.addresses.forEach((addr) => {
      addresses.set(addr.multiaddr.toString(), addr.isCertified);
    });
    (data.addresses ?? []).forEach((addr) => {
      const addrString = addr.multiaddr.toString();
      const isAlreadyCertified = Boolean(addresses.get(addrString));
      const isCertified = isAlreadyCertified || addr.isCertified;
      addresses.set(addrString, isCertified);
    });
    return await this.save({
      id: peerId,
      addresses: Array.from(addresses.entries()).map(([addrStr, isCertified]) => {
        return {
          multiaddr: multiaddr(addrStr),
          isCertified
        };
      }),
      protocols: Array.from(/* @__PURE__ */ new Set([
        ...peer.protocols ?? [],
        ...data.protocols ?? []
      ])),
      metadata: new Map([
        ...peer.metadata?.entries() ?? [],
        ...data.metadata?.entries() ?? []
      ]),
      pubKey: data.pubKey ?? (peer != null ? peer.pubKey : void 0),
      peerRecordEnvelope: data.peerRecordEnvelope ?? (peer != null ? peer.peerRecordEnvelope : void 0)
    });
  }
  async *all() {
    for await (const key of this.components.datastore.queryKeys({
      prefix: NAMESPACE_COMMON
    })) {
      const base32Str = key.toString().split("/")[2];
      const buf2 = base32.decode(base32Str);
      yield this.load(peerIdFromBytes(buf2));
    }
  }
};
var import_err_code116 = __toESM(require_err_code());
var Tags;
(function(Tags2) {
  let _codec;
  Tags2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.tags != null) {
          for (const value2 of obj.tags) {
            w.uint32(10);
            Tag.codec().encode(value2, w, {
              writeDefaults: true
            });
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {
          tags: []
        };
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.tags.push(Tag.codec().decode(reader3, reader3.uint32()));
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Tags2.encode = (obj) => {
    return encodeMessage(obj, Tags2.codec());
  };
  Tags2.decode = (buf2) => {
    return decodeMessage(buf2, Tags2.codec());
  };
})(Tags || (Tags = {}));
var Tag;
(function(Tag2) {
  let _codec;
  Tag2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.name !== "") {
          w.uint32(10);
          w.string(obj.name);
        }
        if (obj.value != null) {
          w.uint32(16);
          w.uint32(obj.value);
        }
        if (obj.expiry != null) {
          w.uint32(24);
          w.uint64(obj.expiry);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {
          name: ""
        };
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.name = reader3.string();
              break;
            case 2:
              obj.value = reader3.uint32();
              break;
            case 3:
              obj.expiry = reader3.uint64();
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Tag2.encode = (obj) => {
    return encodeMessage(obj, Tag2.codec());
  };
  Tag2.decode = (buf2) => {
    return decodeMessage(buf2, Tag2.codec());
  };
})(Tag || (Tag = {}));
var log87 = logger("libp2p:peer-store");
var PersistentPeerStore = class extends EventEmitter2 {
  constructor(components, init = {}) {
    super();
    this.components = components;
    this.store = new PersistentStore(components);
    this.addressBook = new PeerStoreAddressBook(this.dispatchEvent.bind(this), this.store, init.addressFilter);
    this.keyBook = new PeerStoreKeyBook(this.dispatchEvent.bind(this), this.store);
    this.metadataBook = new PeerStoreMetadataBook(this.dispatchEvent.bind(this), this.store);
    this.protoBook = new PeerStoreProtoBook(this.dispatchEvent.bind(this), this.store);
  }
  async forEach(fn) {
    log87.trace("getPeers await read lock");
    const release = await this.store.lock.readLock();
    log87.trace("getPeers got read lock");
    try {
      for await (const peer of this.store.all()) {
        if (peer.id.equals(this.components.peerId)) {
          continue;
        }
        fn(peer);
      }
    } finally {
      log87.trace("getPeers release read lock");
      release();
    }
  }
  async all() {
    const output = [];
    await this.forEach((peer) => {
      output.push(peer);
    });
    return output;
  }
  /**
   * Delete the information of the given peer in every book
   */
  async delete(peerId) {
    log87.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log87.trace("delete got write lock");
    try {
      await this.store.delete(peerId);
    } finally {
      log87.trace("delete release write lock");
      release();
    }
  }
  /**
   * Get the stored information of a given peer
   */
  async get(peerId) {
    log87.trace("get await read lock");
    const release = await this.store.lock.readLock();
    log87.trace("get got read lock");
    try {
      return await this.store.load(peerId);
    } finally {
      log87.trace("get release read lock");
      release();
    }
  }
  /**
   * Returns true if we have a record of the peer
   */
  async has(peerId) {
    log87.trace("has await read lock");
    const release = await this.store.lock.readLock();
    log87.trace("has got read lock");
    try {
      return await this.store.has(peerId);
    } finally {
      log87.trace("has release read lock");
      release();
    }
  }
  async tagPeer(peerId, tag, options = {}) {
    const providedValue = options.value ?? 0;
    const value2 = Math.round(providedValue);
    const ttl2 = options.ttl ?? void 0;
    if (value2 !== providedValue || value2 < 0 || value2 > 100) {
      throw (0, import_err_code116.default)(new Error("Tag value must be between 0-100"), "ERR_TAG_VALUE_OUT_OF_BOUNDS");
    }
    const buf2 = await this.metadataBook.getValue(peerId, "tags");
    let tags = [];
    if (buf2 != null) {
      tags = Tags.decode(buf2).tags;
    }
    for (const t of tags) {
      if (t.name === tag) {
        throw (0, import_err_code116.default)(new Error("Peer already tagged"), "ERR_DUPLICATE_TAG");
      }
    }
    tags.push({
      name: tag,
      value: value2,
      expiry: ttl2 == null ? void 0 : BigInt(Date.now() + ttl2)
    });
    await this.metadataBook.setValue(peerId, "tags", Tags.encode({ tags }).subarray());
  }
  async unTagPeer(peerId, tag) {
    const buf2 = await this.metadataBook.getValue(peerId, "tags");
    let tags = [];
    if (buf2 != null) {
      tags = Tags.decode(buf2).tags;
    }
    tags = tags.filter((t) => t.name !== tag);
    await this.metadataBook.setValue(peerId, "tags", Tags.encode({ tags }).subarray());
  }
  async getTags(peerId) {
    const buf2 = await this.metadataBook.getValue(peerId, "tags");
    let tags = [];
    if (buf2 != null) {
      tags = Tags.decode(buf2).tags;
    }
    const now = BigInt(Date.now());
    const unexpiredTags = tags.filter((tag) => tag.expiry == null || tag.expiry > now);
    if (unexpiredTags.length !== tags.length) {
      await this.metadataBook.setValue(peerId, "tags", Tags.encode({ tags: unexpiredTags }).subarray());
    }
    return unexpiredTags.map((t) => ({
      name: t.name,
      value: t.value ?? 0
    }));
  }
};
var import_err_code117 = __toESM(require_err_code(), 1);
var DHTContentRouting = class {
  constructor(dht) {
    this.dht = dht;
  }
  async provide(cid) {
    await drain(this.dht.provide(cid));
  }
  async *findProviders(cid, options = {}) {
    for await (const event of this.dht.findProviders(cid, options)) {
      if (event.name === "PROVIDER") {
        yield* event.providers;
      }
    }
  }
  async put(key, value2, options) {
    await drain(this.dht.put(key, value2, options));
  }
  async get(key, options) {
    for await (const event of this.dht.get(key, options)) {
      if (event.name === "VALUE") {
        return event.value;
      }
    }
    throw (0, import_err_code117.default)(new Error("Not found"), "ERR_NOT_FOUND");
  }
};
var import_err_code118 = __toESM(require_err_code(), 1);
var DefaultComponents = class {
  constructor(init = {}) {
    this._started = false;
    this._peerId = init.peerId;
    this._addressManager = init.addressManager;
    this._peerStore = init.peerStore;
    this._upgrader = init.upgrader;
    this._metrics = init.metrics;
    this._registrar = init.registrar;
    this._connectionManager = init.connectionManager;
    this._transportManager = init.transportManager;
    this._connectionGater = init.connectionGater;
    this._contentRouting = init.contentRouting;
    this._peerRouting = init.peerRouting;
    this._datastore = init.datastore;
    this._connectionProtector = init.connectionProtector;
    this._dht = init.dht;
    this._pubsub = init.pubsub;
    this._dialer = init.dialer;
  }
  isStarted() {
    return this._started;
  }
  async beforeStart() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.beforeStart != null) {
        await startable.beforeStart();
      }
    }));
  }
  async start() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      await startable.start();
    }));
    this._started = true;
  }
  async afterStart() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.afterStart != null) {
        await startable.afterStart();
      }
    }));
  }
  async beforeStop() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.beforeStop != null) {
        await startable.beforeStop();
      }
    }));
  }
  async stop() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      await startable.stop();
    }));
    this._started = false;
  }
  async afterStop() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.afterStop != null) {
        await startable.afterStop();
      }
    }));
  }
  get peerId() {
    if (this._peerId == null) {
      throw (0, import_err_code118.default)(new Error("peerId not set"), "ERR_SERVICE_MISSING");
    }
    return this._peerId;
  }
  set peerId(peerId) {
    this._peerId = peerId;
  }
  get addressManager() {
    if (this._addressManager == null) {
      throw (0, import_err_code118.default)(new Error("addressManager not set"), "ERR_SERVICE_MISSING");
    }
    return this._addressManager;
  }
  set addressManager(addressManager) {
    this._addressManager = addressManager;
  }
  get peerStore() {
    if (this._peerStore == null) {
      throw (0, import_err_code118.default)(new Error("peerStore not set"), "ERR_SERVICE_MISSING");
    }
    return this._peerStore;
  }
  set peerStore(peerStore) {
    this._peerStore = peerStore;
  }
  get upgrader() {
    if (this._upgrader == null) {
      throw (0, import_err_code118.default)(new Error("upgrader not set"), "ERR_SERVICE_MISSING");
    }
    return this._upgrader;
  }
  set upgrader(upgrader) {
    this._upgrader = upgrader;
  }
  get registrar() {
    if (this._registrar == null) {
      throw (0, import_err_code118.default)(new Error("registrar not set"), "ERR_SERVICE_MISSING");
    }
    return this._registrar;
  }
  set registrar(registrar) {
    this._registrar = registrar;
  }
  get connectionManager() {
    if (this._connectionManager == null) {
      throw (0, import_err_code118.default)(new Error("connectionManager not set"), "ERR_SERVICE_MISSING");
    }
    return this._connectionManager;
  }
  set connectionManager(connectionManager) {
    this._connectionManager = connectionManager;
  }
  get transportManager() {
    if (this._transportManager == null) {
      throw (0, import_err_code118.default)(new Error("transportManager not set"), "ERR_SERVICE_MISSING");
    }
    return this._transportManager;
  }
  set transportManager(transportManager) {
    this._transportManager = transportManager;
  }
  get connectionGater() {
    if (this._connectionGater == null) {
      throw (0, import_err_code118.default)(new Error("connectionGater not set"), "ERR_SERVICE_MISSING");
    }
    return this._connectionGater;
  }
  set connectionGater(connectionGater) {
    this._connectionGater = connectionGater;
  }
  get contentRouting() {
    if (this._contentRouting == null) {
      throw (0, import_err_code118.default)(new Error("contentRouting not set"), "ERR_SERVICE_MISSING");
    }
    return this._contentRouting;
  }
  set contentRouting(contentRouting) {
    this._contentRouting = contentRouting;
  }
  get peerRouting() {
    if (this._peerRouting == null) {
      throw (0, import_err_code118.default)(new Error("peerRouting not set"), "ERR_SERVICE_MISSING");
    }
    return this._peerRouting;
  }
  set peerRouting(peerRouting) {
    this._peerRouting = peerRouting;
  }
  get datastore() {
    if (this._datastore == null) {
      throw (0, import_err_code118.default)(new Error("datastore not set"), "ERR_SERVICE_MISSING");
    }
    return this._datastore;
  }
  set datastore(datastore) {
    this._datastore = datastore;
  }
  get connectionProtector() {
    return this._connectionProtector;
  }
  set connectionProtector(connectionProtector) {
    this._connectionProtector = connectionProtector;
  }
  get dialer() {
    if (this._dialer == null) {
      throw (0, import_err_code118.default)(new Error("dialer not set"), "ERR_SERVICE_MISSING");
    }
    return this._dialer;
  }
  set dialer(dialer) {
    this._dialer = dialer;
  }
  get metrics() {
    return this._metrics;
  }
  set metrics(metrics) {
    this._metrics = metrics;
  }
  get dht() {
    return this._dht;
  }
  set dht(dht) {
    this._dht = dht;
  }
  get pubsub() {
    return this._pubsub;
  }
  set pubsub(pubsub) {
    this._pubsub = pubsub;
  }
};
var import_debug11 = __toESM(require_browser$1());
var import_receptacle = __toESM(require_receptacle());
var globalFetch = globalThis.fetch;
var globalHeaders = globalThis.Headers;
function buildResource(serverResolver, hostname, recordType) {
  return `${serverResolver}?name=${hostname}&type=${recordType}`;
}
async function request(resource, signal) {
  const req = await globalFetch(resource, {
    headers: new globalHeaders({
      accept: "application/dns-json"
    }),
    signal
  });
  const res = await req.json();
  return res;
}
function getCacheKey(hostname, recordType) {
  return `${recordType}_${hostname}`;
}
var log88 = Object.assign((0, import_debug11.default)("dns-over-http-resolver"), {
  error: (0, import_debug11.default)("dns-over-http-resolver:error")
});
var Resolver = class {
  /**
   * @class
   * @param {object} [options]
   * @param {number} [options.maxCache = 100] - maximum number of cached dns records
   * @param {Request} [options.request] - function to return DNSJSON
   */
  constructor(options = {}) {
    this._cache = new import_receptacle.default({ max: options?.maxCache ?? 100 });
    this._TXTcache = new import_receptacle.default({ max: options?.maxCache ?? 100 });
    this._servers = [
      "https://cloudflare-dns.com/dns-query",
      "https://dns.google/resolve"
    ];
    this._request = options.request ?? request;
    this._abortControllers = [];
  }
  /**
   * Cancel all outstanding DNS queries made by this resolver. Any outstanding
   * requests will be aborted and promises rejected.
   */
  cancel() {
    this._abortControllers.forEach((controller) => controller.abort());
  }
  /**
   * Get an array of the IP addresses currently configured for DNS resolution.
   * These addresses are formatted according to RFC 5952. It can include a custom port.
   */
  getServers() {
    return this._servers;
  }
  /**
   * Get a shuffled array of the IP addresses currently configured for DNS resolution.
   * These addresses are formatted according to RFC 5952. It can include a custom port.
   */
  _getShuffledServers() {
    const newServers = [...this._servers];
    for (let i2 = newServers.length - 1; i2 > 0; i2--) {
      const j = Math.floor(Math.random() * i2);
      const temp = newServers[i2];
      newServers[i2] = newServers[j];
      newServers[j] = temp;
    }
    return newServers;
  }
  /**
   * Sets the IP address and port of servers to be used when performing DNS resolution.
   *
   * @param {string[]} servers - array of RFC 5952 formatted addresses.
   */
  setServers(servers) {
    this._servers = servers;
  }
  /**
   * Uses the DNS protocol to resolve the given host name into the appropriate DNS record
   *
   * @param {string} hostname - host name to resolve
   * @param {string} [rrType = 'A'] - resource record type
   */
  async resolve(hostname, rrType = "A") {
    switch (rrType) {
      case "A":
        return await this.resolve4(hostname);
      case "AAAA":
        return await this.resolve6(hostname);
      case "TXT":
        return await this.resolveTxt(hostname);
      default:
        throw new Error(`${rrType} is not supported`);
    }
  }
  /**
   * Uses the DNS protocol to resolve the given host name into IPv4 addresses
   *
   * @param {string} hostname - host name to resolve
   */
  async resolve4(hostname) {
    const recordType = "A";
    const cached = this._cache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a) => a.data);
        const ttl2 = Math.min(...response.Answer.map((a) => a.TTL));
        this._cache.set(getCacheKey(hostname, recordType), data, { ttl: ttl2 });
        return data;
      } catch (err2) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log88.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c) => c !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryA ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  /**
   * Uses the DNS protocol to resolve the given host name into IPv6 addresses
   *
   * @param {string} hostname - host name to resolve
   */
  async resolve6(hostname) {
    const recordType = "AAAA";
    const cached = this._cache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a) => a.data);
        const ttl2 = Math.min(...response.Answer.map((a) => a.TTL));
        this._cache.set(getCacheKey(hostname, recordType), data, { ttl: ttl2 });
        return data;
      } catch (err2) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log88.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c) => c !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryAaaa ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  /**
   * Uses the DNS protocol to resolve the given host name into a Text record
   *
   * @param {string} hostname - host name to resolve
   */
  async resolveTxt(hostname) {
    const recordType = "TXT";
    const cached = this._TXTcache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a) => [a.data.replace(/['"]+/g, "")]);
        const ttl2 = Math.min(...response.Answer.map((a) => a.TTL));
        this._TXTcache.set(getCacheKey(hostname, recordType), data, { ttl: ttl2 });
        return data;
      } catch (err2) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log88.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c) => c !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryTxt ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  clearCache() {
    this._cache.clear();
    this._TXTcache.clear();
  }
};
var src_default2 = Resolver;
var dns_browser_default = src_default2;
var { code: dnsaddrCode } = getProtocol("dnsaddr");
async function dnsaddrResolver(addr, options = {}) {
  const resolver = new dns_browser_default();
  if (options.signal != null) {
    options.signal.addEventListener("abort", () => {
      resolver.cancel();
    });
  }
  const peerId = addr.getPeerId();
  const [, hostname] = addr.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? [];
  if (hostname == null) {
    throw new Error("No hostname found in multiaddr");
  }
  const records = await resolver.resolveTxt(`_dnsaddr.${hostname}`);
  let addresses = records.flat().map((a) => a.split("=")[1]);
  if (peerId != null) {
    addresses = addresses.filter((entry) => entry.includes(peerId));
  }
  return addresses;
}
var DIAL_TIMEOUT = 3e4;
var INBOUND_UPGRADE_TIMEOUT = 3e4;
var MAX_PARALLEL_DIALS = 100;
var MAX_PER_PEER_DIALS = 4;
var MAX_ADDRS_TO_DIAL = 25;
var import_err_code119 = __toESM(require_err_code(), 1);
var DefaultConfig = {
  addresses: {
    listen: [],
    announce: [],
    noAnnounce: [],
    announceFilter: (multiaddrs) => multiaddrs
  },
  connectionManager: {
    maxConnections: 300,
    minConnections: 50,
    autoDial: true,
    autoDialInterval: 1e4,
    maxParallelDials: MAX_PARALLEL_DIALS,
    maxDialsPerPeer: MAX_PER_PEER_DIALS,
    dialTimeout: DIAL_TIMEOUT,
    inboundUpgradeTimeout: INBOUND_UPGRADE_TIMEOUT,
    resolvers: {
      dnsaddr: dnsaddrResolver
    },
    addressSorter: publicAddressesFirst
  },
  connectionGater: {},
  transportManager: {
    faultTolerance: FaultTolerance.FATAL_ALL
  },
  peerRouting: {
    refreshManager: {
      enabled: true,
      interval: 6e5,
      bootDelay: 1e4
    }
  },
  nat: {
    enabled: true,
    ttl: 7200,
    keepAlive: true
  },
  relay: {
    enabled: true,
    advertise: {
      bootDelay: ADVERTISE_BOOT_DELAY,
      enabled: false,
      ttl: ADVERTISE_TTL
    },
    hop: {
      enabled: false,
      active: false,
      timeout: 3e4
    },
    autoRelay: {
      enabled: false,
      maxListeners: 2
    }
  },
  identify: {
    protocolPrefix: "ipfs",
    host: {
      agentVersion: AGENT_VERSION
    },
    // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L48
    timeout: 6e4,
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    maxPushIncomingStreams: 1,
    maxPushOutgoingStreams: 1
  },
  ping: {
    protocolPrefix: "ipfs",
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    timeout: 1e4
  },
  fetch: {
    protocolPrefix: "libp2p",
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    timeout: 1e4
  }
};
function validateConfig(opts) {
  const resultingOptions = merge_options_default(DefaultConfig, opts);
  if (resultingOptions.transports == null || resultingOptions.transports.length < 1) {
    throw (0, import_err_code119.default)(new Error(messages2.ERR_TRANSPORTS_REQUIRED), codes4.ERR_TRANSPORTS_REQUIRED);
  }
  if (resultingOptions.connectionEncryption == null || resultingOptions.connectionEncryption.length === 0) {
    throw (0, import_err_code119.default)(new Error(messages2.CONN_ENCRYPTION_REQUIRED), codes4.CONN_ENCRYPTION_REQUIRED);
  }
  if (resultingOptions.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) {
    throw (0, import_err_code119.default)(new Error(messages2.ERR_PROTECTOR_REQUIRED), codes4.ERR_PROTECTOR_REQUIRED);
  }
  if (resultingOptions.identify.host.agentVersion === AGENT_VERSION) {
    if (isNode2 || isElectronMain) {
      resultingOptions.identify.host.agentVersion += ` UserAgent=${globalThis.process.version}`;
    } else if (isBrowser3 || isWebWorker2 || isElectronRenderer || isReactNative2) {
      resultingOptions.identify.host.agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`;
    }
  }
  return resultingOptions;
}
var PeerIdProto;
(function(PeerIdProto2) {
  let _codec;
  PeerIdProto2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.id != null && obj.id.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.id);
        }
        if (obj.pubKey != null) {
          w.uint32(18);
          w.bytes(obj.pubKey);
        }
        if (obj.privKey != null) {
          w.uint32(26);
          w.bytes(obj.privKey);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {
          id: new Uint8Array(0)
        };
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.id = reader3.bytes();
              break;
            case 2:
              obj.pubKey = reader3.bytes();
              break;
            case 3:
              obj.privKey = reader3.bytes();
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerIdProto2.encode = (obj) => {
    return encodeMessage(obj, PeerIdProto2.codec());
  };
  PeerIdProto2.decode = (buf2) => {
    return decodeMessage(buf2, PeerIdProto2.codec());
  };
})(PeerIdProto || (PeerIdProto = {}));
var createEd25519PeerId = async () => {
  const key = await generateKeyPair4("Ed25519");
  const id = await createFromPrivKey(key);
  if (id.type === "Ed25519") {
    return id;
  }
  throw new Error(`Generated unexpected PeerId type "${id.type}"`);
};
var createRSAPeerId = async (opts) => {
  const key = await generateKeyPair4("RSA", opts?.bits ?? 2048);
  const id = await createFromPrivKey(key);
  if (id.type === "RSA") {
    return id;
  }
  throw new Error(`Generated unexpected PeerId type "${id.type}"`);
};
async function createFromPrivKey(privateKey) {
  return await peerIdFromKeys(marshalPublicKey2(privateKey.public), marshalPrivateKey(privateKey));
}
var import_err_code124 = __toESM(require_err_code(), 1);
var import_err_code120 = __toESM(require_err_code(), 1);
var DummyDHT = class extends EventEmitter2 {
  get [symbol5]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/dummy-dht";
  }
  get wan() {
    throw (0, import_err_code120.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  get lan() {
    throw (0, import_err_code120.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  get() {
    throw (0, import_err_code120.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  findProviders() {
    throw (0, import_err_code120.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  findPeer() {
    throw (0, import_err_code120.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  getClosestPeers() {
    throw (0, import_err_code120.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  provide() {
    throw (0, import_err_code120.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  put() {
    throw (0, import_err_code120.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  async getMode() {
    throw (0, import_err_code120.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  async setMode() {
    throw (0, import_err_code120.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
  async refreshRoutingTable() {
    throw (0, import_err_code120.default)(new Error(messages2.DHT_DISABLED), codes4.DHT_DISABLED);
  }
};
var import_err_code121 = __toESM(require_err_code(), 1);
var DummyPubSub = class extends EventEmitter2 {
  constructor() {
    super(...arguments);
    this.topicValidators = /* @__PURE__ */ new Map();
  }
  isStarted() {
    return false;
  }
  start() {
  }
  stop() {
  }
  get globalSignaturePolicy() {
    throw (0, import_err_code121.default)(new Error(messages2.PUBSUB_DISABLED), codes4.ERR_PUBSUB_DISABLED);
  }
  get multicodecs() {
    throw (0, import_err_code121.default)(new Error(messages2.PUBSUB_DISABLED), codes4.ERR_PUBSUB_DISABLED);
  }
  getPeers() {
    throw (0, import_err_code121.default)(new Error(messages2.PUBSUB_DISABLED), codes4.ERR_PUBSUB_DISABLED);
  }
  getTopics() {
    throw (0, import_err_code121.default)(new Error(messages2.PUBSUB_DISABLED), codes4.ERR_PUBSUB_DISABLED);
  }
  subscribe() {
    throw (0, import_err_code121.default)(new Error(messages2.PUBSUB_DISABLED), codes4.ERR_PUBSUB_DISABLED);
  }
  unsubscribe() {
    throw (0, import_err_code121.default)(new Error(messages2.PUBSUB_DISABLED), codes4.ERR_PUBSUB_DISABLED);
  }
  getSubscribers() {
    throw (0, import_err_code121.default)(new Error(messages2.PUBSUB_DISABLED), codes4.ERR_PUBSUB_DISABLED);
  }
  async publish() {
    throw (0, import_err_code121.default)(new Error(messages2.PUBSUB_DISABLED), codes4.ERR_PUBSUB_DISABLED);
  }
};
var import_err_code123 = __toESM(require_err_code(), 1);
var import_timeout_abort_controller11 = __toESM(require_timeout_abort_controller(), 1);
var import_any_signal7 = __toESM(require_any_signal(), 1);
var import_events30 = __toESM(require_events(), 1);
var import_err_code122 = __toESM(require_err_code(), 1);
var import_any_signal6 = __toESM(require_any_signal(), 1);
var import_p_fifo = __toESM(require_p_fifo(), 1);
var import_events29 = __toESM(require_events(), 1);
var log89 = logger("libp2p:dialer:dial-request");
var DialRequest = class {
  /**
   * Manages running the `dialAction` on multiple provided `addrs` in parallel
   * up to a maximum determined by the number of tokens returned
   * from `dialer.getTokens`. Once a DialRequest is created, it can be
   * started using `DialRequest.run(options)`. Once a single dial has succeeded,
   * all other dials in the request will be cancelled.
   */
  constructor(options) {
    const { addrs, dialAction, dialer } = options;
    this.addrs = addrs;
    this.dialer = dialer;
    this.dialAction = dialAction;
  }
  async run(options = {}) {
    const tokens = this.dialer.getTokens(this.addrs.length);
    if (tokens.length < 1) {
      throw (0, import_err_code122.default)(new Error("No dial tokens available"), codes4.ERR_NO_DIAL_TOKENS);
    }
    const tokenHolder = new import_p_fifo.default();
    for (const token of tokens) {
      void tokenHolder.push(token).catch((err2) => {
        log89.error(err2);
      });
    }
    const dialAbortControllers = this.addrs.map(() => {
      const controller = new AbortController();
      try {
        (0, import_events29.setMaxListeners)?.(Infinity, controller.signal);
      } catch {
      }
      return controller;
    });
    if (options.signal != null) {
      try {
        (0, import_events29.setMaxListeners)?.(Infinity, options.signal);
      } catch {
      }
    }
    let completedDials = 0;
    let done = false;
    try {
      return await Promise.any(this.addrs.map(async (addr, i2) => {
        const token = await tokenHolder.shift();
        if (done) {
          this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);
          throw (0, import_err_code122.default)(new Error("dialAction already succeeded"), codes4.ERR_ALREADY_SUCCEEDED);
        }
        const controller = dialAbortControllers[i2];
        if (controller == null) {
          throw (0, import_err_code122.default)(new Error("dialAction did not come with an AbortController"), codes4.ERR_INVALID_PARAMETERS);
        }
        let conn;
        try {
          const signal = controller.signal;
          conn = await this.dialAction(addr, { ...options, signal: options.signal != null ? (0, import_any_signal6.anySignal)([signal, options.signal]) : signal });
          dialAbortControllers[i2] = void 0;
        } finally {
          completedDials++;
          if (this.addrs.length - completedDials >= tokens.length) {
            void tokenHolder.push(token).catch((err2) => {
              log89.error(err2);
            });
          } else {
            this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);
          }
        }
        if (conn == null) {
          throw (0, import_err_code122.default)(new Error("dialAction led to empty object"), codes4.ERR_TRANSPORT_DIAL_FAILED);
        } else {
          done = true;
        }
        return conn;
      }));
    } finally {
      dialAbortControllers.forEach((c) => {
        if (c !== void 0) {
          c.abort();
        }
      });
      tokens.forEach((token) => this.dialer.releaseToken(token));
    }
  }
};
var log90 = logger("libp2p:dialer");
var DefaultDialer = class {
  constructor(components, init = {}) {
    this.started = false;
    this.addressSorter = init.addressSorter ?? publicAddressesFirst;
    this.maxAddrsToDial = init.maxAddrsToDial ?? MAX_ADDRS_TO_DIAL;
    this.timeout = init.dialTimeout ?? DIAL_TIMEOUT;
    this.maxDialsPerPeer = init.maxDialsPerPeer ?? MAX_PER_PEER_DIALS;
    this.tokens = [...new Array(init.maxParallelDials ?? MAX_PARALLEL_DIALS)].map((_, index2) => index2);
    this.components = components;
    this.pendingDials = trackedMap({
      name: "libp2p_dialler_pending_dials",
      metrics: components.metrics
    });
    this.pendingDialTargets = trackedMap({
      name: "libp2p_dialler_pending_dial_targets",
      metrics: components.metrics
    });
    for (const [key, value2] of Object.entries(init.resolvers ?? {})) {
      resolvers.set(key, value2);
    }
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  /**
   * Clears any pending dials
   */
  async stop() {
    this.started = false;
    for (const dial of this.pendingDials.values()) {
      try {
        dial.controller.abort();
      } catch (err2) {
        log90.error(err2);
      }
    }
    this.pendingDials.clear();
    for (const pendingTarget of this.pendingDialTargets.values()) {
      pendingTarget.abort();
    }
    this.pendingDialTargets.clear();
  }
  /**
   * Connects to a given `peer` by dialing all of its known addresses.
   * The dial to the first address that is successfully able to upgrade a connection
   * will be used.
   */
  async dial(peerIdOrMultiaddr, options = {}) {
    const { peerId, multiaddr: multiaddr2 } = getPeerAddress(peerIdOrMultiaddr);
    if (peerId != null) {
      if (this.components.peerId.equals(peerId)) {
        throw (0, import_err_code123.default)(new Error("Tried to dial self"), codes4.ERR_DIALED_SELF);
      }
      if (multiaddr2 != null) {
        log90("storing multiaddrs %p", peerId, multiaddr2);
        await this.components.peerStore.addressBook.add(peerId, [multiaddr2]);
      }
      if (await this.components.connectionGater.denyDialPeer(peerId)) {
        throw (0, import_err_code123.default)(new Error("The dial request is blocked by gater.allowDialPeer"), codes4.ERR_PEER_DIAL_INTERCEPTED);
      }
    }
    log90("creating dial target for %p", peerId);
    const controller = new AbortController();
    const controllerId = randomId();
    this.pendingDialTargets.set(controllerId, controller);
    let signal = controller.signal;
    if (options.signal != null) {
      signal = (0, import_any_signal7.anySignal)([signal, options.signal]);
    }
    let dialTarget;
    try {
      dialTarget = await this._createDialTarget({ peerId, multiaddr: multiaddr2 }, {
        ...options,
        signal
      });
    } finally {
      this.pendingDialTargets.delete(controllerId);
    }
    if (dialTarget.addrs.length === 0) {
      throw (0, import_err_code123.default)(new Error("The dial request has no valid addresses"), codes4.ERR_NO_VALID_ADDRESSES);
    }
    const pendingDial = this.pendingDials.get(dialTarget.id) ?? this._createPendingDial(dialTarget, options);
    try {
      const connection = await pendingDial.promise;
      log90("dial succeeded to %s", dialTarget.id);
      return connection;
    } catch (err2) {
      log90("dial failed to %s", dialTarget.id, err2);
      if (pendingDial.controller.signal.aborted) {
        err2.code = codes4.ERR_TIMEOUT;
      }
      log90.error(err2);
      throw err2;
    } finally {
      pendingDial.destroy();
    }
  }
  /**
   * Creates a DialTarget. The DialTarget is used to create and track
   * the DialRequest to a given peer.
   *
   * If a multiaddr is received it should be the only address attempted.
   *
   * Multiaddrs not supported by the available transports will be filtered out.
   */
  async _createDialTarget(peerIdOrMultiaddr, options) {
    let addrs = [];
    if (isMultiaddr(peerIdOrMultiaddr.multiaddr)) {
      addrs.push(peerIdOrMultiaddr.multiaddr);
    }
    if (!isMultiaddr(peerIdOrMultiaddr.multiaddr) && isPeerId(peerIdOrMultiaddr.peerId)) {
      addrs.push(...await this._loadAddresses(peerIdOrMultiaddr.peerId));
    }
    addrs = (await Promise.all(addrs.map(async (ma) => await this._resolve(ma, options)))).flat().filter((ma) => Boolean(this.components.transportManager.transportForMultiaddr(ma)));
    addrs = [...new Set(addrs.map((ma) => ma.toString()))].map((ma) => multiaddr(ma));
    if (addrs.length > this.maxAddrsToDial) {
      throw (0, import_err_code123.default)(new Error("dial with more addresses than allowed"), codes4.ERR_TOO_MANY_ADDRESSES);
    }
    const peerId = isPeerId(peerIdOrMultiaddr.peerId) ? peerIdOrMultiaddr.peerId : void 0;
    if (peerId != null) {
      const peerIdMultiaddr = `/p2p/${peerId.toString()}`;
      addrs = addrs.map((addr) => {
        const addressPeerId = addr.getPeerId();
        if (addressPeerId == null || !peerId.equals(addressPeerId)) {
          return addr.encapsulate(peerIdMultiaddr);
        }
        return addr;
      });
    }
    return {
      id: peerId == null ? randomId() : peerId.toString(),
      addrs
    };
  }
  /**
   * Loads a list of addresses from the peer store for the passed peer id
   */
  async _loadAddresses(peer) {
    const addresses = await this.components.peerStore.addressBook.get(peer);
    return (await Promise.all(addresses.map(async (address) => {
      const deny = await this.components.connectionGater.denyDialMultiaddr(peer, address.multiaddr);
      if (deny) {
        return false;
      }
      return address;
    }))).filter(isTruthy).sort(this.addressSorter).map((address) => address.multiaddr);
  }
  /**
   * Creates a PendingDial that wraps the underlying DialRequest
   */
  _createPendingDial(dialTarget, options = {}) {
    const dialAction = async (addr, options2 = {}) => {
      if (options2.signal?.aborted === true) {
        throw (0, import_err_code123.default)(new Error("already aborted"), codes4.ERR_ALREADY_ABORTED);
      }
      return await this.components.transportManager.dial(addr, options2).catch((err2) => {
        log90.error("dial to %s failed", addr, err2);
        throw err2;
      });
    };
    const dialRequest = new DialRequest({
      addrs: dialTarget.addrs,
      dialAction,
      dialer: this
    });
    const timeoutController = new import_timeout_abort_controller11.TimeoutController(this.timeout);
    const signals = [timeoutController.signal];
    options.signal != null && signals.push(options.signal);
    const signal = (0, import_any_signal7.anySignal)(signals);
    try {
      (0, import_events30.setMaxListeners)?.(Infinity, signal);
    } catch {
    }
    const pendingDial = {
      dialRequest,
      controller: timeoutController,
      promise: dialRequest.run({ ...options, signal }),
      destroy: () => {
        timeoutController.clear();
        this.pendingDials.delete(dialTarget.id);
      }
    };
    this.pendingDials.set(dialTarget.id, pendingDial);
    return pendingDial;
  }
  getTokens(num) {
    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length);
    const tokens = this.tokens.splice(0, total);
    log90("%d tokens request, returning %d, %d remaining", num, total, this.tokens.length);
    return tokens;
  }
  releaseToken(token) {
    if (this.tokens.includes(token)) {
      return;
    }
    log90("token %d released", token);
    this.tokens.push(token);
  }
  /**
   * Resolve multiaddr recursively
   */
  async _resolve(ma, options) {
    const resolvableProto = ma.protoNames().includes("dnsaddr");
    if (!resolvableProto) {
      return [ma];
    }
    const resolvedMultiaddrs = await this._resolveRecord(ma, options);
    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(async (nm) => {
      return await this._resolve(nm, options);
    }));
    const addrs = recursiveMultiaddrs.flat();
    return addrs.reduce((array, newM) => {
      if (array.find((m) => m.equals(newM)) == null) {
        array.push(newM);
      }
      return array;
    }, []);
  }
  /**
   * Resolve a given multiaddr. If this fails, an empty array will be returned
   */
  async _resolveRecord(ma, options) {
    try {
      ma = multiaddr(ma.toString());
      const multiaddrs = await ma.resolve(options);
      return multiaddrs;
    } catch (err2) {
      log90.error(`multiaddr ${ma.toString()} could not be resolved`, err2);
      return [];
    }
  }
};
function isTruthy(e) {
  return Boolean(e);
}
function randomId() {
  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
}
var log91 = logger("libp2p");
var Libp2pNode = class extends EventEmitter2 {
  constructor(init) {
    super();
    this.started = false;
    this.peerId = init.peerId;
    const components = this.components = new DefaultComponents({
      peerId: init.peerId,
      datastore: init.datastore ?? new MemoryDatastore(),
      connectionGater: {
        denyDialPeer: async () => await Promise.resolve(false),
        denyDialMultiaddr: async () => await Promise.resolve(false),
        denyInboundConnection: async () => await Promise.resolve(false),
        denyOutboundConnection: async () => await Promise.resolve(false),
        denyInboundEncryptedConnection: async () => await Promise.resolve(false),
        denyOutboundEncryptedConnection: async () => await Promise.resolve(false),
        denyInboundUpgradedConnection: async () => await Promise.resolve(false),
        denyOutboundUpgradedConnection: async () => await Promise.resolve(false),
        filterMultiaddrForPeer: async () => await Promise.resolve(true),
        ...init.connectionGater
      }
    });
    components.peerStore = new PersistentPeerStore(components, {
      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
      ...init.peerStore
    });
    this.services = [
      components
    ];
    if (init.metrics != null) {
      this.metrics = this.components.metrics = this.configureComponent(init.metrics(this.components));
    }
    this.peerStore = this.components.peerStore;
    this.peerStore.addEventListener("peer", (evt) => {
      const { detail: peerData } = evt;
      this.dispatchEvent(new CustomEvent2("peer:discovery", { detail: peerData }));
    });
    if (init.connectionProtector != null) {
      this.components.connectionProtector = init.connectionProtector(components);
    }
    this.components.upgrader = new DefaultUpgrader(this.components, {
      connectionEncryption: (init.connectionEncryption ?? []).map((fn) => this.configureComponent(fn(this.components))),
      muxers: (init.streamMuxers ?? []).map((fn) => this.configureComponent(fn(this.components))),
      inboundUpgradeTimeout: init.connectionManager.inboundUpgradeTimeout
    });
    this.components.dialer = new DefaultDialer(this.components, init.connectionManager);
    this.connectionManager = this.components.connectionManager = new DefaultConnectionManager(this.components, init.connectionManager);
    this.components.connectionManager.addEventListener("peer:disconnect", (event) => {
      this.dispatchEvent(new CustomEvent2("peer:disconnect", { detail: event.detail }));
    });
    this.components.connectionManager.addEventListener("peer:connect", (event) => {
      this.dispatchEvent(new CustomEvent2("peer:connect", { detail: event.detail }));
    });
    this.registrar = this.components.registrar = new DefaultRegistrar(this.components);
    this.components.transportManager = new DefaultTransportManager(this.components, init.transportManager);
    this.components.addressManager = new DefaultAddressManager(this.components, init.addresses);
    this.configureComponent(new PeerRecordUpdater(this.components));
    this.configureComponent(new AutoDialler(this.components, {
      enabled: init.connectionManager.autoDial,
      minConnections: init.connectionManager.minConnections,
      autoDialInterval: init.connectionManager.autoDialInterval
    }));
    const keychainOpts = KeyChain.generateOptions();
    this.keychain = this.configureComponent(new KeyChain(this.components, {
      ...keychainOpts,
      ...init.keychain
    }));
    this.services.push(new NatManager(this.components, init.nat));
    init.transports.forEach((fn) => {
      this.components.transportManager.add(this.configureComponent(fn(this.components)));
    });
    this.identifyService = new IdentifyService(this.components, {
      ...init.identify
    });
    this.configureComponent(this.identifyService);
    if (init.dht != null) {
      this.dht = this.components.dht = init.dht(this.components);
    } else {
      this.dht = new DummyDHT();
    }
    if (init.pubsub != null) {
      this.pubsub = this.components.pubsub = init.pubsub(this.components);
    } else {
      this.pubsub = new DummyPubSub();
    }
    const peerRouters = (init.peerRouters ?? []).map((fn) => this.configureComponent(fn(this.components)));
    if (init.dht != null) {
      peerRouters.push(this.configureComponent(new DHTPeerRouting(this.dht)));
      this.dht.addEventListener("peer", (evt) => {
        this.onDiscoveryPeer(evt);
      });
    }
    this.peerRouting = this.components.peerRouting = this.configureComponent(new DefaultPeerRouting(this.components, {
      ...init.peerRouting,
      routers: peerRouters
    }));
    const contentRouters = (init.contentRouters ?? []).map((fn) => this.configureComponent(fn(this.components)));
    if (init.dht != null) {
      contentRouters.push(this.configureComponent(new DHTContentRouting(this.dht)));
    }
    this.contentRouting = this.components.contentRouting = this.configureComponent(new CompoundContentRouting(this.components, {
      routers: contentRouters
    }));
    if (init.relay.enabled) {
      this.components.transportManager.add(this.configureComponent(new Circuit2(this.components, init.relay)));
      this.configureComponent(new Relay(this.components, {
        addressSorter: init.connectionManager.addressSorter,
        ...init.relay
      }));
    }
    this.fetchService = this.configureComponent(new FetchService(this.components, {
      ...init.fetch
    }));
    this.pingService = this.configureComponent(new PingService(this.components, {
      ...init.ping
    }));
    for (const fn of init.peerDiscovery ?? []) {
      const service = this.configureComponent(fn(this.components));
      service.addEventListener("peer", (evt) => {
        this.onDiscoveryPeer(evt);
      });
    }
  }
  configureComponent(component) {
    if (isStartable(component)) {
      this.services.push(component);
    }
    return component;
  }
  /**
   * Starts the libp2p node and all its subsystems
   */
  async start() {
    if (this.started) {
      return;
    }
    this.started = true;
    log91("libp2p is starting");
    try {
      await Promise.all(this.services.map(async (service) => {
        if (service.beforeStart != null) {
          await service.beforeStart();
        }
      }));
      await Promise.all(this.services.map((service) => service.start()));
      await Promise.all(this.services.map(async (service) => {
        if (service.afterStart != null) {
          await service.afterStart();
        }
      }));
      log91("libp2p has started");
    } catch (err2) {
      log91.error("An error occurred starting libp2p", err2);
      await this.stop();
      throw err2;
    }
  }
  /**
   * Stop the libp2p node by closing its listeners and open connections
   */
  async stop() {
    if (!this.started) {
      return;
    }
    log91("libp2p is stopping");
    this.started = false;
    await Promise.all(this.services.map(async (service) => {
      if (service.beforeStop != null) {
        await service.beforeStop();
      }
    }));
    await Promise.all(this.services.map((service) => service.stop()));
    await Promise.all(this.services.map(async (service) => {
      if (service.afterStop != null) {
        await service.afterStop();
      }
    }));
    log91("libp2p has stopped");
  }
  isStarted() {
    return this.started;
  }
  getConnections(peerId) {
    return this.components.connectionManager.getConnections(peerId);
  }
  getPeers() {
    const peerSet = new PeerSet();
    for (const conn of this.components.connectionManager.getConnections()) {
      peerSet.add(conn.remotePeer);
    }
    return Array.from(peerSet);
  }
  async dial(peer, options = {}) {
    return await this.components.connectionManager.openConnection(peer, options);
  }
  async dialProtocol(peer, protocols, options = {}) {
    if (protocols == null) {
      throw (0, import_err_code124.default)(new Error("no protocols were provided to open a stream"), codes4.ERR_INVALID_PROTOCOLS_FOR_STREAM);
    }
    protocols = Array.isArray(protocols) ? protocols : [protocols];
    if (protocols.length === 0) {
      throw (0, import_err_code124.default)(new Error("no protocols were provided to open a stream"), codes4.ERR_INVALID_PROTOCOLS_FOR_STREAM);
    }
    const connection = await this.dial(peer, options);
    return await connection.newStream(protocols, options);
  }
  getMultiaddrs() {
    return this.components.addressManager.getAddresses();
  }
  getProtocols() {
    return this.components.registrar.getProtocols();
  }
  async hangUp(peer) {
    if (isMultiaddr(peer)) {
      peer = peerIdFromString(peer.getPeerId() ?? "");
    }
    await this.components.connectionManager.closeConnections(peer);
  }
  /**
   * Get the public key for the given peer id
   */
  async getPublicKey(peer, options = {}) {
    log91("getPublicKey %p", peer);
    if (peer.publicKey != null) {
      return peer.publicKey;
    }
    const peerInfo = await this.peerStore.get(peer);
    if (peerInfo.pubKey != null) {
      return peerInfo.pubKey;
    }
    if (this.dht == null) {
      throw (0, import_err_code124.default)(new Error("Public key was not in the peer store and the DHT is not enabled"), codes4.ERR_NO_ROUTERS_AVAILABLE);
    }
    const peerKey = concat([
      fromString3("/pk/"),
      peer.multihash.digest
    ]);
    for await (const event of this.dht.get(peerKey, options)) {
      if (event.name === "VALUE") {
        const key = unmarshalPublicKey2(event.value);
        await this.peerStore.keyBook.set(peer, event.value);
        return key.bytes;
      }
    }
    throw (0, import_err_code124.default)(new Error(`Node not responding with its public key: ${peer.toString()}`), codes4.ERR_INVALID_RECORD);
  }
  async fetch(peer, key, options = {}) {
    if (isMultiaddr(peer)) {
      const peerId = peerIdFromString(peer.getPeerId() ?? "");
      await this.components.peerStore.addressBook.add(peerId, [peer]);
      peer = peerId;
    }
    return await this.fetchService.fetch(peer, key, options);
  }
  async ping(peer, options = {}) {
    if (isMultiaddr(peer)) {
      const peerId = peerIdFromString(peer.getPeerId() ?? "");
      await this.components.peerStore.addressBook.add(peerId, [peer]);
      peer = peerId;
    }
    return await this.pingService.ping(peer, options);
  }
  async handle(protocols, handler, options) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol4) => {
      await this.components.registrar.handle(protocol4, handler, options);
    }));
  }
  async unhandle(protocols) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol4) => {
      await this.components.registrar.unhandle(protocol4);
    }));
  }
  async register(protocol4, topology) {
    return await this.registrar.register(protocol4, topology);
  }
  unregister(id) {
    this.registrar.unregister(id);
  }
  /**
   * Called whenever peer discovery services emit `peer` events.
   * Known peers may be emitted.
   */
  onDiscoveryPeer(evt) {
    const { detail: peer } = evt;
    if (peer.id.toString() === this.peerId.toString()) {
      log91.error(new Error(codes4.ERR_DISCOVERED_SELF));
      return;
    }
    if (peer.multiaddrs.length > 0) {
      void this.components.peerStore.addressBook.add(peer.id, peer.multiaddrs).catch((err2) => log91.error(err2));
    }
    if (peer.protocols.length > 0) {
      void this.components.peerStore.protoBook.set(peer.id, peer.protocols).catch((err2) => log91.error(err2));
    }
    this.dispatchEvent(new CustomEvent2("peer:discovery", { detail: peer }));
  }
};
async function createLibp2pNode(options) {
  if (options.peerId == null) {
    const datastore = options.datastore;
    if (datastore != null) {
      try {
        const keyChain = new KeyChain({
          datastore
        }, {
          ...KeyChain.generateOptions(),
          ...options.keychain ?? {}
        });
        options.peerId = await keyChain.exportPeerId("self");
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
    }
  }
  if (options.peerId == null) {
    options.peerId = await createEd25519PeerId();
  }
  return new Libp2pNode(validateConfig(options));
}
async function createLibp2p(options) {
  const node = await createLibp2pNode(options);
  if (options.start !== false) {
    await node.start();
  }
  return node;
}
var import_k_bucket = __toESM(require_k_bucket(), 1);
var second2 = 1e3;
var minute4 = 60 * second2;
var hour2 = 60 * minute4;
var MAX_RECORD_AGE = 36 * hour2;
var LAN_PREFIX = "/lan";
var PROTOCOL_PREFIX = "/ipfs";
var PROTOCOL_DHT = "/kad/1.0.0";
var RECORD_KEY_PREFIX = "/dht/record";
var PROVIDER_KEY_PREFIX = "/dht/provider";
var PROVIDERS_LRU_CACHE_SIZE = 256;
var PROVIDERS_VALIDITY = 24 * hour2;
var PROVIDERS_CLEANUP_INTERVAL = hour2;
var K = 20;
var ALPHA = 3;
var QUERY_SELF_INTERVAL = Number(5 * minute4);
var QUERY_SELF_TIMEOUT = Number(30 * second2);
var TABLE_REFRESH_INTERVAL = Number(5 * minute4);
var TABLE_REFRESH_QUERY_TIMEOUT = Number(30 * second2);
var DEFAULT_QUERY_TIMEOUT = Number(30 * second2);
var PK_PREFIX = fromString3("/pk/");
function removePrivateAddresses(peer) {
  return {
    ...peer,
    multiaddrs: peer.multiaddrs.filter((multiaddr2) => {
      const [[type, addr]] = multiaddr2.stringTuples();
      if (type === 53 || type === 54 || type === 55) {
        if (addr === "localhost") {
          return false;
        }
        return true;
      }
      if (type !== 4 && type !== 6) {
        return false;
      }
      if (addr == null) {
        return false;
      }
      const isPrivate2 = private_ip_default(addr);
      if (isPrivate2 == null) {
        return true;
      }
      return !isPrivate2;
    })
  };
}
function removePublicAddresses(peer) {
  return {
    ...peer,
    multiaddrs: peer.multiaddrs.filter((multiaddr2) => {
      const [[type, addr]] = multiaddr2.stringTuples();
      if (addr === "localhost") {
        return true;
      }
      if (type !== 4 && type !== 6) {
        return false;
      }
      if (addr == null) {
        return false;
      }
      const isPrivate2 = private_ip_default(addr);
      if (isPrivate2 == null) {
        return false;
      }
      return isPrivate2;
    })
  };
}
async function convertBuffer(buf2) {
  const multihash = await sha256.digest(buf2);
  return multihash.digest;
}
async function convertPeerId(peerId) {
  return await convertBuffer(peerId.toBytes());
}
function bufferToRecordKey(buf2) {
  return new Key(`${RECORD_KEY_PREFIX}/${toString3(buf2, "base32")}`, false);
}
function keyForPublicKey(peer) {
  return concat([
    PK_PREFIX,
    peer.toBytes()
  ]);
}
function isPublicKeyKey(key) {
  return toString3(key.subarray(0, 4)) === "/pk/";
}
function fromPublicKeyKey(key) {
  return peerIdFromBytes(key.subarray(4));
}
function createPutRecord(key, value2) {
  const timeReceived = new Date();
  const rec = new Libp2pRecord(key, value2, timeReceived);
  return rec.serialize();
}
function debounce(callback, wait = 100) {
  let timeout;
  return () => {
    clearTimeout(timeout);
    timeout = setTimeout(() => callback(), wait);
  };
}
var import_timeout_abort_controller12 = __toESM(require_timeout_abort_controller(), 1);
var KAD_CLOSE_TAG_NAME = "kad-close";
var KAD_CLOSE_TAG_VALUE = 50;
var KBUCKET_SIZE = 20;
var PING_TIMEOUT = 1e4;
var PING_CONCURRENCY = 10;
var RoutingTable = class {
  constructor(components, init) {
    const { kBucketSize, pingTimeout, lan, pingConcurrency, protocol: protocol4, tagName, tagValue } = init;
    this.components = components;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:routing-table`);
    this.kBucketSize = kBucketSize ?? KBUCKET_SIZE;
    this.pingTimeout = pingTimeout ?? PING_TIMEOUT;
    this.pingConcurrency = pingConcurrency ?? PING_CONCURRENCY;
    this.lan = lan;
    this.running = false;
    this.protocol = protocol4;
    this.tagName = tagName ?? KAD_CLOSE_TAG_NAME;
    this.tagValue = tagValue ?? KAD_CLOSE_TAG_VALUE;
    const updatePingQueueSizeMetric = () => {
      this.metrics?.pingQueueSize.update(this.pingQueue.size);
      this.metrics?.pingRunning.update(this.pingQueue.pending);
    };
    this.pingQueue = new PQueue({ concurrency: this.pingConcurrency });
    this.pingQueue.addListener("add", updatePingQueueSizeMetric);
    this.pingQueue.addListener("next", updatePingQueueSizeMetric);
    this._onPing = this._onPing.bind(this);
  }
  isStarted() {
    return this.running;
  }
  async start() {
    this.running = true;
    if (this.components.metrics != null) {
      this.metrics = {
        routingTableSize: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? "lan" : "wan"}_routing_table_size`),
        pingQueueSize: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? "lan" : "wan"}_ping_queue_size`),
        pingRunning: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? "lan" : "wan"}_ping_running`)
      };
    }
    const kBuck = new import_k_bucket.default({
      localNodeId: await convertPeerId(this.components.peerId),
      numberOfNodesPerKBucket: this.kBucketSize,
      numberOfNodesToPing: 1
    });
    this.kb = kBuck;
    kBuck.on("ping", this._onPing);
    this._tagPeers(kBuck);
  }
  async stop() {
    this.running = false;
    this.pingQueue.clear();
    this.kb = void 0;
  }
  /**
   * Keep track of our k-closest peers and tag them in the peer store as such
   * - this will lower the chances that connections to them get closed when
   * we reach connection limits
   */
  _tagPeers(kBuck) {
    let kClosest = new PeerSet();
    const updatePeerTags = debounce(() => {
      const newClosest = new PeerSet(kBuck.closest(kBuck.localNodeId, KBUCKET_SIZE).map((contact) => contact.peer));
      const addedPeers = newClosest.difference(kClosest);
      const removedPeers = kClosest.difference(newClosest);
      Promise.resolve().then(async () => {
        for (const peer of addedPeers) {
          await this.components.peerStore.tagPeer(peer, this.tagName, {
            value: this.tagValue
          });
        }
        for (const peer of removedPeers) {
          await this.components.peerStore.unTagPeer(peer, this.tagName);
        }
      }).catch((err2) => {
        this.log.error("Could not update peer tags", err2);
      });
      kClosest = newClosest;
    });
    kBuck.on("added", () => {
      updatePeerTags();
    });
    kBuck.on("removed", () => {
      updatePeerTags();
    });
  }
  /**
   * Called on the `ping` event from `k-bucket` when a bucket is full
   * and cannot split.
   *
   * `oldContacts.length` is defined by the `numberOfNodesToPing` param
   * passed to the `k-bucket` constructor.
   *
   * `oldContacts` will not be empty and is the list of contacts that
   * have not been contacted for the longest.
   */
  _onPing(oldContacts, newContact) {
    this.pingQueue.add(async () => {
      if (!this.running) {
        return;
      }
      let responded = 0;
      try {
        await Promise.all(oldContacts.map(async (oldContact) => {
          let timeoutController;
          try {
            timeoutController = new import_timeout_abort_controller12.TimeoutController(this.pingTimeout);
            const options = {
              signal: timeoutController.signal
            };
            this.log("pinging old contact %p", oldContact.peer);
            const connection = await this.components.connectionManager.openConnection(oldContact.peer, options);
            const stream = await connection.newStream(this.protocol, options);
            stream.close();
            responded++;
          } catch (err2) {
            if (this.running && this.kb != null) {
              this.log.error("could not ping peer %p", oldContact.peer, err2);
              this.log("evicting old contact after ping failed %p", oldContact);
              this.kb.remove(oldContact.id);
            }
          } finally {
            if (timeoutController != null) {
              timeoutController.clear();
            }
            this.metrics?.routingTableSize.update(this.size);
          }
        }));
        if (this.running && responded < oldContacts.length && this.kb != null) {
          this.log("adding new contact %p", newContact.peer);
          this.kb.add(newContact);
        }
      } catch (err2) {
        this.log.error("could not process k-bucket ping event", err2);
      }
    }).catch((err2) => {
      this.log.error("could not process k-bucket ping event", err2);
    });
  }
  // -- Public Interface
  /**
   * Amount of currently stored peers
   */
  get size() {
    if (this.kb == null) {
      return 0;
    }
    return this.kb.count();
  }
  /**
   * Find a specific peer by id
   */
  async find(peer) {
    const key = await convertPeerId(peer);
    const closest = this.closestPeer(key);
    if (closest != null && peer.equals(closest)) {
      return closest;
    }
    return void 0;
  }
  /**
   * Retrieve the closest peers to the given key
   */
  closestPeer(key) {
    const res = this.closestPeers(key, 1);
    if (res.length > 0) {
      return res[0];
    }
    return void 0;
  }
  /**
   * Retrieve the `count`-closest peers to the given key
   */
  closestPeers(key, count = this.kBucketSize) {
    if (this.kb == null) {
      return [];
    }
    const closest = this.kb.closest(key, count);
    return closest.map((p) => p.peer);
  }
  /**
   * Add or update the routing table with the given peer
   */
  async add(peer) {
    if (this.kb == null) {
      throw new Error("RoutingTable is not started");
    }
    const id = await convertPeerId(peer);
    this.kb.add({ id, peer });
    this.log("added %p with kad id %b", peer, id);
    this.metrics?.routingTableSize.update(this.size);
  }
  /**
   * Remove a given peer from the table
   */
  async remove(peer) {
    if (this.kb == null) {
      throw new Error("RoutingTable is not started");
    }
    const id = await convertPeerId(peer);
    this.kb.remove(id);
    this.metrics?.routingTableSize.update(this.size);
  }
};
var generated_prefix_list_browser_default = [
  77591,
  22417,
  43971,
  28421,
  740,
  29829,
  71467,
  228973,
  196661,
  78537,
  27689,
  36431,
  44415,
  14362,
  19456,
  106025,
  96308,
  2882,
  49509,
  21149,
  87173,
  131409,
  75844,
  23676,
  121838,
  30291,
  17492,
  2953,
  7564,
  110620,
  129477,
  127283,
  53113,
  72417,
  165166,
  109690,
  21200,
  102125,
  24049,
  71504,
  90342,
  25307,
  72039,
  26812,
  26715,
  32264,
  133800,
  71161,
  88956,
  171987,
  51779,
  24425,
  16671,
  30251,
  186294,
  247761,
  14202,
  2121,
  8465,
  35024,
  4876,
  85917,
  169730,
  3638,
  256836,
  96184,
  943,
  18678,
  6583,
  52907,
  35807,
  112254,
  214097,
  18796,
  11595,
  9243,
  23554,
  887,
  268203,
  382004,
  24590,
  111335,
  11625,
  16619,
  29039,
  102425,
  69006,
  97976,
  92362,
  32552,
  63717,
  41433,
  128974,
  137630,
  59943,
  10019,
  13986,
  35430,
  33665,
  108037,
  43799,
  43280,
  38195,
  29078,
  58629,
  18265,
  14425,
  46832,
  235538,
  40830,
  77881,
  110717,
  58937,
  3463,
  325358,
  51300,
  47623,
  117252,
  19007,
  10170,
  20540,
  91237,
  294813,
  4951,
  79841,
  56232,
  36270,
  128547,
  69209,
  66275,
  100156,
  32063,
  73531,
  34439,
  80937,
  28892,
  44466,
  88595,
  216307,
  32583,
  49620,
  16605,
  82127,
  45807,
  21630,
  78726,
  20235,
  40163,
  111007,
  96926,
  5567,
  72083,
  21665,
  58844,
  39419,
  179767,
  48328,
  42662,
  51550,
  5251,
  37811,
  49608,
  81056,
  50854,
  55513,
  20922,
  18891,
  197409,
  164656,
  32593,
  71449,
  220474,
  58919,
  85682,
  67854,
  13758,
  35066,
  3565,
  61905,
  214793,
  119572,
  141419,
  21504,
  10302,
  27354,
  67003,
  46131,
  32668,
  15165,
  64871,
  34450,
  17821,
  2757,
  11452,
  34189,
  5160,
  12257,
  85523,
  560,
  53385,
  65887,
  119549,
  135620,
  312353,
  115979,
  122356,
  10867,
  193231,
  124537,
  54783,
  90675,
  120791,
  4715,
  142253,
  50943,
  17271,
  43358,
  25331,
  4917,
  120566,
  34580,
  12878,
  33786,
  160528,
  32523,
  4869,
  301307,
  104817,
  81491,
  23276,
  8832,
  97911,
  31265,
  52065,
  7998,
  49622,
  9715,
  43998,
  34091,
  84587,
  20664,
  69041,
  29419,
  53205,
  10838,
  58288,
  116145,
  6185,
  5154,
  141795,
  35924,
  21307,
  144738,
  43730,
  12085,
  8279,
  10002,
  119,
  133779,
  199668,
  72938,
  31768,
  39176,
  67875,
  38453,
  9700,
  44144,
  4121,
  116048,
  41733,
  12868,
  82669,
  92308,
  128,
  34262,
  11332,
  7712,
  90764,
  36141,
  13553,
  71312,
  77470,
  117314,
  96549,
  49135,
  23602,
  54468,
  28605,
  6327,
  62308,
  17171,
  67531,
  21319,
  14105,
  894,
  107722,
  46157,
  8503,
  51069,
  100472,
  45138,
  15246,
  14577,
  35609,
  191464,
  1757,
  13364,
  161349,
  32067,
  91705,
  81144,
  52339,
  5408,
  91066,
  21983,
  14157,
  100545,
  4372,
  26630,
  129112,
  1423,
  29676,
  213626,
  4397,
  88436,
  99190,
  6877,
  49958,
  26122,
  114348,
  60661,
  29818,
  293118,
  50042,
  179738,
  16400,
  163423,
  89627,
  31040,
  43973,
  36638,
  45952,
  5153,
  1894,
  109322,
  1898,
  134021,
  12402,
  112077,
  68309,
  190269,
  69866,
  31938,
  107383,
  11522,
  105232,
  11248,
  14868,
  39852,
  71707,
  186525,
  16530,
  38162,
  106212,
  11700,
  5130,
  16608,
  26998,
  59586,
  108399,
  230033,
  43683,
  48135,
  82179,
  2073,
  5015,
  196684,
  189293,
  16378,
  23452,
  8301,
  35640,
  11632,
  214551,
  29240,
  57644,
  33137,
  91949,
  55157,
  52384,
  117313,
  5090,
  17717,
  89668,
  49363,
  82238,
  241035,
  66216,
  29066,
  184088,
  97206,
  62820,
  26595,
  4241,
  135635,
  173672,
  8202,
  459,
  71355,
  146294,
  29587,
  3008,
  135385,
  141203,
  14803,
  6634,
  45094,
  69362,
  50925,
  546,
  51884,
  62011,
  83296,
  234584,
  44515,
  56050,
  89476,
  87751,
  19373,
  12691,
  149923,
  19794,
  13833,
  35846,
  87557,
  58339,
  2884,
  19145,
  25647,
  12224,
  11024,
  77338,
  64608,
  122297,
  53025,
  7205,
  36189,
  36294,
  170779,
  21750,
  7739,
  173883,
  75192,
  35664,
  224240,
  113121,
  30181,
  26267,
  27036,
  117827,
  92015,
  106516,
  55628,
  203549,
  67949,
  60462,
  60844,
  35911,
  20457,
  1820,
  920,
  19773,
  8738,
  73173,
  181993,
  38521,
  98254,
  76257,
  46008,
  92796,
  5384,
  26868,
  151566,
  22124,
  2411,
  15919,
  186872,
  180021,
  28099,
  152961,
  78811,
  80237,
  62352,
  102653,
  74259,
  184890,
  16792,
  123702,
  224945,
  29940,
  19512,
  75283,
  14059,
  112691,
  92811,
  233329,
  20411,
  138569,
  53341,
  109802,
  50600,
  134528,
  66747,
  5529,
  166531,
  31578,
  64732,
  67189,
  1596,
  126357,
  967,
  167999,
  206598,
  109752,
  119431,
  207825,
  78791,
  91938,
  10301,
  27311,
  24233,
  252343,
  28831,
  32812,
  66002,
  112267,
  90895,
  8786,
  8095,
  16824,
  22866,
  21813,
  60507,
  174833,
  19549,
  130985,
  117051,
  52110,
  6938,
  81923,
  123864,
  38061,
  919,
  18680,
  53534,
  46739,
  112893,
  161529,
  85429,
  26761,
  11900,
  81121,
  91968,
  15390,
  217947,
  56524,
  1713,
  6654,
  37089,
  85630,
  138866,
  61850,
  16491,
  75577,
  16884,
  98296,
  73523,
  6140,
  44645,
  6062,
  36366,
  29844,
  57946,
  37932,
  42472,
  5266,
  20834,
  19309,
  33753,
  127182,
  134259,
  35810,
  41805,
  45878,
  312001,
  14881,
  47757,
  49251,
  120050,
  44252,
  3708,
  25856,
  107864,
  120347,
  1228,
  36550,
  41682,
  34496,
  47025,
  8393,
  173365,
  246526,
  12894,
  161607,
  35670,
  90785,
  126572,
  2095,
  124731,
  157033,
  58694,
  554,
  12786,
  9642,
  4817,
  16136,
  47864,
  174698,
  66992,
  4639,
  69284,
  10625,
  40710,
  27763,
  51738,
  30404,
  264105,
  137904,
  109882,
  52487,
  42824,
  57514,
  2740,
  10479,
  146799,
  107390,
  16586,
  88038,
  174951,
  9410,
  16185,
  44158,
  5568,
  40658,
  46108,
  12763,
  97385,
  26175,
  108859,
  664,
  230732,
  67470,
  46663,
  14395,
  50750,
  141320,
  93140,
  15361,
  47997,
  55784,
  6791,
  307840,
  118569,
  107326,
  18056,
  58281,
  260415,
  54691,
  8790,
  73332,
  45633,
  7511,
  45674,
  143373,
  14031,
  11799,
  94491,
  35646,
  96544,
  14560,
  26049,
  32983,
  25791,
  83814,
  42094,
  231370,
  63955,
  139212,
  2359,
  169908,
  3108,
  183486,
  105867,
  28197,
  32941,
  124968,
  26402,
  88267,
  149768,
  23053,
  3078,
  19091,
  52924,
  25383,
  19209,
  111548,
  97361,
  3959,
  24880,
  235061,
  9099,
  24921,
  161254,
  151405,
  20508,
  7159,
  34381,
  20133,
  11434,
  74036,
  19974,
  34769,
  36585,
  1076,
  22454,
  17354,
  38727,
  235160,
  111547,
  96454,
  117448,
  156940,
  91330,
  37299,
  7310,
  26915,
  117060,
  51369,
  22620,
  61861,
  322264,
  106850,
  111694,
  15091,
  2624,
  40345,
  300446,
  177064,
  1707,
  27389,
  54792,
  327783,
  132669,
  183543,
  59003,
  17744,
  20603,
  151134,
  106923,
  53084,
  71803,
  279424,
  319816,
  11579,
  21946,
  16728,
  38274,
  72711,
  5085,
  83391,
  88646,
  40159,
  25027,
  34680,
  10752,
  12988,
  54126,
  30365,
  18338,
  100445,
  230674,
  44874,
  84974,
  143877,
  123253,
  139372,
  28082,
  91477,
  144002,
  13096,
  219729,
  46016,
  50029,
  42377,
  14601,
  6660,
  58244,
  58978,
  23918,
  88206,
  113611,
  64452,
  17541,
  41032,
  10942,
  12021,
  49189,
  10978,
  40175,
  37156,
  10947,
  71709,
  106894,
  112538,
  57007,
  137486,
  150608,
  152719,
  40615,
  7746,
  279716,
  13101,
  19524,
  28708,
  40578,
  72320,
  1096,
  182051,
  94527,
  51275,
  22833,
  45164,
  81917,
  77519,
  48508,
  5421,
  140302,
  37845,
  149830,
  5587,
  27579,
  5357,
  428725,
  248187,
  6326,
  206760,
  39814,
  32585,
  89923,
  44341,
  288753,
  284443,
  96368,
  31201,
  94189,
  119504,
  20359,
  52073,
  103216,
  179,
  27934,
  32801,
  96035,
  34111,
  34309,
  101326,
  18198,
  20704,
  210266,
  37643,
  27880,
  141873,
  106e3,
  19414,
  56614,
  167714,
  66483,
  107885,
  86602,
  4379,
  20796,
  75467,
  4987,
  5017,
  118857,
  26003,
  34308,
  114428,
  29198,
  6686,
  29697,
  73632,
  3739,
  69795,
  16798,
  41504,
  7207,
  30722,
  21436,
  36735,
  28067,
  28545,
  3239,
  11221,
  36031,
  41889,
  100010,
  19247,
  317673,
  29495,
  174554,
  6424,
  129725,
  53845,
  94986,
  7955,
  59676,
  2604,
  191497,
  19735,
  102214,
  62954,
  23844,
  11872,
  179525,
  261436,
  34492,
  428,
  78404,
  142035,
  16747,
  17246,
  27578,
  37021,
  33672,
  57944,
  26056,
  135760,
  2369,
  61674,
  122066,
  31327,
  19374,
  157065,
  40553,
  130982,
  69619,
  71290,
  38855,
  72100,
  92903,
  95940,
  51422,
  165999,
  65713,
  57873,
  50726,
  7288,
  20272,
  2081,
  42326,
  22624,
  81120,
  57914,
  79352,
  19447,
  1684,
  72302,
  11774,
  302559,
  161481,
  96396,
  13692,
  414988,
  3721,
  79066,
  56627,
  46883,
  21150,
  11747,
  12184,
  5856,
  113458,
  176117,
  84416,
  52079,
  27933,
  3354,
  59765,
  141359,
  2212,
  216309,
  2555,
  23458,
  196722,
  142463,
  45701,
  44548,
  28798,
  19418,
  215,
  29916,
  9396,
  10574,
  114226,
  84475,
  13520,
  18694,
  34056,
  4524,
  90302,
  62930,
  13539,
  19407,
  77209,
  7728,
  38088,
  9535,
  2263,
  23875,
  183945,
  17750,
  26274,
  67172,
  10585,
  28042,
  22199,
  7478,
  51331,
  66030,
  26774,
  192929,
  31434,
  25850,
  50197,
  52926,
  178158,
  4679,
  181256,
  70184,
  229600,
  9959,
  105594,
  72158,
  73974,
  2726,
  35085,
  78087,
  23284,
  35568,
  51713,
  155676,
  5401,
  27254,
  11966,
  17569,
  223253,
  71993,
  103357,
  111477,
  55722,
  30504,
  26034,
  46774,
  35392,
  36285,
  214814,
  41143,
  163465,
  1051,
  16094,
  81044,
  6636,
  76489,
  179102,
  20712,
  39178,
  35683,
  125177,
  54219,
  30617,
  52994,
  25324,
  50123,
  2543,
  87529,
  58995,
  10688,
  125199,
  12388,
  60158,
  125481,
  131646,
  7642,
  133350,
  65874,
  3438,
  97277,
  101450,
  10075,
  56344,
  116821,
  50778,
  60547,
  98016,
  106135,
  13859,
  14255,
  16300,
  77373,
  173521,
  8285,
  45932,
  37426,
  4054,
  114295,
  55947,
  7703,
  39114,
  52,
  51119,
  128135,
  19714,
  60715,
  9554,
  50492,
  88180,
  2823,
  118271,
  52993,
  122625,
  97919,
  23859,
  37895,
  25040,
  33614,
  32102,
  20431,
  3577,
  9275,
  15686,
  43031,
  157741,
  110358,
  1884,
  40291,
  125391,
  13736,
  5008,
  64881,
  87336,
  77381,
  70711,
  43032,
  49155,
  118587,
  70494,
  4318,
  10168,
  30126,
  12580,
  10524,
  280104,
  104001,
  145413,
  2862,
  84140,
  6603,
  106005,
  13566,
  12780,
  11251,
  42830,
  571,
  179910,
  82443,
  13146,
  469,
  42714,
  32591,
  265217,
  424024,
  92553,
  54721,
  134100,
  6007,
  15242,
  114681,
  59030,
  16718,
  85465,
  200214,
  85982,
  55174,
  165013,
  23493,
  56964,
  82529,
  109150,
  32706,
  27568,
  82442,
  5350,
  14976,
  13165,
  44890,
  60021,
  21343,
  33978,
  17264,
  4655,
  22328,
  27819,
  75730,
  16567,
  55483,
  14510,
  17926,
  45827,
  150609,
  3704,
  7385,
  272531,
  161543,
  76904,
  122163,
  52405,
  2039,
  19165,
  41623,
  14423,
  228354,
  3369,
  176360,
  85491,
  7122,
  35789,
  303724,
  4465,
  13628,
  2233,
  55311,
  118771,
  20713,
  10006,
  221519,
  45115,
  71021,
  35650,
  29775,
  7337,
  10864,
  20665,
  21142,
  1746,
  15080,
  1624,
  32449,
  10905,
  105743,
  229797,
  7701,
  3940,
  22997,
  178467,
  57208,
  389057,
  39683,
  59403,
  63344,
  63125,
  54847,
  69691,
  18336,
  56448,
  3362,
  37202,
  18282,
  29648,
  138224,
  35867,
  10495,
  5911,
  28814,
  26653,
  31514,
  176702,
  26550,
  45621,
  11734,
  4525,
  40543,
  73944,
  121080,
  27858,
  155561,
  14887,
  44670,
  30742,
  8796,
  107455,
  113472,
  56369,
  75581,
  183777,
  240095,
  133699,
  153299,
  8768,
  160464,
  26058,
  49078,
  103971,
  21875,
  71486,
  44888,
  17156,
  9678,
  89541,
  123019,
  102337,
  3972,
  83930,
  21245,
  87852,
  109660,
  287918,
  183019,
  686,
  10100,
  39177,
  283941,
  11274,
  24736,
  26793,
  26214,
  25995,
  77011,
  141580,
  4070,
  23742,
  46285,
  46632,
  30700,
  26669,
  19056,
  35951,
  115575,
  174034,
  56097,
  35463,
  87425,
  24575,
  44245,
  38701,
  82317,
  85922,
  281616,
  100333,
  147697,
  61503,
  7730,
  84330,
  8530,
  59917,
  61597,
  17173,
  9092,
  32658,
  90288,
  193136,
  39023,
  20381,
  56654,
  31132,
  7779,
  1919,
  1375,
  117128,
  30819,
  11169,
  40938,
  23935,
  115201,
  101155,
  151034,
  4835,
  11231,
  74550,
  89388,
  59951,
  91704,
  107312,
  167882,
  115062,
  12732,
  72738,
  88703,
  464019,
  158267,
  57995,
  60496,
  737,
  14371,
  123867,
  4174,
  243339,
  159946,
  7568,
  16025,
  134556,
  110916,
  38103,
  191,
  80226,
  88794,
  29688,
  27230,
  10454,
  76308,
  57647,
  77409,
  113483,
  66864,
  14745,
  19808,
  12023,
  46583,
  84805,
  16015,
  17102,
  2231,
  20611,
  3547,
  95740,
  250131,
  34559,
  108894,
  8498,
  15853,
  159169,
  148920,
  20942,
  2813,
  93160,
  45188,
  210613,
  45531,
  52587,
  149062,
  39782,
  28194,
  57849,
  60965,
  84954,
  89766,
  84453,
  100927,
  16501,
  27658,
  165311,
  103841,
  54192,
  207341,
  19558,
  20084,
  319622,
  5672,
  205467,
  98462,
  61849,
  36279,
  13609,
  147177,
  24726,
  165015,
  209489,
  59591,
  31157,
  6551,
  117580,
  75060,
  141146,
  277310,
  21072,
  22023,
  106474,
  63041,
  137443,
  122965,
  68371,
  5383,
  42146,
  98961,
  113467,
  30863,
  23794,
  4843,
  99630,
  30392,
  82679,
  13699,
  241612,
  33601,
  93146,
  24319,
  18643,
  32155,
  95669,
  40440,
  15333,
  34089,
  67799,
  142144,
  58245,
  38633,
  114531,
  117400,
  77861,
  188726,
  5507,
  2568,
  8853,
  10987,
  107222,
  2663,
  2421,
  11530,
  13345,
  30075,
  41785,
  118661,
  104786,
  17459,
  12490,
  16281,
  71936,
  193555,
  17431,
  5944,
  71758,
  26485,
  77317,
  20803,
  367167,
  158,
  7362,
  93430,
  11735,
  172445,
  46002,
  11532,
  54482,
  930,
  62911,
  2235,
  23004,
  179236,
  4764,
  101859,
  208113,
  22477,
  55163,
  95579,
  14098,
  67320,
  162556,
  90709,
  156949,
  3826,
  57492,
  4025,
  34092,
  87442,
  104565,
  6718,
  186015,
  28214,
  14209,
  10039,
  107186,
  233912,
  58877,
  81637,
  55265,
  39828,
  6194,
  145813,
  50831,
  105849,
  4974,
  88319,
  122296,
  10272,
  197216,
  95714,
  51540,
  72418,
  23324,
  91555,
  8743,
  140452,
  250249,
  51666,
  34124,
  7229,
  38592,
  129641,
  78169,
  174242,
  22464,
  149964,
  51450,
  14034,
  10026,
  95376,
  26190,
  120062,
  14401,
  8700,
  265,
  31386,
  143573,
  7203,
  229889,
  61567,
  4227,
  140981,
  2466,
  72052,
  10787,
  10062,
  30958,
  6099,
  38471,
  30103,
  23202,
  208101,
  70847,
  467,
  58934,
  32271,
  32984,
  36637,
  24107,
  30771,
  17109,
  73353,
  13650,
  2098,
  157040,
  67366,
  66904,
  106018,
  265380,
  107238,
  18535,
  44025,
  32681,
  144983,
  62505,
  91295,
  56120,
  3082,
  77508,
  10322,
  63023,
  36700,
  81885,
  224127,
  16721,
  45023,
  239261,
  111272,
  13852,
  7866,
  149243,
  204199,
  32309,
  22084,
  42029,
  38316,
  126644,
  104973,
  14406,
  43454,
  67322,
  61310,
  15789,
  40285,
  24026,
  181047,
  6301,
  70927,
  23319,
  115823,
  27248,
  66693,
  115875,
  278566,
  63007,
  146844,
  56841,
  59007,
  87368,
  180001,
  22370,
  42114,
  80605,
  12022,
  10374,
  308,
  25079,
  14689,
  12618,
  63368,
  7936,
  264973,
  212291,
  136713,
  95999,
  105801,
  18965,
  32075,
  48700,
  52230,
  35119,
  96912,
  32992,
  8586,
  16606,
  101333,
  101812,
  14969,
  39930,
  759,
  193090,
  27387,
  42914,
  12937,
  5058,
  62646,
  64528,
  38624,
  25743,
  37502,
  3716,
  4435,
  30352,
  178687,
  26461,
  132611,
  42002,
  138442,
  35833,
  59582,
  16345,
  8048,
  60319,
  49349,
  309,
  47800,
  49739,
  90482,
  26405,
  34470,
  63786,
  32479,
  85028,
  39866,
  47846,
  11649,
  23934,
  29466,
  2816,
  42864,
  31828,
  7410,
  74885,
  49632,
  47629,
  111801,
  90749,
  19536,
  18767,
  105764,
  59606,
  21223,
  10746,
  76298,
  22220,
  39408,
  7190,
  79654,
  64856,
  11602,
  82156,
  272765,
  17079,
  70089,
  245473,
  51813,
  184407,
  384678,
  1576,
  122249,
  5064,
  27481,
  6188,
  25790,
  74361,
  27541,
  318284,
  45430,
  31488,
  620,
  93579,
  45723,
  192118,
  22670,
  51913,
  4162,
  70244,
  35966,
  26397,
  16199,
  50899,
  209613,
  121702,
  287507,
  2993,
  36101,
  132229,
  67345,
  33062,
  76295,
  118628,
  78705,
  52316,
  34375,
  107083,
  107454,
  44863,
  127561,
  33964,
  3073,
  154010,
  190914,
  55967,
  39074,
  6272,
  31047,
  5550,
  41123,
  26154,
  98638,
  47110,
  19998,
  148091,
  50229,
  31329,
  59900,
  195442,
  19106,
  61347,
  73497,
  70015,
  682,
  45850,
  25776,
  38022,
  148951,
  6288,
  37411,
  232526,
  109277,
  27286,
  32342,
  9262,
  5220,
  16651,
  23175,
  46740,
  129438,
  78614,
  121925,
  66914,
  88710,
  127952,
  5563,
  21500,
  34521,
  10739,
  14863,
  191006,
  62956,
  17359,
  16749,
  67027,
  56284,
  69134,
  43301,
  35039,
  58883,
  54466,
  60823,
  404451,
  75743,
  59856,
  86979,
  7923,
  34273,
  83785,
  32142,
  7693,
  268986,
  197428,
  282681,
  17049,
  22346,
  22990,
  92245,
  107180,
  3357,
  37104,
  96724,
  49153,
  7683,
  31197,
  43267,
  82231,
  164276,
  23696,
  20848,
  188364,
  22309,
  24821,
  158707,
  1018,
  22514,
  70922,
  27792,
  45589,
  59709,
  10765,
  736,
  35218,
  63479,
  51987,
  24275,
  63588,
  55361,
  92929,
  81964,
  4658,
  20122,
  12330,
  44058,
  13065,
  311456,
  72224,
  8337,
  211229,
  38979,
  22590,
  138478,
  52757,
  32595,
  133600,
  8838,
  31549,
  94412,
  43391,
  90056,
  1585,
  94802,
  127271,
  6223,
  31889,
  137038,
  132910,
  2165,
  57616,
  230152,
  6080,
  10748,
  36737,
  74579,
  134062,
  50525,
  180532,
  119270,
  34556,
  76155,
  82394,
  52595,
  29258,
  31435,
  87820,
  67996,
  26943,
  183878,
  38007,
  2410,
  13526,
  180297,
  69856,
  3503,
  187396,
  167700,
  7838,
  16701,
  9199,
  56267,
  3661,
  37407,
  65994,
  23767,
  5708,
  62508,
  221700,
  67088,
  86978,
  46776,
  84434,
  32088,
  5612,
  9149,
  88244,
  21685,
  95151,
  46750,
  189612,
  2979,
  506311,
  2594,
  3628,
  40074,
  105039,
  78243,
  28523,
  6651,
  38058,
  71999,
  30992,
  12764,
  68261,
  108991,
  6165,
  26450,
  61961,
  13400,
  22426,
  7490,
  60890,
  109623,
  2070,
  12958,
  50355,
  67979,
  257096,
  7213,
  42578,
  52121,
  35716,
  65461,
  7516,
  124758,
  39268,
  302,
  64712,
  14977,
  1467,
  219452,
  2840,
  34229,
  11121,
  21602,
  19270,
  63574,
  8024,
  1532,
  17331,
  79839,
  78885,
  52029,
  180767,
  57957,
  6069,
  91265,
  61380,
  55767,
  8927,
  32881,
  287603,
  22149,
  35029,
  68876,
  6428,
  199567,
  46926,
  13412,
  104132,
  21434,
  366616,
  45060,
  110046,
  81924,
  128910,
  45886,
  52821,
  130416,
  29416,
  77342,
  21762,
  67329,
  121432,
  79924,
  11724,
  38625,
  81006,
  102033,
  28338,
  13326,
  3250,
  82056,
  82526,
  38212,
  21112,
  12382,
  111495,
  3263,
  7414,
  86274,
  93490,
  40844,
  30224,
  45212,
  24019,
  48411,
  71367,
  24941,
  76729,
  57776,
  3769,
  38114,
  202019,
  197745,
  31953,
  237533,
  33270,
  201580,
  255648,
  100798,
  44741,
  32241,
  98468,
  106931,
  10085,
  15090,
  170358,
  33154,
  66787,
  18819,
  69760,
  25061,
  234005,
  82660,
  6295,
  131975,
  16874,
  9076,
  4094,
  25005,
  17740,
  40908,
  19533,
  220019,
  44330,
  99792,
  50040,
  19619,
  13950,
  55228,
  24423,
  31253,
  95308,
  103177,
  184795,
  28590,
  82285,
  5059,
  3210,
  75525,
  49894,
  70007,
  56178,
  10580,
  36051,
  139681,
  21617,
  98736,
  3555,
  106306,
  164189,
  37352,
  63915,
  47824,
  24883,
  145530,
  61904,
  28444,
  11483,
  19837,
  145446,
  30420,
  112972,
  85939,
  11835,
  191233,
  2262,
  20705,
  58630,
  1753,
  148334,
  1197,
  144714,
  6887,
  11223,
  107667,
  60879,
  77914,
  4151,
  57417,
  81594,
  96681,
  169430,
  1784,
  20444,
  95138,
  254041,
  27038,
  596,
  7117,
  72808,
  13759,
  3353,
  126776,
  21074,
  55322,
  27081,
  36942,
  39547,
  139830,
  179275,
  4453,
  713,
  8722,
  71399,
  19204,
  25785,
  22794,
  23923,
  104114,
  11291,
  25458,
  102309,
  88396,
  75288,
  230440,
  206396,
  104551,
  58447,
  130857,
  37247,
  94734,
  31548,
  176529,
  226077,
  65159,
  20104,
  10096,
  66881,
  94191,
  237909,
  27109,
  37404,
  1520,
  27421,
  25220,
  113003,
  23423,
  24884,
  50585,
  6286,
  231877,
  150800,
  11789,
  3226,
  90004,
  60642,
  5053,
  202400,
  61442,
  132531,
  175329,
  57138,
  30116,
  103847,
  9973,
  75367,
  16452,
  32360,
  59119,
  21246,
  10191,
  164804,
  23305,
  61051,
  37348,
  154530,
  13214,
  5468,
  50403,
  66754,
  130976,
  50559,
  80515,
  14436,
  155492,
  84017,
  5472,
  43107,
  41240,
  2890,
  90431,
  70188,
  382,
  76234,
  48040,
  50211,
  281038,
  237007,
  32115,
  142178,
  1536,
  22761,
  96429,
  1811,
  31243,
  1679,
  49143,
  55209,
  17402,
  235054,
  61494,
  7462,
  77030,
  34925,
  87609,
  78002,
  9499,
  9027,
  73289,
  201078,
  101379,
  63544,
  27666,
  5469,
  10642,
  30029,
  49816,
  132979,
  95620,
  58086,
  351930,
  116300,
  2110,
  2043,
  30845,
  6154,
  11279,
  16727,
  4122,
  2277,
  27281,
  4971,
  3650,
  39060,
  61970,
  65951,
  39674,
  75686,
  38151,
  11370,
  130809,
  177895,
  32665,
  63725,
  122267,
  7857,
  39618,
  118483,
  44792,
  157755,
  178624,
  136994,
  24260,
  41308,
  22471,
  12404,
  21707,
  12486,
  30473,
  52781,
  50246,
  20247,
  39065,
  909,
  56825,
  103158,
  128603,
  31542,
  1089,
  41935,
  32744,
  12428,
  37963,
  84420,
  33134,
  72921,
  208449,
  42622,
  168151,
  127335,
  147107,
  46699,
  38216,
  12591,
  94342,
  85814,
  31423,
  24944,
  2605,
  87542,
  67473,
  192551,
  4496,
  56321,
  91819,
  17630,
  6300,
  256183,
  114569,
  202090,
  33209,
  35289,
  34897,
  24967,
  40520,
  43470,
  5344,
  10199,
  34810,
  14283,
  10381,
  10017,
  62923,
  49924,
  23233,
  64539,
  13051,
  35686,
  19698,
  11570,
  135555,
  120868,
  44924,
  87065,
  52318,
  52335,
  47586,
  140906,
  245885,
  109834,
  78668,
  9065,
  46990,
  25258,
  72022,
  61243,
  40838,
  4545,
  146387,
  10537,
  11557,
  17470,
  36930,
  68104,
  46711,
  24264,
  79401,
  81043,
  18225,
  120488,
  24746,
  84338,
  81652,
  28266,
  13776,
  21878,
  46973,
  1047,
  230465,
  73357,
  95777,
  24973,
  210160,
  62210,
  58404,
  110633,
  169651,
  6937,
  41870,
  9909,
  26822,
  191062,
  76553,
  27519,
  96256,
  239070,
  2478,
  205678,
  67955,
  58532,
  20601,
  50120,
  19148,
  78501,
  195724,
  110740,
  8249,
  109665,
  27446,
  30568,
  57631,
  31425,
  49752,
  32820,
  65504,
  50079,
  3663,
  102256,
  219898,
  23849,
  211315,
  14645,
  4359,
  91767,
  9528,
  12449,
  49366,
  7941,
  49763,
  107848,
  8930,
  27086,
  50686,
  9744,
  10447,
  81935,
  39513,
  46514,
  1670,
  29229,
  6172,
  22312,
  137280,
  97759,
  9806,
  14445,
  22976,
  56458,
  73391,
  34983,
  93760,
  174219,
  52573,
  33149,
  59747,
  2429,
  136277,
  75123,
  165263,
  91040,
  7446,
  57632,
  48633,
  97140,
  246081,
  84766,
  151684,
  79918,
  93268,
  120346,
  54059,
  54875,
  77858,
  32996,
  103590,
  45276,
  11968,
  19600,
  25849,
  17159,
  132907,
  42828,
  16817,
  4913,
  99462,
  103303,
  27395,
  5737,
  74184,
  20749,
  21160,
  14377,
  77062,
  131403,
  158735,
  10999,
  27799,
  77785,
  9320,
  34366,
  51593,
  61070,
  33746,
  47048,
  29268,
  36675,
  30262,
  53297,
  9832,
  82e3,
  20188,
  122292,
  39917,
  7331,
  18160,
  68301,
  185935,
  134830,
  15031,
  4935,
  10004,
  165845,
  185534,
  46923,
  30109,
  44134,
  122631,
  18874,
  22903,
  112790,
  26561,
  18549,
  348902,
  82871,
  140345,
  255565,
  135390,
  63556,
  103747,
  145055,
  179600,
  145662,
  296111,
  61661,
  211987,
  23952,
  52342,
  126343,
  48450,
  32919,
  44277,
  82185,
  9591,
  62139,
  205363,
  376969,
  394874,
  108461,
  18040,
  120885,
  14798,
  39863,
  16571,
  16794,
  58271,
  81025,
  55206,
  14640,
  118656,
  6361,
  44092,
  85970,
  6262,
  153863,
  108244,
  180200,
  72264,
  79947,
  38044,
  10050,
  5735,
  61221,
  80712,
  5471,
  115689,
  11391,
  11661,
  184257,
  20010,
  60116,
  30320,
  19327,
  134598,
  45455,
  27542,
  18004,
  125092,
  452272,
  1549,
  91523,
  46567,
  180063,
  156026,
  2608,
  11174,
  58848,
  37788,
  65907,
  80194,
  30490,
  5786,
  40775,
  119519,
  106241,
  11323,
  156297,
  8425,
  61495,
  2617,
  29675,
  2425,
  59886,
  112582,
  49142,
  59618,
  4863,
  50597,
  86710,
  50650,
  168632,
  27693,
  85641,
  83643,
  18993,
  25768,
  84284,
  28090,
  93592,
  36627,
  312804,
  43381,
  9887,
  9402,
  100931,
  97165,
  3311,
  173330,
  66805,
  28935,
  4963,
  184460,
  3201,
  78102,
  19126,
  21607,
  37496,
  24938,
  22615,
  16153,
  32862,
  134792,
  153318,
  61120,
  6067,
  2812,
  12826,
  12792,
  23825,
  37559,
  64662,
  202250,
  102694,
  155488,
  85881,
  149193,
  46233,
  65383,
  15521,
  106982,
  11358,
  176786,
  25752,
  39717,
  34208,
  24510,
  32464,
  77742,
  39371,
  72028,
  138229,
  60688,
  71386,
  102834,
  132477,
  2208,
  11548,
  63670,
  271279,
  28351,
  30338,
  38620,
  32491,
  99845,
  143885,
  152266,
  13252,
  2825,
  178663,
  108097,
  1775,
  78201,
  14897,
  113573,
  163346,
  62292,
  171129,
  22183,
  96598,
  38733,
  64971,
  166776,
  117445,
  9968,
  146393,
  44677,
  74867,
  20908,
  97328,
  12761,
  25656,
  26785,
  9148,
  112344,
  26115,
  99176,
  110121,
  22437,
  49547,
  6180,
  79320,
  5835,
  31392,
  43328,
  33377,
  75870,
  119860,
  69497,
  80273,
  7325,
  155219,
  43167,
  111173,
  28347,
  20222,
  3763,
  71752,
  55041,
  47252,
  14618,
  28088,
  15012,
  97805,
  194698,
  54636,
  2036,
  41349,
  6173,
  96604,
  61530,
  51859,
  43782,
  13361,
  24334,
  22668,
  24792,
  7070,
  23441,
  16789,
  3209,
  36211,
  208475,
  26242,
  32880,
  122181,
  182407,
  21444,
  31060,
  88459,
  29929,
  77907,
  12716,
  10934,
  97005,
  20599,
  31690,
  8403,
  58445,
  30303,
  22700,
  10336,
  86731,
  103115,
  337709,
  72556,
  46788,
  112566,
  47684,
  67089,
  53548,
  36874,
  56487,
  41387,
  125985,
  26893,
  40071,
  106683,
  73712,
  18787,
  40105,
  72992,
  67246,
  137276,
  50802,
  36790,
  70328,
  138827,
  22466,
  39263,
  183295,
  29858,
  50975,
  9322,
  57397,
  10654,
  24364,
  30383,
  55799,
  41600,
  23584,
  127295,
  296610,
  129078,
  143558,
  244131,
  86397,
  36049,
  1085,
  80677,
  3820,
  108139,
  5476,
  34767,
  24683,
  7758,
  13060,
  7239,
  131671,
  250593,
  59556,
  103392,
  29810,
  4188,
  252323,
  39404,
  116877,
  7651,
  43600,
  40338,
  13554,
  157253,
  39196,
  25978,
  144387,
  61211,
  234,
  50104,
  6129,
  10449,
  93777,
  9240,
  356378,
  274148,
  4439,
  72970,
  3724,
  147770,
  78680,
  62570,
  115877,
  40027,
  40547,
  36817,
  224392,
  64609,
  34795,
  165027,
  67440,
  2477,
  37206,
  23431,
  50754,
  164797,
  46018,
  94995,
  170982,
  27051,
  7957,
  22767,
  3674,
  27900,
  56419,
  18930,
  60701,
  41302,
  2692,
  84749,
  339721,
  61996,
  111094,
  80221,
  50129,
  1045,
  8153,
  62945,
  19202,
  8250,
  37208,
  37418,
  32560,
  79477,
  41106,
  88569,
  33963,
  36693,
  5892,
  30570,
  1581,
  66471,
  49647,
  11922,
  160717,
  29442,
  5643,
  114865,
  82962,
  95982,
  132098,
  22633,
  22838,
  94726,
  54556,
  28566,
  205039,
  162340,
  33216,
  16849,
  35847,
  221339,
  94851,
  26533,
  71469,
  1805,
  3804,
  12935,
  45483,
  71020,
  36310,
  65381,
  192960,
  34240,
  35165,
  59773,
  1248,
  46954,
  155332,
  96864,
  4246,
  388800,
  16129,
  57133,
  74592,
  44807,
  442014,
  38203,
  42574,
  80818,
  91592,
  26377,
  36424,
  65760,
  977,
  77387,
  22628,
  147610,
  28018,
  30561,
  98454,
  6969,
  119628,
  63648,
  18170,
  36854,
  26601,
  64018,
  22027,
  37279,
  51395,
  152934,
  21153,
  9430,
  58760,
  194742,
  5330,
  55115,
  34158,
  28917,
  174111,
  13171,
  122326,
  1526,
  43896,
  66094,
  25325,
  4234,
  148354,
  11450,
  275,
  18999,
  112191,
  44365,
  22723,
  68409,
  8733,
  57746,
  96565,
  75007,
  14196,
  108844,
  29475,
  88599,
  177563,
  100792,
  106156,
  86323,
  93726,
  14248,
  135341,
  194131,
  40126,
  47099,
  14779,
  8272,
  39597,
  95983,
  171398,
  65882,
  28052,
  10393,
  47213,
  40689,
  22120,
  72212,
  106829,
  34964,
  109146,
  753,
  648,
  21660,
  30047,
  17527,
  181025,
  5619,
  145357,
  4085,
  216883,
  9359,
  186951,
  24779,
  53931,
  24545,
  36197,
  223296,
  62628,
  168101,
  4243,
  107313,
  30321,
  26642,
  13049,
  51059,
  31027,
  107912,
  807,
  73550,
  26551,
  84369,
  122422,
  165872,
  49754,
  74213,
  234264,
  33151,
  52014,
  33100,
  87183,
  22365,
  52500,
  40013,
  23302,
  5652,
  72723,
  21404,
  26107,
  48434,
  587,
  94049,
  168493,
  96418,
  32871,
  70860,
  31709,
  25128,
  443,
  71597,
  166253,
  15670,
  70994,
  26341,
  133675,
  28280,
  75491,
  54756,
  47955,
  56028,
  26182,
  11952,
  113272,
  472197,
  64640,
  110753,
  17919,
  337,
  50642,
  22576,
  142,
  87371,
  53391,
  93210,
  126694,
  15285,
  19642,
  85667,
  14148,
  1506,
  42092,
  52962,
  33243,
  11970,
  20734,
  135843,
  57044,
  58880,
  13002,
  219134,
  22876,
  64754,
  232519,
  4257,
  43120,
  321573,
  24799,
  64526,
  124728,
  52579,
  81472,
  70831,
  276848,
  17403,
  74359,
  23021,
  182101,
  74597,
  23744,
  148267,
  12055,
  7976,
  5349,
  11772,
  67540,
  167347,
  65318,
  18720,
  127832,
  108238,
  22828,
  90233,
  9987,
  259080,
  118185,
  73209,
  79270,
  13775,
  90100,
  137742,
  90799,
  70569,
  15699,
  19961,
  9087,
  67475,
  57872,
  39731,
  8810,
  134897,
  131868,
  146849,
  19898,
  3334,
  2281,
  167061,
  91073,
  60356,
  467742,
  74712,
  188,
  53179,
  137679,
  92769,
  29241,
  9537,
  132595,
  80119,
  1041,
  88962,
  5976,
  40171,
  44911,
  102859,
  139059,
  104558,
  98987,
  47761,
  19272,
  71472,
  113864,
  175377,
  73338,
  10857,
  23402,
  23758,
  1591,
  139864,
  5644,
  4076,
  118760,
  16427,
  134198,
  18853,
  20291,
  100849,
  37423,
  22038,
  36677,
  19071,
  195521,
  57445,
  11069,
  31869,
  55718,
  66882,
  148490,
  44,
  41296,
  75242,
  49704,
  166810,
  9906,
  20943,
  122258,
  49112,
  105667,
  15969,
  10344,
  6408,
  187694,
  21399,
  72742,
  58970,
  14867,
  14376,
  81889,
  41856,
  23225,
  15042,
  56993,
  16074,
  131389,
  74276,
  72407,
  53875,
  383108,
  53597,
  37363,
  68993,
  44854,
  122548,
  430927,
  198279,
  38430,
  80409,
  12245,
  2981,
  628,
  2818,
  17760,
  37437,
  238229,
  7968,
  46892,
  2200,
  3730,
  34190,
  65983,
  37959,
  112291,
  87850,
  70827,
  6522,
  20750,
  73913,
  111621,
  41652,
  19587,
  2780,
  58668,
  25916,
  85259,
  18200,
  168962,
  95781,
  42445,
  102050,
  7776,
  57662,
  103313,
  47742,
  96358,
  41964,
  66174,
  100396,
  29069,
  204735,
  19679,
  27978,
  7479,
  40264,
  22534,
  61183,
  36081,
  107436,
  58223,
  14680,
  23002,
  101311,
  24716,
  124108,
  12908,
  5646,
  31750,
  40380,
  14215,
  232799,
  102772,
  14122,
  96775,
  61398,
  50917,
  12096,
  149880,
  67833,
  598749,
  124194,
  155871,
  49216,
  790,
  14677,
  65319,
  56917,
  7440,
  145744,
  95701,
  12206,
  49405,
  129269,
  76199,
  45732,
  9767,
  11058,
  9047,
  210885,
  11051,
  7392,
  26307,
  2130,
  8132,
  147526,
  20802,
  232698,
  115660,
  50060,
  59789,
  57344,
  107623,
  80343,
  112676,
  23291,
  9866,
  160971,
  34032,
  118291,
  15719,
  59730,
  164911,
  28975,
  2659,
  58046,
  78480,
  21854,
  66209,
  53863,
  109085,
  116045,
  29021,
  46481,
  107552,
  22130,
  18764,
  70254,
  31272,
  11300,
  52460,
  43933,
  84738,
  20721,
  53869,
  190840,
  79673,
  105300,
  7561,
  321817,
  66924,
  13940,
  33281,
  101046,
  183181,
  32176,
  71878,
  5678,
  62924,
  79535,
  56646,
  40303,
  19559,
  27703,
  93042,
  73368,
  42187,
  3670,
  37376,
  46440,
  7023,
  36816,
  109628,
  20680,
  5940,
  276440,
  275233,
  170848,
  112093,
  136996,
  14984,
  20226,
  111441,
  77693,
  112960,
  48577,
  39370,
  55707,
  50314,
  123404,
  26570,
  54281,
  61372,
  123391,
  4857,
  35928,
  246740,
  132507,
  106646,
  44241,
  7196,
  92258,
  9825,
  37688,
  51197,
  303141,
  5590,
  15476,
  132986,
  10955,
  85782,
  34486,
  26696,
  7991,
  28813,
  18858,
  39546,
  11703,
  11365,
  38185,
  5716,
  93555,
  11925,
  40121,
  60002,
  6985,
  10976,
  171384,
  3887,
  43394,
  13337,
  56346,
  6381,
  252336,
  39573,
  75042,
  53711,
  1028,
  31781,
  44295,
  95925,
  131713,
  7214,
  68125,
  43571,
  70954,
  213234,
  1628,
  8760,
  13391,
  65485,
  17320,
  56038,
  1710,
  25248,
  60803,
  57399,
  19839,
  3870,
  326,
  281556,
  50945,
  72400,
  21460,
  316244,
  75619,
  56246,
  98775,
  481,
  13513,
  55765,
  50427,
  7388,
  123519,
  32929,
  57908,
  27124,
  61316,
  101097,
  57467,
  30228,
  48792,
  10788,
  20402,
  37318,
  50526,
  155730,
  34456,
  158065,
  145305,
  17832,
  43733,
  64052,
  4506,
  35072,
  205355,
  177028,
  184004,
  187081,
  68616,
  35938,
  83703,
  10367,
  36892,
  93186,
  260137,
  51934,
  89970,
  4985,
  23445,
  26755,
  21558,
  7948,
  78741,
  23376,
  124405,
  85594,
  68596,
  57536,
  49351,
  12619,
  56593,
  132668,
  99924,
  109728,
  71844,
  71935,
  196018,
  65464,
  17617,
  14987,
  89701,
  143773,
  33997,
  8687,
  22701,
  33258,
  2914,
  4436,
  72108,
  85610,
  9671,
  49067,
  2327,
  82988,
  1361,
  1672,
  44033,
  35777,
  30269,
  24057,
  10605,
  82236,
  616,
  15793,
  13919,
  47249,
  112086,
  116698,
  9484,
  80207,
  90574,
  33304,
  68624,
  93127,
  56101,
  42210,
  160929,
  4827,
  38995,
  38095,
  4701,
  125119,
  5027,
  33680,
  9236,
  231236,
  14135,
  87837,
  23318,
  70261,
  78893,
  30151,
  81482,
  14332,
  1084,
  74256,
  27532,
  46644,
  79185,
  3148,
  62615,
  6981,
  55672,
  31668,
  36825,
  1849,
  14536,
  37446,
  14738,
  23779,
  43058,
  162749,
  72199,
  1168,
  21346,
  5592,
  85932,
  85302,
  9668,
  18351,
  57135,
  150360,
  2080,
  228015,
  77953,
  34670,
  119302,
  151751,
  31009,
  106725,
  84265,
  45214,
  59289,
  74178,
  113071,
  263206,
  111009,
  4021,
  44449,
  188119,
  192629,
  123592,
  392506,
  292847,
  114487,
  12831,
  205858,
  9852,
  20780,
  79648,
  75767,
  357014,
  97721,
  18166,
  21005,
  67950,
  33226,
  204009,
  16536,
  2987,
  11335,
  66717,
  144910,
  47950,
  17262,
  55060,
  15063,
  2934,
  51038,
  26775,
  178497,
  66008,
  3427,
  49433,
  128592,
  20036,
  157553,
  63861,
  3089,
  23015,
  51210,
  28696,
  35933,
  49942,
  71135,
  231518,
  99620,
  17248,
  21835,
  176536,
  20676,
  16944,
  38700,
  165831,
  233253,
  295625,
  36723,
  13023,
  52745,
  10907,
  19423,
  67972,
  125868,
  95473,
  82875,
  1183,
  108455,
  52685,
  33417,
  64095,
  21433,
  52438,
  33191,
  127809,
  44505,
  211823,
  7810,
  2752,
  95548,
  162031,
  7185,
  91196,
  47563,
  61721,
  33359,
  17897,
  23682,
  42806,
  178101,
  22874,
  49707,
  199897,
  75419,
  82456,
  8618,
  11171,
  79712,
  116847,
  18783,
  44190,
  46564,
  5346,
  59046,
  95032,
  7893,
  14916,
  3214,
  26800,
  24172,
  121453,
  34362,
  10250,
  17408,
  18888,
  4840,
  68696,
  22831,
  13162,
  36005,
  32512,
  14800,
  62357,
  41723,
  45046,
  27247,
  37486,
  5372,
  2564,
  34261,
  298500,
  66509,
  133920,
  89138,
  31305,
  117697,
  19097,
  108304,
  81386,
  84106,
  23802,
  46411,
  63304,
  946,
  51417,
  41777,
  41041,
  19501,
  115864,
  60743,
  294354,
  37955,
  94165,
  18116,
  1156,
  17937,
  20645,
  57114,
  90804,
  58042,
  48643,
  92288,
  9861,
  2557,
  88546,
  61333,
  101008,
  12853,
  5148,
  87856,
  4152,
  144503,
  73841,
  18718,
  9789,
  147565,
  10846,
  42085,
  12789,
  30223,
  8993,
  56352,
  67203,
  2448,
  28215,
  6052,
  23540,
  126319,
  75933,
  36689,
  80235,
  23231,
  23561,
  21383,
  38800,
  77548,
  102798,
  21234,
  31468,
  158608,
  46188,
  63960,
  191679,
  8051,
  67014,
  11185,
  170078,
  42186,
  28827,
  34777,
  41930,
  212079,
  12421,
  34750,
  24111,
  110344,
  73918,
  45171,
  70826,
  141949,
  40063,
  23979,
  24254,
  37309,
  26724,
  27179,
  24718,
  83648,
  54938,
  14591,
  17425,
  29525,
  102675,
  48975,
  48654,
  12316,
  8929,
  60640,
  41709,
  50168,
  63264,
  89812,
  50716,
  48632,
  38755,
  138583,
  160123,
  55579,
  71829,
  24230,
  233277,
  46322,
  39650,
  166388,
  34718,
  24108,
  98252,
  7031,
  106695,
  62498,
  18258,
  35062,
  217827,
  78731,
  34824,
  33354,
  19520,
  60852,
  2432,
  60224,
  8587,
  2836,
  62955,
  702,
  20227,
  42285,
  40560,
  95592,
  62486,
  11094,
  53035,
  143291,
  18842,
  46177,
  77994,
  1770,
  9657,
  107422,
  172915,
  32655,
  128716,
  25886,
  25164,
  156740,
  119928,
  165875,
  85817,
  11007,
  89110,
  33956,
  12652,
  65156,
  180266,
  8494,
  36889,
  19958,
  20955,
  96,
  1264,
  118288,
  135769,
  44754,
  86671,
  5632,
  19026,
  168220,
  289120,
  33569,
  93821,
  66144,
  70635,
  7687,
  5642,
  2714,
  55445,
  56636,
  71545,
  184182,
  93133,
  7332,
  37389,
  12643,
  52315,
  22729,
  11014,
  158742,
  17050,
  152889,
  50178,
  34601,
  41945,
  52136,
  9948,
  26914,
  63548,
  95721,
  115951,
  40759,
  8960,
  158258,
  38938,
  49232,
  48325,
  42234,
  81523,
  253019,
  66128,
  40978,
  20048,
  238048,
  38760,
  62928,
  122560,
  118532,
  43687,
  137472,
  163689,
  26680,
  9878,
  17448,
  51035,
  16211,
  60834,
  36749,
  29178,
  14241,
  59868,
  150086,
  2305,
  26477,
  42422,
  34342,
  165341,
  83279,
  33894,
  14257,
  29928,
  12743,
  13957,
  125571,
  89134,
  66712,
  10952,
  16507,
  147839,
  30146,
  7249,
  16565,
  45399,
  39874,
  114565,
  215780,
  31990,
  230881,
  171477,
  102,
  196546,
  44538,
  10880,
  84948,
  281705,
  86651,
  10617,
  31395,
  2342,
  453658,
  43569,
  60561,
  132901,
  21845,
  17727,
  58556,
  258242,
  22262,
  58728,
  4008,
  77997,
  11806,
  37431,
  30599,
  81375,
  109137,
  185787,
  114085,
  217292,
  97453,
  169085,
  30593,
  60212,
  11544,
  102056,
  65580,
  2384,
  91655,
  4855,
  95725,
  7295,
  157994,
  16228,
  20669,
  53276,
  141590,
  105246,
  17334,
  25440,
  76067,
  17967,
  39321,
  38911,
  11362,
  28559,
  63807,
  21627,
  26468,
  85816,
  40120,
  1025,
  15234,
  58319,
  69516,
  66512,
  124548,
  75845,
  78873,
  22137,
  46681,
  51242,
  85683,
  32909,
  76747,
  35555,
  43396,
  101465,
  1765,
  73094,
  1077,
  2962,
  39028,
  66777,
  57831,
  42048,
  15828,
  13962,
  36041,
  63657,
  52412,
  5242,
  58846,
  2141,
  5506,
  219012,
  134451,
  3936,
  182230,
  17558,
  17153,
  152237,
  22621,
  49377,
  170216,
  35257,
  68233,
  65374,
  6510,
  11126,
  212151,
  7184,
  2480,
  22517,
  3437,
  33073,
  30156,
  16557,
  3768,
  55067,
  86829,
  91e3,
  12350,
  148650,
  66017,
  79424,
  70885,
  49066,
  28250,
  21369,
  51213,
  34533,
  11510,
  3258,
  18176,
  18465,
  84413,
  6315,
  36411,
  163765,
  4346,
  356,
  107618,
  598,
  13727,
  285026,
  162695,
  8749,
  14583,
  7132,
  63521,
  184253,
  32378,
  25991,
  5604,
  30961,
  53675,
  4874,
  84693,
  5086,
  34811,
  26978,
  56564,
  7904,
  33519,
  51221,
  113942,
  69253,
  6664,
  125563,
  22055,
  220680,
  102008,
  742,
  51930,
  19494,
  176108,
  44424,
  35123,
  13025,
  75685,
  11759,
  74335,
  22250,
  181453,
  131147,
  16984,
  132115,
  154311,
  11991,
  76452,
  52609,
  85351,
  196,
  30969,
  9198,
  74919,
  2529,
  56838,
  71779,
  29187,
  116304,
  3504,
  62330,
  41190,
  86153,
  28393,
  254926,
  104228,
  105189,
  13264,
  84359,
  3574,
  12415,
  8534,
  57147,
  10175,
  188174,
  59504,
  60932,
  66318,
  16407,
  107921,
  17638,
  99103,
  49278,
  28403,
  39786,
  145865,
  8462,
  3558,
  43406,
  142271,
  29139,
  21989,
  36552,
  93955,
  72365,
  7176,
  13556,
  106185,
  37957,
  321774,
  17782,
  129017,
  51154,
  27938,
  24952,
  1935,
  39366,
  2791,
  33489,
  41582,
  56078,
  24558,
  9311,
  5449,
  218786,
  27808,
  190429,
  68013,
  36020,
  86003,
  29735,
  3404,
  87348,
  119357,
  115714,
  2324,
  86796,
  81973,
  40992,
  43376,
  93621,
  28784,
  16808,
  36367,
  2517,
  2909,
  191926,
  24978,
  55303,
  53308,
  205724,
  60068,
  3098,
  21375,
  64784,
  23949,
  26579,
  63121,
  12319,
  80145,
  39967,
  97861,
  6757,
  70143,
  67642,
  37082,
  34698,
  69140,
  122883,
  46151,
  62187,
  80934,
  429,
  19437,
  135071,
  137885,
  222647,
  13331,
  154065,
  327,
  61778,
  74257,
  40116,
  37493,
  14855,
  85079,
  237641,
  42342,
  102164,
  199965,
  71204,
  4662,
  29368,
  5042,
  113914,
  122214,
  8955,
  13149,
  102503,
  43173,
  5659,
  163787,
  69003,
  307084,
  63392,
  171080,
  21390,
  81918,
  86666,
  36622,
  24126,
  28887,
  5736,
  28054,
  207170,
  163428,
  79891,
  346467,
  95363,
  38980,
  111806,
  80828,
  9200,
  19288,
  294896,
  114468,
  87405,
  111715,
  141705,
  7015,
  72754,
  68463,
  48738,
  243147,
  33397,
  101210,
  37051,
  98801,
  82847,
  20397,
  4940,
  185559,
  18716,
  54718,
  83491,
  11725,
  40803,
  1128,
  12128,
  23060,
  5174,
  7745,
  67007,
  46701,
  1571,
  27807,
  180186,
  256996,
  18975,
  16837,
  7877,
  212758,
  250379,
  15440,
  87954,
  57755,
  24719,
  124057,
  83461,
  258,
  50864,
  8874,
  29038,
  71289,
  31627,
  15429,
  9005,
  4061,
  113851,
  107716,
  82819,
  13651,
  79656,
  117851,
  17539,
  111446,
  12938,
  39724,
  190787,
  4352,
  15402,
  21070,
  62708,
  8539,
  23777,
  73853,
  13552,
  38810,
  86117,
  16285,
  56400,
  1718,
  75342,
  142863,
  29033,
  378,
  110113,
  180321,
  32586,
  23606,
  26393,
  160984,
  207987,
  23783,
  8406,
  16904,
  24596,
  47274,
  11693,
  46539,
  60524,
  78595,
  48423,
  31718,
  20170,
  9009,
  146268,
  15183,
  191060,
  172765,
  1349,
  138436,
  37365,
  10970,
  40509,
  225817,
  20021,
  70394,
  152138,
  21541,
  66559,
  66544,
  89352,
  2725,
  17258,
  91345,
  7313,
  3815,
  115868,
  8660,
  40362,
  4071,
  103524,
  39388,
  118275,
  21950,
  6549,
  38226,
  32754,
  209574,
  29201,
  43495,
  18028,
  20296,
  40597,
  18370,
  47520,
  202450,
  24134,
  2219,
  8195,
  69545,
  38041,
  136934,
  46374,
  19041,
  159811,
  84865,
  58620,
  846,
  98749,
  13569,
  30714,
  97246,
  32186,
  4479,
  27355,
  92973,
  35214,
  151491,
  75963,
  37631,
  1561,
  27200,
  238083,
  23182,
  60756,
  12291,
  25766,
  39355,
  102333,
  87362,
  65741,
  59906,
  19538,
  201575,
  48772,
  102938,
  24438,
  292580,
  39964,
  66366,
  9004,
  61379,
  50548,
  37622,
  38732,
  28379,
  68180,
  76622,
  17488,
  69849,
  5963,
  7219,
  48143,
  43413,
  55358,
  540,
  58691,
  29506,
  19245,
  52193,
  48621,
  5518,
  13048,
  118625,
  44755,
  191081,
  42061,
  89197,
  2259,
  60665,
  66994,
  71210,
  51232,
  3585,
  142096,
  55024,
  7892,
  8345,
  58653,
  463307,
  65658,
  64319,
  137941,
  136323,
  53499,
  12746,
  43492,
  6978,
  95163,
  29925,
  60175,
  5128,
  7352,
  41463,
  184756,
  121146,
  20473,
  18426,
  4598,
  5309,
  54580,
  14277,
  121151,
  10691,
  56711,
  43880,
  63409,
  76682,
  11830,
  172218,
  264898,
  32632,
  66536,
  81062,
  31649,
  25788,
  92774,
  60222,
  11100,
  63159,
  9432,
  224657,
  25240,
  53613,
  152,
  138620,
  163829,
  2397,
  85345,
  12501,
  37507,
  64932,
  38575,
  43522,
  65789,
  80198,
  78796,
  35226,
  3851,
  108891,
  73311,
  3060,
  28391,
  93671,
  39663,
  46142,
  30982,
  66041,
  37281,
  68157,
  26553,
  71872,
  81142,
  211527,
  39747,
  118119,
  22695,
  2859,
  11066,
  20232,
  168911,
  7933,
  197005,
  17066,
  111071,
  44434,
  133994,
  120798,
  12766,
  227798,
  45756,
  132852,
  29917,
  36076,
  55352,
  65281,
  129800,
  41958,
  18944,
  84678,
  18580,
  168093,
  132621,
  39997,
  54092,
  27740,
  32354,
  3770,
  114118,
  103242,
  43918,
  15899,
  18574,
  145944,
  3190,
  123469,
  219903,
  24169,
  100571,
  62403,
  16776,
  92779,
  14535,
  17168,
  16475,
  14304,
  37231,
  1712,
  28218,
  242754,
  61688,
  28980,
  1318,
  51359,
  222657,
  99200,
  67989,
  31772,
  23932,
  35351,
  201251,
  49041,
  27306,
  19128,
  40135,
  3986,
  77333,
  19649,
  120683,
  151927,
  21081,
  7076,
  78375,
  77501,
  101599,
  8011,
  89585,
  96715,
  58179,
  5378,
  102138,
  106793,
  26051,
  217276,
  4197,
  16297,
  27014,
  46721,
  13322,
  22806,
  5278,
  29629,
  70632,
  9647,
  71519,
  58818,
  40603,
  128530,
  8903,
  36770,
  56900,
  31483,
  26935,
  43845,
  34265,
  34920,
  87658,
  6114,
  84767,
  64250,
  47318,
  50720,
  19264,
  162514,
  33357,
  13117,
  6705,
  46696,
  75032,
  71054,
  87004,
  42035,
  69138,
  11903,
  99854,
  102328,
  19611,
  34525,
  69312,
  6431,
  49842,
  101600,
  133178,
  108751,
  41829,
  89939,
  225664,
  48916,
  99556,
  9195,
  130387,
  5960,
  36857,
  116724,
  53518,
  94002,
  39077,
  53996,
  6945,
  22261,
  64291,
  8314,
  152785,
  57588,
  16522,
  9091,
  5048,
  87671,
  35441,
  39509,
  1945,
  12423,
  158923,
  178413,
  37549,
  14095,
  1475,
  73188,
  62878,
  4819,
  24012,
  68534,
  42606,
  4010,
  120809,
  57497,
  59564,
  101758,
  103718,
  32701,
  80116,
  12345,
  95834,
  46918,
  21468,
  53213,
  15665,
  31200,
  3867,
  5140,
  96013,
  250744,
  21016,
  10069,
  13968,
  35449,
  180829,
  27683,
  39704,
  59956,
  22893,
  3115,
  26293,
  32785,
  75934,
  62445,
  141162,
  62720,
  2018,
  83638,
  19949,
  114012,
  95006,
  3330,
  99829,
  130935,
  309272,
  9565,
  55874,
  121727,
  37017,
  23586,
  319858,
  40970,
  27602,
  8625,
  112329,
  61060,
  100088,
  118525,
  25922,
  16232,
  1907,
  60671,
  51583,
  44553,
  80993,
  5262,
  94679,
  8676,
  940,
  20736,
  11823,
  3020,
  16476,
  12340,
  152600,
  97416,
  3703,
  25744,
  66826,
  16245,
  16876,
  46446,
  84798,
  74227,
  176020,
  45192,
  61955,
  75496,
  23946,
  23626,
  40372,
  26036,
  6149,
  11822,
  30582,
  16541,
  41914,
  82385,
  232823,
  40921,
  80773,
  14930,
  3631,
  7517,
  39619,
  4348,
  36180,
  126106,
  138939,
  62611,
  1477,
  113512,
  47321,
  25052,
  14546,
  118881,
  29060,
  23589,
  128322,
  36795,
  18401,
  137921,
  104699,
  267929,
  36194,
  172791,
  18113,
  4766,
  188215,
  30083,
  332586,
  94089,
  5805,
  77909,
  22194,
  68234,
  154976,
  43220,
  40660,
  70001,
  184893,
  138095,
  11128,
  103010,
  22663,
  5108,
  212615,
  8485,
  5565,
  49222,
  54614,
  26530,
  42639,
  16319,
  55062,
  152662,
  105595,
  21114,
  22216,
  10294,
  68158,
  10436,
  86950,
  7206,
  62115,
  3977,
  3657,
  59874,
  456,
  118617,
  18156,
  106663,
  112229,
  80992,
  17442,
  8217,
  55551,
  5133,
  34344,
  251927,
  51153,
  39364,
  201321,
  7816,
  66803,
  23057,
  156724,
  145664,
  14276,
  95705,
  979,
  2796,
  6875,
  13429,
  212525,
  50602,
  26276,
  28284,
  3424,
  19465,
  52397,
  46963,
  31420,
  51399,
  206476,
  92317,
  48851,
  637,
  100820,
  83349,
  10317,
  60227,
  21972,
  6908,
  282439,
  32857,
  224767,
  95629,
  83882,
  42106,
  87338,
  69757,
  29840,
  68709,
  37665,
  45244,
  114577,
  49188,
  175943,
  54009,
  186746,
  106158,
  70168,
  3358,
  234002,
  50555,
  9221,
  129338,
  9562,
  20118,
  32923,
  78479,
  118280,
  65752,
  4977,
  10474,
  102174,
  60947,
  129006,
  10570,
  83451,
  8598,
  8078,
  159367,
  123785,
  80438,
  16742,
  5905,
  5281,
  181513,
  42402,
  6977,
  163136,
  93179,
  42191,
  14968,
  50421,
  112401,
  105440,
  33456,
  57347,
  121611,
  4221,
  94954,
  36517,
  24046,
  27796,
  6255,
  33394,
  72990,
  135408,
  116627,
  1233,
  57874,
  25654,
  95419,
  68156,
  401399,
  313338,
  55208,
  45573,
  93124,
  119251,
  47200,
  38196,
  11909,
  130667,
  45391,
  73904,
  64964,
  167846,
  4137,
  115606,
  52036,
  62214,
  7969,
  160925,
  7187,
  1132,
  134835,
  40309,
  73195,
  64494,
  80472,
  444841,
  61111,
  26500,
  45323,
  40743,
  53625,
  52797,
  22659,
  15631,
  29739,
  36706,
  28841,
  39147,
  102836,
  26794,
  10536,
  14845,
  87305,
  45874,
  12241,
  127587,
  83833,
  57183,
  79722,
  30844,
  41304,
  84655,
  20825,
  92500,
  3722,
  25655,
  27811,
  10157,
  81634,
  31362,
  34088,
  92487,
  70123,
  22190,
  185100,
  72658,
  139035,
  192523,
  88241,
  2078,
  230490,
  44528,
  85638,
  100198,
  22088,
  29982,
  291233,
  241062,
  13865,
  4445,
  137791,
  37835,
  107218,
  31726,
  19718,
  38234,
  72528,
  23046,
  19177,
  66695,
  5109,
  17251,
  28077,
  5617,
  21554,
  47839,
  72425,
  133825,
  1486,
  73065,
  181275,
  141508,
  21768,
  62971,
  63082,
  2512,
  34200,
  9904,
  120309,
  6392,
  91243,
  68416,
  268253,
  41199,
  116757,
  138551,
  185526,
  41246,
  28986,
  4093,
  19057,
  17295,
  4148,
  245766,
  122360,
  35356,
  112075,
  20301,
  75441,
  10998,
  7977,
  19769,
  62922,
  937,
  63547,
  100196,
  26427,
  157820,
  20983,
  236696,
  22935,
  8140,
  90315,
  156004,
  47204,
  140973,
  7726,
  45097,
  52725,
  22636,
  23436,
  257282,
  105247,
  522,
  88389,
  216031,
  202204,
  46812,
  211666,
  19693,
  68828,
  81691,
  45925,
  11256,
  30292,
  372,
  5236,
  167826,
  88328,
  232776,
  151611,
  5360,
  82104,
  18841,
  80393,
  25465,
  18285,
  20320,
  72377,
  31730,
  33160,
  45803,
  38715,
  27705,
  37379,
  24163,
  18360,
  103586,
  4015,
  32305,
  269494,
  91252,
  20080,
  36567,
  54650,
  7797,
  57073,
  12650,
  31164,
  42209,
  6375,
  261663,
  105528,
  81661,
  106002,
  2800,
  5375,
  17247,
  43151,
  4442,
  15727,
  194619,
  100855,
  144898,
  62320,
  78465,
  39929,
  16454,
  1967,
  28311,
  61363,
  17219,
  9395,
  8745,
  121445,
  76939,
  80385,
  162380,
  22009,
  54191,
  44248,
  16299,
  122830,
  48151,
  74429,
  78291,
  64755,
  14238,
  44966,
  2511,
  17712,
  67954,
  93583,
  829,
  105899,
  49935,
  84750,
  11591,
  33185,
  85447,
  42717,
  27409,
  208542,
  28965,
  62052,
  52525,
  5597,
  25694,
  65594,
  16343,
  63224,
  276188,
  12475,
  9331,
  127507,
  38522,
  57287,
  24128,
  133161,
  79723,
  105548,
  133695,
  48917,
  27558,
  43278,
  46520,
  13778,
  141954,
  110785,
  83366,
  17715,
  46317,
  105763,
  66298,
  147013,
  41086,
  94180,
  16478,
  220447,
  44611,
  730,
  19722,
  78975,
  117889,
  125643,
  26254,
  16574,
  18480,
  65006,
  15806,
  38549,
  246418,
  46052,
  36056,
  8440,
  34984,
  30170,
  3163,
  59800,
  4458,
  115442,
  4283,
  41970,
  33507,
  104078,
  1653,
  22,
  121158,
  276486,
  3655,
  6338,
  24048,
  133421,
  23641,
  2161,
  24422,
  36006,
  8086,
  10675,
  181474,
  12307,
  29514,
  59143,
  14729,
  52509,
  87128,
  122470,
  19446,
  80852,
  33314,
  24573,
  119864,
  14237,
  9652,
  57779,
  6612,
  51851,
  15284,
  98871,
  90581,
  124466,
  156831,
  21190,
  22015,
  71380,
  161906,
  87247,
  69201,
  18392,
  17908,
  108470,
  72962,
  40719,
  14338,
  17911,
  95260,
  43339,
  20610,
  78916,
  20710,
  72451,
  11315,
  31448,
  17263,
  58853,
  178878,
  48111,
  116002,
  45497,
  80506,
  82605,
  85880,
  36300,
  121755,
  25215,
  36118,
  301929,
  88728,
  405223,
  276136,
  553,
  34704,
  212438,
  49970,
  78329,
  922,
  20711,
  25036,
  257130,
  38295,
  145369,
  18128,
  15385,
  30829,
  55656,
  48345,
  8012,
  3561,
  28004,
  122041,
  192900,
  58338,
  112508,
  41085,
  29976,
  87040,
  47117,
  23905,
  4336,
  92061,
  138880,
  97407,
  42083,
  172121,
  6256,
  25192,
  172671,
  5,
  93568,
  1420,
  12677,
  31605,
  56743,
  40620,
  6015,
  78415,
  231077,
  31298,
  80026,
  13902,
  19048,
  24924,
  170586,
  32955,
  176119,
  87859,
  36731,
  6773,
  27711,
  24658,
  26475,
  115216,
  133207,
  93250,
  95820,
  88522,
  8317,
  5714,
  124047,
  55219,
  86860,
  19677,
  23961,
  22928,
  162209,
  8904,
  225992,
  359835,
  56084,
  96201,
  29392,
  96558,
  86071,
  93643,
  55114,
  13347,
  8183,
  95129,
  82012,
  2017,
  123336,
  34219,
  115554,
  157159,
  47747,
  101684,
  41008,
  18735,
  193781,
  104151,
  226906,
  7552,
  179874,
  124113,
  31159,
  21162,
  44010,
  14771,
  51268,
  166128,
  31382,
  73124,
  77438,
  92830,
  205709,
  12113,
  1292,
  38937,
  13114,
  1334,
  2118,
  15597,
  69581,
  14449,
  21934,
  76618,
  48728,
  67038,
  14967,
  51495,
  24243,
  87736,
  147249,
  26720,
  11119,
  46063,
  43749,
  5843,
  44147,
  152629,
  133428,
  65703,
  14269,
  45604,
  57982,
  28672,
  55616,
  45957,
  8438,
  95433,
  37698,
  220862,
  132034,
  39456,
  61870,
  4161,
  26501,
  73560,
  56418,
  9845,
  4654,
  20916,
  10456,
  88920,
  119358,
  9015,
  65931,
  96507,
  48029,
  38534,
  21676,
  109081,
  43078,
  34943,
  25089,
  6131,
  28766,
  23665,
  5477,
  10255,
  16695,
  67,
  45778,
  42443,
  42770,
  29534,
  23733,
  100513,
  62617,
  42630,
  48746,
  14191,
  43753,
  50295,
  26007,
  8792,
  57243,
  43119,
  54725,
  164253,
  58250,
  112304,
  131796,
  25165,
  4651,
  3188,
  24831,
  47748,
  3705,
  19540,
  13211,
  102095,
  5593,
  18699,
  23666,
  32005,
  117571,
  33541,
  60584,
  74573,
  86311,
  99443,
  25172,
  27222,
  168938,
  7143,
  11853,
  53560,
  18834,
  19960,
  86522,
  28217,
  53266,
  117700,
  72989,
  34323,
  18721,
  66450,
  34346,
  74056,
  47217,
  202002,
  46269,
  9429,
  68582,
  75458,
  37823,
  82843,
  96652,
  32549,
  145144,
  27958,
  19820,
  158086,
  31955,
  201406,
  135379,
  31207,
  192545,
  12950,
  51704,
  9094,
  248263,
  76147,
  64028,
  110009,
  79407,
  89345,
  99284,
  223492,
  47966,
  26848,
  15359,
  201137,
  2861,
  110507,
  71231,
  72297,
  31851,
  118777,
  71039,
  151051,
  240855,
  16333,
  50766,
  14727,
  7939,
  4149,
  80908,
  418780,
  88378,
  59276,
  1327,
  7284,
  38576,
  79814,
  65820,
  42199,
  84860,
  49574,
  62596,
  12396,
  70598,
  40117,
  8648,
  7994,
  16836,
  7630,
  14047,
  359699,
  106878,
  525,
  29037,
  28064,
  13380,
  11675,
  50669,
  74216,
  103539,
  180314,
  27449,
  56299,
  172344,
  19274,
  7301,
  246099,
  32043,
  19422,
  36506,
  129317,
  6806,
  30140,
  4614,
  46639,
  66926,
  932,
  86600,
  6322,
  27847,
  233103,
  10541,
  39025,
  34887,
  3517,
  12972,
  26220,
  2031,
  66561,
  115015,
  48658,
  47596,
  12714,
  33845,
  3893,
  16165,
  35237,
  89983,
  14769,
  11962,
  147224,
  47018,
  29977,
  27979,
  5552,
  82338,
  86023,
  131368,
  1218,
  24853,
  237840,
  132193,
  15455,
  40873,
  3668,
  65351,
  53388,
  15229,
  59889,
  272245,
  47934,
  11858,
  34347,
  18038,
  90853,
  86981,
  300602,
  19343,
  114181,
  29362,
  84921,
  6095,
  106059,
  79472,
  38015,
  1206,
  48741,
  6208,
  8e4,
  21916,
  17423,
  6002,
  108083,
  24479,
  34931,
  56661,
  9511,
  26995,
  100694,
  163853,
  35997,
  81254,
  58321,
  18919,
  171890,
  86877,
  91341,
  74503,
  70477,
  53412,
  7027,
  59281,
  39892,
  131302,
  5864,
  15947,
  61301,
  67466,
  162369,
  47956,
  27874,
  35624,
  282324,
  21270,
  111847,
  102548,
  41482,
  30955,
  116737,
  28264,
  8592,
  55458,
  22301,
  75090,
  29821,
  30697,
  51709,
  3041,
  19208,
  8038,
  24634,
  30467,
  87509,
  126428,
  19389,
  18814,
  152686,
  20701,
  83474,
  45832,
  80891,
  105808,
  11378,
  153223,
  120770,
  98186,
  150633,
  49838,
  9141,
  12755,
  30962,
  5260,
  74490,
  21256,
  31678,
  65062,
  33326,
  289838,
  187831,
  20595,
  89768,
  2805,
  58535,
  10844,
  70085,
  12090,
  2451,
  138068,
  98544,
  24461,
  4511,
  6754,
  41684,
  28203,
  3383,
  65355,
  82833,
  30161,
  83924,
  234361,
  128424,
  28921,
  222594,
  33975,
  125491,
  34069,
  11508,
  67464,
  144226,
  41850,
  98703,
  34371,
  7901,
  21254,
  38398,
  65651,
  23549,
  53883,
  213340,
  123269,
  12028,
  71764,
  177701,
  28758,
  2623,
  68395,
  11549,
  15232,
  68603,
  9660,
  63116,
  36079,
  57093,
  31198,
  20475,
  48467,
  89984,
  35619,
  186847,
  107469,
  31389,
  43631,
  73867,
  41949,
  68841,
  114250,
  1605,
  30564,
  63403,
  17588,
  27680,
  99533,
  12641,
  70325,
  50428,
  73426,
  78379,
  11855,
  91651,
  72081,
  91720,
  60198,
  15743,
  12065,
  83398,
  140046,
  6761,
  46598,
  45900,
  5068,
  886,
  62448,
  148968,
  37347,
  19405,
  9680,
  15819,
  43496,
  63370,
  75667,
  163700,
  37639,
  3633,
  22774,
  34341,
  183131,
  134335,
  37200,
  23915,
  7054,
  14194,
  12970,
  26438,
  13350,
  285521,
  25594,
  8219,
  104410,
  91039,
  168804,
  138480,
  149734,
  15907,
  33818,
  61132,
  60082,
  4622,
  110187,
  56736,
  13551,
  73571,
  3945,
  73463,
  65498,
  17758,
  263266,
  17593,
  2710,
  27585,
  54469,
  38200,
  45367,
  63754,
  28881,
  3473,
  12791,
  98287,
  31895,
  65787,
  4463,
  94536,
  24951,
  36332,
  59901,
  28803,
  52130,
  86403,
  7668,
  181822,
  74831,
  18977,
  9850,
  177206,
  145485,
  109798,
  7292,
  31421,
  26280,
  77211,
  58511,
  12507,
  127004,
  11113,
  147,
  8729,
  56208,
  43066,
  79926,
  129937,
  31345,
  83947,
  39915,
  46146,
  98763,
  42566,
  1337,
  13192,
  18323,
  105163,
  80570,
  117753,
  16555,
  72883,
  11077,
  159438,
  40764,
  70933,
  83329,
  26066,
  12276,
  72059,
  21655,
  173836,
  126713,
  69454,
  153482,
  91585,
  70644,
  102558,
  110483,
  6764,
  127864,
  190133,
  3961,
  101798,
  20945,
  71138,
  82402,
  90884,
  69669,
  44753,
  923,
  16939,
  59700,
  164258,
  25969,
  27082,
  31399,
  43846,
  6306,
  246093,
  51342,
  6153,
  151581,
  202801,
  182731,
  56475,
  162188,
  89426,
  141356,
  14355,
  121815,
  27536,
  28023,
  65257,
  77523,
  106668,
  127314,
  24947,
  12790,
  38796,
  169698,
  23555,
  10725,
  44573,
  183083,
  42088,
  62716,
  43265,
  105958,
  32050,
  44067,
  50118,
  1668,
  3874,
  6243,
  318411,
  16599,
  1691,
  94999,
  52378,
  28671,
  216728,
  123258,
  2059,
  34969,
  69225,
  5913,
  136280,
  171443,
  141515,
  91662,
  22175,
  135282,
  80020,
  92270,
  1663,
  4808,
  4482,
  3495,
  34691,
  5226,
  109830,
  108512,
  17342,
  107488,
  11606,
  123190,
  100247,
  29666,
  146527,
  113014,
  15794,
  30894,
  13224,
  39585,
  243192,
  22351,
  9903,
  7836,
  47699,
  11078,
  25468,
  122291,
  48821,
  26780,
  122679,
  75521,
  81450,
  630,
  4895,
  92900,
  55074,
  74293,
  17441,
  3563,
  111657,
  103102,
  51613,
  12318,
  52370,
  36191,
  68245,
  34269,
  40445,
  41354,
  122901,
  168604,
  182500,
  62012,
  42557,
  11259,
  24428,
  115113,
  86345,
  12362,
  3909,
  78430,
  86852,
  134602,
  20459,
  47853,
  93879,
  22577,
  7659,
  3688,
  38555,
  13349,
  17381,
  56715,
  91639,
  12493,
  10895,
  92438,
  3142,
  37057,
  28928,
  2004,
  36427,
  32268,
  34222,
  209974,
  10432,
  67436,
  41989,
  173518,
  107930,
  27079,
  62729,
  30908,
  55558,
  5828,
  45031,
  14902,
  53546,
  8204,
  144263,
  60255,
  14520,
  88212,
  86582,
  109589,
  69356,
  8064,
  47449,
  8505,
  66558,
  16886,
  4844,
  52817,
  111260,
  215129,
  12941,
  91118,
  650,
  20770,
  6273,
  73089,
  40618,
  62790,
  2873,
  35002,
  14023,
  97208,
  19386,
  102646,
  36993,
  143736,
  135457,
  35385,
  113601,
  17893,
  32627,
  84439,
  100619,
  56016,
  6581,
  57264,
  172160,
  45452,
  111710,
  203627,
  70131,
  24100,
  322787,
  1996,
  35665,
  70078,
  22358,
  90922,
  83658,
  4097,
  63200,
  58499,
  14542,
  99153,
  52159,
  6615,
  12414,
  63415,
  31986,
  16823,
  1579,
  65405,
  137809,
  8841,
  16898,
  48082,
  259,
  33014,
  42375,
  12260,
  179850,
  73667,
  91389,
  98882,
  29532,
  17311,
  326251,
  41092,
  5928,
  20742,
  44964,
  48019,
  43505,
  9317,
  49265,
  6643,
  192712,
  48424,
  163487,
  19861,
  20113,
  70848,
  31928,
  105333,
  23685,
  78563,
  14638,
  54755,
  7158,
  24142,
  44018,
  20774,
  125255,
  20331,
  24280,
  10163,
  1285,
  2336,
  39851,
  4299,
  117269,
  46714,
  63816,
  87779,
  159624,
  11731,
  9971,
  990,
  137317,
  108831,
  50994,
  74554,
  162680,
  23640,
  131597,
  146962,
  170620,
  34829,
  91205,
  21184,
  1913,
  63616,
  18427,
  93136,
  156592,
  17519,
  67565,
  115882,
  138220,
  78622,
  88535,
  18115,
  2711,
  33554,
  109492,
  54298,
  971,
  24914,
  25863,
  36363,
  45715,
  27099,
  194995,
  14299,
  178181,
  111488,
  72395,
  322385,
  157719,
  130787,
  11897,
  81843,
  83999,
  11369,
  49280,
  118604,
  40922,
  61332,
  110343,
  53407,
  75639,
  40582,
  300440,
  54722,
  25637,
  13694,
  48248,
  48278,
  194521,
  56203,
  52779,
  48783,
  72627,
  10953,
  376,
  16733,
  280238,
  26351,
  230789,
  15132,
  25168,
  137270,
  3588,
  63704,
  73376,
  94031,
  74284,
  19443,
  159557,
  9697,
  39901,
  13351,
  119050,
  15406,
  146455,
  3460,
  29556,
  75195,
  37673,
  102524,
  92329,
  47289,
  98413,
  15311,
  100684,
  56345,
  7116,
  95480,
  11590,
  7200,
  167,
  23610,
  58426,
  17730,
  136656,
  27944,
  53151,
  2701,
  8824,
  103124,
  3017,
  90744,
  113588,
  53216,
  79736,
  65940,
  26931,
  498,
  29568,
  80540,
  143543,
  21292,
  1740,
  59268,
  16561,
  180816,
  42323,
  50174,
  40890,
  52866,
  10703,
  57169,
  4700,
  17191,
  4424,
  93511,
  49698,
  166650,
  26972,
  48631,
  165169,
  82879,
  69326,
  202970,
  4007,
  2376,
  231325,
  139592,
  22119,
  62851,
  37504,
  68816,
  58345,
  67398,
  186643,
  43331,
  277416,
  53749,
  15746,
  23102,
  17432,
  4793,
  151138,
  48822,
  54265,
  48203,
  198688,
  14305,
  54287,
  2291,
  18018,
  113378,
  123260,
  7180,
  97549,
  87027,
  120085,
  2920,
  76080,
  8190,
  102005,
  5641,
  64580,
  14955,
  59802,
  54028,
  58884,
  19367,
  81779,
  412567,
  85957,
  97053,
  103637,
  78871,
  29364,
  27637,
  141728,
  4767,
  30686,
  112738,
  130146,
  42745,
  12730,
  105040,
  14844,
  232,
  210944,
  36581,
  152317,
  135543,
  29744,
  3129,
  55647,
  58149,
  46319,
  27265,
  17499,
  28005,
  59948,
  7170,
  34138,
  5702,
  293047,
  110892,
  408,
  91760,
  218674,
  18469,
  46095,
  81403,
  14389,
  4610,
  35672,
  73060,
  11006,
  74848,
  104820,
  118143,
  190357,
  20043,
  105358,
  141735,
  5115,
  27093,
  45924,
  123073,
  52599,
  29433,
  9616,
  238350,
  78610,
  24851,
  58858,
  26769,
  31969,
  24613,
  18294,
  4982,
  32735,
  39639,
  143563,
  112073,
  202205,
  12567,
  4873,
  88601,
  44897,
  81503,
  101648,
  81362,
  34662,
  85277,
  17574,
  48173,
  21435,
  221188,
  40215,
  39576,
  80786,
  26544,
  64668,
  81841,
  10731,
  37733,
  247986,
  149188,
  127703,
  495,
  18382,
  54388,
  72446,
  43071,
  30974,
  198723,
  89608,
  41360,
  190,
  33045,
  8386,
  31658,
  19992,
  237838,
  119015,
  137622,
  50890,
  100913,
  6460,
  116233,
  267230,
  26621,
  104129,
  65114,
  14190,
  41542,
  14888,
  85962,
  23342,
  23041,
  26453,
  43725,
  71809,
  45186,
  4770,
  46452,
  53894,
  56616,
  221286,
  18973,
  9038,
  109299,
  55365,
  19366,
  26863,
  18808,
  60909,
  69353,
  41738,
  83463,
  12100,
  68561,
  72860,
  3980,
  13796,
  49340,
  12332,
  31311,
  27418,
  4255,
  53430,
  18976,
  45523,
  510,
  14224,
  30477,
  26581,
  4530,
  3651,
  101663,
  139840,
  22709,
  150861,
  31996,
  63923,
  120623,
  262522,
  3076,
  10528,
  2929,
  14672,
  130238,
  18087,
  9816,
  121894,
  100308,
  25085,
  55111,
  14565,
  18952,
  53293,
  2042,
  369988,
  23674,
  61789,
  133529,
  28783,
  108293,
  35477,
  47119,
  36448,
  71049,
  40015,
  33055,
  78598,
  198442,
  1833,
  159937,
  40654,
  77444,
  189245,
  113153,
  8621,
  18599,
  38553,
  35223,
  166072,
  2375,
  11659,
  21786,
  89523,
  6032,
  12116,
  63046,
  159398,
  18454,
  3678,
  32521,
  47626,
  11411,
  103527,
  38896,
  42946,
  15696,
  26370,
  10185,
  8413,
  37080,
  165583,
  4331,
  63555,
  14907,
  72220,
  50056,
  6623,
  62236,
  36565,
  49783,
  10049,
  17503,
  100581,
  55951,
  146244,
  24724,
  9626,
  17969,
  25524,
  109300,
  173965,
  99994,
  101056,
  46459,
  43647,
  53737,
  277968,
  8347,
  123521,
  74858,
  33829,
  44762,
  77574,
  877,
  81377,
  222525,
  123532,
  30602,
  43881,
  53145,
  2973,
  16284,
  81940,
  61281,
  127044,
  63620,
  9875,
  14756,
  114829,
  19032,
  9202,
  52759,
  119141,
  23928,
  120551,
  19607,
  3599,
  33401,
  76821,
  73233,
  117430,
  39968,
  36539,
  7071,
  5446,
  121735,
  194059,
  15206,
  45283,
  6706,
  15603,
  65615,
  1207,
  165723,
  92275,
  34773,
  104447,
  8396,
  32353,
  205240,
  164323,
  13600,
  60555,
  79205,
  25532,
  22907,
  33410,
  57480,
  107111,
  69630,
  32137,
  47832,
  70913,
  33161,
  20321,
  2371,
  117348,
  10714,
  86246,
  1625,
  11763,
  17900,
  268,
  78457,
  99175,
  97940,
  101092,
  86660,
  32221,
  14041,
  128504,
  125080,
  53744,
  124263,
  31017,
  13897,
  403,
  31859,
  21964,
  5633,
  111630,
  5547,
  77329,
  17961,
  18241,
  84995,
  25984,
  12983,
  67491,
  62168,
  47262,
  5241,
  297,
  51191,
  7351,
  8967,
  147212,
  82060,
  16821,
  782,
  11033,
  82431,
  62957,
  5026,
  43459,
  77963,
  203477,
  53528,
  6247,
  191852,
  87774,
  74164,
  215654,
  13467,
  1522,
  219964,
  28589,
  244104,
  16242,
  117821,
  67725,
  72570,
  156792,
  17186,
  15979,
  26990,
  44128,
  193014,
  35276,
  57125,
  16212,
  166451,
  68017,
  6905,
  77608,
  16364,
  53777,
  75921,
  76426,
  37975,
  26203,
  269296,
  64099,
  84122,
  12077,
  38533,
  830,
  4407,
  20139,
  963,
  43028,
  38902,
  42911,
  37503,
  83343,
  85045,
  16979,
  1165,
  60835,
  137387,
  58380,
  86990,
  110066,
  134540,
  56331,
  193845,
  81238,
  17922,
  163093,
  38744,
  110641,
  12502,
  56404,
  34862,
  26865,
  125964,
  12965,
  111648,
  25547,
  7771,
  27196,
  136980,
  9555,
  29551,
  107158,
  57885,
  18831,
  37705,
  35505,
  101742,
  13970,
  102109,
  62548,
  124657,
  23328,
  11124,
  89592,
  146376,
  248050,
  6241,
  22033,
  18337,
  80685,
  29898,
  11908,
  216623,
  67721,
  106162,
  146610,
  21377,
  15085,
  91552,
  42041,
  62560,
  122532,
  125336,
  102365,
  121537,
  142559,
  29693,
  223919,
  11515,
  110495,
  18776,
  22494,
  5895,
  185059,
  103592,
  229351,
  51220,
  100102,
  37027,
  257855,
  29359,
  54123,
  36066,
  106493,
  12244,
  79258,
  32002,
  432,
  56205,
  94836,
  90182,
  6726,
  14762,
  29391,
  48938,
  26864,
  38083,
  60364,
  3310,
  60192,
  14766,
  205567,
  57504,
  110760,
  22649,
  24666,
  46333,
  21517,
  3430,
  13135,
  28873,
  27052,
  158809,
  11597,
  20529,
  6695,
  23138,
  22960,
  37137,
  45574,
  6545,
  305877,
  43423,
  26153,
  24769,
  59844,
  14501,
  10430,
  134352,
  56169,
  13213,
  103432,
  49523,
  35181,
  13435,
  12408,
  129475,
  64620,
  230854,
  77390,
  51990,
  15653,
  83248,
  33466,
  44571,
  117828,
  51481,
  2187,
  10559,
  68019,
  18021,
  54895,
  48247,
  18354,
  33737,
  4554,
  108595,
  37288,
  39767,
  116707,
  9175,
  3726,
  108877,
  21616,
  83684,
  49862,
  1938,
  8543,
  276466,
  20134,
  108498,
  48770,
  102254,
  31914,
  131520,
  185291,
  100559,
  51890,
  209,
  19526,
  76471,
  50544,
  71814,
  99351,
  8172,
  198526,
  28816,
  20419,
  9109,
  98389,
  136777,
  76479,
  75596,
  30635,
  165417,
  48216,
  120220,
  25955,
  211071,
  39314,
  24308,
  32164,
  2559,
  146280,
  43403,
  9233,
  17947,
  90585,
  1786,
  86920,
  125662,
  2457,
  64741,
  32152,
  32918,
  122882,
  78538,
  44001,
  31723,
  56426,
  23375,
  103172,
  88177,
  145697,
  52506,
  49319,
  68016,
  31664,
  41488,
  18486,
  110400,
  7030,
  28241,
  986,
  109199,
  19900,
  42147,
  56864,
  65287,
  49183,
  7858,
  24e3,
  30453,
  840,
  16673,
  25907,
  68916,
  89927,
  6309,
  158335,
  36407,
  199737,
  130464,
  13137,
  59603,
  201778,
  195292,
  21015,
  42466,
  179062,
  172561,
  89492,
  11075,
  180407,
  31868,
  72493,
  20998,
  60217,
  9865,
  19530,
  39274,
  130266,
  54539,
  21623,
  12535,
  13505,
  40641,
  73375,
  4087,
  85633,
  2153,
  3117,
  70680,
  55788,
  92096,
  47509,
  98493,
  37490,
  271936,
  151475,
  3032,
  16171,
  96642,
  34106,
  78425,
  125761,
  19591,
  3366,
  19316,
  54508,
  24183,
  50786,
  194248,
  91528,
  33253,
  34622,
  108355,
  41741,
  705,
  3814,
  3883,
  108929,
  13203,
  67831,
  10142,
  59754,
  68208,
  29128,
  84820,
  56880,
  38794,
  24972,
  48571,
  40821,
  40476,
  18137,
  164254,
  24064,
  236309,
  79181,
  11282,
  395,
  39169,
  2013,
  51587,
  28551,
  9645,
  701,
  109513,
  115899,
  113566,
  12762,
  62045,
  58322,
  103726,
  41343,
  40866,
  244102,
  143816,
  2490,
  70346,
  40973,
  52618,
  15412,
  30720,
  104315,
  38917,
  42027,
  93676,
  17513,
  107418,
  20706,
  123890,
  13399,
  97727,
  24044,
  87962,
  65606,
  44250,
  98044,
  65276,
  74790,
  101473,
  19350,
  91570,
  1326,
  87790,
  172042,
  7577,
  100813,
  86896,
  85891,
  41512,
  108130,
  27794,
  14875,
  71431,
  12835,
  156250,
  58135,
  3759,
  22476,
  42176,
  115873,
  34686,
  56523,
  73643,
  108505,
  51491,
  20838,
  12721,
  32863,
  45700,
  29496,
  13700,
  34294,
  55360,
  29206,
  155942,
  123812,
  7706,
  163234,
  203,
  132720,
  49358,
  144431,
  8130,
  175788,
  35818,
  3270,
  76832,
  25710,
  54095,
  97274,
  28779,
  94621,
  74396,
  19092,
  128242,
  58067,
  20885,
  14670,
  93255,
  15107,
  63291,
  23654,
  126900,
  129421,
  59294,
  262659,
  9798,
  3251,
  67344,
  28600,
  44629,
  50672,
  29072,
  26999,
  31526,
  23183,
  49175,
  165843,
  175455,
  17282,
  175411,
  32022,
  45989,
  30298,
  90690,
  78118,
  83156,
  23749,
  35636,
  31317,
  7069,
  80381,
  94561,
  133756,
  14960,
  97404,
  6138,
  41065,
  78041,
  32843,
  16601,
  34123,
  9559,
  146529,
  123377,
  96395,
  54441,
  42012,
  84257,
  123541,
  10745,
  22139,
  106459,
  11720,
  150883,
  172651,
  154996,
  110538,
  4728,
  53447,
  25704,
  2009,
  71152,
  119354,
  21166,
  66604,
  1429,
  216162,
  8637,
  122250,
  63520,
  27180,
  29172,
  36124,
  276428,
  107787,
  77184,
  4680,
  14952,
  104903,
  24418,
  14793,
  51561,
  52931,
  8371,
  26342,
  48526,
  7118,
  92066,
  67280,
  40653,
  8847,
  34597,
  105438,
  14198,
  50163,
  61188,
  146286,
  50315,
  41205,
  170829,
  161496,
  585,
  197359,
  95056,
  1687,
  365794,
  91349,
  48507,
  5804,
  49263,
  5146,
  104902,
  96365,
  117343,
  132222,
  46084,
  96919,
  16875,
  8073,
  262381,
  79982,
  52663,
  13928,
  16056,
  153908,
  15145,
  109256,
  132308,
  18763,
  24904,
  167644,
  13618,
  40750,
  18686,
  147124,
  114709,
  150038,
  52849,
  2938,
  12568,
  48617,
  8778,
  5459,
  44202,
  44591,
  74914,
  17183,
  248689,
  13878,
  7822,
  80060,
  23116,
  194037,
  18487,
  2067,
  7798,
  43077,
  33678,
  244028,
  31320,
  74273,
  2794,
  19466,
  8218,
  36280,
  183997,
  48124,
  19416,
  29656,
  19280,
  98734,
  7715,
  18311,
  30701,
  133602,
  150307,
  126956,
  7378,
  2933,
  79903,
  13178,
  12593,
  86571,
  26604,
  92446,
  13574,
  44205,
  65699,
  427599,
  21118,
  8245,
  14407,
  27877,
  47936,
  33542,
  7916,
  26460,
  117762,
  21596,
  37818,
  2249,
  127359,
  209394,
  60044,
  47677,
  308089,
  36791,
  154971,
  31417,
  6998,
  150042,
  174360,
  12255,
  43009,
  29335,
  48739,
  3912,
  101398,
  53340,
  2580,
  146939,
  151295,
  45360,
  125275,
  15273,
  45383,
  27456,
  48761,
  23314,
  8750,
  60801,
  85823,
  104759,
  27894,
  123685,
  66968,
  39480,
  26917,
  55290,
  83305,
  2696,
  98390,
  57569,
  145853,
  340733,
  4919,
  20024,
  52268,
  30884,
  7413,
  203685,
  70989,
  112855,
  4129,
  50536,
  349518,
  68205,
  332641,
  159581,
  135361,
  236026,
  37563,
  176404,
  64899,
  6578,
  122033,
  63871,
  1850,
  85234,
  82089,
  66124,
  74145,
  121098,
  107351,
  12687,
  36881,
  117334,
  13136,
  14698,
  85933,
  93866,
  18047,
  32620,
  310,
  15094,
  46e3,
  88451,
  23632,
  36645,
  27940,
  87618,
  80520,
  58892,
  20976,
  27702,
  140090,
  96075,
  67841,
  103292,
  238964,
  87778,
  107338,
  17019,
  83427,
  67522,
  7302,
  8261,
  47570,
  116787,
  8730,
  80484,
  61772,
  174422,
  56005,
  131193,
  52875,
  14588,
  28471,
  59817,
  9586,
  15720,
  158155,
  51307,
  109734,
  15196,
  11025,
  59331,
  3884,
  52626,
  102602,
  84797,
  25158,
  27314,
  4437,
  20488,
  76214,
  189248,
  35023,
  114952,
  157376,
  2827,
  62439,
  102878,
  129749,
  36405,
  10329,
  109339,
  108633,
  36662,
  1254,
  13267,
  5470,
  87105,
  58004,
  15397,
  10434,
  159667,
  21864,
  52022,
  179464,
  3013,
  32147,
  31496,
  116832,
  18494,
  105502,
  129227,
  107267,
  50033,
  13481,
  9954,
  24267,
  22141,
  16257,
  116154,
  36185,
  950,
  115685,
  11305,
  176708,
  2048,
  178671,
  112573,
  287867,
  162328,
  497663,
  95170,
  50979,
  193861,
  50987,
  30368,
  136257,
  31830,
  46549,
  15119,
  169876,
  23788,
  17462,
  249887,
  57377,
  1949,
  35448,
  14791,
  43769,
  210091,
  3783,
  34612,
  282103,
  88380,
  245190,
  5457,
  20491,
  98908,
  11402,
  86899,
  117916,
  16028,
  162584,
  60644,
  320177,
  156096,
  31065,
  55876,
  22e3,
  77655,
  9992,
  23397,
  13757,
  317623,
  63978,
  215255,
  2443,
  17648,
  93231,
  27388,
  104529,
  93807,
  55505,
  140477,
  12046,
  112040,
  70887,
  40152,
  94365,
  112353,
  25063,
  114679,
  266061,
  71248,
  119555,
  15589,
  2244,
  617,
  14129,
  211431,
  70110,
  100652,
  7777,
  4383,
  85911,
  89221,
  21010,
  120615,
  58357,
  86405,
  37554,
  41647,
  18,
  15143,
  69662,
  60491,
  14714,
  186134,
  148344,
  42347,
  5410,
  168175,
  44535,
  42449,
  343894,
  129417,
  99682,
  20659,
  27272,
  140483,
  63455,
  222159,
  17536,
  13722,
  42637,
  62324,
  11976,
  114691,
  148109,
  2283,
  32057,
  182393,
  4295,
  147364,
  33705,
  2075,
  44303,
  30274,
  28331,
  63740,
  69740,
  29148,
  10346,
  44862,
  33716,
  73937,
  153333,
  12930,
  38784,
  247159,
  2515,
  41053,
  20256,
  83368,
  256189,
  54639,
  115240,
  5096,
  24661,
  175419,
  153552,
  26516,
  141,
  138176,
  63885,
  34115,
  47222,
  55709,
  2765,
  28479,
  38875,
  236608,
  12229,
  22921,
  77291,
  54426,
  45388,
  2860,
  57787,
  114579,
  295139,
  105782,
  17826,
  71066,
  19119,
  54364,
  69385,
  16568,
  12323,
  28057,
  33346,
  34919,
  124763,
  155533,
  101386,
  31644,
  8627,
  49001,
  303600,
  29868,
  63213,
  9103,
  77280,
  71333,
  9696,
  138789,
  37059,
  24823,
  5057,
  21352,
  32368,
  114208,
  56803,
  19424,
  10445,
  58514,
  8661,
  209508,
  26187,
  171838,
  10460,
  63454,
  14016,
  122504,
  41328,
  21329,
  46618,
  32493,
  38225,
  7855,
  31763,
  7945,
  29876,
  8734,
  6438,
  24205,
  97490,
  139977,
  130740,
  47323,
  33195,
  85390,
  57194,
  13813,
  60600,
  21313,
  96251,
  7699,
  27584,
  170521,
  139271,
  1363,
  4402,
  336738,
  129223,
  84983,
  69150,
  13147,
  3590,
  163929,
  207225,
  155260,
  55916,
  20288,
  4503,
  8398,
  98490,
  11773,
  27512,
  37113,
  84976,
  86558,
  28365,
  11756,
  116005,
  182148,
  13733,
  115313,
  47644,
  67208,
  85069,
  9347,
  14995,
  226141,
  14704,
  101835,
  41159,
  35314,
  13113,
  63526,
  214039,
  29978,
  50446,
  83339,
  17440,
  129441,
  72522,
  118641,
  97816,
  24907,
  73844,
  15717,
  118884,
  167255,
  96509,
  162793,
  30847,
  36849,
  51297,
  78974,
  77793,
  10427,
  1873,
  2972,
  9999,
  35074,
  28190,
  64297,
  146836,
  46298,
  60038,
  163007,
  108919,
  61219,
  2403,
  75022,
  127339,
  4233,
  110389,
  69022,
  9833,
  128097,
  88016,
  79390,
  222936,
  22570,
  94657,
  28462,
  56956,
  38803,
  81536,
  30474,
  152794,
  19566,
  16481,
  147408,
  74574,
  81895,
  20731,
  1918,
  1366,
  76367,
  187321,
  54494,
  24366,
  21690,
  61696,
  33283,
  107477,
  77499,
  31112,
  414383,
  74362,
  18463,
  218441,
  120929,
  59848,
  258629,
  201924,
  69269,
  454,
  19989,
  13054,
  59894,
  3623,
  58908,
  20681,
  35723,
  78523,
  102680,
  38988,
  184112,
  108087,
  50944,
  132704,
  52966,
  21699,
  18860,
  96349,
  201411,
  82697,
  85395,
  95658,
  5093,
  6427,
  177894,
  44191,
  32755,
  26961,
  155739,
  6249,
  31310,
  81030,
  26574,
  84311,
  120155,
  86730,
  113535,
  7424,
  48888,
  13516,
  45747,
  98098,
  20077,
  183995,
  81945,
  43210,
  26704,
  40420,
  75831,
  45648,
  11180,
  6855,
  57927,
  65528,
  124096,
  34851,
  2598,
  156633,
  107572,
  127352,
  38169,
  123845,
  60142,
  62722,
  105584,
  232364,
  23211,
  68120,
  1601,
  22169,
  89299,
  747,
  258039,
  80572,
  7258,
  152249,
  11862,
  101204,
  8834,
  121434,
  33761,
  19175,
  133142,
  46343,
  40178,
  48723,
  3589,
  41977,
  30210,
  38868,
  62257,
  10087,
  82658,
  87827,
  90646,
  16415,
  47552,
  351723,
  28298,
  72225,
  91146,
  272760,
  1701,
  11295,
  1652,
  109651,
  300747,
  51863,
  198800,
  29446,
  11794,
  32345,
  37538,
  22356,
  33102,
  37590,
  113544,
  37970,
  11478,
  179743,
  25454,
  103417,
  59905,
  221970,
  105196,
  145604,
  7817,
  164809,
  102360,
  16974,
  75840,
  255333,
  56902,
  6659,
  1954,
  645,
  59400,
  67769,
  7689,
  18675,
  5215,
  13793,
  20536,
  27852,
  3387,
  29523,
  259718,
  16860,
  94625,
  43143,
  29245,
  15848,
  233581,
  22685,
  63631,
  78557,
  22836,
  133302,
  84513,
  1348,
  51826,
  47129,
  98836,
  58284,
  1830,
  1749,
  94642,
  10933,
  6145,
  12506,
  10975,
  13879,
  103781,
  144434,
  10268,
  28409,
  32346,
  52968,
  121567,
  107374,
  77268,
  23686,
  35097,
  10501,
  155275,
  15303,
  47136,
  21102,
  168741,
  55332,
  90385,
  15996,
  84817,
  681,
  137803,
  25054,
  142275,
  6163,
  38175,
  8056,
  124296,
  240642,
  65621,
  4934,
  178205,
  16101,
  62803,
  60964,
  18230,
  100622,
  76465,
  44689,
  14545,
  9543,
  47514,
  16852,
  93380,
  28048,
  12047,
  107106,
  37575,
  101485,
  77047,
  57326,
  34819,
  96137,
  76916,
  6469,
  46264,
  115983,
  75768,
  87668,
  69942,
  13027,
  165,
  8373,
  114231,
  26434,
  52844,
  42799,
  182044,
  23580,
  146254,
  38081,
  43236,
  33883,
  146220,
  382894,
  14606,
  46035,
  36481,
  166621,
  35417,
  95382,
  2957,
  59384,
  60428,
  36358,
  66343,
  75378,
  22267,
  22950,
  83528,
  17577,
  56474,
  25285,
  4619,
  179691,
  75355,
  95836,
  53295,
  34588,
  171410,
  4487,
  14679,
  84208,
  44015,
  18562,
  109133,
  54101,
  11531,
  86052,
  174479,
  303157,
  28095,
  9953,
  35642,
  14564,
  39802,
  16145,
  77606,
  117406,
  53038,
  121117,
  53624,
  22062,
  1212,
  7632,
  127157,
  237292,
  189087,
  10478,
  127345,
  102515,
  181997,
  86752,
  87623,
  10966,
  121602,
  68783,
  68681,
  83042,
  114380,
  138349,
  191305,
  67176,
  50085,
  39016,
  1427,
  42384,
  1412,
  67118,
  122616,
  72389,
  25260,
  2237,
  13576,
  137346,
  19938,
  20304,
  2191,
  68759,
  5373,
  61364,
  238507,
  75814,
  23931,
  69565,
  38993,
  131741,
  38364,
  12528,
  87762,
  5679,
  129853,
  5310,
  186831,
  32653,
  90338,
  260176,
  389531,
  108118,
  26843,
  43985,
  50175,
  30563,
  25106,
  56965,
  18130,
  140428,
  4542,
  165503,
  117991,
  24219,
  229605,
  1819,
  129663,
  1240,
  3797,
  76093,
  18398,
  71339,
  51919,
  93043,
  27175,
  47060,
  216257,
  6483,
  35051,
  1217,
  16512,
  80798,
  129064,
  13225,
  69339,
  8548,
  237079,
  72298,
  2575,
  34280,
  51379,
  117910,
  55671,
  53345,
  247552,
  29486,
  39328,
  140821,
  34681,
  57045,
  60177,
  5004,
  90269,
  78522,
  2479,
  322607,
  48474,
  61296,
  13057,
  31558,
  4678,
  59271,
  6699,
  27044,
  31988,
  35944,
  12503,
  83480,
  4389,
  136508,
  3781,
  114121,
  70279,
  4488,
  155829,
  42214,
  2898,
  68191,
  75695,
  305850,
  45041,
  74344,
  106509,
  30087,
  17429,
  93292,
  12477,
  290,
  23080,
  114802,
  35714,
  18751,
  26554,
  105424,
  17775,
  2144,
  2412,
  100610,
  65192,
  113975,
  52975,
  180272,
  135050,
  129815,
  76238,
  106483,
  21440,
  63186,
  4260,
  46189,
  9711,
  28249,
  4169,
  23429,
  23390,
  8324,
  141585,
  63809,
  67668,
  38457,
  38063,
  39226,
  59972,
  1189,
  203916,
  62368,
  14403,
  16949,
  61767,
  85801,
  1739,
  40147,
  35049,
  76757,
  33124,
  62102,
  15780,
  103593,
  103009,
  53484,
  22952,
  67973,
  114645,
  6566,
  5245,
  50462,
  7601,
  8288,
  3513,
  194571,
  80276,
  1908,
  54592,
  5124,
  58571,
  2513,
  6800,
  273997,
  193904,
  1119,
  17991,
  117245,
  2508,
  129156,
  82366,
  26278,
  71465,
  63341,
  56943,
  39662,
  106116,
  94966,
  156875,
  9736,
  2204,
  122308,
  94418,
  27134,
  1280,
  24539,
  49022,
  45314,
  3764,
  50904,
  46424,
  30699,
  28087,
  293839,
  9400,
  33646,
  40165,
  822,
  147499,
  50263,
  116179,
  29085,
  11863,
  31314,
  5578,
  17797,
  5104,
  12454,
  1604,
  15342,
  219206,
  10232,
  67800,
  94261,
  25872,
  13565,
  90339,
  78971,
  75377,
  26649,
  41184,
  47695,
  11514,
  35369,
  20767,
  14227,
  41953,
  309396,
  148270,
  147938,
  33074,
  14453,
  27499,
  109019,
  39018,
  25738,
  240196,
  158931,
  52820,
  8612,
  95853,
  21524,
  137010,
  84901,
  70869,
  70021,
  116794,
  48404,
  38771,
  6732,
  1070,
  70990,
  187297,
  49140,
  5238,
  576,
  3564,
  253975,
  16027,
  16483,
  2811,
  37775,
  19034,
  25259,
  4053,
  2e3,
  70083,
  95774,
  19713,
  33431,
  92703,
  91314,
  42381,
  288770,
  48194,
  95985,
  3991,
  77418,
  13406,
  241328,
  245086,
  56533,
  35275,
  62725,
  9246,
  51924,
  70181,
  95331,
  16163,
  31410,
  79016,
  39312,
  120878,
  119371,
  275987,
  80124,
  27712,
  9186,
  220,
  23598,
  146167,
  85209,
  68238,
  282190,
  57048,
  31273,
  30555,
  80913,
  17594,
  75779,
  59160,
  135002,
  101219,
  189377,
  29225,
  96735,
  60126,
  62522,
  104e3,
  27620,
  86814,
  17240,
  147533,
  11001,
  5425,
  43682,
  410,
  49460,
  87270,
  69480,
  46315,
  59448,
  1816,
  76201,
  9431,
  11788,
  87960,
  29063,
  65539,
  47347,
  11678,
  33846,
  7008,
  196704,
  9895,
  6753,
  8633,
  120892,
  59970,
  572824,
  115934,
  6646,
  202559,
  892,
  48351,
  37611,
  251282,
  57823,
  67263,
  57750,
  26527,
  34485,
  90747,
  7685,
  88370,
  6144,
  64182,
  1709,
  41969,
  21458,
  62327,
  181657,
  49247,
  225330,
  122600,
  114574,
  107124,
  85361,
  111833,
  63243,
  71420,
  15655,
  191178,
  72430,
  18063,
  51425,
  54002,
  12364,
  53225,
  86557,
  18193,
  97580,
  41232,
  138398,
  67821,
  128724,
  8944,
  233212,
  101353,
  52099,
  42127,
  14006,
  120107,
  32789,
  32132,
  3498,
  18123,
  33758,
  56058,
  5779,
  128760,
  59888,
  98869,
  18445,
  84702,
  51911,
  13234,
  218379,
  20093,
  39031,
  8074,
  70195,
  20708,
  23462,
  24355,
  131384,
  60189,
  26390,
  10403,
  41060,
  7140,
  10781,
  49410,
  42261,
  87202,
  82566,
  41663,
  43105,
  60276,
  2768,
  5733,
  74176,
  28329,
  2297,
  145430,
  131632,
  83615,
  122915,
  105441,
  655,
  224102,
  5284,
  136426,
  67763,
  16294,
  188511,
  32538,
  61049,
  27893,
  3394,
  13951,
  159099,
  28542,
  17930,
  145360,
  9492,
  190122,
  32285,
  78855,
  26440,
  13570,
  58648,
  73908,
  4239,
  124561,
  2444,
  74172,
  53131,
  11468,
  10794,
  73566,
  11623,
  35343,
  64710,
  30481,
  4163,
  10328,
  38309,
  29901,
  10538,
  154377,
  76132,
  92405,
  24839,
  11679,
  3465,
  13449,
  11637,
  7824,
  2337,
  57754,
  1260,
  14458,
  41118,
  19878,
  38661,
  13416,
  159180,
  37074,
  163164,
  54137,
  28627,
  52134,
  184900,
  8520,
  40385,
  29546,
  30502,
  22386,
  66527,
  107458,
  6850,
  24022,
  47983,
  30603,
  35083,
  8934,
  304066,
  39500,
  9,
  28261,
  33026,
  77251,
  9374,
  44833,
  116312,
  34990,
  29236,
  63563,
  125639,
  135405,
  165398,
  159055,
  55690,
  88141,
  69643,
  236964,
  31983,
  25572,
  20436,
  36746,
  60896,
  31850,
  16179,
  11828,
  5888,
  3043,
  66368,
  9750,
  31167,
  7915,
  53111,
  36430,
  1333,
  64344,
  93659,
  20061,
  60596,
  180191,
  51630,
  6792,
  30244,
  43509,
  101058,
  22409,
  420,
  44210,
  109783,
  43223,
  27030,
  72477,
  72831,
  32679,
  29235,
  7675,
  47556,
  12258,
  39907,
  149412,
  84926,
  118247,
  24692,
  71717,
  105038,
  86009,
  45941,
  41189,
  89453,
  29856,
  52543,
  30627,
  226798,
  67303,
  59230,
  67415,
  34408,
  1367,
  99685,
  16867,
  128419,
  52147,
  4111,
  125381,
  117881,
  16173,
  44093,
  102224,
  31575,
  23234,
  24870,
  83790,
  127407,
  239098,
  3200,
  994,
  1255,
  100903,
  242275,
  117266,
  55116,
  38205,
  16140,
  29662,
  11307,
  40414,
  208793,
  123355,
  56470,
  4862,
  75600,
  30119,
  58218,
  70828,
  24075,
  26974,
  7802,
  192353,
  4851,
  5475,
  78720,
  66596,
  3409,
  28573,
  64396,
  30381,
  30690,
  59859,
  88256,
  5406,
  99945,
  103064,
  34463,
  37727,
  24238,
  86643,
  60088,
  4057,
  23741,
  5967,
  162904,
  38240,
  28356,
  93858,
  25510,
  122879,
  6897,
  3278,
  7057,
  11971,
  4400,
  35461,
  211413,
  21395,
  59615,
  39471,
  87233,
  55795,
  128426,
  3051,
  22470,
  41950,
  14705,
  3974,
  180108,
  80476,
  78442,
  204996,
  91987,
  15634,
  67610,
  139015,
  142373,
  35611,
  51134,
  10387,
  4353,
  153456,
  57749,
  181039,
  14183,
  68447,
  151532,
  21107,
  36452,
  20551,
  3186,
  46247,
  46383,
  129666,
  88736,
  140662,
  146243,
  2066,
  8360,
  7978,
  64818,
  106963,
  17896,
  47801,
  10723,
  114821,
  223295,
  74192,
  3293,
  3393,
  16987,
  74064,
  11277,
  91622,
  4270,
  29828,
  27951,
  387869,
  103235,
  1374,
  61988,
  120083,
  477,
  145892,
  128378,
  11779,
  211263,
  61354,
  18221,
  17869,
  46530,
  83061,
  108538,
  157981,
  90608,
  67199,
  95080,
  49064,
  195814,
  12302,
  66307,
  10348,
  231346,
  160732,
  112859,
  63633,
  146558,
  21271,
  31037,
  198802,
  47622,
  12862,
  95710,
  3910,
  77850,
  73961,
  85585,
  34752,
  61e3,
  4082,
  24595,
  103679,
  71107,
  8208,
  79568,
  150019,
  16615,
  24961,
  139857,
  32664,
  197366,
  4559,
  54735,
  32696,
  4126,
  162019,
  75698,
  13916,
  70108,
  159638,
  19834,
  9349,
  24675,
  175560,
  49643,
  18206,
  52459,
  27992,
  10809,
  88865,
  401975,
  133172,
  29e3,
  34558,
  30915,
  3658,
  25834,
  42430,
  36562,
  125265,
  18182,
  10155,
  40149,
  97082,
  208980,
  19575,
  60853,
  90529,
  66545,
  9600,
  789,
  46420,
  2317,
  88593,
  55595,
  98980,
  115302,
  5742,
  169155,
  1073,
  177901,
  3472,
  11189,
  63711,
  78643,
  65472,
  50459,
  127979,
  93,
  42202,
  67053,
  21720,
  157650,
  11145,
  141378,
  42033,
  22824,
  85705,
  79114,
  35584,
  15974,
  1510,
  54172,
  28562,
  12451,
  104226,
  19190,
  97151,
  73024,
  20948,
  5151,
  81741,
  21499,
  29006,
  84183,
  198074,
  54003,
  45120,
  170125,
  26240,
  35177,
  28389,
  64863,
  79974,
  60778,
  176915,
  232183,
  45342,
  2038,
  80253,
  41564,
  40703,
  32689,
  5430,
  100689,
  5366,
  23007,
  134279,
  14266,
  26712,
  73993,
  24934,
  64242,
  52113,
  102887,
  61801,
  46415,
  201049,
  54251,
  62133,
  122757,
  164883,
  30815,
  139966,
  2319,
  30842,
  766,
  13362,
  10287,
  134518,
  86111,
  81665,
  82440,
  28333,
  43019,
  18963,
  8804,
  161944,
  23439,
  102144,
  101145,
  80029,
  39052,
  248708,
  30350,
  117340,
  11878,
  128467,
  974,
  138625,
  63961,
  5237,
  74778,
  61834,
  67040,
  43814,
  13690,
  65947,
  33809,
  232476,
  115258,
  181745,
  28824,
  94013,
  9510,
  10246,
  93722,
  81976,
  7217,
  114383,
  3493,
  16014,
  69045,
  72692,
  12145,
  80981,
  9507,
  6692,
  1620,
  60820,
  330444,
  35474,
  33962,
  4797,
  7053,
  295463,
  46445,
  27026,
  12491,
  77988,
  49524,
  35675,
  90947,
  29114,
  166705,
  101385,
  133782,
  32704,
  6186,
  84595,
  176031,
  185623,
  45966,
  151302,
  63069,
  1699,
  107491,
  947,
  15458,
  74452,
  196212,
  6046,
  10498,
  12163,
  10239,
  35191,
  243951,
  9277,
  9090,
  29539,
  54460,
  22820,
  26514,
  112549,
  60372,
  51753,
  48756,
  21812,
  70861,
  260326,
  41,
  44222,
  10441,
  16961,
  48148,
  138771,
  216194,
  5914,
  52153,
  53400,
  212036,
  56519,
  26245,
  10117,
  45888,
  15294,
  138019,
  90913,
  26368,
  43842,
  42111,
  23348,
  6082,
  194845,
  161089,
  156206,
  51546,
  11647,
  30759,
  302912,
  262094,
  8635,
  78876,
  26535,
  35283,
  54183,
  31183,
  85484,
  147873,
  12989,
  5197,
  6356,
  72894,
  65347,
  20150,
  27370,
  73787,
  1493,
  45918,
  12366,
  190217,
  20724,
  13858,
  10981,
  67449,
  81213,
  7553,
  14115,
  72242,
  271517,
  11842,
  48310,
  88743,
  143726,
  22177,
  3290,
  243231,
  58452,
  62937,
  12592,
  1654,
  40066,
  33477,
  13751,
  9921,
  128442,
  15868,
  7106,
  75236,
  83773,
  10775,
  36938,
  10482,
  170465,
  17368,
  17469,
  161508,
  32752,
  98340,
  800,
  19824,
  264456,
  3901,
  87319,
  2867,
  26782,
  9630,
  113102,
  185815,
  24197,
  44584,
  86366,
  40224,
  3636,
  140916,
  31731,
  267731,
  9567,
  53678,
  72984,
  29389,
  27963,
  17106,
  50282,
  284911,
  60170,
  8322,
  12608,
  23374,
  89652,
  5268,
  39044,
  229766,
  8869,
  151350,
  31436,
  177342,
  12269,
  183212,
  120418,
  116270,
  2843,
  78888,
  69192,
  7865,
  184099,
  1086,
  129897,
  18383,
  70508,
  20242,
  18508,
  229924,
  124569,
  35749,
  50589,
  55626,
  9884,
  83115,
  40971,
  30671,
  18135,
  14452,
  38861,
  17844,
  201826,
  5549,
  26413,
  17189,
  13561,
  38539,
  10679,
  143331,
  3314,
  36785,
  171194,
  49685,
  187713,
  67506,
  4618,
  104039,
  17060,
  195080,
  50648,
  33159,
  19238,
  67559,
  134840,
  28599,
  157523,
  17130,
  38064,
  117398,
  94355,
  31918,
  13575,
  34538,
  40326,
  13997,
  3494,
  348283,
  62481,
  26862,
  3603,
  104426,
  244363,
  153709,
  112487,
  304612,
  199674,
  41239,
  35545,
  54869,
  293005,
  28223,
  26277,
  26899,
  4533,
  18518,
  15492,
  38587,
  80488,
  70485,
  160395,
  263,
  60162,
  11382,
  222152,
  4696,
  250751,
  51921,
  182609,
  10707,
  48463,
  46243,
  1227,
  49111,
  111564,
  46502,
  33342,
  56846,
  68541,
  63559,
  858,
  139927,
  16654,
  229375,
  76759,
  26478,
  33205,
  95828,
  23399,
  92945,
  2637,
  35630,
  28470,
  143992,
  50214,
  14174,
  21456,
  166191,
  65665,
  1711,
  21594,
  78019,
  97599,
  111701,
  36,
  147151,
  110246,
  189022,
  43021,
  30397,
  40757,
  131935,
  42065,
  73335,
  48039,
  26596,
  28984,
  15102,
  2361,
  7421,
  202167,
  69744,
  43766,
  52826,
  3642,
  83304,
  33873,
  75140,
  63169,
  192389,
  36551,
  92748,
  13039,
  123959,
  233220,
  21738,
  84447,
  77230,
  20228,
  187852,
  19095,
  25799,
  92136,
  108774,
  29237,
  53947,
  2299,
  118106,
  2687,
  8830,
  42331,
  202924,
  33667,
  2023,
  73763,
  30704,
  19363,
  19779,
  16737,
  35629,
  48081,
  24068,
  101013,
  162338,
  291912,
  13749,
  24745,
  328289,
  167679,
  70086,
  48299,
  23306,
  16732,
  17801,
  43322,
  54589,
  3586,
  63653,
  43624,
  53474,
  925,
  109177,
  251316,
  43805,
  13082,
  19511,
  86565,
  142182,
  92461,
  17117,
  101033,
  103319,
  64589,
  4022,
  4351,
  235897,
  5352,
  82705,
  107142,
  46391,
  156084,
  5860,
  61365,
  10558,
  13045,
  7717,
  18357,
  33922,
  12590,
  33065,
  6928,
  46993,
  783,
  46937,
  67846,
  8952,
  26295,
  6107,
  119656,
  18799,
  17458,
  50747,
  4229,
  179559,
  112727,
  118080,
  20683,
  41464,
  125468,
  51560,
  49749,
  44231,
  7359,
  35339,
  62988,
  136487,
  67015,
  5208,
  29150,
  24956,
  105186,
  48858,
  6143,
  18097,
  6972,
  16404,
  73489,
  58742,
  97196,
  36357,
  164616,
  5834,
  32267,
  13746,
  147733,
  15113,
  132091,
  34127,
  106298,
  39729,
  106426,
  22294,
  9780,
  15602,
  36213,
  71502,
  42808,
  66802,
  599,
  60755,
  5851,
  39120,
  67363,
  108623,
  126368,
  72770,
  91263,
  32486,
  30596,
  151717,
  7951,
  52002,
  43103,
  11768,
  68942,
  40901,
  39344,
  24037,
  127500,
  116890,
  48403,
  16926,
  86750,
  17745,
  48648,
  159545,
  34460,
  58419,
  5634,
  114317,
  67865,
  31462,
  23352,
  24010,
  98185,
  125708,
  69686,
  68337,
  13610,
  26271,
  70691,
  2980,
  4768,
  27225,
  102402,
  75453,
  28106,
  8104,
  6931,
  1176,
  6274,
  6475,
  112635,
  22498,
  6176,
  238686,
  26832,
  28893,
  90319,
  14441,
  15682,
  15087,
  39517,
  45270,
  109134,
  104440,
  45965,
  47645,
  81772,
  7876,
  52683,
  87720,
  12898,
  4505,
  185665,
  2769,
  113401,
  15664,
  57592,
  105229,
  137381,
  97059,
  119268,
  6876,
  43309,
  33886,
  128363,
  35476,
  144249,
  67013,
  143587,
  83367,
  25703,
  91436,
  59347,
  53236,
  2289,
  16519,
  19844,
  46309,
  58558,
  99834,
  23313,
  218816,
  231303,
  36388,
  51333,
  183535,
  109792,
  139277,
  54306,
  90139,
  18235,
  8275,
  32710,
  37677,
  82464,
  86025,
  92204,
  88842,
  117723,
  37570,
  128723,
  234242,
  76350,
  73795,
  34896,
  148247,
  58424,
  11105,
  11744,
  45746,
  63372,
  17118,
  49772,
  199520,
  81902,
  38004,
  22911,
  33752,
  3125,
  1995,
  53792,
  4689,
  26909,
  108150,
  146062,
  69674,
  41811,
  161444,
  84855,
  8999,
  28561,
  16731,
  93937,
  3189,
  21967,
  24890,
  22943,
  1356,
  145300,
  51569,
  28802,
  517,
  118679,
  31703,
  40607,
  48098,
  108854,
  25003,
  10233,
  73969,
  177495,
  5248,
  24516,
  215347,
  146192,
  48712,
  60626,
  69188,
  40735,
  5866,
  586,
  101541,
  6509,
  47590,
  52129,
  5969,
  222045,
  110933,
  25733,
  24223,
  65339,
  62812,
  2414,
  155418,
  35819,
  16022,
  78423,
  43138,
  20995,
  128255,
  240673,
  46745,
  236093,
  72176,
  57085,
  97841,
  61248,
  107,
  36068,
  193177,
  105427,
  55726,
  215229,
  20446,
  47228,
  100420,
  87091,
  14429,
  121708,
  23605,
  21157,
  187721,
  21880,
  2997,
  203976,
  99166,
  95068,
  25877,
  7724,
  98925,
  83401,
  4829,
  13182,
  18229,
  13718,
  239662,
  38653,
  116505,
  153497,
  30589,
  89029,
  38962,
  181302,
  43853,
  78872,
  180301,
  4786,
  248240,
  7401,
  106136,
  112590,
  77745,
  19731,
  60880,
  77789,
  125748,
  135487,
  5975,
  48627,
  34084,
  12419,
  215770,
  47557,
  254582,
  10364,
  106495,
  21856,
  67539,
  88981,
  38805,
  21428,
  48732,
  42316,
  12149,
  16078,
  52808,
  25327,
  51322,
  33850,
  51147,
  12253,
  122354,
  46077,
  56483,
  254553,
  115417,
  81834,
  150991,
  94662,
  86668,
  7381,
  12841,
  100650,
  18218,
  15741,
  22372,
  68294,
  50705,
  15535,
  84660,
  61887,
  22553,
  72299,
  31361,
  24824,
  17743,
  46820,
  64288,
  31582,
  77006,
  111674,
  116384,
  30760,
  80920,
  86149,
  77192,
  51979,
  79691,
  60342,
  122805,
  103800,
  240873,
  160744,
  233114,
  78962,
  54920,
  8608,
  3484,
  316104,
  72548,
  24337,
  5088,
  230040,
  21926,
  10172,
  36838,
  26,
  86221,
  83458,
  102176,
  12062,
  17571,
  41929,
  41170,
  28428,
  68239,
  41750,
  103930,
  2634,
  18313,
  53019,
  34825,
  97837,
  63115,
  24606,
  73157,
  152474,
  14715,
  91439,
  37033,
  109806,
  140259,
  30668,
  174760,
  380,
  135597,
  95673,
  136073,
  65073,
  134249,
  13829,
  17279,
  122305,
  4420,
  46444,
  10237,
  64848,
  203623,
  70728,
  10349,
  182885,
  65075,
  24519,
  25783,
  40318,
  34139,
  22222,
  63394,
  55266,
  102764,
  41422,
  20126,
  65100,
  90408,
  53640,
  35128,
  48932,
  11192,
  38935,
  96839,
  34782,
  39492,
  19396,
  41332,
  6250,
  5511,
  19492,
  51304,
  25936,
  104466,
  54099,
  73771,
  86115,
  5080,
  7669,
  30891,
  111700,
  13931,
  25276,
  72289,
  135447,
  14820,
  258641,
  25265,
  31005,
  281179,
  75286,
  393,
  95359,
  14623,
  13584,
  6680,
  101227,
  80173,
  44933,
  76666,
  54542,
  13244,
  39348,
  458,
  25379,
  109451,
  134348,
  81143,
  6959,
  65554,
  12027,
  51311,
  8716,
  57589,
  140731,
  28467,
  23316,
  17272,
  30458,
  25980,
  55229,
  77197,
  83798,
  28302,
  114784,
  7428,
  34548,
  26241,
  14712,
  39336,
  103304,
  18928,
  54080,
  12870,
  334,
  87722,
  15208,
  16895,
  142098,
  114262,
  39820,
  83913,
  57817,
  28682,
  7721,
  14900,
  108672,
  11250,
  62246,
  42849,
  415188,
  1724,
  26555,
  24549,
  25505,
  26443,
  107450,
  145899,
  61035,
  43528,
  6901,
  60726,
  65906,
  267741,
  21338,
  147590,
  42079,
  18924,
  73017,
  135236,
  15393,
  5206,
  4026,
  84185,
  1531,
  5988,
  113890,
  82647,
  303391,
  7386,
  69844,
  71611,
  189865,
  76523,
  31877,
  13315,
  19314,
  198575,
  32821,
  1928,
  67641,
  25913,
  104475,
  103489,
  3297,
  70391,
  18406,
  15446,
  113347,
  19295,
  93790,
  27856,
  1792,
  167471,
  116449,
  8541,
  4408,
  41757,
  63233,
  25765,
  86680,
  64501,
  27034,
  24816,
  34975,
  6079,
  4486,
  49693,
  36229,
  16917,
  21581,
  62426,
  27862,
  11612,
  54284,
  35702,
  194034,
  355,
  24277,
  48262,
  87411,
  70504,
  310164,
  118018,
  12516,
  47559,
  43502,
  57433,
  107139,
  9290,
  66533,
  80863,
  14634,
  34312,
  91725,
  28606,
  21342,
  67241,
  72355,
  43244,
  375789,
  37402,
  174015,
  105070,
  8342,
  44167,
  67494,
  1890,
  16365,
  11723,
  271002,
  1865,
  47918,
  8350,
  45564,
  27742,
  25110,
  125803,
  8553,
  49504,
  81925,
  62211,
  4534,
  15491,
  19011,
  80373,
  206920,
  667,
  102405,
  128623,
  245524,
  5553,
  113309,
  192739,
  65766,
  19567,
  22832,
  261958,
  29679,
  21293,
  71134,
  20962,
  105123,
  24721,
  860,
  21752,
  33448,
  18372,
  157167,
  94822,
  35770,
  173224,
  232737,
  75729,
  28937,
  46828,
  28062,
  25453,
  5207,
  140366,
  36665,
  30652,
  6169,
  67920,
  150458,
  92040,
  23186,
  184604,
  92330,
  20891,
  176492,
  49427,
  27828,
  38305,
  42495,
  143982,
  49560,
  25503,
  90043,
  29747,
  65328,
  47830,
  12932,
  11068,
  77721,
  9003,
  25213,
  94205,
  140426,
  46090,
  89945,
  138173,
  192691,
  33329,
  112232,
  129905,
  35709,
  27514,
  1841,
  19957,
  31411,
  127476,
  53572,
  17497,
  173549,
  55063,
  175135,
  19841,
  69314,
  5192,
  237921,
  117660,
  150697,
  4060,
  273045,
  50414,
  98940,
  65348,
  153665,
  164423,
  58804,
  156695,
  48994,
  213928,
  86036,
  28608,
  8355,
  39574,
  34540,
  16927,
  135680,
  18374,
  151587,
  10830,
  53805,
  16878,
  16623,
  4282,
  48030,
  8537,
  14986,
  46102,
  13062,
  72897,
  72,
  33050,
  108227,
  39451,
  45935,
  651,
  113320,
  40535,
  95176,
  57450,
  48843,
  5003,
  19019,
  10407,
  211163,
  3848,
  1068,
  4988,
  32091,
  30095,
  41692,
  15099,
  43602,
  107434,
  50744,
  7627,
  171349,
  16313,
  150832,
  352665,
  207750,
  33937,
  38256,
  51091,
  156e3,
  87889,
  90663,
  84175,
  24908,
  114900,
  50365,
  31494,
  83829,
  5398,
  169342,
  47521,
  54818,
  18935,
  8356,
  43094,
  41212,
  174536,
  10082,
  92550,
  6678,
  60614,
  23355,
  69721,
  14796,
  34149,
  128830,
  58187,
  3179,
  208,
  40325,
  28399,
  225029,
  401412,
  51150,
  31580,
  207268,
  6657,
  10993,
  69818,
  64282,
  289845,
  23308,
  12961,
  38447,
  6681,
  52944,
  31855,
  2572,
  47646,
  120728,
  179148,
  37240,
  45196,
  218274,
  4816,
  3695,
  21961,
  50084,
  35209,
  18073,
  51452,
  27004,
  6100,
  33941,
  1377,
  84831,
  171214,
  85,
  141510,
  9078,
  99227,
  32610,
  6417,
  11718,
  49868,
  65579,
  87902,
  73018,
  49062,
  46280,
  61742,
  21512,
  40862,
  107733,
  15941,
  29168,
  157765,
  144919,
  14487,
  5767,
  158014,
  140070,
  7241,
  573,
  71584,
  16921,
  223566,
  40331,
  179473,
  35081,
  47926,
  140885,
  41508,
  52104,
  59180,
  42310,
  32811,
  29048,
  123517,
  102413,
  80208,
  10104,
  14746,
  12649,
  153641,
  126022,
  37965,
  113017,
  4171,
  83,
  142592,
  2809,
  6362,
  50416,
  71323,
  116894,
  260776,
  16204,
  1524,
  5760,
  30351,
  12658,
  20703,
  54403,
  36083,
  45408,
  74772,
  4946,
  14485,
  50759,
  111222,
  10890,
  2195,
  167147,
  92962,
  130534,
  16283,
  177256,
  35016,
  15472,
  210156,
  151187,
  73922,
  117691,
  43250,
  52051,
  37392,
  24811,
  24358,
  30830,
  5775,
  818,
  21969,
  1476,
  127322,
  151783,
  58392,
  31021,
  106913,
  65215,
  89407,
  90802,
  28531,
  11690,
  20234,
  95249,
  44602,
  37256,
  18707,
  11928,
  5161,
  4410,
  26571,
  51903,
  49768,
  22008,
  25252,
  65780,
  209499,
  68769,
  203726,
  13249,
  137363,
  48845,
  86823,
  6658,
  5674,
  31881,
  1083,
  1823,
  108676,
  34518,
  166752,
  13791,
  14287,
  91576,
  91429,
  8665,
  11529,
  26401,
  16191,
  91972,
  30964,
  5254,
  28486,
  54697,
  79613,
  66520,
  18447,
  22870,
  45203,
  194466,
  22822,
  51703,
  12278,
  76716,
  44595,
  73455,
  33546,
  12235,
  144843,
  36154,
  51247,
  11116,
  33040,
  3180,
  225753,
  60864,
  1972,
  28469,
  12891,
  28879,
  10338,
  144157,
  56294,
  353058,
  38302,
  41447,
  87532,
  110616,
  27065,
  168438,
  6557,
  1213,
  50804,
  144643,
  24817,
  2390,
  136531,
  38174,
  247513,
  16190,
  4059,
  122791,
  131994,
  137430,
  39506,
  57650,
  16305,
  5188,
  54309,
  106128,
  20628,
  88071,
  67394,
  395446,
  250285,
  66176,
  91254,
  1399,
  114196,
  43915,
  60230,
  44853,
  27206,
  106353,
  43013,
  18733,
  345105,
  226453,
  51202,
  16607,
  57106,
  117175,
  35492,
  10476,
  89598,
  127439,
  15187,
  39624,
  13688,
  61570,
  10615,
  31111,
  59370,
  6238,
  175252,
  32143,
  224492,
  41388,
  95408,
  34384,
  148238,
  78307,
  38959,
  9340,
  160091,
  61443,
  15737,
  11216,
  41244,
  170,
  38299,
  102443,
  113097,
  26382,
  14027,
  33707,
  3957,
  76300,
  66160,
  19431,
  18900,
  6952,
  1717,
  108656,
  82206,
  188021,
  257335,
  27295,
  43999,
  41210,
  31777,
  46956,
  57457,
  12657,
  11489,
  15697,
  48060,
  204748,
  53583,
  82422,
  284790,
  30503,
  137341,
  8120,
  19615,
  220311,
  15991,
  10217,
  63424,
  9808,
  67431,
  70976,
  98221,
  4491,
  15177,
  28535,
  144789,
  751,
  13230,
  2394,
  1504,
  33977,
  132104,
  30316,
  22230,
  931,
  97193,
  185240,
  24826,
  22687,
  174322,
  15307,
  22988,
  1390,
  188745,
  180325,
  29580,
  59068,
  74903,
  18994,
  29195,
  79,
  15436,
  7622,
  38462,
  11566,
  138710,
  44828,
  45774,
  37768,
  99236,
  68137,
  84083,
  19282,
  22698,
  17134,
  74807,
  126662,
  173497,
  46248,
  16938,
  119735,
  3212,
  28292,
  213652,
  49013,
  9975,
  32180,
  45660,
  86250,
  4801,
  68788,
  95490,
  77482,
  113751,
  11994,
  44624,
  94452,
  46839,
  128497,
  100316,
  5798,
  58588,
  73184,
  202987,
  65417,
  37790,
  88524,
  1606,
  43156,
  97964,
  105717,
  34947,
  11203,
  100060,
  37742,
  130074,
  93653,
  107799,
  94311,
  196106,
  41347,
  8035,
  10780,
  16390,
  27883,
  118236,
  167395,
  1979,
  25006,
  19375,
  31628,
  18916,
  144723,
  78502,
  114047,
  103107,
  86492,
  107686,
  5844,
  20934,
  206963,
  23556,
  22591,
  16562,
  146333,
  20167,
  10471,
  117434,
  33085,
  2863,
  9740,
  36669,
  41849,
  37271,
  22790,
  18209,
  28979,
  8231,
  12952,
  54408,
  21731,
  25130,
  45208,
  55748,
  138120,
  75826,
  414,
  29593,
  9925,
  292865,
  25999,
  683,
  123149,
  7036,
  92159,
  86055,
  61827,
  103680,
  23176,
  54918,
  58466,
  57578,
  13305,
  5709,
  86479,
  16697,
  31064,
  17660,
  200919,
  10770,
  49793,
  33423,
  32370,
  52047,
  16488,
  62555,
  6459,
  8426,
  83493,
  7763,
  59725,
  82812,
  18628,
  67760,
  79405,
  68557,
  9612,
  7673,
  28102,
  56517,
  69620,
  171797,
  32458,
  29541,
  15870,
  81109,
  32080,
  207644,
  71495,
  21202,
  11039,
  91036,
  61230,
  2810,
  130800,
  32260,
  4613,
  60590,
  37112,
  75214,
  33979,
  126402,
  155062,
  30642,
  63875,
  12810,
  194463,
  82799,
  47664,
  16725,
  36685,
  43367,
  61099,
  449,
  172150,
  102867,
  21691,
  301838,
  36745,
  7130,
  18671,
  57316,
  34852,
  38034,
  54182,
  35578,
  65900,
  99486,
  19771,
  3456,
  2658,
  16914,
  99866,
  28390,
  28109,
  8262,
  21147,
  34353,
  20006,
  4228,
  137085,
  1675,
  203023,
  283196,
  198286,
  214375,
  163329,
  290603,
  152574,
  40471,
  83506,
  30068,
  14730,
  23177,
  131539,
  34759,
  27668,
  32178,
  71896,
  104799,
  116305,
  85430,
  119262,
  42860,
  25160,
  8911,
  23428,
  49437,
  105322,
  6519,
  16203,
  6349,
  74711,
  1230,
  38045,
  8540,
  75165,
  44736,
  25909,
  51026,
  317034,
  4984,
  32281,
  91312,
  27060,
  44431,
  17817,
  45363,
  155937,
  239085,
  35697,
  59784,
  91993,
  29531,
  126740,
  213757,
  76560,
  167776,
  285273,
  24262,
  8237,
  65030,
  41160,
  74437,
  48804,
  118916,
  13159,
  37842,
  1031,
  75349,
  1478,
  11655,
  108777,
  23435,
  277425,
  101734,
  67469,
  70231,
  124711,
  43532,
  28514,
  65526,
  54956,
  1e3,
  21882,
  17728,
  25302,
  40952,
  52214,
  149632,
  1999,
  2111,
  3259,
  63362,
  89961,
  220561,
  39777,
  26335,
  9063,
  10572,
  12416,
  34551,
  34623,
  38604,
  24723,
  5947,
  15588,
  69927,
  66252,
  119177,
  69173,
  46629,
  28714,
  70715,
  212408,
  20521,
  406913,
  74380,
  11716,
  50659,
  50862,
  37009,
  88460,
  130101,
  7210,
  53853,
  538,
  65120,
  151950,
  55806,
  163748,
  52837,
  13153,
  21100,
  16674,
  64536,
  6091,
  138201,
  44837,
  58547,
  3723,
  163,
  2177,
  32288,
  85454,
  34033,
  8497,
  14282,
  25742,
  10535,
  10741,
  79559,
  117493,
  243787,
  49337,
  100718,
  79495,
  40139,
  42956,
  7551,
  55433,
  15421,
  31509,
  23034,
  45081,
  547,
  61176,
  53434,
  328001,
  8470,
  36263,
  30145,
  4519,
  74173,
  53935,
  11845,
  73774,
  60211,
  78025,
  3,
  4102,
  73782,
  109293,
  315332,
  48412,
  26683,
  13714,
  6865,
  20128,
  18490,
  104141,
  325,
  39470,
  171970,
  115860,
  15707,
  7268,
  73301,
  74336,
  31370,
  2368,
  111827,
  107757,
  136231,
  142844,
  97138,
  96638,
  84053,
  38691,
  23801,
  1588,
  10573,
  122098,
  77039,
  240,
  186135,
  146101,
  11996,
  18143,
  112963,
  46171,
  155836,
  348769,
  47795,
  121213,
  116266,
  132515,
  3344,
  144804,
  31286,
  99187,
  255838,
  129694,
  35894,
  48779,
  55235,
  148582,
  71967,
  65282,
  15174,
  13920,
  47080,
  6147,
  108242,
  157593,
  125025,
  7136,
  1286,
  28957,
  127956,
  28402,
  98813,
  20805,
  7532,
  109417,
  40610,
  5041,
  32958,
  15142,
  18408,
  108596,
  33543,
  50517,
  27748,
  80114,
  233434,
  91447,
  487,
  37094,
  100048,
  30541,
  43477,
  10639,
  89862,
  155868,
  37667,
  8726,
  60684,
  237903,
  73408,
  99589,
  12190,
  38739,
  97348,
  3914,
  13594,
  2680,
  149016,
  13907,
  30171,
  28343,
  23530,
  115225,
  61104,
  35821,
  147679,
  14337,
  4297,
  244282,
  24085,
  326976,
  56428,
  7851,
  21303,
  131620,
  71446,
  83253,
  68692,
  111870,
  5224,
  15813,
  38197,
  49026,
  45057,
  13660,
  3306,
  76345,
  40671,
  27905,
  91072,
  996,
  68527,
  62085,
  91351,
  122634,
  55109,
  168209,
  2024,
  27560,
  112707,
  17352,
  8306,
  167115,
  169921,
  166958,
  5031,
  46020,
  11844,
  67284,
  19130,
  76185,
  6920,
  32849,
  5450,
  14610,
  22451,
  21002,
  17392,
  31872,
  66682,
  84796,
  13709,
  40210,
  59898,
  12029,
  8719,
  53564,
  21462,
  91884,
  21647,
  88379,
  194428,
  12754,
  37797,
  132826,
  160016,
  22567,
  54383,
  53186,
  77611,
  31107,
  8339,
  4694,
  19185,
  90355,
  23597,
  17222,
  140675,
  28442,
  23668,
  55977,
  9128,
  61555,
  28774,
  155229,
  17658,
  9390,
  24379,
  69357,
  15752,
  127381,
  239631,
  62460,
  93181,
  55913,
  45133,
  140155,
  18676,
  25249,
  33164,
  29581,
  82837,
  67223,
  22362,
  29975,
  7317,
  52813,
  1943,
  29613,
  20012,
  207130,
  49617,
  49651,
  5636,
  15334,
  36313,
  29226,
  28084,
  95247,
  72072,
  19e3,
  224932,
  15811,
  114,
  32127,
  38097,
  37508,
  88507,
  37225,
  27359,
  91626,
  12193,
  69279,
  20608,
  11055,
  88156,
  92808,
  2152,
  57259,
  55275,
  72789,
  24475,
  104414,
  1708,
  9882,
  3818,
  48661,
  66897,
  1631,
  34806,
  227930,
  85815,
  87753,
  18321,
  250664,
  72733,
  25107,
  206797,
  50891,
  8082,
  196411,
  92596,
  96764,
  152823,
  65514,
  22819,
  387277,
  62176,
  51225,
  40329,
  15563,
  189,
  3659,
  73670,
  64357,
  51793,
  275136,
  33482,
  86653,
  74615,
  67058,
  11318,
  125720,
  15388,
  22388,
  8267,
  1730,
  102663,
  170910,
  40784,
  7144,
  85373,
  13040,
  7088,
  94309,
  583,
  44224,
  140424,
  77439,
  18496,
  164026,
  36578,
  4722,
  9151,
  5824,
  63365,
  26510,
  35199,
  40500,
  79277,
  32495,
  44614,
  35233,
  9566,
  203293,
  152144,
  7097,
  2330,
  183480,
  98629,
  13423,
  330887,
  44130,
  68600,
  30939,
  97829,
  31012,
  345465,
  56747,
  94879,
  4939,
  160027,
  149761,
  99423,
  46099,
  32251,
  15332,
  8761,
  96094,
  128555,
  5763,
  235318,
  222223,
  55729,
  30241,
  55420,
  201746,
  3987,
  81382,
  8259,
  49325,
  23287,
  7719,
  24633,
  251100,
  92311,
  18591,
  110533,
  64759,
  170260,
  393860,
  7175,
  21144,
  132887,
  3593,
  75346,
  101277,
  91109,
  16387,
  259187,
  11627,
  57459,
  173829,
  44694,
  55780,
  49797,
  89192,
  120443,
  62622,
  3904,
  14814,
  23887,
  1027,
  112258,
  64955,
  99800,
  11132,
  66353,
  36202,
  48624,
  18158,
  88481,
  96882,
  43059,
  11040,
  2455,
  7077,
  21651,
  181159,
  99126,
  100434,
  61388,
  68186,
  19161,
  110468,
  120052,
  8819,
  55324,
  41494,
  7014,
  37689,
  3618,
  87729,
  92615,
  207943,
  9823,
  128657,
  12587,
  15857,
  6379,
  67628,
  51216,
  71775,
  157617,
  63244,
  1503,
  3864,
  218754,
  110864,
  5769,
  21492,
  7243,
  1192,
  87921,
  85529,
  31512,
  18537,
  42698,
  35350,
  73510,
  84474,
  34301,
  8991,
  21013,
  35034,
  566,
  38832,
  19838,
  35586,
  37216,
  39413,
  55006,
  12178,
  59742,
  856,
  84563,
  6900,
  25632,
  17437,
  49786,
  30723,
  13847,
  70845,
  4044,
  7843,
  23944,
  235976,
  55530,
  48942,
  6518,
  20939,
  73769,
  192653,
  52936,
  95207,
  23895,
  132542,
  142982,
  22632,
  87452,
  48042,
  54018,
  178468,
  10728,
  26230,
  23559,
  363,
  81269,
  142012,
  5718,
  346258,
  31456,
  84333,
  246476,
  51018,
  66692,
  101804,
  120570,
  39962,
  30373,
  70593,
  2864,
  60541,
  19425,
  54209,
  104092,
  7201,
  31545,
  48018,
  25865,
  15442,
  46257,
  40443,
  8328,
  6451,
  111782,
  47527,
  97754,
  33046,
  470,
  245116,
  31095,
  39,
  91934,
  87208,
  73470,
  36708,
  36521,
  12801,
  70624,
  36272,
  8892,
  79768,
  12427,
  55454,
  103756,
  5908,
  52390,
  62962,
  22720,
  141138,
  94634,
  41689,
  128402,
  126390,
  6628,
  106394,
  35527,
  134394,
  82727,
  254651,
  194502,
  148064,
  89549,
  3202,
  28359,
  957,
  21954,
  27906,
  49840,
  142747,
  8307,
  24206,
  48978,
  1186,
  71728,
  133038,
  71474,
  91306,
  6333,
  110959,
  74600,
  70387,
  18983,
  62609,
  56057,
  22970,
  1147,
  135850,
  1321,
  28834,
  3578,
  59715,
  102227,
  32827,
  81415,
  99952,
  55636,
  257598,
  390,
  22702,
  35701,
  85872,
  402916,
  39216,
  189795,
  14929,
  19467,
  10112,
  144422,
  61514,
  5279,
  63421,
  134686,
  41436,
  8424,
  51925,
  10598,
  132295,
  124416,
  4604,
  194739,
  210929,
  57866,
  31829,
  51626,
  50007,
  9976,
  91878,
  61906,
  56168,
  81906,
  60918,
  61859,
  40017,
  23059,
  16887,
  40927,
  62064,
  12785,
  32893,
  32913,
  21782,
  93965,
  20169,
  44387,
  79084,
  38463,
  11457,
  93950,
  27127,
  157050,
  2697,
  337088,
  5116,
  54128,
  48255,
  33279,
  8821,
  27352,
  25515,
  124022,
  65710,
  28906,
  38557,
  33390,
  1722,
  104435,
  72215,
  38551,
  12094,
  30978,
  25113,
  6671,
  37355,
  175109,
  42862,
  98024,
  65406,
  221276,
  59624,
  118012,
  64637,
  78760,
  86697,
  21426,
  1639,
  40350,
  12584,
  67193,
  84144,
  31396,
  7863,
  143011,
  69629,
  63112,
  9454,
  28666,
  65798,
  46372,
  134721,
  6314,
  51402,
  30837,
  151922,
  2847,
  38676,
  38008,
  92823,
  136245,
  17540,
  5504,
  109295,
  205242,
  37606,
  5211,
  214892,
  1586,
  20670,
  208711,
  137743,
  19328,
  40652,
  16995,
  20023,
  14657,
  154919,
  34422,
  12996,
  13918,
  38221,
  47690,
  16398,
  2959,
  37680,
  89122,
  6721,
  198469,
  91876,
  172043,
  83898,
  101992,
  26084,
  94570,
  3635,
  76958,
  22853,
  76497,
  38266,
  176590,
  168403,
  44464,
  142840,
  79180,
  184594,
  1984,
  41806,
  83147,
  11985,
  6546,
  366068,
  59732,
  24533,
  271505,
  8736,
  39084,
  222992,
  93429,
  28962,
  58985,
  86665,
  8432,
  30028,
  14548,
  32439,
  54424,
  165029,
  55175,
  27458,
  69046,
  121277,
  46168,
  33732,
  20661,
  24581,
  135574,
  123110,
  37556,
  79260,
  72611,
  16957,
  12939,
  46162,
  58238,
  44907,
  72936,
  253758,
  41324,
  32518,
  96480,
  11949,
  124438,
  65280,
  43256,
  34107,
  53533,
  43531,
  37037,
  28366,
  45970,
  32741,
  173438,
  6121,
  194202,
  62969,
  26355,
  30314,
  58370,
  28455,
  1848,
  50519,
  82830,
  90393,
  21761,
  295490,
  10936,
  256940,
  133568,
  44050,
  20269,
  4089,
  27457,
  21610,
  219460,
  36743,
  14821,
  101388,
  52005,
  13124,
  30979,
  140816,
  167362,
  26054,
  18458,
  60789,
  34917,
  40447,
  26606,
  33422,
  9066,
  3452,
  83614,
  5761,
  20263,
  137238,
  25038,
  91310,
  101,
  52322,
  74548,
  42572,
  38084,
  214054,
  186568,
  31802,
  17665,
  30620,
  141936,
  37730,
  14420,
  4265,
  187218,
  49640,
  188208,
  51441,
  55388,
  96452,
  66659,
  40869,
  42039,
  60967,
  221027,
  19234,
  178581,
  29105,
  96050,
  9165,
  196118,
  157335,
  3738,
  40354,
  117436,
  2965,
  34136,
  59659,
  15570,
  50843,
  230035,
  31444,
  71260,
  43886,
  18316,
  5387,
  38500,
  168508,
  17406,
  32174,
  8828,
  103373,
  143806,
  90367,
  3560,
  18719,
  122310,
  16508,
  26719,
  2541,
  105429,
  6645,
  37998,
  73190,
  10591,
  235916,
  49737,
  87112,
  233941,
  53188,
  32193,
  79154,
  4544,
  52905,
  126477,
  7580,
  63501,
  57314,
  3216,
  31337,
  6541,
  103083,
  60846,
  49,
  9756,
  15481,
  1355,
  43840,
  14319,
  13743,
  27486,
  10222,
  73114,
  230718,
  418644,
  16706,
  6674,
  279748,
  23058,
  45273,
  295831,
  86306,
  2743,
  5535,
  88773,
  21829,
  35253,
  120938,
  31153,
  3169,
  16839,
  42847,
  8751,
  80974,
  33942,
  36867,
  35514,
  16485,
  26474,
  77775,
  56877,
  5391,
  48346,
  3882,
  108713,
  31403,
  27804,
  55248,
  26235,
  43821,
  136104,
  40118,
  175507,
  28034,
  203908,
  18732,
  1788,
  34030,
  106427,
  36958,
  54359,
  7251,
  44936,
  15356,
  69139,
  455,
  157915,
  22173,
  140291,
  50348,
  43275,
  82066,
  49621,
  54952,
  15216,
  36226,
  96695,
  66855,
  6936,
  1987,
  8227,
  196087,
  4631,
  68827,
  99004,
  47541,
  110265,
  17953,
  147605,
  110242,
  58520,
  31312,
  38724,
  329975,
  642,
  3155,
  34497,
  75937,
  6207,
  73843,
  6120,
  17249,
  51429,
  117746,
  3218,
  910,
  68961,
  319671,
  14938,
  29555,
  34700,
  1649,
  66673,
  72268,
  9655,
  76800,
  153087,
  6941,
  210168,
  27130,
  35398,
  1780,
  73242,
  3135,
  56689,
  19556,
  165307,
  8765,
  35967,
  121458,
  13333,
  70453,
  17350,
  117253,
  22265,
  13340,
  44265,
  39869,
  441,
  3742,
  135025,
  23581,
  33309,
  16543,
  17731,
  13291,
  157637,
  283005,
  21408,
  101360,
  63887,
  52312,
  83873,
  5338,
  233779,
  23759,
  186949,
  34531,
  177320,
  38069,
  156465,
  91004,
  19353,
  59852,
  68160,
  14891,
  1338,
  1072,
  29823,
  1950,
  28901,
  81407,
  313445,
  73038,
  84807,
  162348,
  240257,
  37162,
  138934,
  16111,
  58013,
  41253,
  102951,
  16457,
  96056,
  19541,
  56402,
  67217,
  41638,
  94381,
  89674,
  29481,
  37456,
  80815,
  151579,
  13937,
  13683,
  132537,
  19699,
  134545,
  67020,
  29816,
  222341,
  141235,
  427578,
  48868,
  129557,
  233342,
  23077,
  87871,
  16213,
  18728,
  16184,
  9469,
  37913,
  19680,
  2798,
  171356,
  178328,
  13216,
  50049,
  72690,
  71904,
  124644,
  55455,
  7504,
  29052,
  41036,
  266546,
  19899,
  30391,
  188755,
  8659,
  59469,
  16,
  104298,
  112943,
  53865,
  76203,
  138226,
  68857,
  139953,
  14125,
  107625,
  119795,
  173133,
  4398,
  50273,
  48808,
  54390,
  16466,
  122086,
  31835,
  67035,
  50971,
  48859,
  7508,
  46427,
  66477,
  73021,
  84615,
  39985,
  83076,
  46779,
  201569,
  53336,
  36443,
  60865,
  168164,
  143810,
  51393,
  25548,
  169307,
  32896,
  24485,
  38424,
  21837,
  29087,
  275813,
  51674,
  6714,
  64883,
  46169,
  187369,
  55186,
  76192,
  12852,
  12018,
  62134,
  31067,
  118303,
  16542,
  12125,
  10579,
  4928,
  26291,
  43854,
  7091,
  10946,
  253716,
  109062,
  39283,
  17261,
  113012,
  258512,
  47764,
  125126,
  32646,
  55892,
  80279,
  201623,
  149872,
  3192,
  385,
  1208,
  48750,
  5376,
  58738,
  22335,
  5427,
  82416,
  47811,
  32435,
  143086,
  38930,
  94128,
  59975,
  156037,
  37977,
  38224,
  62485,
  7698,
  50405,
  71027,
  16462,
  21559,
  136153,
  34131,
  107506,
  162069,
  63703,
  3101,
  215029,
  40407,
  4178,
  3774,
  9187,
  80019,
  17880,
  97926,
  67579,
  2600,
  18405,
  8351,
  47924,
  86638,
  70820,
  92206,
  86453,
  29610,
  42241,
  119200,
  3198,
  15466,
  67813,
  57863,
  35454,
  4779,
  99518,
  4649,
  104641,
  144269,
  33730,
  38073,
  65864,
  6838,
  109456,
  193298,
  154007,
  5623,
  45741,
  30846,
  182578,
  25573,
  157224,
  1543,
  58575,
  138703,
  146140,
  44971,
  49356,
  18275,
  59064,
  20300,
  13122,
  11848,
  24453,
  11973,
  9797,
  86843,
  2919,
  25530,
  49210,
  1130,
  161220,
  76788,
  75373,
  85604,
  34926,
  36014,
  17777,
  17255,
  51533,
  11676,
  92226,
  51845,
  119859,
  21525,
  5936,
  18507,
  28050,
  1140,
  31418,
  14857,
  34207,
  47859,
  10750,
  36382,
  32079,
  106909,
  59426,
  87757,
  38393,
  110042,
  15965,
  97104,
  33757,
  35344,
  97993,
  53979,
  33651,
  45407,
  41884,
  82515,
  173089,
  7177,
  58371,
  35365,
  47543,
  51927,
  35587,
  10670,
  23544,
  29306,
  84233,
  39976,
  76076,
  62097,
  9007,
  8668,
  28119,
  78281,
  120790,
  19835,
  143020,
  54968,
  18670,
  64959,
  20649,
  34469,
  42570,
  33001,
  136570,
  87796,
  120044,
  1106,
  58700,
  63951,
  127623,
  12805,
  83057,
  40212,
  31773,
  49850,
  7361,
  54336,
  347524,
  101314,
  23751,
  19569,
  48791,
  29174,
  49369,
  20467,
  7465,
  75842,
  38281,
  623,
  112457,
  60210,
  28849,
  51003,
  94720,
  6426,
  90047,
  85560,
  43761,
  3579,
  85105,
  34607,
  90410,
  118528,
  7224,
  42907,
  111163,
  18168,
  6960,
  161135,
  191298,
  5247,
  100584,
  127552,
  171568,
  20121,
  91173,
  12636,
  54615,
  20199,
  63730,
  98105,
  2396,
  40387,
  14438,
  125012,
  4765,
  33235,
  12865,
  45299,
  37728,
  82098,
  77872,
  114037,
  59253,
  19675,
  24838,
  398016,
  102561,
  11446,
  17069,
  57508,
  178277,
  65836,
  99941,
  26114,
  2585,
  271882,
  136866,
  50126,
  11027,
  155648,
  118367,
  14585,
  8910,
  123015,
  335383,
  40434,
  41016,
  53021,
  14439,
  87098,
  176860,
  201543,
  121888,
  2358,
  9286,
  5739,
  22666,
  54270,
  37884,
  169381,
  33984,
  93859,
  16124,
  89364,
  72207,
  51639,
  76366,
  99029,
  65812,
  2198,
  12147,
  174891,
  194289,
  6986,
  30252,
  88822,
  21284,
  11445,
  288337,
  160821,
  33034,
  100869,
  43852,
  25761,
  52882,
  1144,
  103809,
  1924,
  84458,
  86079,
  43411,
  13542,
  139276,
  18141,
  34978,
  41298,
  7276,
  26481,
  173800,
  33210,
  17951,
  142652,
  33616,
  33677,
  2210,
  19941,
  98568,
  2486,
  192414,
  80136,
  12058,
  235883,
  50963,
  249638,
  29572,
  27221,
  47034,
  6124,
  72107,
  63346,
  97620,
  158513,
  299699,
  40388,
  23235,
  37176,
  224244,
  198386,
  121323,
  67992,
  23827,
  63170,
  17838,
  106622,
  158590,
  26807,
  5345,
  23489,
  91891,
  55474,
  74834,
  37981,
  13058,
  5977,
  72552,
  34706,
  26828,
  145172,
  19904,
  21367,
  34043,
  960,
  77092,
  91381,
  4733,
  47446,
  7680,
  41697,
  5170,
  16960,
  14741,
  46101,
  13656,
  473,
  51842,
  37433,
  11103,
  11551,
  121951,
  13191,
  97536,
  165932,
  50397,
  51628,
  129028,
  9069,
  44885,
  6590,
  59195,
  47045,
  32940,
  225472,
  90345,
  21833,
  13303,
  29407,
  96615,
  141951,
  5198,
  6028,
  18395,
  7181,
  3861,
  14966,
  156358,
  167182,
  36529,
  55253,
  25942,
  173153,
  30959,
  27261,
  50691,
  150176,
  162201,
  38467,
  48462,
  80602,
  42163,
  118482,
  168,
  108756,
  26011,
  17166,
  54149,
  456538,
  22512,
  91374,
  13816,
  90358,
  131615,
  18132,
  226707,
  1824,
  28139,
  26860,
  42253,
  93877,
  77351,
  65575,
  8980,
  80574,
  22020,
  27948,
  40422,
  91324,
  76376,
  13528,
  39281,
  91685,
  82215,
  122541,
  144066,
  1983,
  193851,
  17283,
  26320,
  2739,
  194978,
  4790,
  26845,
  42627,
  61300,
  65815,
  174612,
  55133,
  4200,
  191130,
  79771,
  158321,
  52280,
  166796,
  221620,
  62461,
  11278,
  4067,
  88152,
  83409,
  31717,
  121367,
  13522,
  47325,
  37945,
  10406,
  174348,
  249321,
  154101,
  64912,
  29938,
  51775,
  17220,
  15776,
  166138,
  78890,
  84425,
  54121,
  42861,
  16368,
  24572,
  291647,
  10197,
  32073,
  22651,
  11677,
  97509,
  26952,
  35787,
  18424,
  41910,
  71614,
  94977,
  72318,
  41594,
  70024,
  275419,
  37702,
  60199,
  7335,
  39107,
  61315,
  18271,
  18394,
  33768,
  87884,
  104277,
  123724,
  7277,
  56288,
  71981,
  189803,
  49320,
  3352,
  6798,
  14240,
  8954,
  69220,
  94433,
  57372,
  28620,
  68863,
  193727,
  85575,
  42309,
  41667,
  67689,
  42081,
  22543,
  44824,
  12719,
  28540,
  114236,
  101553,
  27638,
  27296,
  4300,
  5353,
  4663,
  19379,
  94098,
  3758,
  95888,
  95144,
  80344,
  87320,
  28447,
  259518,
  12718,
  71391,
  152731,
  37063,
  24132,
  31911,
  104896,
  15672,
  103782,
  1521,
  4945,
  72541,
  23717,
  122632,
  15619,
  87175,
  206120,
  29428,
  189780,
  61416,
  28350,
  44457,
  972,
  1175,
  47233,
  198738,
  95789,
  41907,
  21953,
  97034,
  59341,
  22864,
  53713,
  16873,
  32971,
  20693,
  20954,
  31336,
  21477,
  16169,
  38370,
  16412,
  9019,
  3841,
  24599,
  21938,
  17085,
  6484,
  81198,
  76413,
  5849,
  72514,
  12320,
  65247,
  276175,
  37234,
  59796,
  52642,
  16312,
  57349,
  198507,
  94148,
  46134,
  18958,
  125552,
  1747,
  18725,
  151873,
  14901,
  5490,
  68287,
  29470,
  3689,
  64794,
  40814,
  26018,
  25692,
  54450,
  2703,
  88278,
  124886,
  173087,
  174e3,
  24159,
  179477,
  24276,
  46004,
  201876,
  209202,
  445,
  52876,
  31948,
  30206,
  157610,
  39180,
  18439,
  44124,
  50469,
  5774,
  96278,
  222758,
  200216,
  50290,
  45486,
  20435,
  46986,
  46276,
  140133,
  142326,
  15569,
  13363,
  47522,
  92583,
  2182,
  7135,
  16853,
  22998,
  30272,
  4952,
  63263,
  35623,
  39096,
  53789,
  44864,
  20053,
  110392,
  124213,
  4630,
  16087,
  28221,
  127787,
  25839,
  77481,
  44693,
  13464,
  113146,
  6983,
  27069,
  55717,
  50102,
  4760,
  7107,
  26186,
  66507,
  59145,
  36032,
  104182,
  71328,
  29425,
  64317,
  50781,
  47465,
  94298,
  69706,
  74899,
  22754,
  120756,
  25108,
  93077,
  56834,
  73286,
  39928,
  16218,
  41699,
  176763,
  7555,
  70819,
  50083,
  26895,
  23315,
  26014,
  16773,
  123079,
  41712,
  5719,
  31516,
  90427,
  158540,
  85051,
  183128,
  40864,
  27505,
  55392,
  9058,
  45224,
  96857,
  30901,
  136622,
  96557,
  56304,
  120061,
  11501,
  151448,
  5773,
  89743,
  7769,
  86069,
  2935,
  18471,
  41628,
  10114,
  33660,
  110170,
  49479,
  26745,
  92846,
  33221,
  26731,
  18795,
  87076,
  8550,
  2100,
  29972,
  120289,
  3077,
  72490,
  33784,
  2630,
  208722,
  50861,
  63483,
  79029,
  6419,
  39467,
  14302,
  45286,
  64207,
  9686,
  67513,
  44170,
  1050,
  77246,
  59266,
  17055,
  53801,
  7150,
  11111,
  42432,
  4278,
  94579,
  362117,
  36175,
  42902,
  41933,
  39002,
  98489,
  22913,
  74161,
  84773,
  57036,
  17556,
  162288,
  74485,
  178760,
  93867,
  73635,
  128860,
  50362,
  261,
  67455,
  80001,
  46080,
  35662,
  4368,
  25247,
  19230,
  74393,
  22588,
  1822,
  27682,
  235324,
  13798,
  85998,
  13194,
  235067,
  23514,
  71669,
  147632,
  23191,
  134748,
  214683,
  105101,
  1518,
  25489,
  247114,
  7380,
  54842,
  26922,
  3971,
  26361,
  20844,
  68642,
  170517,
  77339,
  123255,
  8963,
  77818,
  150998,
  48466,
  36806,
  2732,
  23261,
  11741,
  236162,
  18243,
  126216,
  28690,
  50546,
  16385,
  92760,
  197383,
  246558,
  201295,
  88255,
  67588,
  71687,
  176076,
  172653,
  169058,
  33906,
  63747,
  24835,
  157621,
  43338,
  30050,
  46152,
  132741,
  2770,
  51371,
  94835,
  6614,
  15112,
  11749,
  56936,
  1250,
  19027,
  399017,
  58036,
  100215,
  23388,
  55815,
  308768,
  124152,
  94803,
  9521,
  64186,
  8971,
  28,
  30427,
  62163,
  7616,
  103838,
  35079,
  29203,
  131235,
  7743,
  17389,
  10882,
  37420,
  61460,
  228512,
  85363,
  41581,
  131077,
  62822,
  119647,
  10130,
  54445,
  26925,
  19968,
  29016,
  24446,
  74028,
  24176,
  61448,
  67185,
  9254,
  8563,
  119129,
  9771,
  99184,
  37716,
  39514,
  10532,
  221512,
  258753,
  218630,
  55980,
  23394,
  32141,
  61924,
  66749,
  32411,
  3741,
  36475,
  26678,
  77010,
  44946,
  91203,
  128749,
  116953,
  20476,
  49625,
  53116,
  13735,
  102335,
  29376,
  51946,
  83407,
  67892,
  59212,
  34685,
  21083,
  1546,
  112982,
  32972,
  74397,
  1078,
  190545,
  16082,
  86140,
  58591,
  89611,
  101531,
  10061,
  105104,
  76319,
  20035,
  17551,
  52611,
  169061,
  190842,
  100780,
  23907,
  90413,
  115619,
  9675,
  34710,
  193435,
  49443,
  129734,
  11183,
  258877,
  16318,
  136182,
  126808,
  44635,
  27304,
  192375,
  2599,
  125648,
  47051,
  12091,
  23814,
  721,
  58800,
  40137,
  66726,
  97930,
  60877,
  74487,
  7942,
  54326,
  9841,
  41428,
  13762,
  8211,
  85383,
  6950,
  99177,
  79806,
  201786,
  296464,
  124087,
  13144,
  29741,
  41721,
  47634,
  55088,
  254286,
  106408,
  17041,
  99064,
  12942,
  64086,
  45233,
  14005,
  2612,
  55827,
  255,
  7984,
  13980,
  38574,
  12776,
  46654,
  73499,
  249951,
  2101,
  26676,
  25996,
  132326,
  116415,
  119062,
  50449,
  31033,
  23038,
  11589,
  179252,
  20007,
  14860,
  129270,
  21143,
  17796,
  144715,
  60106,
  70758,
  69842,
  34674,
  282133,
  44014,
  16774,
  57268,
  38528,
  24053,
  46373,
  201667,
  28327,
  471023,
  51889,
  102667,
  21193,
  114909,
  84132,
  69317,
  96723,
  67969,
  16134,
  68145,
  15058,
  28765,
  32035,
  2524,
  101089,
  98664,
  25045,
  76571,
  14957,
  86040,
  118506,
  262428,
  154764,
  81573,
  39681,
  283900,
  73287,
  127825,
  544,
  80448,
  52347,
  38512,
  175971,
  15180,
  45467,
  33086,
  46552,
  48894,
  81107,
  43213,
  36672,
  54025,
  76703,
  8053,
  7608,
  13299,
  56619,
  20752,
  238099,
  54164,
  105133,
  1444,
  32942,
  953,
  37564,
  8e3,
  66316,
  119463,
  106817,
  404,
  13667,
  149108,
  128597,
  31267,
  10269,
  49836,
  106150,
  1484,
  52330,
  76965,
  160486,
  171648,
  38456,
  31263,
  22424,
  37738,
  66245,
  67467,
  143369,
  60471,
  75610,
  20895,
  115528,
  86070,
  60854,
  40796,
  49347,
  18989,
  15030,
  11371,
  37578,
  15779,
  79867,
  10187,
  86462,
  46402,
  155626,
  93200,
  40229,
  7090,
  57547,
  108053,
  99598,
  11088,
  47505,
  41218,
  206017,
  2173,
  20988,
  30219,
  22919,
  80563,
  57566,
  42369,
  93141,
  41675,
  2407,
  182519,
  120495,
  27154,
  16702,
  29456,
  14349,
  7958,
  16688,
  117177,
  140375,
  42467,
  261919,
  74916,
  153569,
  10836,
  34742,
  49526,
  7621,
  105997,
  12212,
  2270,
  392377,
  7755,
  17959,
  25086,
  232152,
  138791,
  33847,
  13860,
  35316,
  5811,
  1344,
  71259,
  50452,
  207539,
  92635,
  50359,
  5821,
  33674,
  30255,
  2086,
  2587,
  96264,
  17543,
  42,
  6029,
  9580,
  43007,
  139248,
  82831,
  12917,
  29607,
  25786,
  51467,
  42137,
  85161,
  100698,
  31561,
  88989,
  121990,
  278500,
  3602,
  109344,
  37982,
  15279,
  116442,
  28936,
  30880,
  87894,
  58079,
  128661,
  126731,
  67392,
  28051,
  146885,
  4861,
  16216,
  97344,
  42827,
  147561,
  153948,
  22684,
  21335,
  47685,
  1853,
  43349,
  15185,
  59642,
  10229,
  25520,
  187921,
  108972,
  5579,
  98037,
  24945,
  6697,
  19193,
  63734,
  137934,
  75056,
  89740,
  19767,
  224268,
  56138,
  63643,
  151661,
  39313,
  70618,
  84031,
  89723,
  84074,
  13703,
  85626,
  35460,
  8867,
  64845,
  3439,
  57906,
  99776,
  63968,
  49270,
  81130,
  34356,
  16210,
  23547,
  36446,
  34090,
  140028,
  72439,
  2221,
  22163,
  57058,
  363492,
  113754,
  18913,
  95451,
  48663,
  54464,
  54037,
  176097,
  68425,
  3023,
  34906,
  29482,
  117389,
  341780,
  80431,
  58330,
  16753,
  92616,
  60907,
  94846,
  147486,
  4498,
  48646,
  7773,
  46801,
  7778,
  18946,
  464978,
  47558,
  33223,
  177444,
  7328,
  15626,
  63337,
  94700,
  11743,
  9351,
  255024,
  39098,
  16447,
  42647,
  96230,
  39769,
  58840,
  10068,
  63439,
  35800,
  65843,
  58823,
  413844,
  9156,
  51258,
  7434,
  61791,
  85018,
  6872,
  3692,
  28096,
  7121,
  33024,
  6009,
  75532,
  31997,
  192535,
  9661,
  3304,
  9547,
  14753,
  31987,
  25314,
  55689,
  15896,
  20430,
  39472,
  31340,
  99744,
  25398,
  115569,
  54883,
  28719,
  205423,
  23071,
  57855,
  64638,
  149867,
  25671,
  82403,
  37616,
  20668,
  39989,
  77996,
  74948,
  140555,
  175248,
  64810,
  36515,
  46595,
  4958,
  248773,
  24045,
  28728,
  136673,
  168704,
  20804,
  114833,
  100325,
  27135,
  21205,
  96151,
  153134,
  45992,
  7093,
  13992,
  76047,
  1980,
  19432,
  145001,
  75159,
  87462,
  17710,
  1013,
  45556,
  34297,
  144882,
  20648,
  26061,
  11319,
  129567,
  108555,
  18872,
  464580,
  33386,
  22717,
  65948,
  167189,
  5603,
  135042,
  79542,
  8801,
  202632,
  18114,
  91882,
  5973,
  5239,
  67315,
  4431,
  60916,
  47819,
  71693,
  32597,
  32606,
  18183,
  45072,
  80329,
  76385,
  24749,
  51305,
  40314,
  156514,
  14693,
  130345,
  13168,
  66214,
  18029,
  12858,
  34801,
  27628,
  14544,
  10823,
  40522,
  40185,
  33739,
  148694,
  23548,
  9923,
  61012,
  28859,
  17933,
  19442,
  34364,
  99849,
  164107,
  141167,
  30629,
  21054,
  6744,
  36491,
  8096,
  42474,
  41706,
  155060,
  30650,
  10600,
  163442,
  1143,
  96655,
  61390,
  52359,
  7559,
  51568,
  64256,
  203854,
  4467,
  22453,
  14504,
  436398,
  7878,
  6980,
  8293,
  63610,
  293747,
  16167,
  35763,
  19627,
  147603,
  15419,
  18032,
  110744,
  51346,
  33681,
  54571,
  40472,
  48615,
  39073,
  21604,
  13754,
  173027,
  92560,
  11083,
  47299,
  63062,
  11813,
  52007,
  29883,
  9734,
  139722,
  15953,
  1550,
  20651,
  13616,
  49306,
  16113,
  90089,
  92326,
  7584,
  30712,
  72424,
  164858,
  6831,
  152871,
  55746,
  197721,
  34167,
  196442,
  6022,
  112107,
  55215,
  7538,
  123381,
  4920,
  43539,
  77165,
  8939,
  50392,
  34192,
  20225,
  79762,
  22505,
  58667,
  40770,
  29788,
  97180,
  82835,
  4568,
  8579,
  13273,
  363569,
  35898,
  49983,
  436,
  36598,
  3237,
  131691,
  62418,
  35591,
  8101,
  4073,
  379438,
  65218,
  76072,
  33887,
  2968,
  27573,
  212619,
  288680,
  68278,
  72851,
  150504,
  217896,
  6913,
  121339,
  22017,
  35340,
  51072,
  43616,
  75043,
  31437,
  10833,
  81487,
  4364,
  22968,
  41454,
  106687,
  85446,
  19863,
  109625,
  149241,
  524,
  141850,
  214404,
  54376,
  657,
  237023,
  9401,
  108137,
  53800,
  32474,
  49712,
  53334,
  126876,
  27337,
  45552,
  177696,
  8269,
  15036,
  12097,
  42240,
  2328,
  125374,
  119295,
  99715,
  2500,
  19624,
  39441,
  27220,
  102691,
  60957,
  94543,
  39101,
  18566,
  67362,
  13975,
  78230,
  25017,
  34017,
  239007,
  90027,
  39351,
  41681,
  35354,
  43822,
  1043,
  916,
  58587,
  141983,
  94818,
  38799,
  75459,
  41114,
  67432,
  16195,
  36606,
  59568,
  22272,
  126769,
  31424,
  68659,
  12287,
  134302,
  257977,
  5756,
  207285,
  95637,
  47248,
  117689,
  19583,
  77451,
  22373,
  12200,
  54993,
  117118,
  34244,
  29386,
  34562,
  53819,
  71267,
  64172,
  77665,
  49368,
  7716,
  59301,
  25749,
  45426,
  194789,
  17297,
  2650,
  1766,
  32501,
  45198,
  20403,
  20984,
  6600,
  14171,
  94604,
  19037,
  5402,
  29896,
  9938,
  59935,
  109708,
  88081,
  145182,
  44844,
  39167,
  352626,
  164173,
  35374,
  45982,
  6122,
  154,
  73419,
  220487,
  53834,
  53601,
  17992,
  8609,
  229321,
  5610,
  68098,
  66815,
  71012,
  95069,
  140968,
  27396,
  8957,
  134489,
  24656,
  86659,
  56598,
  134852,
  17316,
  123838,
  255436,
  6613,
  41610,
  138033,
  81452,
  32023,
  32396,
  123687,
  63398,
  8693,
  29712,
  30407,
  19296,
  121188,
  3551,
  36099,
  20032,
  111948,
  56624,
  16547,
  27453,
  35916,
  15378,
  52039,
  56849,
  13489,
  22214,
  73177,
  53097,
  277349,
  2157,
  14029,
  187886,
  10260,
  141743,
  246460,
  91880,
  50869,
  3788,
  49486,
  133566,
  54950,
  33120,
  129337,
  53768,
  18333,
  9525,
  26902,
  312251,
  10297,
  9020,
  70759,
  16647,
  112432,
  59260,
  84609,
  9818,
  82766,
  73569,
  468,
  46001,
  75780,
  55028,
  52106,
  11498,
  43645,
  108069,
  17150,
  17753,
  29417,
  16705,
  31799,
  9606,
  289,
  122254,
  115975,
  8620,
  6133,
  255357,
  56908,
  14456,
  133464,
  43554,
  79224,
  11247,
  29630,
  160,
  12756,
  25464,
  65960,
  350428,
  62521,
  321796,
  100359,
  67358,
  35169,
  46172,
  113128,
  48988,
  88868,
  31094,
  33266,
  6847,
  60887,
  98188,
  49659,
  69117,
  92977,
  220228,
  13947,
  80181,
  35103,
  62170,
  97351,
  13475,
  2440,
  199768,
  19498,
  36597,
  46971,
  25234,
  67806,
  62881,
  84717,
  73648,
  181966,
  10488,
  94149,
  21550,
  26655,
  63436,
  48375,
  14405,
  165650,
  9621,
  24439,
  28043,
  42735,
  4490,
  29963,
  56674,
  45373,
  1934,
  262446,
  50855,
  67098,
  26898,
  5261,
  52696,
  40644,
  33900,
  9440,
  180286,
  87162,
  22940,
  19704,
  26936,
  69769,
  10254,
  101759,
  27406,
  12243,
  48e3,
  73926,
  113215,
  54935,
  5726,
  192787,
  4312,
  106216,
  9366,
  11550,
  52949,
  23457,
  212271,
  277152,
  133895,
  108374,
  6191,
  96477,
  29980,
  218916,
  58024,
  54696,
  40853,
  91124,
  65894,
  91170,
  65908,
  252552,
  6793,
  29212,
  15389,
  44516,
  122515,
  52617,
  35058,
  9017,
  103536,
  39510,
  49136,
  19242,
  130652,
  662077,
  74699,
  47024,
  31422,
  8517,
  73351,
  24399,
  13867,
  128360,
  4810,
  4434,
  61779,
  111983,
  61036,
  17798,
  110240,
  59722,
  102960,
  39688,
  10001,
  23803,
  23039,
  176498,
  56659,
  44814,
  134295,
  17188,
  77577,
  74466,
  226175,
  102472,
  154333,
  63900,
  111747,
  18062,
  41171,
  79669,
  32773,
  408933,
  42562,
  28931,
  30907,
  107388,
  43487,
  2946,
  240310,
  23938,
  24354,
  319,
  184983,
  7927,
  6488,
  1422,
  10790,
  68809,
  68209,
  64775,
  4361,
  202,
  17123,
  59634,
  51200,
  44391,
  18188,
  17843,
  2619,
  74278,
  3230,
  9540,
  47187,
  21702,
  36274,
  56894,
  43907,
  16310,
  34790,
  16866,
  6150,
  5561,
  13587,
  107545,
  108873,
  126867,
  86986,
  28640,
  33427,
  19017,
  5762,
  80637,
  17430,
  46903,
  2047,
  131055,
  25958,
  13558,
  5444,
  47152,
  13900,
  44563,
  122857,
  45348,
  70863,
  39593,
  54332,
  38068,
  33637,
  318,
  40310,
  143467,
  18502,
  24520,
  11377,
  62013,
  28942,
  27246,
  28269,
  83545,
  17999,
  59015,
  90707,
  30065,
  15161,
  34720,
  1263,
  37008,
  2012,
  6060,
  98575,
  92933,
  5721,
  299,
  199555,
  24578,
  29223,
  2985,
  743,
  115825,
  109523,
  136657,
  47454,
  26378,
  53586,
  3733,
  174945,
  93340,
  244456,
  5693,
  37386,
  28782,
  89767,
  27545,
  23573,
  18798,
  136425,
  34320,
  84778,
  20041,
  48453,
  38215,
  7477,
  71958,
  40621,
  8773,
  5874,
  187927,
  105965,
  51100,
  43533,
  18083,
  8443,
  10180,
  43597,
  2003,
  183999,
  69689,
  12216,
  129696,
  146188,
  62389,
  34044,
  68410,
  12765,
  43273,
  26949,
  266807,
  3345,
  34477,
  79197,
  5688,
  47539,
  213110,
  21634,
  22257,
  50092,
  32222,
  42346,
  39530,
  63668,
  98,
  134978,
  74022,
  5152,
  59088,
  174145,
  37220,
  9934,
  9545,
  118937,
  5724,
  87240,
  19875,
  15784,
  40143,
  23263,
  87513,
  181654,
  285152,
  37881,
  263241,
  4966,
  43934,
  10433,
  186657,
  6470,
  74416,
  225854,
  25908,
  142677,
  246262,
  32280,
  6192,
  75890,
  45546,
  143264,
  135305,
  29742,
  47013,
  77787,
  11732,
  126658,
  8763,
  37950,
  21806,
  57557,
  113464,
  89465,
  108995,
  164574,
  23894,
  22996,
  23169,
  15369,
  23117,
  17642,
  130607,
  40503,
  36239,
  280990,
  44666,
  9981,
  40427,
  147487,
  26869,
  168452,
  32886,
  32991,
  46798,
  240839,
  15111,
  70502,
  65697,
  88548,
  44145,
  28701,
  48767,
  31139,
  206777,
  35659,
  181164,
  166262,
  14554,
  171445,
  31786,
  66523,
  76607,
  17956,
  6507,
  31279,
  90476,
  116611,
  167918,
  6560,
  1243,
  115324,
  80128,
  41867,
  55897,
  187323,
  37069,
  32596,
  189444,
  145931,
  13390,
  105530,
  65709,
  26805,
  6999,
  55714,
  41300,
  22915,
  68951,
  22138,
  21120,
  22264,
  10058,
  19945,
  33635,
  56123,
  99085,
  10032,
  5818,
  6016,
  46649,
  57476,
  35264,
  94413,
  112522,
  262288,
  93686,
  83038,
  14341,
  23204,
  28807,
  66084,
  77987,
  6101,
  126673,
  7133,
  38126,
  5923,
  122091,
  170240,
  97772,
  46874,
  215746,
  43948,
  41622,
  3272,
  55596,
  8332,
  146411,
  251315,
  13533,
  8561,
  81521,
  115449,
  48616,
  175175,
  2063,
  186556,
  3036,
  134537,
  75772,
  29728,
  82360,
  22973,
  186559,
  86348,
  89100,
  38388,
  82297,
  45610,
  2613,
  87082,
  9986,
  177812,
  57884,
  23591,
  47485,
  42543,
  33582,
  44713,
  74439,
  257444,
  252451,
  31825,
  35631,
  38540,
  33066,
  5147,
  13973,
  4343,
  51830,
  70378,
  22827,
  26448,
  95560,
  36896,
  241741,
  48067,
  203953,
  298860,
  61620,
  20450,
  3220,
  67272,
  6586,
  107662,
  100160,
  108684,
  6929,
  57226,
  4762,
  7457,
  1320,
  40404,
  77204,
  99309,
  62750,
  208653,
  59977,
  44e3,
  74315,
  34332,
  5819,
  172217,
  64904,
  114077,
  18147,
  84012,
  1791,
  98456,
  90930,
  21446,
  116669,
  103938,
  7422,
  85140,
  59713,
  5768,
  326211,
  16239,
  75411,
  13229,
  29398,
  10758,
  236107,
  1539,
  112472,
  95979,
  152154,
  151294,
  306,
  21196,
  38146,
  10700,
  6891,
  84282,
  109646,
  56492,
  40539,
  6589,
  119491,
  51354,
  30685,
  140209,
  136906,
  29622,
  73617,
  49553,
  70525,
  51671,
  166869,
  139616,
  74395,
  37439,
  49595,
  45678,
  11959,
  33211,
  86560,
  52434,
  9282,
  62690,
  112155,
  130810,
  5243,
  108261,
  99970,
  265613,
  72551,
  80049,
  6391,
  33365,
  90721,
  66737,
  69872,
  87011,
  1860,
  9032,
  112544,
  60905,
  37371,
  89015,
  140351,
  19076,
  850,
  373531,
  2802,
  36725,
  218795,
  72062,
  28990,
  16550,
  24614,
  7815,
  6187,
  26336,
  33373,
  32162,
  42791,
  73555,
  32062,
  23386,
  10244,
  56392,
  49442,
  27076,
  136262,
  12412,
  14883,
  1134,
  33675,
  97153,
  199281,
  15608,
  100152,
  74072,
  47942,
  254301,
  36451,
  16026,
  10687,
  65067,
  56708,
  254030,
  30290,
  50490,
  13864,
  57941,
  259331,
  35588,
  23485,
  43486,
  24869,
  21620,
  92971,
  22072,
  88645,
  1048,
  182050,
  13343,
  32452,
  14825,
  19509,
  3325,
  216938,
  45740,
  99716,
  189082,
  53740,
  78245,
  25609,
  24311,
  176777,
  47340,
  308354,
  40669,
  66085,
  14102,
  125339,
  9225,
  128709,
  97207,
  1271,
  200933,
  78439,
  113451,
  88975,
  18324,
  46521,
  11819,
  18570,
  141756,
  72512,
  170020,
  52754,
  63550,
  118515,
  103073,
  93330,
  32736,
  50499,
  14722,
  31600,
  68452,
  398867,
  29316,
  172786,
  18417,
  104924,
  2606,
  5670,
  84818,
  16288,
  67106,
  59580,
  82929,
  607401,
  291,
  85829,
  359,
  15897,
  35830,
  50696,
  65630,
  52672,
  22115,
  356968,
  29895,
  40837,
  231192,
  34024,
  38957,
  26722,
  406,
  23335,
  124952,
  72068,
  68804,
  13268,
  147101,
  164740,
  276569,
  162596,
  66943,
  11569,
  26654,
  66358,
  4777,
  23229,
  102127,
  5848,
  978,
  2921,
  59666,
  5371,
  28212,
  90108,
  42938,
  39320,
  2499,
  4271,
  108792,
  33510,
  125072,
  71653,
  65239,
  38250,
  66357,
  38577,
  13964,
  86251,
  35708,
  50755,
  36010,
  29448,
  12209,
  3844,
  38222,
  206337,
  100876,
  67827,
  137088,
  14167,
  252225,
  84163,
  195270,
  1306,
  5703,
  54198,
  779,
  46802,
  22028,
  51124,
  86759,
  70560,
  113164,
  35685,
  162145,
  45471,
  34561,
  422,
  2611,
  6464,
  47486,
  19223,
  38246,
  9191,
  18331,
  89942,
  243642,
  212364,
  15893,
  17518,
  22617,
  6409,
  30046,
  126182,
  59716,
  36560,
  104428,
  18846,
  26592,
  19458,
  50793,
  147333,
  30826,
  1388,
  27647,
  10922,
  14495,
  33545,
  19269,
  135828,
  39727,
  41601,
  46931,
  233379,
  49169,
  131130,
  182112,
  16276,
  82381,
  118209,
  142445,
  128310,
  19672,
  28740,
  82907,
  33436,
  3118,
  102206,
  28723,
  24819,
  41937,
  38854,
  5157,
  3881,
  111491,
  1142,
  9776,
  421673,
  152241,
  29309,
  14961,
  87854,
  6054,
  15424,
  3796,
  82656,
  54996,
  2108,
  55367,
  239450,
  154525,
  9643,
  118103,
  106041,
  64601,
  68549,
  48707,
  30266,
  25772,
  18740,
  9462,
  229669,
  91798,
  112152,
  191327,
  14493,
  72828,
  8175,
  66636,
  236474,
  25817,
  87351,
  129027,
  76653,
  20422,
  22983,
  71240,
  27846,
  44661,
  12399,
  46158,
  77704,
  53101,
  35032,
  11072,
  17300,
  109294,
  33638,
  24408,
  1895,
  11241,
  760,
  17584,
  82479,
  125877,
  63150,
  141075,
  34259,
  23274,
  81698,
  15732,
  43577,
  48340,
  91584,
  14688,
  16379,
  24481,
  150280,
  96420,
  262050,
  48635,
  43727,
  61819,
  56268,
  72003,
  88178,
  17281,
  79912,
  13218,
  122519,
  125295,
  166396,
  11811,
  2171,
  118930,
  67746,
  17636,
  178278,
  174656,
  95661,
  173039,
  83845,
  79689,
  17473,
  98555,
  127696,
  203415,
  54730,
  22925,
  232239,
  9309,
  12136,
  175026,
  20740,
  180188,
  10747,
  39816,
  314017,
  266131,
  10040,
  175732,
  112550,
  220651,
  31974,
  37393,
  888,
  23008,
  86799,
  4303,
  64905,
  148467,
  75337,
  251,
  3284,
  370102,
  50264,
  9835,
  5438,
  23655,
  4481,
  29851,
  329,
  12855,
  7162,
  64931,
  78141,
  12804,
  42372,
  296771,
  83547,
  18624,
  34874,
  86271,
  3360,
  48665,
  77735,
  88767,
  11463,
  63527,
  28889,
  22258,
  29140,
  194315,
  113924,
  25499,
  6406,
  31334,
  1845,
  4802,
  49184,
  43455,
  35469,
  127594,
  92970,
  61038,
  115005,
  38840,
  87761,
  106838,
  8811,
  20572,
  55637,
  11162,
  96721,
  132425,
  108925,
  2948,
  125457,
  36356,
  3502,
  75270,
  27622,
  127192,
  2561,
  123095,
  49394,
  61155,
  16897,
  110064,
  9699,
  89448,
  53356,
  19628,
  220310,
  21622,
  83036,
  9885,
  112214,
  6087,
  26713,
  17901,
  161912,
  91492,
  3440,
  68594,
  9266,
  92238,
  8087,
  6866,
  150194,
  72175,
  80701,
  13459,
  31836,
  43243,
  239700,
  95846,
  44749,
  50647,
  21945,
  230538,
  120612,
  132371,
  244604,
  5193,
  105637,
  34661,
  41341,
  68775,
  85393,
  1874,
  8771,
  33718,
  49672,
  77403,
  595452,
  99507,
  6490,
  58895,
  128742,
  7704,
  39239,
  73217,
  43816,
  62824,
  37804,
  199976,
  22361,
  80005,
  87514,
  94832,
  14089,
  4574,
  139975,
  59142,
  75523,
  100268,
  43906,
  53442,
  15152,
  2547,
  186002,
  17011,
  19513,
  204282,
  3343,
  60568,
  128318,
  119250,
  4298,
  51871,
  41336,
  71759,
  21921,
  45074,
  98169,
  145889,
  99427,
  11350,
  1237,
  5520,
  28799,
  7803,
  53702,
  21026,
  136352,
  38293,
  128690,
  12158,
  90132,
  44600,
  10184,
  26957,
  39459,
  126025,
  78904,
  82999,
  59373,
  39301,
  150198,
  120529,
  153042,
  20177,
  50089,
  14764,
  271571,
  30530,
  123161,
  38975,
  101562,
  22941,
  5648,
  124654,
  109243,
  69817,
  71675,
  49162,
  106884,
  21241,
  107795,
  30258,
  16572,
  188262,
  141456,
  7688,
  60718,
  8271,
  11044,
  32440,
  104608,
  103419,
  236109,
  93156,
  43293,
  128929,
  42107,
  67180,
  25201,
  115254,
  185488,
  130954,
  72813,
  167547,
  20537,
  39969,
  38432,
  22582,
  184022,
  1139,
  27199,
  5655,
  17767,
  97412,
  122606,
  209377,
  27070,
  35871,
  326617,
  188954,
  42680,
  73512,
  80911,
  22629,
  3011,
  95021,
  315242,
  157737,
  383,
  41821,
  41808,
  19335,
  27950,
  15674,
  25677,
  110950,
  35375,
  76835,
  59108,
  57370,
  35262,
  16569,
  160415,
  37706,
  78086,
  32041,
  49691,
  137143,
  9782,
  172080,
  50148,
  77917,
  6323,
  10110,
  69172,
  17711,
  21795,
  59511,
  76184,
  135114,
  31046,
  132319,
  59105,
  157578,
  20549,
  80778,
  57649,
  158421,
  65143,
  4575,
  72235,
  21899,
  10797,
  92745,
  34035,
  106079,
  80159,
  4508,
  78304,
  25350,
  75457,
  46458,
  32937,
  25623,
  47,
  8531,
  104751,
  84953,
  8138,
  36508,
  187199,
  66310,
  115274,
  13253,
  32461,
  38536,
  1916,
  42007,
  187160,
  35055,
  26325,
  84394,
  35963,
  94216,
  45590,
  97782
];
var import_timeout_abort_controller13 = __toESM(require_timeout_abort_controller(), 1);
var MAX_COMMON_PREFIX_LENGTH = 15;
var RoutingTableRefresh = class {
  constructor(init) {
    const { peerRouting, routingTable, refreshInterval, refreshQueryTimeout, lan } = init;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:routing-table:refresh`);
    this.peerRouting = peerRouting;
    this.routingTable = routingTable;
    this.refreshInterval = refreshInterval ?? TABLE_REFRESH_INTERVAL;
    this.refreshQueryTimeout = refreshQueryTimeout ?? TABLE_REFRESH_QUERY_TIMEOUT;
    this.commonPrefixLengthRefreshedAt = [];
    this.refreshTable = this.refreshTable.bind(this);
  }
  async start() {
    this.log(`refreshing routing table every ${this.refreshInterval}ms`);
    this.refreshTable(true);
  }
  async stop() {
    if (this.refreshTimeoutId != null) {
      clearTimeout(this.refreshTimeoutId);
    }
  }
  /**
   * To speed lookups, we seed the table with random PeerIds. This means
   * when we are asked to locate a peer on the network, we can find a KadId
   * that is close to the requested peer ID and query that, then network
   * peers will tell us who they know who is close to the fake ID
   */
  refreshTable(force = false) {
    this.log("refreshing routing table");
    const prefixLength = this._maxCommonPrefix();
    const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);
    this.log(`max common prefix length ${prefixLength}`);
    this.log(`tracked CPLs [ ${refreshCpls.map((date) => date.toISOString()).join(", ")} ]`);
    Promise.all(refreshCpls.map(async (lastRefresh, index2) => {
      try {
        await this._refreshCommonPrefixLength(index2, lastRefresh, force);
        if (this._numPeersForCpl(prefixLength) === 0) {
          const lastCpl = Math.min(2 * (index2 + 1), refreshCpls.length - 1);
          for (let n = index2 + 1; n < lastCpl + 1; n++) {
            try {
              await this._refreshCommonPrefixLength(n, lastRefresh, force);
            } catch (err2) {
              this.log.error(err2);
            }
          }
        }
      } catch (err2) {
        this.log.error(err2);
      }
    })).catch((err2) => {
      this.log.error(err2);
    }).then(() => {
      this.refreshTimeoutId = setTimeout(this.refreshTable, this.refreshInterval);
      if (this.refreshTimeoutId.unref != null) {
        this.refreshTimeoutId.unref();
      }
    }).catch((err2) => {
      this.log.error(err2);
    });
  }
  async _refreshCommonPrefixLength(cpl, lastRefresh, force) {
    if (!force && lastRefresh.getTime() > Date.now() - this.refreshInterval) {
      this.log("not running refresh for cpl %s as time since last refresh not above interval", cpl);
      return;
    }
    const peerId = await this._generateRandomPeerId(cpl);
    this.log("starting refreshing cpl %s with key %p (routing table size was %s)", cpl, peerId, this.routingTable.size);
    const controller = new import_timeout_abort_controller13.TimeoutController(this.refreshQueryTimeout);
    try {
      const peers = await length(this.peerRouting.getClosestPeers(peerId.toBytes(), { signal: controller.signal }));
      this.log(`found ${peers} peers that were close to imaginary peer %p`, peerId);
      this.log("finished refreshing cpl %s with key %p (routing table size is now %s)", cpl, peerId, this.routingTable.size);
    } finally {
      controller.clear();
    }
  }
  _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {
    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {
      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;
    }
    const dates = [];
    for (let i2 = 0; i2 <= maxCommonPrefix; i2++) {
      dates[i2] = this.commonPrefixLengthRefreshedAt[i2] ?? new Date();
    }
    return dates;
  }
  async _generateRandomPeerId(targetCommonPrefixLength) {
    if (this.routingTable.kb == null) {
      throw new Error("Routing table not started");
    }
    const randomData = randomBytes$1(2);
    const randomUint16 = (randomData[1] << 8) + randomData[0];
    const key = await this._makePeerId(this.routingTable.kb.localNodeId, randomUint16, targetCommonPrefixLength);
    return peerIdFromBytes(key);
  }
  async _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {
    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {
      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);
    }
    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);
    const localPrefix = view.getUint16(0, false);
    const toggledLocalPrefix = localPrefix ^ 32768 >> targetCommonPrefixLength;
    const mask = 65535 << 16 - (targetCommonPrefixLength + 1);
    const targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask;
    const keyPrefix2 = generated_prefix_list_browser_default[targetPrefix];
    const keyBuffer = new ArrayBuffer(34);
    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);
    keyView.setUint8(0, sha256.code);
    keyView.setUint8(1, 32);
    keyView.setUint32(2, keyPrefix2, false);
    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);
  }
  /**
   * returns the maximum common prefix length between any peer in the table
   * and the current peer
   */
  _maxCommonPrefix() {
    let prefixLength = 0;
    for (const length3 of this._prefixLengths()) {
      if (length3 > prefixLength) {
        prefixLength = length3;
      }
    }
    return prefixLength;
  }
  /**
   * Returns the number of peers in the table with a given prefix length
   */
  _numPeersForCpl(prefixLength) {
    let count = 0;
    for (const length3 of this._prefixLengths()) {
      if (length3 === prefixLength) {
        count++;
      }
    }
    return count;
  }
  /**
   * Yields the common prefix length of every peer in the table
   */
  *_prefixLengths() {
    if (this.routingTable.kb == null) {
      return;
    }
    for (const { id } of this.routingTable.kb.toIterable()) {
      const distance = xor(this.routingTable.kb.localNodeId, id);
      let leadingZeros = 0;
      for (const byte of distance) {
        if (byte === 0) {
          leadingZeros++;
        } else {
          break;
        }
      }
      yield leadingZeros;
    }
  }
};
var import_err_code125 = __toESM(require_err_code(), 1);
var Record2;
(function(Record3) {
  let _codec;
  Record3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, writer2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer2.fork();
        }
        if (obj.key != null) {
          writer2.uint32(10);
          writer2.bytes(obj.key);
        }
        if (obj.value != null) {
          writer2.uint32(18);
          writer2.bytes(obj.value);
        }
        if (obj.author != null) {
          writer2.uint32(26);
          writer2.bytes(obj.author);
        }
        if (obj.signature != null) {
          writer2.uint32(34);
          writer2.bytes(obj.signature);
        }
        if (obj.timeReceived != null) {
          writer2.uint32(42);
          writer2.string(obj.timeReceived);
        }
        if (opts.lengthDelimited !== false) {
          writer2.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {};
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.key = reader3.bytes();
              break;
            case 2:
              obj.value = reader3.bytes();
              break;
            case 3:
              obj.author = reader3.bytes();
              break;
            case 4:
              obj.signature = reader3.bytes();
              break;
            case 5:
              obj.timeReceived = reader3.string();
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Record3.encode = (obj) => {
    return encodeMessage(obj, Record3.codec());
  };
  Record3.decode = (buf2) => {
    return decodeMessage(buf2, Record3.codec());
  };
})(Record2 || (Record2 = {}));
var Message;
(function(Message4) {
  (function(MessageType4) {
    MessageType4["PUT_VALUE"] = "PUT_VALUE";
    MessageType4["GET_VALUE"] = "GET_VALUE";
    MessageType4["ADD_PROVIDER"] = "ADD_PROVIDER";
    MessageType4["GET_PROVIDERS"] = "GET_PROVIDERS";
    MessageType4["FIND_NODE"] = "FIND_NODE";
    MessageType4["PING"] = "PING";
  })(Message4.MessageType || (Message4.MessageType = {}));
  let __MessageTypeValues;
  (function(__MessageTypeValues2) {
    __MessageTypeValues2[__MessageTypeValues2["PUT_VALUE"] = 0] = "PUT_VALUE";
    __MessageTypeValues2[__MessageTypeValues2["GET_VALUE"] = 1] = "GET_VALUE";
    __MessageTypeValues2[__MessageTypeValues2["ADD_PROVIDER"] = 2] = "ADD_PROVIDER";
    __MessageTypeValues2[__MessageTypeValues2["GET_PROVIDERS"] = 3] = "GET_PROVIDERS";
    __MessageTypeValues2[__MessageTypeValues2["FIND_NODE"] = 4] = "FIND_NODE";
    __MessageTypeValues2[__MessageTypeValues2["PING"] = 5] = "PING";
  })(__MessageTypeValues || (__MessageTypeValues = {}));
  (function(MessageType4) {
    MessageType4.codec = () => {
      return enumeration(__MessageTypeValues);
    };
  })(Message4.MessageType || (Message4.MessageType = {}));
  (function(ConnectionType2) {
    ConnectionType2["NOT_CONNECTED"] = "NOT_CONNECTED";
    ConnectionType2["CONNECTED"] = "CONNECTED";
    ConnectionType2["CAN_CONNECT"] = "CAN_CONNECT";
    ConnectionType2["CANNOT_CONNECT"] = "CANNOT_CONNECT";
  })(Message4.ConnectionType || (Message4.ConnectionType = {}));
  let __ConnectionTypeValues;
  (function(__ConnectionTypeValues2) {
    __ConnectionTypeValues2[__ConnectionTypeValues2["NOT_CONNECTED"] = 0] = "NOT_CONNECTED";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CONNECTED"] = 1] = "CONNECTED";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CAN_CONNECT"] = 2] = "CAN_CONNECT";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CANNOT_CONNECT"] = 3] = "CANNOT_CONNECT";
  })(__ConnectionTypeValues || (__ConnectionTypeValues = {}));
  (function(ConnectionType2) {
    ConnectionType2.codec = () => {
      return enumeration(__ConnectionTypeValues);
    };
  })(Message4.ConnectionType || (Message4.ConnectionType = {}));
  (function(Peer4) {
    let _codec2;
    Peer4.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, writer2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            writer2.fork();
          }
          if (obj.id != null) {
            writer2.uint32(10);
            writer2.bytes(obj.id);
          }
          if (obj.addrs != null) {
            for (const value2 of obj.addrs) {
              writer2.uint32(18);
              writer2.bytes(value2);
            }
          } else {
            throw new Error('Protocol error: required field "addrs" was not found in object');
          }
          if (obj.connection != null) {
            writer2.uint32(24);
            Message4.ConnectionType.codec().encode(obj.connection, writer2);
          }
          if (opts.lengthDelimited !== false) {
            writer2.ldelim();
          }
        }, (reader3, length3) => {
          const obj = {
            addrs: []
          };
          const end = length3 == null ? reader3.len : reader3.pos + length3;
          while (reader3.pos < end) {
            const tag = reader3.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.id = reader3.bytes();
                break;
              case 2:
                obj.addrs.push(reader3.bytes());
                break;
              case 3:
                obj.connection = Message4.ConnectionType.codec().decode(reader3);
                break;
              default:
                reader3.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer4.encode = (obj) => {
      return encodeMessage(obj, Peer4.codec());
    };
    Peer4.decode = (buf2) => {
      return decodeMessage(buf2, Peer4.codec());
    };
  })(Message4.Peer || (Message4.Peer = {}));
  let _codec;
  Message4.codec = () => {
    if (_codec == null) {
      _codec = message((obj, writer2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer2.fork();
        }
        if (obj.type != null) {
          writer2.uint32(8);
          Message4.MessageType.codec().encode(obj.type, writer2);
        }
        if (obj.clusterLevelRaw != null) {
          writer2.uint32(80);
          writer2.int32(obj.clusterLevelRaw);
        }
        if (obj.key != null) {
          writer2.uint32(18);
          writer2.bytes(obj.key);
        }
        if (obj.record != null) {
          writer2.uint32(26);
          writer2.bytes(obj.record);
        }
        if (obj.closerPeers != null) {
          for (const value2 of obj.closerPeers) {
            writer2.uint32(66);
            Message4.Peer.codec().encode(value2, writer2);
          }
        } else {
          throw new Error('Protocol error: required field "closerPeers" was not found in object');
        }
        if (obj.providerPeers != null) {
          for (const value2 of obj.providerPeers) {
            writer2.uint32(74);
            Message4.Peer.codec().encode(value2, writer2);
          }
        } else {
          throw new Error('Protocol error: required field "providerPeers" was not found in object');
        }
        if (opts.lengthDelimited !== false) {
          writer2.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {
          closerPeers: [],
          providerPeers: []
        };
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = Message4.MessageType.codec().decode(reader3);
              break;
            case 10:
              obj.clusterLevelRaw = reader3.int32();
              break;
            case 2:
              obj.key = reader3.bytes();
              break;
            case 3:
              obj.record = reader3.bytes();
              break;
            case 8:
              obj.closerPeers.push(Message4.Peer.codec().decode(reader3, reader3.uint32()));
              break;
            case 9:
              obj.providerPeers.push(Message4.Peer.codec().decode(reader3, reader3.uint32()));
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message4.encode = (obj) => {
    return encodeMessage(obj, Message4.codec());
  };
  Message4.decode = (buf2) => {
    return decodeMessage(buf2, Message4.codec());
  };
})(Message || (Message = {}));
var MESSAGE_TYPE = Message.MessageType;
var CONNECTION_TYPE = Message.ConnectionType;
var MESSAGE_TYPE_LOOKUP = Object.keys(MESSAGE_TYPE);
var Message2 = class {
  constructor(type, key, level) {
    if (!(key instanceof Uint8Array)) {
      throw new Error("Key must be a Uint8Array");
    }
    this.type = type;
    this.key = key;
    this.clusterLevelRaw = level;
    this.closerPeers = [];
    this.providerPeers = [];
    this.record = void 0;
  }
  /**
   * @type {number}
   */
  get clusterLevel() {
    const level = this.clusterLevelRaw - 1;
    if (level < 0) {
      return 0;
    }
    return level;
  }
  set clusterLevel(level) {
    this.clusterLevelRaw = level;
  }
  /**
   * Encode into protobuf
   */
  serialize() {
    return Message.encode({
      key: this.key,
      type: this.type,
      clusterLevelRaw: this.clusterLevelRaw,
      closerPeers: this.closerPeers.map(toPbPeer),
      providerPeers: this.providerPeers.map(toPbPeer),
      record: this.record == null ? void 0 : this.record.serialize().subarray()
    });
  }
  /**
   * Decode from protobuf
   */
  static deserialize(raw) {
    const dec = Message.decode(raw);
    const msg = new Message2(dec.type ?? Message.MessageType.PUT_VALUE, dec.key ?? Uint8Array.from([]), dec.clusterLevelRaw ?? 0);
    msg.closerPeers = dec.closerPeers.map(fromPbPeer);
    msg.providerPeers = dec.providerPeers.map(fromPbPeer);
    if (dec.record?.length != null) {
      msg.record = Libp2pRecord.deserialize(dec.record);
    }
    return msg;
  }
};
function toPbPeer(peer) {
  const output = {
    id: peer.id.toBytes(),
    addrs: (peer.multiaddrs ?? []).map((m) => m.bytes),
    connection: CONNECTION_TYPE.CONNECTED
  };
  return output;
}
function fromPbPeer(peer) {
  if (peer.id == null) {
    throw new Error("Invalid peer in message");
  }
  return {
    id: peerIdFromBytes(peer.id),
    multiaddrs: (peer.addrs ?? []).map((a) => multiaddr(a)),
    protocols: []
  };
}
function sendingQueryEvent(fields) {
  return {
    ...fields,
    name: "SENDING_QUERY",
    type: 0,
    messageName: fields.type,
    messageType: MESSAGE_TYPE_LOOKUP.indexOf(fields.type.toString())
  };
}
function peerResponseEvent(fields) {
  return {
    ...fields,
    name: "PEER_RESPONSE",
    type: 1,
    messageName: fields.messageType,
    closer: fields.closer != null ? fields.closer : [],
    providers: fields.providers != null ? fields.providers : []
  };
}
function finalPeerEvent(fields) {
  return {
    ...fields,
    name: "FINAL_PEER",
    type: 2
  };
}
function queryErrorEvent(fields) {
  return {
    ...fields,
    name: "QUERY_ERROR",
    type: 3
  };
}
function providerEvent(fields) {
  return {
    ...fields,
    name: "PROVIDER",
    type: 4
  };
}
function valueEvent(fields) {
  return {
    ...fields,
    name: "VALUE",
    type: 5
  };
}
function dialingPeerEvent(fields) {
  return {
    ...fields,
    name: "DIALING_PEER",
    type: 7
  };
}
var Network = class extends EventEmitter2 {
  /**
   * Create a new network
   */
  constructor(components, init) {
    super();
    const { protocol: protocol4, lan } = init;
    this.components = components;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:network`);
    this.running = false;
    this.protocol = protocol4;
  }
  /**
   * Start the network
   */
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
  }
  /**
   * Stop all network activity
   */
  async stop() {
    this.running = false;
  }
  /**
   * Is the network online?
   */
  isStarted() {
    return this.running;
  }
  /**
   * Send a request and record RTT for latency measurements
   */
  async *sendRequest(to, msg, options = {}) {
    if (!this.running) {
      return;
    }
    this.log("sending %s to %p", msg.type, to);
    yield dialingPeerEvent({ peer: to });
    yield sendingQueryEvent({ to, type: msg.type });
    try {
      const connection = await this.components.connectionManager.openConnection(to, options);
      const stream2 = await connection.newStream(this.protocol, options);
      const response = await this._writeReadMessage(stream2, msg.serialize(), options);
      yield peerResponseEvent({
        from: to,
        messageType: response.type,
        closer: response.closerPeers,
        providers: response.providerPeers,
        record: response.record
      });
    } catch (err2) {
      yield queryErrorEvent({ from: to, error: err2 });
    } finally {
    }
  }
  /**
   * Sends a message without expecting an answer
   */
  async *sendMessage(to, msg, options = {}) {
    if (!this.running) {
      return;
    }
    this.log("sending %s to %p", msg.type, to);
    yield dialingPeerEvent({ peer: to });
    yield sendingQueryEvent({ to, type: msg.type });
    try {
      const connection = await this.components.connectionManager.openConnection(to, options);
      const stream2 = await connection.newStream(this.protocol, options);
      await this._writeMessage(stream2, msg.serialize(), options);
      yield peerResponseEvent({ from: to, messageType: msg.type });
    } catch (err2) {
      yield queryErrorEvent({ from: to, error: err2 });
    } finally {
    }
  }
  /**
   * Write a message to the given stream
   */
  async _writeMessage(stream, msg, options) {
    if (options.signal != null) {
      stream = abortableDuplex(stream, options.signal);
    }
    await pipe([msg], encode15(), stream, drain);
  }
  /**
   * Write a message and read its response.
   * If no response is received after the specified timeout
   * this will error out.
   */
  async _writeReadMessage(stream, msg, options) {
    if (options.signal != null) {
      stream = abortableDuplex(stream, options.signal);
    }
    const res = await pipe([msg], encode15(), stream, decode14(), async (source) => {
      const buf2 = await first(source);
      if (buf2 != null) {
        return buf2;
      }
      throw (0, import_err_code125.default)(new Error("No message received"), "ERR_NO_MESSAGE_RECEIVED");
    });
    const message2 = Message2.deserialize(res);
    message2.closerPeers.forEach((peerData) => {
      this.dispatchEvent(new CustomEvent2("peer", {
        detail: peerData
      }));
    });
    message2.providerPeers.forEach((peerData) => {
      this.dispatchEvent(new CustomEvent2("peer", {
        detail: peerData
      }));
    });
    return message2;
  }
};
var import_err_code128 = __toESM(require_err_code(), 1);
var import_err_code126 = __toESM(require_err_code());
function verifyRecord(validators22, record) {
  const key = record.key;
  const keyString = toString3(key);
  const parts2 = keyString.split("/");
  if (parts2.length < 3) {
    return;
  }
  const validator = validators22[parts2[1].toString()];
  if (validator == null) {
    const errMsg = "Invalid record keytype";
    throw (0, import_err_code126.default)(new Error(errMsg), "ERR_INVALID_RECORD_KEY_TYPE");
  }
  return validator(key, record.value);
}
var validatePublicKeyRecord = async (key, publicKey) => {
  if (!(key instanceof Uint8Array)) {
    throw (0, import_err_code126.default)(new Error('"key" must be a Uint8Array'), "ERR_INVALID_RECORD_KEY_NOT_BUFFER");
  }
  if (key.byteLength < 5) {
    throw (0, import_err_code126.default)(new Error("invalid public key record"), "ERR_INVALID_RECORD_KEY_TOO_SHORT");
  }
  const prefix = toString3(key.subarray(0, 4));
  if (prefix !== "/pk/") {
    throw (0, import_err_code126.default)(new Error("key was not prefixed with /pk/"), "ERR_INVALID_RECORD_KEY_BAD_PREFIX");
  }
  const keyhash = key.slice(4);
  const publicKeyHash = await sha256.digest(publicKey);
  if (!equals(keyhash, publicKeyHash.bytes)) {
    throw (0, import_err_code126.default)(new Error("public key does not match passed in key"), "ERR_INVALID_RECORD_HASH_MISMATCH");
  }
};
var validators$1 = {
  pk: validatePublicKeyRecord
};
var import_err_code127 = __toESM(require_err_code());
function bestRecord(selectors2, k, records) {
  if (records.length === 0) {
    const errMsg = "No records given";
    throw (0, import_err_code127.default)(new Error(errMsg), "ERR_NO_RECORDS_RECEIVED");
  }
  const kStr = toString3(k);
  const parts2 = kStr.split("/");
  if (parts2.length < 3) {
    const errMsg = "Record key does not have a selector function";
    throw (0, import_err_code127.default)(new Error(errMsg), "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY");
  }
  const selector = selectors2[parts2[1].toString()];
  if (selector == null) {
    const errMsg = `Unrecognized key prefix: ${parts2[1]}`;
    throw (0, import_err_code127.default)(new Error(errMsg), "ERR_UNRECOGNIZED_KEY_PREFIX");
  }
  if (records.length === 1) {
    return 0;
  }
  return selector(k, records);
}
function publickKey(k, records) {
  return 0;
}
var selectors = {
  pk: publickKey
};
var ContentFetching = class {
  constructor(components, init) {
    const { validators: validators22, selectors: selectors2, peerRouting, queryManager, routingTable, network, lan } = init;
    this.components = components;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:content-fetching`);
    this.validators = validators22;
    this.selectors = selectors2;
    this.peerRouting = peerRouting;
    this.queryManager = queryManager;
    this.routingTable = routingTable;
    this.network = network;
  }
  async putLocal(key, rec) {
    const dsKey = bufferToRecordKey(key);
    await this.components.datastore.put(dsKey, rec);
  }
  /**
   * Attempt to retrieve the value for the given key from
   * the local datastore
   */
  async getLocal(key) {
    this.log("getLocal %b", key);
    const dsKey = bufferToRecordKey(key);
    this.log("fetching record for key %k", dsKey);
    const raw = await this.components.datastore.get(dsKey);
    this.log("found %k in local datastore", dsKey);
    const rec = Libp2pRecord.deserialize(raw);
    await verifyRecord(this.validators, rec);
    return rec;
  }
  /**
   * Send the best record found to any peers that have an out of date record
   */
  async *sendCorrectionRecord(key, vals, best, options = {}) {
    this.log("sendCorrection for %b", key);
    const fixupRec = await createPutRecord(key, best);
    for (const { value: value2, from: from3 } of vals) {
      if (equals(value2, best)) {
        this.log("record was ok");
        continue;
      }
      if (this.components.peerId.equals(from3)) {
        try {
          const dsKey = bufferToRecordKey(key);
          this.log(`Storing corrected record for key ${dsKey.toString()}`);
          await this.components.datastore.put(dsKey, fixupRec.subarray());
        } catch (err2) {
          this.log.error("Failed error correcting self", err2);
        }
        continue;
      }
      let sentCorrection = false;
      const request2 = new Message2(MESSAGE_TYPE.PUT_VALUE, key, 0);
      request2.record = Libp2pRecord.deserialize(fixupRec);
      for await (const event of this.network.sendRequest(from3, request2, options)) {
        if (event.name === "PEER_RESPONSE" && event.record != null && equals(event.record.value, Libp2pRecord.deserialize(fixupRec).value)) {
          sentCorrection = true;
        }
        yield event;
      }
      if (!sentCorrection) {
        yield queryErrorEvent({ from: from3, error: (0, import_err_code128.default)(new Error("value not put correctly"), "ERR_PUT_VALUE_INVALID") });
      }
      this.log.error("Failed error correcting entry");
    }
  }
  /**
   * Store the given key/value pair in the DHT
   */
  async *put(key, value2, options = {}) {
    this.log("put key %b value %b", key, value2);
    const record = await createPutRecord(key, value2);
    const dsKey = bufferToRecordKey(key);
    this.log(`storing record for key ${dsKey.toString()}`);
    await this.components.datastore.put(dsKey, record.subarray());
    yield* pipe(this.peerRouting.getClosestPeers(key, { signal: options.signal }), (source) => map(source, (event) => {
      return async () => {
        if (event.name !== "FINAL_PEER") {
          return [event];
        }
        const events2 = [];
        const msg = new Message2(MESSAGE_TYPE.PUT_VALUE, key, 0);
        msg.record = Libp2pRecord.deserialize(record);
        this.log("send put to %p", event.peer.id);
        for await (const putEvent of this.network.sendRequest(event.peer.id, msg, options)) {
          events2.push(putEvent);
          if (putEvent.name !== "PEER_RESPONSE") {
            continue;
          }
          if (!(putEvent.record != null && equals(putEvent.record.value, Libp2pRecord.deserialize(record).value))) {
            events2.push(queryErrorEvent({ from: event.peer.id, error: (0, import_err_code128.default)(new Error("value not put correctly"), "ERR_PUT_VALUE_INVALID") }));
          }
        }
        return events2;
      };
    }), (source) => parallel(source, {
      ordered: false,
      concurrency: ALPHA
    }), async function* (source) {
      for await (const events2 of source) {
        yield* events2;
      }
    });
  }
  /**
   * Get the value to the given key
   */
  async *get(key, options = {}) {
    this.log("get %b", key);
    const vals = [];
    for await (const event of this.getMany(key, options)) {
      if (event.name === "VALUE") {
        vals.push(event);
      }
      yield event;
    }
    if (vals.length === 0) {
      return;
    }
    const records = vals.map((v) => v.value);
    let i2 = 0;
    try {
      i2 = bestRecord(this.selectors, key, records);
    } catch (err2) {
      if (err2.code !== "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY") {
        throw err2;
      }
    }
    const best = records[i2];
    this.log("GetValue %b %b", key, best);
    if (best == null) {
      throw (0, import_err_code128.default)(new Error("best value was not found"), "ERR_NOT_FOUND");
    }
    yield* this.sendCorrectionRecord(key, vals, best, options);
    yield vals[i2];
  }
  /**
   * Get the `n` values to the given key without sorting
   */
  async *getMany(key, options = {}) {
    this.log("getMany values for %b", key);
    try {
      const localRec = await this.getLocal(key);
      yield valueEvent({
        value: localRec.value,
        from: this.components.peerId
      });
    } catch (err2) {
      this.log("error getting local value for %b", key, err2);
    }
    const id = await convertBuffer(key);
    const rtp = this.routingTable.closestPeers(id);
    this.log("found %d peers in routing table", rtp.length);
    const self2 = this;
    const getValueQuery = async function* ({ peer, signal }) {
      for await (const event of self2.peerRouting.getValueOrPeers(peer, key, { signal })) {
        yield event;
        if (event.name === "PEER_RESPONSE" && event.record != null) {
          yield valueEvent({ from: peer, value: event.record.value });
        }
      }
    };
    yield* this.queryManager.run(key, rtp, getValueQuery, options);
  }
};
var ContentRouting = class {
  constructor(components, init) {
    const { network, peerRouting, queryManager, routingTable, providers, lan } = init;
    this.components = components;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:content-routing`);
    this.network = network;
    this.peerRouting = peerRouting;
    this.queryManager = queryManager;
    this.routingTable = routingTable;
    this.providers = providers;
  }
  /**
   * Announce to the network that we can provide the value for a given key and
   * are contactable on the given multiaddrs
   */
  async *provide(key, multiaddrs, options = {}) {
    this.log("provide %s", key);
    await this.providers.addProvider(key, this.components.peerId);
    const msg = new Message2(MESSAGE_TYPE.ADD_PROVIDER, key.multihash.bytes, 0);
    msg.providerPeers = [{
      id: this.components.peerId,
      multiaddrs,
      protocols: []
    }];
    let sent = 0;
    const maybeNotifyPeer = (event) => {
      return async () => {
        if (event.name !== "FINAL_PEER") {
          return [event];
        }
        const events2 = [];
        this.log("putProvider %s to %p", key, event.peer.id);
        try {
          this.log("sending provider record for %s to %p", key, event.peer.id);
          for await (const sendEvent of this.network.sendMessage(event.peer.id, msg, options)) {
            if (sendEvent.name === "PEER_RESPONSE") {
              this.log("sent provider record for %s to %p", key, event.peer.id);
              sent++;
            }
            events2.push(sendEvent);
          }
        } catch (err2) {
          this.log.error("error sending provide record to peer %p", event.peer.id, err2);
          events2.push(queryErrorEvent({ from: event.peer.id, error: err2 }));
        }
        return events2;
      };
    };
    yield* pipe(this.peerRouting.getClosestPeers(key.multihash.bytes, options), (source) => map(source, (event) => maybeNotifyPeer(event)), (source) => parallel(source, {
      ordered: false,
      concurrency: ALPHA
    }), async function* (source) {
      for await (const events2 of source) {
        yield* events2;
      }
    });
    this.log("sent provider records to %d peers", sent);
  }
  /**
   * Search the dht for up to `K` providers of the given CID.
   */
  async *findProviders(key, options) {
    const toFind = this.routingTable.kBucketSize;
    const target = key.multihash.bytes;
    const id = await convertBuffer(target);
    const self2 = this;
    this.log("findProviders %c", key);
    const provs = await this.providers.getProviders(key);
    if (provs.length > 0) {
      const providers2 = [];
      for (const peerId of provs.slice(0, toFind)) {
        providers2.push({
          id: peerId,
          multiaddrs: (await this.components.peerStore.addressBook.get(peerId) ?? []).map((address) => address.multiaddr),
          protocols: []
        });
      }
      yield peerResponseEvent({ from: this.components.peerId, messageType: MESSAGE_TYPE.GET_PROVIDERS, providers: providers2 });
      yield providerEvent({ from: this.components.peerId, providers: providers2 });
    }
    if (provs.length >= toFind) {
      return;
    }
    const findProvidersQuery = async function* ({ peer, signal }) {
      const request2 = new Message2(MESSAGE_TYPE.GET_PROVIDERS, target, 0);
      yield* self2.network.sendRequest(peer, request2, { signal });
    };
    const providers = new Set(provs.map((p) => p.toString()));
    for await (const event of this.queryManager.run(target, this.routingTable.closestPeers(id), findProvidersQuery, options)) {
      yield event;
      if (event.name === "PEER_RESPONSE") {
        this.log("Found %d provider entries for %c and %d closer peers", event.providers.length, key, event.closer.length);
        const newProviders = [];
        for (const peer of event.providers) {
          if (providers.has(peer.id.toString())) {
            continue;
          }
          providers.add(peer.id.toString());
          newProviders.push(peer);
        }
        if (newProviders.length > 0) {
          yield providerEvent({ from: event.from, providers: newProviders });
        }
        if (providers.size === toFind) {
          return;
        }
      }
    }
  }
};
var import_err_code129 = __toESM(require_err_code(), 1);
var PeerDistanceList = class {
  constructor(originDhtKey, capacity) {
    this.originDhtKey = originDhtKey;
    this.capacity = capacity;
    this.peerDistances = [];
  }
  /**
   * The length of the list
   */
  get length() {
    return this.peerDistances.length;
  }
  /**
   * The peerIds in the list, in order of distance from the origin key
   */
  get peers() {
    return this.peerDistances.map((pd) => pd.peerId);
  }
  /**
   * Add a peerId to the list.
   */
  async add(peerId) {
    if (this.peerDistances.find((pd) => pd.peerId.equals(peerId)) != null) {
      return;
    }
    const dhtKey = await convertPeerId(peerId);
    const el = {
      peerId,
      distance: xor(this.originDhtKey, dhtKey)
    };
    this.peerDistances.push(el);
    this.peerDistances.sort((a, b) => compare2(a.distance, b.distance));
    this.peerDistances = this.peerDistances.slice(0, this.capacity);
  }
  /**
   * Indicates whether any of the peerIds passed as a parameter are closer
   * to the origin key than the furthest peerId in the PeerDistanceList.
   */
  async anyCloser(peerIds) {
    if (peerIds.length === 0) {
      return false;
    }
    if (this.length === 0) {
      return true;
    }
    const dhtKeys = await Promise.all(peerIds.map(convertPeerId));
    const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance;
    for (const dhtKey of dhtKeys) {
      const keyDistance = xor(this.originDhtKey, dhtKey);
      if (compare2(keyDistance, furthestDistance) < 0) {
        return true;
      }
    }
    return false;
  }
};
var PeerRouting = class {
  constructor(components, init) {
    const { routingTable, network, validators: validators22, queryManager, lan } = init;
    this.components = components;
    this.routingTable = routingTable;
    this.network = network;
    this.validators = validators22;
    this.queryManager = queryManager;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:peer-routing`);
  }
  /**
   * Look if we are connected to a peer with the given id.
   * Returns its id and addresses, if found, otherwise `undefined`.
   */
  async findPeerLocal(peer) {
    let peerData;
    const p = await this.routingTable.find(peer);
    if (p != null) {
      this.log("findPeerLocal found %p in routing table", peer);
      try {
        peerData = await this.components.peerStore.get(p);
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
    }
    if (peerData == null) {
      try {
        peerData = await this.components.peerStore.get(peer);
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
    }
    if (peerData != null) {
      this.log("findPeerLocal found %p in peer store", peer);
      return {
        id: peerData.id,
        multiaddrs: peerData.addresses.map((address) => address.multiaddr),
        protocols: []
      };
    }
    return void 0;
  }
  /**
   * Get a value via rpc call for the given parameters
   */
  async *_getValueSingle(peer, key, options = {}) {
    const msg = new Message2(MESSAGE_TYPE.GET_VALUE, key, 0);
    yield* this.network.sendRequest(peer, msg, options);
  }
  /**
   * Get the public key directly from a node
   */
  async *getPublicKeyFromNode(peer, options = {}) {
    const pkKey = keyForPublicKey(peer);
    for await (const event of this._getValueSingle(peer, pkKey, options)) {
      yield event;
      if (event.name === "PEER_RESPONSE" && event.record != null) {
        const recPeer = await peerIdFromKeys(keys_exports2.marshalPublicKey({ bytes: event.record.value }));
        if (!recPeer.equals(peer)) {
          throw (0, import_err_code129.default)(new Error("public key does not match id"), "ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID");
        }
        if (recPeer.publicKey == null) {
          throw (0, import_err_code129.default)(new Error("public key missing"), "ERR_PUBLIC_KEY_MISSING");
        }
        yield valueEvent({ from: peer, value: recPeer.publicKey });
      }
    }
    throw (0, import_err_code129.default)(new Error(`Node not responding with its public key: ${peer.toString()}`), "ERR_INVALID_RECORD");
  }
  /**
   * Search for a peer with the given ID
   */
  async *findPeer(id, options = {}) {
    this.log("findPeer %p", id);
    const pi = await this.findPeerLocal(id);
    if (pi != null) {
      this.log("found local");
      yield finalPeerEvent({
        from: this.components.peerId,
        peer: pi
      });
      return;
    }
    const key = await convertPeerId(id);
    const peers = this.routingTable.closestPeers(key);
    const match = peers.find((p) => p.equals(id));
    if (match != null) {
      try {
        const peer = await this.components.peerStore.get(id);
        this.log("found in peerStore");
        yield finalPeerEvent({
          from: this.components.peerId,
          peer: {
            id: peer.id,
            multiaddrs: peer.addresses.map((address) => address.multiaddr),
            protocols: []
          }
        });
        return;
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
    }
    const self2 = this;
    const findPeerQuery = async function* ({ peer, signal }) {
      const request2 = new Message2(MESSAGE_TYPE.FIND_NODE, id.toBytes(), 0);
      for await (const event of self2.network.sendRequest(peer, request2, { signal })) {
        yield event;
        if (event.name === "PEER_RESPONSE") {
          const match2 = event.closer.find((p) => p.id.equals(id));
          if (match2 != null) {
            yield finalPeerEvent({ from: event.from, peer: match2 });
          }
        }
      }
    };
    let foundPeer = false;
    for await (const event of this.queryManager.run(id.toBytes(), peers, findPeerQuery, options)) {
      if (event.name === "FINAL_PEER") {
        foundPeer = true;
      }
      yield event;
    }
    if (!foundPeer) {
      yield queryErrorEvent({ from: this.components.peerId, error: (0, import_err_code129.default)(new Error("Not found"), "ERR_NOT_FOUND") });
    }
  }
  /**
   * Kademlia 'node lookup' operation on a key, which could be a the
   * bytes from a multihash or a peer ID
   */
  async *getClosestPeers(key, options = {}) {
    this.log("getClosestPeers to %b", key);
    const id = await convertBuffer(key);
    const tablePeers = this.routingTable.closestPeers(id);
    const self2 = this;
    const peers = new PeerDistanceList(id, this.routingTable.kBucketSize);
    await Promise.all(tablePeers.map(async (peer) => await peers.add(peer)));
    const getCloserPeersQuery = async function* ({ peer, signal }) {
      self2.log("closerPeersSingle %s from %p", toString3(key, "base32"), peer);
      const request2 = new Message2(MESSAGE_TYPE.FIND_NODE, key, 0);
      yield* self2.network.sendRequest(peer, request2, { signal });
    };
    for await (const event of this.queryManager.run(key, tablePeers, getCloserPeersQuery, options)) {
      yield event;
      if (event.name === "PEER_RESPONSE") {
        await Promise.all(event.closer.map(async (peerData) => await peers.add(peerData.id)));
      }
    }
    this.log("found %d peers close to %b", peers.length, key);
    for (const peer of peers.peers) {
      yield finalPeerEvent({
        from: this.components.peerId,
        peer: {
          id: peer,
          multiaddrs: (await this.components.peerStore.addressBook.get(peer) ?? []).map((addr) => addr.multiaddr),
          protocols: []
        }
      });
    }
  }
  /**
   * Query a particular peer for the value for the given key.
   * It will either return the value or a list of closer peers.
   *
   * Note: The peerStore is updated with new addresses found for the given peer.
   */
  async *getValueOrPeers(peer, key, options = {}) {
    for await (const event of this._getValueSingle(peer, key, options)) {
      if (event.name === "PEER_RESPONSE") {
        if (event.record != null) {
          try {
            await this._verifyRecordOnline(event.record);
          } catch (err2) {
            const errMsg = "invalid record received, discarded";
            this.log(errMsg);
            yield queryErrorEvent({ from: event.from, error: (0, import_err_code129.default)(new Error(errMsg), "ERR_INVALID_RECORD") });
            continue;
          }
        }
      }
      yield event;
    }
  }
  /**
   * Verify a record, fetching missing public keys from the network.
   * Throws an error if the record is invalid.
   */
  async _verifyRecordOnline(record) {
    if (record.timeReceived == null) {
      throw (0, import_err_code129.default)(new Error("invalid record received"), "ERR_INVALID_RECORD");
    }
    await verifyRecord(this.validators, new Libp2pRecord(record.key, record.value, record.timeReceived));
  }
  /**
   * Get the nearest peers to the given query, but if closer
   * than self
   */
  async getCloserPeersOffline(key, closerThan) {
    const id = await convertBuffer(key);
    const ids = this.routingTable.closestPeers(id);
    const output = [];
    for (const peerId of ids) {
      if (peerId.equals(closerThan)) {
        continue;
      }
      try {
        const addresses = await this.components.peerStore.addressBook.get(peerId);
        const protocols = await this.components.peerStore.protoBook.get(peerId);
        output.push({
          id: peerId,
          multiaddrs: addresses.map((address) => address.multiaddr),
          protocols
        });
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
    }
    if (output.length > 0) {
      this.log("getCloserPeersOffline found %d peer(s) closer to %b than %p", output.length, key, closerThan);
    } else {
      this.log("getCloserPeersOffline could not find peer closer to %b than %p", key, closerThan);
    }
    return output;
  }
};
var import_hashlru4 = __toESM(require_hashlru(), 1);
var import_varint7 = __toESM(require_varint(), 1);
var log92 = logger("libp2p:kad-dht:providers");
var Providers = class {
  constructor(components, init = {}) {
    const { cacheSize, cleanupInterval, provideValidity } = init;
    this.components = components;
    this.cleanupInterval = cleanupInterval ?? PROVIDERS_CLEANUP_INTERVAL;
    this.provideValidity = provideValidity ?? PROVIDERS_VALIDITY;
    this.cache = (0, import_hashlru4.default)(cacheSize ?? PROVIDERS_LRU_CACHE_SIZE);
    this.syncQueue = new PQueue({ concurrency: 1 });
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  /**
   * Start the provider cleanup service
   */
  async start() {
    if (this.started) {
      return;
    }
    this.started = true;
    this.cleaner = setInterval(() => {
      this._cleanup().catch((err2) => {
        log92.error(err2);
      });
    }, this.cleanupInterval);
  }
  /**
   * Release any resources.
   */
  async stop() {
    this.started = false;
    if (this.cleaner != null) {
      clearInterval(this.cleaner);
      this.cleaner = void 0;
    }
  }
  /**
   * Check all providers if they are still valid, and if not delete them
   */
  async _cleanup() {
    return await this.syncQueue.add(async () => {
      const start = Date.now();
      let count = 0;
      let deleteCount = 0;
      const deleted = /* @__PURE__ */ new Map();
      const batch2 = this.components.datastore.batch();
      const query = this.components.datastore.query({ prefix: PROVIDER_KEY_PREFIX });
      for await (const entry of query) {
        try {
          const { cid, peerId } = parseProviderKey(entry.key);
          const time = readTime(entry.value).getTime();
          const now = Date.now();
          const delta = now - time;
          const expired = delta > this.provideValidity;
          log92("comparing: %d - %d = %d > %d %s", now, time, delta, this.provideValidity, expired ? "(expired)" : "");
          if (expired) {
            deleteCount++;
            batch2.delete(entry.key);
            const peers = deleted.get(cid) ?? /* @__PURE__ */ new Set();
            peers.add(peerId);
            deleted.set(cid, peers);
          }
          count++;
        } catch (err2) {
          log92.error(err2.message);
        }
      }
      if (deleted.size > 0) {
        log92("deleting %d / %d entries", deleteCount, count);
        await batch2.commit();
      } else {
        log92("nothing to delete");
      }
      for (const [cid, peers] of deleted) {
        const key = makeProviderKey(cid);
        const provs = this.cache.get(key);
        if (provs != null) {
          for (const peerId of peers) {
            provs.delete(peerId);
          }
          if (provs.size === 0) {
            this.cache.remove(key);
          } else {
            this.cache.set(key, provs);
          }
        }
      }
      log92("Cleanup successful (%dms)", Date.now() - start);
    });
  }
  /**
   * Get the currently known provider peer ids for a given CID
   */
  async _getProvidersMap(cid) {
    const cacheKey = makeProviderKey(cid);
    let provs = this.cache.get(cacheKey);
    if (provs == null) {
      provs = await loadProviders(this.components.datastore, cid);
      this.cache.set(cacheKey, provs);
    }
    return provs;
  }
  /**
   * Add a new provider for the given CID
   */
  async addProvider(cid, provider) {
    return await this.syncQueue.add(async () => {
      log92("%p provides %s", provider, cid);
      const provs = await this._getProvidersMap(cid);
      log92("loaded %s provs", provs.size);
      const now = new Date();
      provs.set(provider.toString(), now);
      const dsKey = makeProviderKey(cid);
      this.cache.set(dsKey, provs);
      await writeProviderEntry(this.components.datastore, cid, provider, now);
    });
  }
  /**
   * Get a list of providers for the given CID
   */
  async getProviders(cid) {
    return await this.syncQueue.add(async () => {
      log92("get providers for %s", cid);
      const provs = await this._getProvidersMap(cid);
      return [...provs.keys()].map((peerIdStr) => {
        return peerIdFromString(peerIdStr);
      });
    });
  }
};
function makeProviderKey(cid) {
  const cidStr = typeof cid === "string" ? cid : toString3(cid.multihash.bytes, "base32");
  return `${PROVIDER_KEY_PREFIX}/${cidStr}`;
}
async function writeProviderEntry(store, cid, peer, time) {
  const dsKey = [
    makeProviderKey(cid),
    "/",
    peer.toString()
  ].join("");
  const key = new Key(dsKey);
  const buffer2 = Uint8Array.from(import_varint7.default.encode(time.getTime()));
  return await store.put(key, buffer2);
}
function parseProviderKey(key) {
  const parts2 = key.toString().split("/");
  if (parts2.length !== 5) {
    throw new Error(`incorrectly formatted provider entry key in datastore: ${key.toString()}`);
  }
  return {
    cid: parts2[3],
    peerId: parts2[4]
  };
}
async function loadProviders(store, cid) {
  const providers = /* @__PURE__ */ new Map();
  const query = store.query({ prefix: makeProviderKey(cid) });
  for await (const entry of query) {
    const { peerId } = parseProviderKey(entry.key);
    providers.set(peerId, readTime(entry.value));
  }
  return providers;
}
function readTime(buf2) {
  return new Date(import_varint7.default.decode(buf2));
}
var import_timeout_abort_controller15 = __toESM(require_timeout_abort_controller(), 1);
var import_any_signal9 = __toESM(require_any_signal(), 1);
var import_err_code130 = __toESM(require_err_code(), 1);
var import_timeout_abort_controller14 = __toESM(require_timeout_abort_controller(), 1);
var import_any_signal8 = __toESM(require_any_signal(), 1);
var MAX_XOR = BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF");
async function* queryPath(options) {
  const { key, startingPeer, ourPeerId, signal, query, alpha, pathIndex, numPaths, cleanUp, queryFuncTimeout, log: log107, peersSeen } = options;
  const queue = new PQueue({
    concurrency: alpha
  });
  const kadId = await convertBuffer(key);
  function queryPeer(peer, peerKadId) {
    if (peer == null) {
      return;
    }
    peersSeen.add(peer);
    const peerXor = BigInt("0x" + toString3(xor(peerKadId, kadId), "base16"));
    queue.add(async () => {
      let timeout;
      const signals = [signal];
      if (queryFuncTimeout != null) {
        timeout = new import_timeout_abort_controller14.TimeoutController(queryFuncTimeout);
        signals.push(timeout.signal);
      }
      const compoundSignal = (0, import_any_signal8.anySignal)(signals);
      try {
        for await (const event of query({
          key,
          peer,
          signal: compoundSignal,
          pathIndex,
          numPaths
        })) {
          if (compoundSignal.aborted) {
            return;
          }
          if (event.name === "PEER_RESPONSE") {
            for (const closerPeer of event.closer) {
              if (peersSeen.has(closerPeer.id)) {
                log107("already seen %p in query", closerPeer.id);
                continue;
              }
              if (ourPeerId.equals(closerPeer.id)) {
                log107("not querying ourselves");
                continue;
              }
              const closerPeerKadId = await convertPeerId(closerPeer.id);
              const closerPeerXor = BigInt("0x" + toString3(xor(closerPeerKadId, kadId), "base16"));
              if (closerPeerXor > peerXor) {
                log107("skipping %p as they are not closer to %b than %p", closerPeer.id, key, peer);
                continue;
              }
              log107("querying closer peer %p", closerPeer.id);
              queryPeer(closerPeer.id, closerPeerKadId);
            }
          }
          queue.emit("completed", event);
        }
        timeout?.clear();
      } catch (err2) {
        if (signal.aborted) {
          queue.emit("error", err2);
        } else {
          queue.emit("completed", queryErrorEvent({
            from: peer,
            error: err2
          }));
        }
      } finally {
        timeout?.clear();
      }
    }, {
      // use xor value as the queue priority - closer peers should execute first
      // subtract it from MAX_XOR because higher priority values execute sooner
      // @ts-expect-error this is supposed to be a Number but it's ok to use BigInts
      // as long as all priorities are BigInts since we won't mix BigInts and Number
      // values in arithmetic operations
      priority: MAX_XOR - peerXor
    }).catch((err2) => {
      log107.error(err2);
    });
  }
  queryPeer(startingPeer, await convertPeerId(startingPeer));
  yield* toGenerator(queue, signal, cleanUp, log107);
}
async function* toGenerator(queue, signal, cleanUp, log107) {
  let deferred = pDefer();
  let running = true;
  const results = [];
  const cleanup = () => {
    if (!running) {
      return;
    }
    log107("clean up queue, results %d, queue size %d, pending tasks %d", results.length, queue.size, queue.pending);
    running = false;
    queue.clear();
    results.splice(0, results.length);
  };
  queue.on("completed", (result) => {
    results.push(result);
    deferred.resolve();
  });
  queue.on("error", (err2) => {
    log107("queue error", err2);
    cleanup();
    deferred.reject(err2);
  });
  queue.on("idle", () => {
    log107("queue idle");
    running = false;
    deferred.resolve();
  });
  signal.addEventListener("abort", () => {
    log107("abort queue");
    const wasRunning = running;
    cleanup();
    if (wasRunning) {
      deferred.reject((0, import_err_code130.default)(new Error("Query aborted"), "ERR_QUERY_ABORTED"));
    }
  });
  cleanUp.addEventListener("cleanup", () => {
    cleanup();
    deferred.resolve();
  });
  while (running) {
    await deferred.promise;
    deferred = pDefer();
    while (results.length > 0) {
      const result = results.shift();
      if (result != null) {
        yield result;
      }
    }
  }
  yield* results;
}
var import_events38 = __toESM(require_events(), 1);
var QueryManager = class {
  constructor(components, init) {
    const { lan = false, disjointPaths = K, alpha = ALPHA } = init;
    this.components = components;
    this.disjointPaths = disjointPaths ?? K;
    this.controllers = /* @__PURE__ */ new Set();
    this.running = false;
    this.alpha = alpha ?? ALPHA;
    this.lan = lan;
    this.queries = 0;
  }
  isStarted() {
    return this.running;
  }
  /**
   * Starts the query manager
   */
  async start() {
    this.running = true;
    if (this.components.metrics != null && this.metrics == null) {
      this.metrics = {
        runningQueries: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? "lan" : "wan"}_running_queries`),
        queryTime: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? "lan" : "wan"}_query_time_seconds`)
      };
    }
  }
  /**
   * Stops all queries
   */
  async stop() {
    this.running = false;
    for (const controller of this.controllers) {
      controller.abort();
    }
    this.controllers.clear();
  }
  async *run(key, peers, queryFunc, options = {}) {
    if (!this.running) {
      throw new Error("QueryManager not started");
    }
    const stopQueryTimer = this.metrics?.queryTime.timer();
    let timeoutController;
    if (options.signal == null) {
      timeoutController = new import_timeout_abort_controller15.TimeoutController(DEFAULT_QUERY_TIMEOUT);
      options.signal = timeoutController.signal;
      try {
        if (import_events38.setMaxListeners != null) {
          (0, import_events38.setMaxListeners)(Infinity, timeoutController.signal);
        }
      } catch {
      }
    }
    const abortController = new AbortController();
    this.controllers.add(abortController);
    const signals = [abortController.signal];
    if (options.signal != null) {
      signals.push(options.signal);
    }
    const signal = (0, import_any_signal9.anySignal)(signals);
    try {
      if (import_events38.setMaxListeners != null) {
        (0, import_events38.setMaxListeners)(Infinity, signal);
      }
    } catch {
    }
    const log107 = logger(`libp2p:kad-dht:${this.lan ? "lan" : "wan"}:query:` + toString3(key, "base58btc"));
    const peersToQuery = peers.slice(0, Math.min(this.disjointPaths, peers.length));
    const startTime = Date.now();
    const cleanUp = new EventEmitter2();
    try {
      log107("query:start");
      this.queries++;
      this.metrics?.runningQueries.update(this.queries);
      if (peers.length === 0) {
        log107.error("Running query with no peers");
        return;
      }
      const peersSeen = new PeerSet();
      const paths = peersToQuery.map((peer, index2) => {
        return queryPath({
          key,
          startingPeer: peer,
          ourPeerId: this.components.peerId,
          signal,
          query: queryFunc,
          pathIndex: index2,
          numPaths: peersToQuery.length,
          alpha: this.alpha,
          cleanUp,
          queryFuncTimeout: options.queryFuncTimeout,
          log: log107,
          peersSeen
        });
      });
      for await (const event of merge$1(...paths)) {
        yield event;
        if (event.name === "QUERY_ERROR") {
          log107("error", event.error);
        }
      }
    } catch (err2) {
      if (!this.running && err2.code === "ERR_QUERY_ABORTED")
        ;
      else {
        throw err2;
      }
    } finally {
      this.controllers.delete(abortController);
      if (timeoutController != null) {
        timeoutController.clear();
      }
      this.queries--;
      this.metrics?.runningQueries.update(this.queries);
      if (stopQueryTimer != null) {
        stopQueryTimer();
      }
      cleanUp.dispatchEvent(new CustomEvent2("cleanup"));
      log107("query:done in %dms", Date.now() - startTime);
    }
  }
};
var import_err_code131 = __toESM(require_err_code(), 1);
var log93 = logger("libp2p:kad-dht:rpc:handlers:add-provider");
var AddProviderHandler = class {
  constructor(init) {
    const { providers } = init;
    this.providers = providers;
  }
  async handle(peerId, msg) {
    log93("start");
    if (msg.key == null || msg.key.length === 0) {
      throw (0, import_err_code131.default)(new Error("Missing key"), "ERR_MISSING_KEY");
    }
    let cid;
    try {
      cid = CID.decode(msg.key);
    } catch (err2) {
      throw (0, import_err_code131.default)(new Error("Invalid CID"), "ERR_INVALID_CID");
    }
    if (msg.providerPeers == null || msg.providerPeers.length === 0) {
      log93.error("no providers found in message");
    }
    await Promise.all(msg.providerPeers.map(async (pi) => {
      if (!pi.id.equals(peerId)) {
        log93("invalid provider peer %p from %p", pi.id, peerId);
        return;
      }
      if (pi.multiaddrs.length < 1) {
        log93("no valid addresses for provider %p. Ignore", peerId);
        return;
      }
      log93("received provider %p for %s (addrs %s)", peerId, cid, pi.multiaddrs.map((m) => m.toString()));
      await this.providers.addProvider(cid, pi.id);
    }));
    return void 0;
  }
};
var log94 = logger("libp2p:kad-dht:rpc:handlers:find-node");
var FindNodeHandler = class {
  constructor(components, init) {
    const { peerRouting, lan } = init;
    this.components = components;
    this.peerRouting = peerRouting;
    this.lan = Boolean(lan);
  }
  /**
   * Process `FindNode` DHT messages
   */
  async handle(peerId, msg) {
    log94("incoming request from %p for peers closer to %b", peerId, msg.key);
    let closer = [];
    if (equals(this.components.peerId.toBytes(), msg.key)) {
      closer = [{
        id: this.components.peerId,
        multiaddrs: this.components.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code)),
        protocols: []
      }];
    } else {
      closer = await this.peerRouting.getCloserPeersOffline(msg.key, peerId);
    }
    closer = closer.map(this.lan ? removePublicAddresses : removePrivateAddresses).filter(({ multiaddrs }) => multiaddrs.length);
    const response = new Message2(msg.type, new Uint8Array(0), msg.clusterLevel);
    if (closer.length > 0) {
      response.closerPeers = closer;
    } else {
      log94("could not find any peers closer to %b than %p", msg.key, peerId);
    }
    return response;
  }
};
var import_err_code132 = __toESM(require_err_code(), 1);
var log95 = logger("libp2p:kad-dht:rpc:handlers:get-providers");
var GetProvidersHandler = class {
  constructor(components, init) {
    const { peerRouting, providers, lan } = init;
    this.components = components;
    this.peerRouting = peerRouting;
    this.providers = providers;
    this.lan = Boolean(lan);
  }
  async handle(peerId, msg) {
    let cid;
    try {
      cid = CID.decode(msg.key);
    } catch (err2) {
      throw (0, import_err_code132.default)(new Error("Invalid CID"), "ERR_INVALID_CID");
    }
    log95("%p asking for providers for %s", peerId, cid);
    const [peers, closer] = await Promise.all([
      this.providers.getProviders(cid),
      this.peerRouting.getCloserPeersOffline(msg.key, peerId)
    ]);
    const providerPeers = await this._getPeers(peers);
    const closerPeers = await this._getPeers(closer.map(({ id }) => id));
    const response = new Message2(msg.type, msg.key, msg.clusterLevel);
    if (providerPeers.length > 0) {
      response.providerPeers = providerPeers;
    }
    if (closerPeers.length > 0) {
      response.closerPeers = closerPeers;
    }
    log95("got %s providers %s closerPeers", providerPeers.length, closerPeers.length);
    return response;
  }
  async _getAddresses(peerId) {
    const addrs = await this.components.peerStore.addressBook.get(peerId);
    return addrs.map((address) => address.multiaddr);
  }
  async _getPeers(peerIds) {
    const output = [];
    const addrFilter = this.lan ? removePublicAddresses : removePrivateAddresses;
    for (const peerId of peerIds) {
      const peer = addrFilter({
        id: peerId,
        multiaddrs: await this._getAddresses(peerId),
        protocols: []
      });
      if (peer.multiaddrs.length > 0) {
        output.push(peer);
      }
    }
    return output;
  }
};
var import_err_code133 = __toESM(require_err_code(), 1);
var log96 = logger("libp2p:kad-dht:rpc:handlers:get-value");
var GetValueHandler = class {
  constructor(components, init) {
    const { peerRouting } = init;
    this.components = components;
    this.peerRouting = peerRouting;
  }
  async handle(peerId, msg) {
    const key = msg.key;
    log96("%p asked for key %b", peerId, key);
    if (key == null || key.length === 0) {
      throw (0, import_err_code133.default)(new Error("Invalid key"), "ERR_INVALID_KEY");
    }
    const response = new Message2(MESSAGE_TYPE.GET_VALUE, key, msg.clusterLevel);
    if (isPublicKeyKey(key)) {
      log96("is public key");
      const idFromKey = fromPublicKeyKey(key);
      let pubKey;
      try {
        const key2 = await this.components.peerStore.keyBook.get(idFromKey);
        if (key2 == null) {
          throw (0, import_err_code133.default)(new Error("No public key found in key book"), "ERR_NOT_FOUND");
        }
        pubKey = key2;
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
      if (pubKey != null) {
        log96("returning found public key");
        response.record = new Libp2pRecord(key, pubKey, new Date());
        return response;
      }
    }
    const [record, closer] = await Promise.all([
      this._checkLocalDatastore(key),
      this.peerRouting.getCloserPeersOffline(msg.key, peerId)
    ]);
    if (record != null) {
      log96("had record for %b in local datastore", key);
      response.record = record;
    }
    if (closer.length > 0) {
      log96("had %s closer peers in routing table", closer.length);
      response.closerPeers = closer;
    }
    return response;
  }
  /**
   * Try to fetch a given record by from the local datastore.
   * Returns the record iff it is still valid, meaning
   * - it was either authored by this node, or
   * - it was received less than `MAX_RECORD_AGE` ago.
   */
  async _checkLocalDatastore(key) {
    log96("checkLocalDatastore looking for %b", key);
    const dsKey = bufferToRecordKey(key);
    let rawRecord;
    try {
      rawRecord = await this.components.datastore.get(dsKey);
    } catch (err2) {
      if (err2.code === "ERR_NOT_FOUND") {
        return void 0;
      }
      throw err2;
    }
    const record = Libp2pRecord.deserialize(rawRecord);
    if (record == null) {
      throw (0, import_err_code133.default)(new Error("Invalid record"), "ERR_INVALID_RECORD");
    }
    if (record.timeReceived == null || Date.now() - record.timeReceived.getTime() > MAX_RECORD_AGE) {
      await this.components.datastore.delete(dsKey);
      return void 0;
    }
    return record;
  }
};
var log97 = logger("libp2p:kad-dht:rpc:handlers:ping");
var PingHandler = class {
  async handle(peerId, msg) {
    log97("ping from %p", peerId);
    return msg;
  }
};
var import_err_code134 = __toESM(require_err_code(), 1);
var PutValueHandler = class {
  constructor(components, init) {
    const { validators: validators22 } = init;
    this.components = components;
    this.log = logger("libp2p:kad-dht:rpc:handlers:put-value");
    this.validators = validators22;
  }
  async handle(peerId, msg) {
    const key = msg.key;
    this.log("%p asked us to store value for key %b", peerId, key);
    const record = msg.record;
    if (record == null) {
      const errMsg = `Empty record from: ${peerId.toString()}`;
      this.log.error(errMsg);
      throw (0, import_err_code134.default)(new Error(errMsg), "ERR_EMPTY_RECORD");
    }
    try {
      await verifyRecord(this.validators, record);
      record.timeReceived = new Date();
      const recordKey = bufferToRecordKey(record.key);
      await this.components.datastore.put(recordKey, record.serialize().subarray());
      this.log("put record for %b into datastore under key %k", key, recordKey);
    } catch (err2) {
      this.log("did not put record for key %b into datastore %o", key, err2);
    }
    return msg;
  }
};
var RPC2 = class {
  constructor(components, init) {
    const { providers, peerRouting, validators: validators22, lan } = init;
    this.log = logger("libp2p:kad-dht:rpc");
    this.routingTable = init.routingTable;
    this.handlers = {
      [MESSAGE_TYPE.GET_VALUE]: new GetValueHandler(components, { peerRouting }),
      [MESSAGE_TYPE.PUT_VALUE]: new PutValueHandler(components, { validators: validators22 }),
      [MESSAGE_TYPE.FIND_NODE]: new FindNodeHandler(components, { peerRouting, lan }),
      [MESSAGE_TYPE.ADD_PROVIDER]: new AddProviderHandler({ providers }),
      [MESSAGE_TYPE.GET_PROVIDERS]: new GetProvidersHandler(components, { peerRouting, providers, lan }),
      [MESSAGE_TYPE.PING]: new PingHandler()
    };
  }
  /**
   * Process incoming DHT messages
   */
  async handleMessage(peerId, msg) {
    try {
      await this.routingTable.add(peerId);
    } catch (err2) {
      this.log.error("Failed to update the kbucket store", err2);
    }
    const handler = this.handlers[msg.type];
    if (handler == null) {
      this.log.error(`no handler found for message type: ${msg.type}`);
      return;
    }
    return await handler.handle(peerId, msg);
  }
  /**
   * Handle incoming streams on the dht protocol
   */
  onIncomingStream(data) {
    Promise.resolve().then(async () => {
      const { stream, connection } = data;
      const peerId = connection.remotePeer;
      try {
        await this.routingTable.add(peerId);
      } catch (err2) {
        this.log.error(err2);
      }
      const self2 = this;
      await pipe(stream, decode14(), async function* (source) {
        for await (const msg of source) {
          const desMessage = Message2.deserialize(msg);
          self2.log("incoming %s from %p", desMessage.type, peerId);
          const res = await self2.handleMessage(peerId, desMessage);
          if (res != null) {
            yield res.serialize();
          }
        }
      }, encode15(), stream);
    }).catch((err2) => {
      this.log.error(err2);
    });
  }
};
var TopologyListener = class extends EventEmitter2 {
  constructor(components, init) {
    super();
    const { protocol: protocol4, lan } = init;
    this.components = components;
    this.log = logger(`libp2p:kad-dht:topology-listener:${lan ? "lan" : "wan"}`);
    this.running = false;
    this.protocol = protocol4;
  }
  isStarted() {
    return this.running;
  }
  /**
   * Start the network
   */
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    const topology = createTopology({
      onConnect: (peerId) => {
        this.log("observed peer %p with protocol %s", peerId, this.protocol);
        this.dispatchEvent(new CustomEvent2("peer", {
          detail: peerId
        }));
      }
    });
    this.registrarId = await this.components.registrar.register(this.protocol, topology);
  }
  /**
   * Stop all network activity
   */
  stop() {
    this.running = false;
    if (this.registrarId != null) {
      this.components.registrar.unregister(this.registrarId);
      this.registrarId = void 0;
    }
  }
};
var import_events41 = __toESM(require_events(), 1);
var import_timeout_abort_controller16 = __toESM(require_timeout_abort_controller(), 1);
var import_any_signal10 = __toESM(require_any_signal(), 1);
var QuerySelf = class {
  constructor(components, init) {
    const { peerRouting, lan, count, interval, queryTimeout } = init;
    this.components = components;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:query-self`);
    this.running = false;
    this.peerRouting = peerRouting;
    this.count = count ?? K;
    this.interval = interval ?? QUERY_SELF_INTERVAL;
    this.queryTimeout = queryTimeout ?? QUERY_SELF_TIMEOUT;
  }
  isStarted() {
    return this.running;
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    this._querySelf();
  }
  async stop() {
    this.running = false;
    if (this.timeoutId != null) {
      clearTimeout(this.timeoutId);
    }
    if (this.controller != null) {
      this.controller.abort();
    }
  }
  _querySelf() {
    Promise.resolve().then(async () => {
      const timeoutController = new import_timeout_abort_controller16.TimeoutController(this.queryTimeout);
      try {
        this.controller = new AbortController();
        const signal = (0, import_any_signal10.anySignal)([this.controller.signal, timeoutController.signal]);
        try {
          if (import_events41.setMaxListeners != null) {
            (0, import_events41.setMaxListeners)(Infinity, signal);
          }
        } catch {
        }
        const found = await pipe(this.peerRouting.getClosestPeers(this.components.peerId.toBytes(), {
          signal
        }), (source) => take(source, this.count), async (source) => await length(source));
        this.log("query ran successfully - found %d peers", found);
      } catch (err2) {
        this.log("query error", err2);
      } finally {
        this.timeoutId = setTimeout(this._querySelf.bind(this), this.interval);
        timeoutController.clear();
      }
    }).catch((err2) => {
      this.log("query error", err2);
    });
  }
};
var DEFAULT_MAX_INBOUND_STREAMS2 = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS2 = 64;
var KadDHT = class extends EventEmitter2 {
  /**
   * Create a new KadDHT
   */
  constructor(components, init) {
    super();
    const { kBucketSize, clientMode, validators: validators22, selectors: selectors2, querySelfInterval, lan, protocolPrefix, pingTimeout, pingConcurrency, maxInboundStreams, maxOutboundStreams, providers: providersInit } = init;
    this.running = false;
    this.components = components;
    this.lan = Boolean(lan);
    this.log = logger(`libp2p:kad-dht:${lan === true ? "lan" : "wan"}`);
    this.protocol = `${protocolPrefix ?? PROTOCOL_PREFIX}${lan === true ? LAN_PREFIX : ""}${PROTOCOL_DHT}`;
    this.kBucketSize = kBucketSize ?? 20;
    this.clientMode = clientMode ?? true;
    this.maxInboundStreams = maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS2;
    this.maxOutboundStreams = maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS2;
    this.routingTable = new RoutingTable(components, {
      kBucketSize,
      lan: this.lan,
      pingTimeout,
      pingConcurrency,
      protocol: this.protocol
    });
    this.providers = new Providers(components, providersInit ?? {});
    this.validators = {
      ...validators$1,
      ...validators22
    };
    this.selectors = {
      ...selectors,
      ...selectors2
    };
    this.network = new Network(components, {
      protocol: this.protocol,
      lan: this.lan
    });
    this.queryManager = new QueryManager(components, {
      // Number of disjoint query paths to use - This is set to `kBucketSize/2` per the S/Kademlia paper
      disjointPaths: Math.ceil(this.kBucketSize / 2),
      lan
    });
    this.peerRouting = new PeerRouting(components, {
      routingTable: this.routingTable,
      network: this.network,
      validators: this.validators,
      queryManager: this.queryManager,
      lan: this.lan
    });
    this.contentFetching = new ContentFetching(components, {
      validators: this.validators,
      selectors: this.selectors,
      peerRouting: this.peerRouting,
      queryManager: this.queryManager,
      routingTable: this.routingTable,
      network: this.network,
      lan: this.lan
    });
    this.contentRouting = new ContentRouting(components, {
      network: this.network,
      peerRouting: this.peerRouting,
      queryManager: this.queryManager,
      routingTable: this.routingTable,
      providers: this.providers,
      lan: this.lan
    });
    this.routingTableRefresh = new RoutingTableRefresh({
      peerRouting: this.peerRouting,
      routingTable: this.routingTable,
      lan: this.lan
    });
    this.rpc = new RPC2(components, {
      routingTable: this.routingTable,
      providers: this.providers,
      peerRouting: this.peerRouting,
      validators: this.validators,
      lan: this.lan
    });
    this.topologyListener = new TopologyListener(components, {
      protocol: this.protocol,
      lan: this.lan
    });
    this.querySelf = new QuerySelf(components, {
      peerRouting: this.peerRouting,
      interval: querySelfInterval,
      lan: this.lan
    });
    this.network.addEventListener("peer", (evt) => {
      const peerData = evt.detail;
      this.onPeerConnect(peerData).catch((err2) => {
        this.log.error("could not add %p to routing table", peerData.id, err2);
      });
      this.dispatchEvent(new CustomEvent2("peer", {
        detail: peerData
      }));
    });
    this.topologyListener.addEventListener("peer", (evt) => {
      const peerId = evt.detail;
      Promise.resolve().then(async () => {
        const multiaddrs = await this.components.peerStore.addressBook.get(peerId);
        const peerData = {
          id: peerId,
          multiaddrs: multiaddrs.map((addr) => addr.multiaddr),
          protocols: []
        };
        await this.onPeerConnect(peerData);
      }).catch((err2) => {
        this.log.error("could not add %p to routing table", peerId, err2);
      });
    });
  }
  get [symbol5]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/kad-dht";
  }
  async onPeerConnect(peerData) {
    this.log("peer %p connected with protocols %s", peerData.id, peerData.protocols);
    if (this.lan) {
      peerData = removePublicAddresses(peerData);
    } else {
      peerData = removePrivateAddresses(peerData);
    }
    if (peerData.multiaddrs.length === 0) {
      this.log("ignoring %p as they do not have any %s addresses in %s", peerData.id, this.lan ? "private" : "public", peerData.multiaddrs.map((addr) => addr.toString()));
      return;
    }
    try {
      await this.routingTable.add(peerData.id);
    } catch (err2) {
      this.log.error("could not add %p to routing table", peerData.id, err2);
    }
  }
  /**
   * Is this DHT running.
   */
  isStarted() {
    return this.running;
  }
  /**
   * If 'server' this node will respond to DHT queries, if 'client' this node will not
   */
  async getMode() {
    return this.clientMode ? "client" : "server";
  }
  /**
   * If 'server' this node will respond to DHT queries, if 'client' this node will not
   */
  async setMode(mode) {
    await this.components.registrar.unhandle(this.protocol);
    if (mode === "client") {
      this.log("enabling client mode");
      this.clientMode = true;
    } else {
      this.log("enabling server mode");
      this.clientMode = false;
      await this.components.registrar.handle(this.protocol, this.rpc.onIncomingStream.bind(this.rpc), {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams
      });
    }
  }
  /**
   * Start listening to incoming connections.
   */
  async start() {
    this.running = true;
    await this.setMode(this.clientMode ? "client" : "server");
    await Promise.all([
      this.providers.start(),
      this.queryManager.start(),
      this.network.start(),
      this.routingTable.start(),
      this.topologyListener.start(),
      this.querySelf.start()
    ]);
    await this.routingTableRefresh.start();
  }
  /**
   * Stop accepting incoming connections and sending outgoing
   * messages.
   */
  async stop() {
    this.running = false;
    await Promise.all([
      this.providers.stop(),
      this.queryManager.stop(),
      this.network.stop(),
      this.routingTable.stop(),
      this.routingTableRefresh.stop(),
      this.topologyListener.stop(),
      this.querySelf.stop()
    ]);
  }
  /**
   * Store the given key/value pair in the DHT
   */
  async *put(key, value2, options = {}) {
    yield* this.contentFetching.put(key, value2, options);
  }
  /**
   * Get the value that corresponds to the passed key
   */
  async *get(key, options = {}) {
    yield* this.contentFetching.get(key, options);
  }
  // ----------- Content Routing
  /**
   * Announce to the network that we can provide given key's value
   */
  async *provide(key, options = {}) {
    yield* this.contentRouting.provide(key, this.components.addressManager.getAddresses(), options);
  }
  /**
   * Search the dht for providers of the given CID
   */
  async *findProviders(key, options = {}) {
    yield* this.contentRouting.findProviders(key, options);
  }
  // ----------- Peer Routing -----------
  /**
   * Search for a peer with the given ID
   */
  async *findPeer(id, options = {}) {
    yield* this.peerRouting.findPeer(id, options);
  }
  /**
   * Kademlia 'node lookup' operation
   */
  async *getClosestPeers(key, options = {}) {
    yield* this.peerRouting.getClosestPeers(key, options);
  }
  async refreshRoutingTable() {
    await this.routingTableRefresh.refreshTable(true);
  }
};
var import_err_code135 = __toESM(require_err_code(), 1);
var log98 = logger("libp2p:kad-dht");
var DualKadDHT = class extends EventEmitter2 {
  constructor(components, wan, lan) {
    super();
    this.components = components;
    this.wan = wan;
    this.lan = lan;
    this.wan.addEventListener("peer", (evt) => {
      this.dispatchEvent(new CustomEvent2("peer", {
        detail: evt.detail
      }));
    });
    this.lan.addEventListener("peer", (evt) => {
      this.dispatchEvent(new CustomEvent2("peer", {
        detail: evt.detail
      }));
    });
  }
  get [symbol5]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/dual-kad-dht";
  }
  /**
   * Is this DHT running.
   */
  isStarted() {
    return this.wan.isStarted() && this.lan.isStarted();
  }
  /**
   * If 'server' this node will respond to DHT queries, if 'client' this node will not
   */
  async getMode() {
    return await this.wan.getMode();
  }
  /**
   * If 'server' this node will respond to DHT queries, if 'client' this node will not
   */
  async setMode(mode) {
    await this.wan.setMode(mode);
  }
  /**
   * Start listening to incoming connections.
   */
  async start() {
    await Promise.all([
      this.lan.start(),
      this.wan.start()
    ]);
  }
  /**
   * Stop accepting incoming connections and sending outgoing
   * messages.
   */
  async stop() {
    await Promise.all([
      this.lan.stop(),
      this.wan.stop()
    ]);
  }
  /**
   * Store the given key/value pair in the DHT
   */
  async *put(key, value2, options = {}) {
    for await (const event of merge$1(this.lan.put(key, value2, options), this.wan.put(key, value2, options))) {
      yield event;
    }
  }
  /**
   * Get the value that corresponds to the passed key
   */
  async *get(key, options = {}) {
    let queriedPeers = false;
    let foundValue = false;
    for await (const event of merge$1(this.lan.get(key, options), this.wan.get(key, options))) {
      yield event;
      if (event.name === "DIALING_PEER") {
        queriedPeers = true;
      }
      if (event.name === "VALUE") {
        queriedPeers = true;
        if (event.value != null) {
          foundValue = true;
        }
      }
      if (event.name === "SENDING_QUERY") {
        queriedPeers = true;
      }
    }
    if (!queriedPeers) {
      throw (0, import_err_code135.default)(new Error("No peers found in routing table!"), "ERR_NO_PEERS_IN_ROUTING_TABLE");
    }
    if (!foundValue) {
      yield queryErrorEvent({
        from: this.components.peerId,
        error: (0, import_err_code135.default)(new Error("Not found"), "ERR_NOT_FOUND")
      });
    }
  }
  // ----------- Content Routing
  /**
   * Announce to the network that we can provide given key's value
   */
  async *provide(key, options = {}) {
    let sent = 0;
    let success = 0;
    const errors2 = [];
    const dhts = [this.lan];
    if (await this.wan.getMode() === "server") {
      dhts.push(this.wan);
    }
    for await (const event of merge$1(...dhts.map((dht) => dht.provide(key, options)))) {
      yield event;
      if (event.name === "SENDING_QUERY") {
        sent++;
      }
      if (event.name === "QUERY_ERROR") {
        errors2.push(event.error);
      }
      if (event.name === "PEER_RESPONSE" && event.messageName === "ADD_PROVIDER") {
        log98("sent provider record for %s to %p", key, event.from);
        success++;
      }
    }
    if (success === 0) {
      if (errors2.length > 0) {
        throw (0, import_err_code135.default)(new Error(`Failed to provide to ${errors2.length} of ${sent} peers`), "ERR_PROVIDES_FAILED", { errors: errors2 });
      }
      throw (0, import_err_code135.default)(new Error("Failed to provide - no peers found"), "ERR_PROVIDES_FAILED");
    }
  }
  /**
   * Search the dht for up to `K` providers of the given CID
   */
  async *findProviders(key, options = {}) {
    yield* merge$1(this.lan.findProviders(key, options), this.wan.findProviders(key, options));
  }
  // ----------- Peer Routing -----------
  /**
   * Search for a peer with the given ID
   */
  async *findPeer(id, options = {}) {
    let queriedPeers = false;
    for await (const event of merge$1(this.lan.findPeer(id, options), this.wan.findPeer(id, options))) {
      yield event;
      if (event.name === "SENDING_QUERY" || event.name === "FINAL_PEER") {
        queriedPeers = true;
      }
    }
    if (!queriedPeers) {
      throw (0, import_err_code135.default)(new Error("Peer lookup failed"), "ERR_LOOKUP_FAILED");
    }
  }
  /**
   * Kademlia 'node lookup' operation
   */
  async *getClosestPeers(key, options = {}) {
    yield* merge$1(this.lan.getClosestPeers(key, options), this.wan.getClosestPeers(key, options));
  }
  async refreshRoutingTable() {
    await Promise.all([
      this.lan.refreshRoutingTable(),
      this.wan.refreshRoutingTable()
    ]);
  }
};
var KadDHT2 = class extends DualKadDHT {
  constructor(components, init) {
    super(components, new KadDHT(components, {
      protocolPrefix: "/ipfs",
      ...init,
      lan: false
    }), new KadDHT(components, {
      protocolPrefix: "/ipfs",
      ...init,
      clientMode: false,
      lan: true
    }));
  }
};
function kadDHT(init) {
  return (components) => new KadDHT2(components, init);
}
var log99 = logger("libp2p:bootstrap");
var DEFAULT_BOOTSTRAP_TAG_NAME = "bootstrap";
var DEFAULT_BOOTSTRAP_TAG_VALUE = 50;
var DEFAULT_BOOTSTRAP_TAG_TTL = 12e4;
var DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1e3;
var Bootstrap = class extends EventEmitter2 {
  constructor(components, options = { list: [] }) {
    if (options.list == null || options.list.length === 0) {
      throw new Error("Bootstrap requires a list of peer addresses");
    }
    super();
    this.components = components;
    this.timeout = options.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT;
    this.list = [];
    for (const candidate of options.list) {
      if (!P2P.matches(candidate)) {
        log99.error("Invalid multiaddr");
        continue;
      }
      const ma = multiaddr(candidate);
      const peerIdStr = ma.getPeerId();
      if (peerIdStr == null) {
        log99.error("Invalid bootstrap multiaddr without peer id");
        continue;
      }
      const peerData = {
        id: peerIdFromString(peerIdStr),
        multiaddrs: [ma],
        protocols: []
      };
      this.list.push(peerData);
    }
    this._init = options;
  }
  get [symbol5]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/bootstrap";
  }
  isStarted() {
    return Boolean(this.timer);
  }
  /**
   * Start emitting events
   */
  start() {
    if (this.isStarted()) {
      return;
    }
    log99("Starting bootstrap node discovery, discovering peers after %s ms", this.timeout);
    this.timer = setTimeout(() => {
      void this._discoverBootstrapPeers().catch((err2) => {
        log99.error(err2);
      });
    }, this.timeout);
  }
  /**
   * Emit each address in the list as a PeerInfo
   */
  async _discoverBootstrapPeers() {
    if (this.timer == null) {
      return;
    }
    for (const peerData of this.list) {
      await this.components.peerStore.tagPeer(peerData.id, this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME, {
        value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,
        ttl: this._init.tagTTL ?? DEFAULT_BOOTSTRAP_TAG_TTL
      });
      if (this.timer == null) {
        return;
      }
      this.dispatchEvent(new CustomEvent2("peer", { detail: peerData }));
    }
  }
  /**
   * Stop emitting events
   */
  stop() {
    if (this.timer != null) {
      clearTimeout(this.timer);
    }
    this.timer = void 0;
  }
};
Bootstrap.tag = "bootstrap";
function bootstrap(init) {
  return (components) => new Bootstrap(components, init);
}
var web_socket_browser_default = WebSocket;
var import_event_iterator = __toESM(require_dom(), 1);
function isArrayBuffer$1(obj) {
  return obj instanceof ArrayBuffer || obj?.constructor?.name === "ArrayBuffer" && typeof obj?.byteLength === "number";
}
var source_default = (socket) => {
  socket.binaryType = "arraybuffer";
  const connected = async () => await new Promise((resolve7, reject) => {
    if (isConnected) {
      return resolve7();
    }
    if (connError != null) {
      return reject(connError);
    }
    const cleanUp = (cont) => {
      socket.removeEventListener("open", onOpen);
      socket.removeEventListener("error", onError);
      cont();
    };
    const onOpen = () => cleanUp(resolve7);
    const onError = (event) => {
      cleanUp(() => reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`)));
    };
    socket.addEventListener("open", onOpen);
    socket.addEventListener("error", onError);
  });
  const source = async function* () {
    const messages3 = new import_event_iterator.EventIterator(({ push, stop: stop2, fail }) => {
      const onMessage = (event) => {
        let data = null;
        if (typeof event.data === "string") {
          data = fromString3(event.data);
        }
        if (isArrayBuffer$1(event.data)) {
          data = new Uint8Array(event.data);
        }
        if (event.data instanceof Uint8Array) {
          data = event.data;
        }
        if (data == null) {
          return;
        }
        push(data);
      };
      const onError = (event) => fail(event.error ?? new Error("Socket error"));
      socket.addEventListener("message", onMessage);
      socket.addEventListener("error", onError);
      socket.addEventListener("close", stop2);
      return () => {
        socket.removeEventListener("message", onMessage);
        socket.removeEventListener("error", onError);
        socket.removeEventListener("close", stop2);
      };
    }, { highWaterMark: Infinity });
    await connected();
    for await (const chunk of messages3) {
      yield isArrayBuffer$1(chunk) ? new Uint8Array(chunk) : chunk;
    }
  }();
  let isConnected = socket.readyState === 1;
  let connError;
  socket.addEventListener("open", () => {
    isConnected = true;
    connError = null;
  });
  socket.addEventListener("close", () => {
    isConnected = false;
    connError = null;
  });
  socket.addEventListener("error", (event) => {
    if (!isConnected) {
      connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`);
    }
  });
  return Object.assign(source, {
    connected
  });
};
var ready_default = (socket) => {
  if (socket.readyState >= 2) {
    throw new Error("socket closed");
  }
  if (socket.readyState === 1) {
    return;
  }
  return new Promise((resolve7, reject) => {
    function cleanup() {
      socket.removeEventListener("open", handleOpen);
      socket.removeEventListener("error", handleErr);
    }
    function handleOpen() {
      cleanup();
      resolve7();
    }
    function handleErr(event) {
      cleanup();
      reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
    }
    socket.addEventListener("open", handleOpen);
    socket.addEventListener("error", handleErr);
  });
};
var sink_default = (socket, options) => {
  options = options ?? {};
  options.closeOnEnd = options.closeOnEnd !== false;
  const sink = async (source) => {
    for await (const data of source) {
      try {
        await ready_default(socket);
      } catch (err2) {
        if (err2.message === "socket closed")
          break;
        throw err2;
      }
      socket.send(data);
    }
    if (options.closeOnEnd != null && socket.readyState <= 1) {
      return await new Promise((resolve7, reject) => {
        socket.addEventListener("close", (event) => {
          if (event.wasClean || event.code === 1006) {
            resolve7();
          } else {
            const err2 = Object.assign(new Error("ws error"), { event });
            reject(err2);
          }
        });
        setTimeout(() => socket.close());
      });
    }
  };
  return sink;
};
var duplex_default = (socket, options) => {
  options = options ?? {};
  const connectedSource = source_default(socket);
  let remoteAddress = options.remoteAddress;
  let remotePort = options.remotePort;
  if (socket.url != null) {
    try {
      const url2 = new URL(socket.url);
      remoteAddress = url2.hostname;
      remotePort = parseInt(url2.port, 10);
    } catch {
    }
  }
  if (remoteAddress == null || remotePort == null) {
    throw new Error("Remote connection did not have address and/or port");
  }
  const duplex = {
    sink: sink_default(socket, options),
    source: connectedSource,
    connected: async () => await connectedSource.connected(),
    close: async () => {
      if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {
        await new Promise((resolve7) => {
          socket.addEventListener("close", () => {
            resolve7();
          });
          socket.close();
        });
      }
    },
    destroy: () => {
      if (socket.terminate != null) {
        socket.terminate();
      } else {
        socket.close();
      }
    },
    remoteAddress,
    remotePort,
    socket
  };
  return duplex;
};
var import_iso_url2 = __toESM(require_iso_url(), 1);
var map3 = { http: "ws", https: "wss" };
var def = "ws";
var ws_url_default = (url2, location2) => (0, import_iso_url2.relative)(url2, location2, map3, def);
function connect(addr, opts) {
  const location2 = typeof window === "undefined" ? "" : window.location;
  opts = opts ?? {};
  const url2 = ws_url_default(addr, location2.toString());
  const socket = new web_socket_browser_default(url2, opts.websocket);
  return duplex_default(socket, opts);
}
function createListener3() {
  throw new Error("WebSocket Servers can not be created in the browser!");
}
var CODE_P2P2 = 421;
var CODE_CIRCUIT2 = 290;
var CODE_TCP = 6;
var CODE_WSS = 478;
var CLOSE_TIMEOUT2 = 2e3;
var log100 = logger("libp2p:websockets:socket");
function socketToMaConn(stream, remoteAddr, options) {
  options = options ?? {};
  const maConn = {
    async sink(source) {
      if (options?.signal != null) {
        source = abortableSource(source, options.signal);
      }
      try {
        await stream.sink(source);
      } catch (err2) {
        if (err2.type !== "aborted") {
          log100.error(err2);
        }
      }
    },
    source: options.signal != null ? abortableSource(stream.source, options.signal) : stream.source,
    remoteAddr,
    timeline: { open: Date.now() },
    async close() {
      const start = Date.now();
      try {
        await pTimeout2(stream.close(), {
          milliseconds: CLOSE_TIMEOUT2
        });
      } catch (err2) {
        const { host, port } = maConn.remoteAddr.toOptions();
        log100("timeout closing stream to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
        stream.destroy();
      } finally {
        maConn.timeline.close = Date.now();
      }
    }
  };
  stream.socket.addEventListener("close", () => {
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }, { once: true });
  return maConn;
}
function all2(multiaddrs) {
  return multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT2)) {
      return false;
    }
    const testMa = ma.decapsulateCode(CODE_P2P2);
    return WebSockets.matches(testMa) || WebSocketsSecure.matches(testMa);
  });
}
function dnsWss(multiaddrs) {
  return multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT2)) {
      return false;
    }
    const testMa = ma.decapsulateCode(CODE_P2P2);
    return WebSocketsSecure.matches(testMa) && DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS));
  });
}
var log101 = logger("libp2p:websockets");
var WebSockets2 = class {
  constructor(init) {
    this.init = init;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/websockets";
  }
  get [symbol4]() {
    return true;
  }
  async dial(ma, options) {
    log101("dialing %s", ma);
    options = options ?? {};
    const socket = await this._connect(ma, options);
    const maConn = socketToMaConn(socket, ma);
    log101("new outbound connection %s", maConn.remoteAddr);
    const conn = await options.upgrader.upgradeOutbound(maConn);
    log101("outbound connection %s upgraded", maConn.remoteAddr);
    return conn;
  }
  async _connect(ma, options) {
    if (options?.signal?.aborted === true) {
      throw new AbortError3();
    }
    const cOpts = ma.toOptions();
    log101("dialing %s:%s", cOpts.host, cOpts.port);
    const errorPromise = pDefer();
    const errfn = (err2) => {
      log101.error("connection error:", err2);
      errorPromise.reject(err2);
    };
    const rawSocket = connect(multiaddrToUri(ma), this.init);
    if (rawSocket.socket.on != null) {
      rawSocket.socket.on("error", errfn);
    } else {
      rawSocket.socket.onerror = errfn;
    }
    if (options.signal == null) {
      await Promise.race([rawSocket.connected(), errorPromise.promise]);
      log101("connected %s", ma);
      return rawSocket;
    }
    let onAbort;
    const abort = new Promise((resolve7, reject) => {
      onAbort = () => {
        reject(new AbortError3());
        rawSocket.close().catch((err2) => {
          log101.error("error closing raw socket", err2);
        });
      };
      if (options?.signal?.aborted === true) {
        return onAbort();
      }
      options?.signal?.addEventListener("abort", onAbort);
    });
    try {
      await Promise.race([abort, errorPromise.promise, rawSocket.connected()]);
    } finally {
      if (onAbort != null) {
        options?.signal?.removeEventListener("abort", onAbort);
      }
    }
    log101("connected %s", ma);
    return rawSocket;
  }
  /**
   * Creates a Websockets listener. The provided `handler` function will be called
   * anytime a new incoming Connection has been successfully upgraded via
   * `upgrader.upgradeInbound`
   */
  createListener(options) {
    return createListener3({ ...this.init, ...options });
  }
  /**
   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.
   * By default, in a browser environment only DNS+WSS multiaddr is accepted,
   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.
   */
  filter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    if (this.init?.filter != null) {
      return this.init?.filter(multiaddrs);
    }
    if (isBrowser3 || isWebWorker2) {
      return dnsWss(multiaddrs);
    }
    return all2(multiaddrs);
  }
};
function webSockets(init = {}) {
  return () => {
    return new WebSockets2(init);
  };
}
var import_varint8 = __toESM(require_varint(), 1);
function allocUnsafe3(size) {
  return new Uint8Array(size);
}
var MessageTypes;
(function(MessageTypes2) {
  MessageTypes2[MessageTypes2["NEW_STREAM"] = 0] = "NEW_STREAM";
  MessageTypes2[MessageTypes2["MESSAGE_RECEIVER"] = 1] = "MESSAGE_RECEIVER";
  MessageTypes2[MessageTypes2["MESSAGE_INITIATOR"] = 2] = "MESSAGE_INITIATOR";
  MessageTypes2[MessageTypes2["CLOSE_RECEIVER"] = 3] = "CLOSE_RECEIVER";
  MessageTypes2[MessageTypes2["CLOSE_INITIATOR"] = 4] = "CLOSE_INITIATOR";
  MessageTypes2[MessageTypes2["RESET_RECEIVER"] = 5] = "RESET_RECEIVER";
  MessageTypes2[MessageTypes2["RESET_INITIATOR"] = 6] = "RESET_INITIATOR";
})(MessageTypes || (MessageTypes = {}));
var MessageTypeNames = Object.freeze({
  0: "NEW_STREAM",
  1: "MESSAGE_RECEIVER",
  2: "MESSAGE_INITIATOR",
  3: "CLOSE_RECEIVER",
  4: "CLOSE_INITIATOR",
  5: "RESET_RECEIVER",
  6: "RESET_INITIATOR"
});
var InitiatorMessageTypes = Object.freeze({
  NEW_STREAM: MessageTypes.NEW_STREAM,
  MESSAGE: MessageTypes.MESSAGE_INITIATOR,
  CLOSE: MessageTypes.CLOSE_INITIATOR,
  RESET: MessageTypes.RESET_INITIATOR
});
var ReceiverMessageTypes = Object.freeze({
  MESSAGE: MessageTypes.MESSAGE_RECEIVER,
  CLOSE: MessageTypes.CLOSE_RECEIVER,
  RESET: MessageTypes.RESET_RECEIVER
});
var DEFAULT_BATCH_SIZE = 1024 * 1024;
var DEFAULT_SERIALIZE = (buf2, list) => list.append(buf2);
async function* batchedBytes(source, options = {}) {
  let buffer2 = new Uint8ArrayList();
  let ended = false;
  let deferred = pDefer();
  let size = Number(options.size ?? DEFAULT_BATCH_SIZE);
  if (isNaN(size) || size === 0 || size < 0) {
    size = DEFAULT_BATCH_SIZE;
  }
  const yieldAfter = options.yieldAfter ?? 0;
  const serialize = options.serialize ?? DEFAULT_SERIALIZE;
  void Promise.resolve().then(async () => {
    try {
      let timeout;
      for await (const buf2 of source) {
        serialize(buf2, buffer2);
        if (buffer2.byteLength >= size) {
          clearTimeout(timeout);
          deferred.resolve();
          continue;
        }
        timeout = setTimeout(() => {
          deferred.resolve();
        }, yieldAfter);
      }
      clearTimeout(timeout);
      deferred.resolve();
    } catch (err2) {
      deferred.reject(err2);
    } finally {
      ended = true;
    }
  });
  while (!ended) {
    await deferred.promise;
    deferred = pDefer();
    if (buffer2.byteLength > 0) {
      const b = buffer2;
      buffer2 = new Uint8ArrayList();
      yield b.subarray();
    }
  }
}
var src_default3 = batchedBytes;
var POOL_SIZE = 10 * 1024;
var Encoder2 = class {
  constructor() {
    this._pool = allocUnsafe3(POOL_SIZE);
    this._poolOffset = 0;
  }
  /**
   * Encodes the given message and adds it to the passed list
   */
  write(msg, list) {
    const pool = this._pool;
    let offset = this._poolOffset;
    import_varint8.default.encode(msg.id << 3 | msg.type, pool, offset);
    offset += import_varint8.default.encode.bytes ?? 0;
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      import_varint8.default.encode(msg.data.length, pool, offset);
    } else {
      import_varint8.default.encode(0, pool, offset);
    }
    offset += import_varint8.default.encode.bytes ?? 0;
    const header = pool.subarray(this._poolOffset, offset);
    if (POOL_SIZE - offset < 100) {
      this._pool = allocUnsafe3(POOL_SIZE);
      this._poolOffset = 0;
    } else {
      this._poolOffset = offset;
    }
    list.append(header);
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      list.append(msg.data);
    }
  }
};
var encoder = new Encoder2();
async function* encode19(source, minSendBytes = 0) {
  if (minSendBytes == null || minSendBytes === 0) {
    for await (const messages3 of source) {
      const list = new Uint8ArrayList();
      for (const msg of messages3) {
        encoder.write(msg, list);
      }
      yield list.subarray();
    }
    return;
  }
  yield* src_default3(source, {
    size: minSendBytes,
    serialize: (obj, list) => {
      for (const m of obj) {
        encoder.write(m, list);
      }
    }
  });
}
var MAX_MSG_SIZE = 1 << 20;
var MAX_MSG_QUEUE_SIZE = 4 << 20;
var Decoder2 = class {
  constructor(maxMessageSize = MAX_MSG_SIZE, maxUnprocessedMessageQueueSize = MAX_MSG_QUEUE_SIZE) {
    this._buffer = new Uint8ArrayList();
    this._headerInfo = null;
    this._maxMessageSize = maxMessageSize;
    this._maxUnprocessedMessageQueueSize = maxUnprocessedMessageQueueSize;
  }
  write(chunk) {
    if (chunk == null || chunk.length === 0) {
      return [];
    }
    this._buffer.append(chunk);
    if (this._buffer.byteLength > this._maxUnprocessedMessageQueueSize) {
      throw Object.assign(new Error("unprocessed message queue size too large!"), { code: "ERR_MSG_QUEUE_TOO_BIG" });
    }
    const msgs = [];
    while (this._buffer.length !== 0) {
      if (this._headerInfo == null) {
        try {
          this._headerInfo = this._decodeHeader(this._buffer);
        } catch (err2) {
          if (err2.code === "ERR_MSG_TOO_BIG") {
            throw err2;
          }
          break;
        }
      }
      const { id, type, length: length3, offset } = this._headerInfo;
      const bufferedDataLength = this._buffer.length - offset;
      if (bufferedDataLength < length3) {
        break;
      }
      const msg = {
        id,
        type
      };
      if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {
        msg.data = this._buffer.sublist(offset, offset + length3);
      }
      msgs.push(msg);
      this._buffer.consume(offset + length3);
      this._headerInfo = null;
    }
    return msgs;
  }
  /**
   * Attempts to decode the message header from the buffer
   */
  _decodeHeader(data) {
    const { value: h, offset } = readVarInt(data);
    const { value: length3, offset: end } = readVarInt(data, offset);
    const type = h & 7;
    if (MessageTypeNames[type] == null) {
      throw new Error(`Invalid type received: ${type}`);
    }
    if (length3 > this._maxMessageSize) {
      throw Object.assign(new Error("message size too large!"), { code: "ERR_MSG_TOO_BIG" });
    }
    return { id: h >> 3, type, offset: offset + end, length: length3 };
  }
};
var MSB = 128;
var REST = 127;
function readVarInt(buf2, offset = 0) {
  let res = 0;
  let shift = 0;
  let counter = offset;
  let b;
  const l = buf2.length;
  do {
    if (counter >= l || shift > 49) {
      offset = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2.get(counter++);
    res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB);
  offset = counter - offset;
  return {
    value: res,
    offset
  };
}
var import_err_code136 = __toESM(require_err_code(), 1);
var import_any_signal11 = __toESM(require_any_signal(), 1);
var log102 = logger("libp2p:mplex:stream");
var ERR_STREAM_RESET = "ERR_STREAM_RESET";
var ERR_STREAM_ABORT = "ERR_STREAM_ABORT";
var ERR_SINK_ENDED = "ERR_SINK_ENDED";
var ERR_DOUBLE_SINK = "ERR_DOUBLE_SINK";
function createStream(options) {
  const { id, name: name9, send, onEnd, type = "initiator", maxMsgSize = MAX_MSG_SIZE } = options;
  const abortController = new AbortController();
  const resetController = new AbortController();
  const closeController = new AbortController();
  const Types2 = type === "initiator" ? InitiatorMessageTypes : ReceiverMessageTypes;
  const externalId = type === "initiator" ? `i${id}` : `r${id}`;
  const streamName = `${name9 == null ? id : name9}`;
  let sourceEnded = false;
  let sinkEnded = false;
  let sinkSunk = false;
  let endErr;
  const timeline = {
    open: Date.now()
  };
  const onSourceEnd = (err2) => {
    if (sourceEnded) {
      return;
    }
    sourceEnded = true;
    log102.trace("%s stream %s source end - err: %o", type, streamName, err2);
    if (err2 != null && endErr == null) {
      endErr = err2;
    }
    if (sinkEnded) {
      stream.stat.timeline.close = Date.now();
      if (onEnd != null) {
        onEnd(endErr);
      }
    }
  };
  const onSinkEnd = (err2) => {
    if (sinkEnded) {
      return;
    }
    sinkEnded = true;
    log102.trace("%s stream %s sink end - err: %o", type, streamName, err2);
    if (err2 != null && endErr == null) {
      endErr = err2;
    }
    if (sourceEnded) {
      timeline.close = Date.now();
      if (onEnd != null) {
        onEnd(endErr);
      }
    }
  };
  const streamSource = pushable({
    onEnd: onSourceEnd
  });
  const stream = {
    // Close for both Reading and Writing
    close: () => {
      log102.trace("%s stream %s close", type, streamName);
      stream.closeRead();
      stream.closeWrite();
    },
    // Close for reading
    closeRead: () => {
      log102.trace("%s stream %s closeRead", type, streamName);
      if (sourceEnded) {
        return;
      }
      streamSource.end();
    },
    // Close for writing
    closeWrite: () => {
      log102.trace("%s stream %s closeWrite", type, streamName);
      if (sinkEnded) {
        return;
      }
      closeController.abort();
      try {
        send({ id, type: Types2.CLOSE });
      } catch (err2) {
        log102.trace("%s stream %s error sending close", type, name9, err2);
      }
      onSinkEnd();
    },
    // Close for reading and writing (local error)
    abort: (err2) => {
      log102.trace("%s stream %s abort", type, streamName, err2);
      streamSource.end(err2);
      abortController.abort();
      onSinkEnd(err2);
    },
    // Close immediately for reading and writing (remote error)
    reset: () => {
      const err2 = (0, import_err_code136.default)(new Error("stream reset"), ERR_STREAM_RESET);
      resetController.abort();
      streamSource.end(err2);
      onSinkEnd(err2);
    },
    sink: async (source) => {
      if (sinkSunk) {
        throw (0, import_err_code136.default)(new Error("sink already called on stream"), ERR_DOUBLE_SINK);
      }
      sinkSunk = true;
      if (sinkEnded) {
        throw (0, import_err_code136.default)(new Error("stream closed for writing"), ERR_SINK_ENDED);
      }
      source = abortableSource(source, (0, import_any_signal11.anySignal)([
        abortController.signal,
        resetController.signal,
        closeController.signal
      ]));
      try {
        if (type === "initiator") {
          send({ id, type: InitiatorMessageTypes.NEW_STREAM, data: new Uint8ArrayList(fromString3(streamName)) });
        }
        for await (let data of source) {
          while (data.length > 0) {
            if (data.length <= maxMsgSize) {
              send({ id, type: Types2.MESSAGE, data: data instanceof Uint8Array ? new Uint8ArrayList(data) : data });
              break;
            }
            data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data;
            send({ id, type: Types2.MESSAGE, data: data.sublist(0, maxMsgSize) });
            data.consume(maxMsgSize);
          }
        }
      } catch (err2) {
        if (err2.type === "aborted" && err2.message === "The operation was aborted") {
          if (closeController.signal.aborted) {
            return;
          }
          if (resetController.signal.aborted) {
            err2.message = "stream reset";
            err2.code = ERR_STREAM_RESET;
          }
          if (abortController.signal.aborted) {
            err2.message = "stream aborted";
            err2.code = ERR_STREAM_ABORT;
          }
        }
        if (err2.code === ERR_STREAM_RESET) {
          log102.trace("%s stream %s reset", type, name9);
        } else {
          log102.trace("%s stream %s error", type, name9, err2);
          try {
            send({ id, type: Types2.RESET });
          } catch (err3) {
            log102.trace("%s stream %s error sending reset", type, name9, err3);
          }
        }
        streamSource.end(err2);
        onSinkEnd(err2);
        return;
      }
      try {
        send({ id, type: Types2.CLOSE });
      } catch (err2) {
        log102.trace("%s stream %s error sending close", type, name9, err2);
      }
      onSinkEnd();
    },
    source: streamSource,
    sourcePush: (data) => {
      streamSource.push(data);
    },
    sourceReadableLength() {
      return streamSource.readableLength;
    },
    stat: {
      direction: type === "initiator" ? "outbound" : "inbound",
      timeline
    },
    metadata: {},
    id: externalId
  };
  return stream;
}
var import_err_code137 = __toESM(require_err_code(), 1);
var import_rate_limiter_flexible2 = __toESM(require_rate_limiter_flexible(), 1);
var import_any_signal12 = __toESM(require_any_signal(), 1);
var log103 = logger("libp2p:mplex");
var MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4;
var DISCONNECT_THRESHOLD = 5;
function printMessage(msg) {
  const output = {
    ...msg,
    type: `${MessageTypeNames[msg.type]} (${msg.type})`
  };
  if (msg.type === MessageTypes.NEW_STREAM) {
    output.data = toString3(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray());
  }
  if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {
    output.data = toString3(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), "base16");
  }
  return output;
}
var MplexStreamMuxer = class {
  constructor(init) {
    this.protocol = "/mplex/6.7.0";
    init = init ?? {};
    this._streamId = 0;
    this._streams = {
      /**
       * Stream to ids map
       */
      initiators: /* @__PURE__ */ new Map(),
      /**
       * Stream to ids map
       */
      receivers: /* @__PURE__ */ new Map()
    };
    this._init = init;
    this.sink = this._createSink();
    const source = this._createSource();
    this._source = source;
    this.source = source;
    this.closeController = new AbortController();
    this.rateLimiter = new import_rate_limiter_flexible2.RateLimiterMemory({
      points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,
      duration: 1
    });
  }
  /**
   * Returns a Map of streams and their ids
   */
  get streams() {
    const streams = [];
    for (const stream of this._streams.initiators.values()) {
      streams.push(stream);
    }
    for (const stream of this._streams.receivers.values()) {
      streams.push(stream);
    }
    return streams;
  }
  /**
   * Initiate a new stream with the given name. If no name is
   * provided, the id of the stream will be used.
   */
  newStream(name9) {
    if (this.closeController.signal.aborted) {
      throw new Error("Muxer already closed");
    }
    const id = this._streamId++;
    name9 = name9 == null ? id.toString() : name9.toString();
    const registry = this._streams.initiators;
    return this._newStream({ id, name: name9, type: "initiator", registry });
  }
  /**
   * Close or abort all tracked streams and stop the muxer
   */
  close(err2) {
    if (this.closeController.signal.aborted)
      return;
    if (err2 != null) {
      this.streams.forEach((s) => s.abort(err2));
    } else {
      this.streams.forEach((s) => s.close());
    }
    this.closeController.abort();
  }
  /**
   * Called whenever an inbound stream is created
   */
  _newReceiverStream(options) {
    const { id, name: name9 } = options;
    const registry = this._streams.receivers;
    return this._newStream({ id, name: name9, type: "receiver", registry });
  }
  _newStream(options) {
    const { id, name: name9, type, registry } = options;
    log103("new %s stream %s", type, id);
    if (type === "initiator" && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {
      throw (0, import_err_code137.default)(new Error("Too many outbound streams open"), "ERR_TOO_MANY_OUTBOUND_STREAMS");
    }
    if (registry.has(id)) {
      throw new Error(`${type} stream ${id} already exists!`);
    }
    const send = (msg) => {
      if (log103.enabled) {
        log103.trace("%s stream %s send", type, id, printMessage(msg));
      }
      this._source.push(msg);
    };
    const onEnd = () => {
      log103("%s stream with id %s and protocol %s ended", type, id, stream.stat.protocol);
      registry.delete(id);
      if (this._init.onStreamEnd != null) {
        this._init.onStreamEnd(stream);
      }
    };
    const stream = createStream({ id, name: name9, send, type, onEnd, maxMsgSize: this._init.maxMsgSize });
    registry.set(id, stream);
    return stream;
  }
  /**
   * Creates a sink with an abortable source. Incoming messages will
   * also have their size restricted. All messages will be varint decoded.
   */
  _createSink() {
    const sink = async (source) => {
      const abortSignals = [this.closeController.signal];
      if (this._init.signal != null) {
        abortSignals.push(this._init.signal);
      }
      source = abortableSource(source, (0, import_any_signal12.default)(abortSignals));
      try {
        const decoder = new Decoder2(this._init.maxMsgSize, this._init.maxUnprocessedMessageQueueSize);
        for await (const chunk of source) {
          for (const msg of decoder.write(chunk)) {
            await this._handleIncoming(msg);
          }
        }
        this._source.end();
      } catch (err2) {
        log103("error in sink", err2);
        this._source.end(err2);
      }
    };
    return sink;
  }
  /**
   * Creates a source that restricts outgoing message sizes
   * and varint encodes them
   */
  _createSource() {
    const onEnd = (err2) => {
      this.close(err2);
    };
    const source = pushableV({
      objectMode: true,
      onEnd
    });
    return Object.assign(encode19(source, this._init.minSendBytes), {
      push: source.push,
      end: source.end,
      return: source.return
    });
  }
  async _handleIncoming(message2) {
    const { id, type } = message2;
    if (log103.enabled) {
      log103.trace("incoming message", printMessage(message2));
    }
    if (message2.type === MessageTypes.NEW_STREAM) {
      if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {
        log103("too many inbound streams open");
        this._source.push({
          id,
          type: MessageTypes.RESET_RECEIVER
        });
        try {
          await this.rateLimiter.consume("new-stream", 1);
        } catch {
          log103("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection");
          this._source.end(new Error("Too many open streams"));
          return;
        }
        return;
      }
      const stream2 = this._newReceiverStream({ id, name: toString3(message2.data instanceof Uint8Array ? message2.data : message2.data.subarray()) });
      if (this._init.onIncomingStream != null) {
        this._init.onIncomingStream(stream2);
      }
      return;
    }
    const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers;
    const stream = list.get(id);
    if (stream == null) {
      log103("missing stream %s for message type %s", id, MessageTypeNames[type]);
      return;
    }
    const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE;
    switch (type) {
      case MessageTypes.MESSAGE_INITIATOR:
      case MessageTypes.MESSAGE_RECEIVER:
        if (stream.sourceReadableLength() > maxBufferSize) {
          this._source.push({
            id: message2.id,
            type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR
          });
          const error = (0, import_err_code137.default)(new Error("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers"), "ERR_STREAM_INPUT_BUFFER_FULL");
          stream.abort(error);
          return;
        }
        stream.sourcePush(message2.data);
        break;
      case MessageTypes.CLOSE_INITIATOR:
      case MessageTypes.CLOSE_RECEIVER:
        stream.closeRead();
        break;
      case MessageTypes.RESET_INITIATOR:
      case MessageTypes.RESET_RECEIVER:
        stream.reset();
        break;
      default:
        log103("unknown message type %s", type);
    }
  }
};
var Mplex = class {
  constructor(init = {}) {
    this.protocol = "/mplex/6.7.0";
    this._init = init;
  }
  createStreamMuxer(init = {}) {
    return new MplexStreamMuxer({
      ...init,
      ...this._init
    });
  }
};
function mplex(init = {}) {
  return () => new Mplex(init);
}
function pbStream(duplex, opts = {}) {
  const shake = handshake(duplex);
  const lpReader = decode14.fromReader(shake.reader, opts);
  const W = {
    read: async (bytes2) => {
      const { value: value2 } = await shake.reader.next(bytes2);
      if (value2 == null) {
        throw new Error("Value is null");
      }
      return value2;
    },
    readLP: async () => {
      const { value: value2 } = await lpReader.next();
      if (value2 == null) {
        throw new Error("Value is null");
      }
      return value2;
    },
    readPB: async (proto) => {
      const value2 = await W.readLP();
      if (value2 == null) {
        throw new Error("Value is null");
      }
      const buf2 = value2 instanceof Uint8Array ? value2 : value2.subarray();
      return proto.decode(buf2);
    },
    write: (data) => {
      if (data instanceof Uint8Array) {
        shake.writer.push(data);
      } else {
        shake.writer.push(data.subarray());
      }
    },
    writeLP: (data) => {
      W.write(encode15.single(data, opts));
    },
    writePB: (data, proto) => {
      W.writeLP(proto.encode(data));
    },
    pb: (proto) => {
      return {
        read: async () => await W.readPB(proto),
        write: (d) => W.writePB(d, proto)
      };
    },
    unwrap: () => {
      shake.rest();
      return shake.stream;
    }
  };
  return W;
}
function pair() {
  const deferred = pDefer();
  let piped = false;
  return {
    sink: async (source) => {
      if (piped) {
        throw new Error("already piped");
      }
      piped = true;
      deferred.resolve(source);
    },
    source: async function* () {
      const source = await deferred.promise;
      yield* source;
    }()
  };
}
function duplexPair() {
  const a = pair();
  const b = pair();
  return [
    {
      source: a.source,
      sink: b.sink
    },
    {
      source: b.source,
      sink: a.sink
    }
  ];
}
var NOISE_MSG_MAX_LENGTH_BYTES = 65535;
var NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;
var DUMP_SESSION_KEYS = Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS);
var import_hkdf = __toESM(require_hkdf(), 1);
var x25519 = __toESM(require_x25519(), 1);
var import_sha256 = __toESM(require_sha2562(), 1);
var import_chacha20poly1305 = __toESM(require_chacha20poly1305(), 1);
var stablelib = {
  hashSHA256(data) {
    return (0, import_sha256.hash)(data);
  },
  getHKDF(ck, ikm) {
    const hkdf = new import_hkdf.HKDF(import_sha256.SHA256, ikm, ck);
    const okmU8Array = hkdf.expand(96);
    const okm = okmU8Array;
    const k1 = okm.subarray(0, 32);
    const k2 = okm.subarray(32, 64);
    const k3 = okm.subarray(64, 96);
    return [k1, k2, k3];
  },
  generateX25519KeyPair() {
    const keypair = x25519.generateKeyPair();
    return {
      publicKey: keypair.publicKey,
      privateKey: keypair.secretKey
    };
  },
  generateX25519KeyPairFromSeed(seed2) {
    const keypair = x25519.generateKeyPairFromSeed(seed2);
    return {
      publicKey: keypair.publicKey,
      privateKey: keypair.secretKey
    };
  },
  generateX25519SharedKey(privateKey, publicKey) {
    return x25519.sharedKey(privateKey, publicKey);
  },
  chaCha20Poly1305Encrypt(plaintext, nonce, ad, k) {
    const ctx = new import_chacha20poly1305.ChaCha20Poly1305(k);
    return ctx.seal(nonce, plaintext, ad);
  },
  chaCha20Poly1305Decrypt(ciphertext, nonce, ad, k, dst) {
    const ctx = new import_chacha20poly1305.ChaCha20Poly1305(k);
    return ctx.open(nonce, ciphertext, ad, dst);
  }
};
var import_chacha20poly13052 = __toESM(require_chacha20poly1305(), 1);
var allocUnsafe4 = (len) => {
  if (globalThis.Buffer) {
    return globalThis.Buffer.allocUnsafe(len);
  }
  return new Uint8Array(len);
};
var uint16BEEncode = (value2) => {
  const target = allocUnsafe4(2);
  new DataView(target.buffer, target.byteOffset, target.byteLength).setUint16(0, value2, false);
  return target;
};
uint16BEEncode.bytes = 2;
var uint16BEDecode = (data) => {
  if (data.length < 2)
    throw RangeError("Could not decode int16BE");
  if (data instanceof Uint8Array) {
    return new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0, false);
  }
  return data.getUint16(0);
};
uint16BEDecode.bytes = 2;
function encode0(message2) {
  return concat([message2.ne, message2.ciphertext], message2.ne.length + message2.ciphertext.length);
}
function encode1(message2) {
  return concat([message2.ne, message2.ns, message2.ciphertext], message2.ne.length + message2.ns.length + message2.ciphertext.length);
}
function encode22(message2) {
  return concat([message2.ns, message2.ciphertext], message2.ns.length + message2.ciphertext.length);
}
function decode0(input) {
  if (input.length < 32) {
    throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");
  }
  return {
    ne: input.subarray(0, 32),
    ciphertext: input.subarray(32, input.length),
    ns: new Uint8Array(0)
  };
}
function decode1(input) {
  if (input.length < 80) {
    throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");
  }
  return {
    ne: input.subarray(0, 32),
    ns: input.subarray(32, 80),
    ciphertext: input.subarray(80, input.length)
  };
}
function decode22(input) {
  if (input.length < 48) {
    throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");
  }
  return {
    ne: new Uint8Array(0),
    ns: input.subarray(0, 48),
    ciphertext: input.subarray(48, input.length)
  };
}
function encryptStream(handshake2, metrics) {
  return async function* (source) {
    for await (const chunk of source) {
      for (let i2 = 0; i2 < chunk.length; i2 += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
        let end = i2 + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
        if (end > chunk.length) {
          end = chunk.length;
        }
        const data = handshake2.encrypt(chunk.subarray(i2, end), handshake2.session);
        metrics?.encryptedPackets.increment();
        yield uint16BEEncode(data.byteLength);
        yield data;
      }
    }
  };
}
function decryptStream(handshake2, metrics) {
  return async function* (source) {
    for await (const chunk of source) {
      for (let i2 = 0; i2 < chunk.length; i2 += NOISE_MSG_MAX_LENGTH_BYTES) {
        let end = i2 + NOISE_MSG_MAX_LENGTH_BYTES;
        if (end > chunk.length) {
          end = chunk.length;
        }
        if (end - import_chacha20poly13052.TAG_LENGTH < i2) {
          throw new Error("Invalid chunk");
        }
        const encrypted = chunk.subarray(i2, end);
        const dst = chunk.subarray(i2, end - import_chacha20poly13052.TAG_LENGTH);
        const { plaintext: decrypted, valid } = handshake2.decrypt(encrypted, handshake2.session, dst);
        if (!valid) {
          metrics?.decryptErrors.increment();
          throw new Error("Failed to validate decrypted chunk");
        }
        metrics?.decryptedPackets.increment();
        yield decrypted;
      }
    }
  };
}
var UnexpectedPeerError = class extends Error {
  constructor(message2 = "Unexpected Peer") {
    super(message2);
    this.code = UnexpectedPeerError.code;
  }
  static get code() {
    return "ERR_UNEXPECTED_PEER";
  }
};
var InvalidCryptoExchangeError = class extends Error {
  constructor(message2 = "Invalid crypto exchange") {
    super(message2);
    this.code = InvalidCryptoExchangeError.code;
  }
  static get code() {
    return "ERR_INVALID_CRYPTO_EXCHANGE";
  }
};
var NoiseExtensions;
(function(NoiseExtensions2) {
  let _codec;
  NoiseExtensions2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.webtransportCerthashes != null) {
          for (const value2 of obj.webtransportCerthashes) {
            w.uint32(10);
            w.bytes(value2);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {
          webtransportCerthashes: []
        };
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.webtransportCerthashes.push(reader3.bytes());
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  NoiseExtensions2.encode = (obj) => {
    return encodeMessage(obj, NoiseExtensions2.codec());
  };
  NoiseExtensions2.decode = (buf2) => {
    return decodeMessage(buf2, NoiseExtensions2.codec());
  };
})(NoiseExtensions || (NoiseExtensions = {}));
var NoiseHandshakePayload;
(function(NoiseHandshakePayload2) {
  let _codec;
  NoiseHandshakePayload2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.identityKey != null && obj.identityKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.identityKey);
        }
        if (opts.writeDefaults === true || obj.identitySig != null && obj.identitySig.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.identitySig);
        }
        if (obj.extensions != null) {
          w.uint32(34);
          NoiseExtensions.codec().encode(obj.extensions, w, {
            writeDefaults: false
          });
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader3, length3) => {
        const obj = {
          identityKey: new Uint8Array(0),
          identitySig: new Uint8Array(0)
        };
        const end = length3 == null ? reader3.len : reader3.pos + length3;
        while (reader3.pos < end) {
          const tag = reader3.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.identityKey = reader3.bytes();
              break;
            case 2:
              obj.identitySig = reader3.bytes();
              break;
            case 4:
              obj.extensions = NoiseExtensions.codec().decode(reader3, reader3.uint32());
              break;
            default:
              reader3.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  NoiseHandshakePayload2.encode = (obj) => {
    return encodeMessage(obj, NoiseHandshakePayload2.codec());
  };
  NoiseHandshakePayload2.decode = (buf2) => {
    return decodeMessage(buf2, NoiseHandshakePayload2.codec());
  };
})(NoiseHandshakePayload || (NoiseHandshakePayload = {}));
async function getPayload(localPeer, staticPublicKey, extensions) {
  const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));
  if (localPeer.publicKey == null) {
    throw new Error("PublicKey was missing from local PeerId");
  }
  return createHandshakePayload(localPeer.publicKey, signedPayload, extensions);
}
function createHandshakePayload(libp2pPublicKey, signedPayload, extensions) {
  return NoiseHandshakePayload.encode({
    identityKey: libp2pPublicKey,
    identitySig: signedPayload,
    extensions: extensions ?? { webtransportCerthashes: [] }
  }).subarray();
}
async function signPayload(peerId, payload) {
  if (peerId.privateKey == null) {
    throw new Error("PrivateKey was missing from PeerId");
  }
  const privateKey = await unmarshalPrivateKey3(peerId.privateKey);
  return await privateKey.sign(payload);
}
async function getPeerIdFromPayload(payload) {
  return await peerIdFromKeys(payload.identityKey);
}
function decodePayload2(payload) {
  return NoiseHandshakePayload.decode(payload);
}
function getHandshakePayload(publicKey) {
  const prefix = fromString3("noise-libp2p-static-key:");
  return concat([prefix, publicKey], prefix.length + publicKey.length);
}
async function verifySignedPayload(noiseStaticKey, payload, remotePeer) {
  const payloadPeerId = await peerIdFromKeys(payload.identityKey);
  if (!payloadPeerId.equals(remotePeer)) {
    throw new Error("Peer ID doesn't match libp2p public key.");
  }
  const generatedPayload = getHandshakePayload(noiseStaticKey);
  if (payloadPeerId.publicKey == null) {
    throw new Error("PublicKey was missing from PeerId");
  }
  if (payload.identitySig == null) {
    throw new Error("Signature was missing from message");
  }
  const publicKey = unmarshalPublicKey2(payloadPeerId.publicKey);
  const valid = await publicKey.verify(generatedPayload, payload.identitySig);
  if (!valid) {
    throw new Error("Static key doesn't match to peer that signed payload!");
  }
  return payloadPeerId;
}
function isValidPublicKey(pk) {
  if (!(pk instanceof Uint8Array)) {
    return false;
  }
  if (pk.length !== 32) {
    return false;
  }
  return true;
}
var log104 = logger("libp2p:noise");
var keyLogger;
if (DUMP_SESSION_KEYS) {
  keyLogger = log104;
} else {
  keyLogger = Object.assign(() => {
  }, {
    enabled: false,
    trace: () => {
    },
    error: () => {
    }
  });
}
function logLocalStaticKeys(s) {
  keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${toString3(s.publicKey, "hex")}`);
  keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${toString3(s.privateKey, "hex")}`);
}
function logLocalEphemeralKeys(e) {
  if (e) {
    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString3(e.publicKey, "hex")}`);
    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString3(e.privateKey, "hex")}`);
  } else {
    keyLogger("Missing local ephemeral keys.");
  }
}
function logRemoteStaticKey(rs) {
  keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${toString3(rs, "hex")}`);
}
function logRemoteEphemeralKey(re2) {
  keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString3(re2, "hex")}`);
}
function logCipherState(session) {
  if (session.cs1 && session.cs2) {
    keyLogger(`CIPHER_STATE_1 ${session.cs1.n.getUint64()} ${toString3(session.cs1.k, "hex")}`);
    keyLogger(`CIPHER_STATE_2 ${session.cs2.n.getUint64()} ${toString3(session.cs2.k, "hex")}`);
  } else {
    keyLogger("Missing cipher state.");
  }
}
var MIN_NONCE = 0;
var MAX_NONCE = 4294967295;
var ERR_MAX_NONCE = "Cipherstate has reached maximum n, a new handshake must be performed";
var Nonce = class {
  constructor(n = MIN_NONCE) {
    this.n = n;
    this.bytes = new Uint8Array(12);
    this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);
    this.view.setUint32(4, n, true);
  }
  increment() {
    this.n++;
    this.view.setUint32(4, this.n, true);
  }
  getBytes() {
    return this.bytes;
  }
  getUint64() {
    return this.n;
  }
  assertValue() {
    if (this.n > MAX_NONCE) {
      throw new Error(ERR_MAX_NONCE);
    }
  }
};
var AbstractHandshake = class {
  constructor(crypto4) {
    this.crypto = crypto4;
  }
  encryptWithAd(cs, ad, plaintext) {
    const e = this.encrypt(cs.k, cs.n, ad, plaintext);
    cs.n.increment();
    return e;
  }
  decryptWithAd(cs, ad, ciphertext, dst) {
    const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext, dst);
    if (valid)
      cs.n.increment();
    return { plaintext, valid };
  }
  // Cipher state related
  hasKey(cs) {
    return !this.isEmptyKey(cs.k);
  }
  createEmptyKey() {
    return new Uint8Array(32);
  }
  isEmptyKey(k) {
    const emptyKey = this.createEmptyKey();
    return equals(emptyKey, k);
  }
  encrypt(k, n, ad, plaintext) {
    n.assertValue();
    return this.crypto.chaCha20Poly1305Encrypt(plaintext, n.getBytes(), ad, k);
  }
  encryptAndHash(ss, plaintext) {
    let ciphertext;
    if (this.hasKey(ss.cs)) {
      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);
    } else {
      ciphertext = plaintext;
    }
    this.mixHash(ss, ciphertext);
    return ciphertext;
  }
  decrypt(k, n, ad, ciphertext, dst) {
    n.assertValue();
    const encryptedMessage = this.crypto.chaCha20Poly1305Decrypt(ciphertext, n.getBytes(), ad, k, dst);
    if (encryptedMessage) {
      return {
        plaintext: encryptedMessage,
        valid: true
      };
    } else {
      return {
        plaintext: new Uint8Array(0),
        valid: false
      };
    }
  }
  decryptAndHash(ss, ciphertext) {
    let plaintext;
    let valid = true;
    if (this.hasKey(ss.cs)) {
      ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext));
    } else {
      plaintext = ciphertext;
    }
    this.mixHash(ss, ciphertext);
    return { plaintext, valid };
  }
  dh(privateKey, publicKey) {
    try {
      const derivedU8 = this.crypto.generateX25519SharedKey(privateKey, publicKey);
      if (derivedU8.length === 32) {
        return derivedU8;
      }
      return derivedU8.subarray(0, 32);
    } catch (e) {
      const err2 = e;
      log104(err2.message);
      return new Uint8Array(32);
    }
  }
  mixHash(ss, data) {
    ss.h = this.getHash(ss.h, data);
  }
  getHash(a, b) {
    const u = this.crypto.hashSHA256(concat([a, b], a.length + b.length));
    return u;
  }
  mixKey(ss, ikm) {
    const [ck, tempK] = this.crypto.getHKDF(ss.ck, ikm);
    ss.cs = this.initializeKey(tempK);
    ss.ck = ck;
  }
  initializeKey(k) {
    return { k, n: new Nonce() };
  }
  // Symmetric state related
  initializeSymmetric(protocolName) {
    const protocolNameBytes = fromString3(protocolName, "utf-8");
    const h = this.hashProtocolName(protocolNameBytes);
    const ck = h;
    const key = this.createEmptyKey();
    const cs = this.initializeKey(key);
    return { cs, ck, h };
  }
  hashProtocolName(protocolName) {
    if (protocolName.length <= 32) {
      const h = new Uint8Array(32);
      h.set(protocolName);
      return h;
    } else {
      return this.getHash(protocolName, new Uint8Array(0));
    }
  }
  split(ss) {
    const [tempk1, tempk2] = this.crypto.getHKDF(ss.ck, new Uint8Array(0));
    const cs1 = this.initializeKey(tempk1);
    const cs2 = this.initializeKey(tempk2);
    return { cs1, cs2 };
  }
  writeMessageRegular(cs, payload) {
    const ciphertext = this.encryptWithAd(cs, new Uint8Array(0), payload);
    const ne = this.createEmptyKey();
    const ns = new Uint8Array(0);
    return { ne, ns, ciphertext };
  }
  readMessageRegular(cs, message2) {
    return this.decryptWithAd(cs, new Uint8Array(0), message2.ciphertext);
  }
};
var XX = class extends AbstractHandshake {
  initializeInitiator(prologue, s, rs, psk) {
    const name9 = "Noise_XX_25519_ChaChaPoly_SHA256";
    const ss = this.initializeSymmetric(name9);
    this.mixHash(ss, prologue);
    const re2 = new Uint8Array(32);
    return { ss, s, rs, psk, re: re2 };
  }
  initializeResponder(prologue, s, rs, psk) {
    const name9 = "Noise_XX_25519_ChaChaPoly_SHA256";
    const ss = this.initializeSymmetric(name9);
    this.mixHash(ss, prologue);
    const re2 = new Uint8Array(32);
    return { ss, s, rs, psk, re: re2 };
  }
  writeMessageA(hs, payload, e) {
    const ns = new Uint8Array(0);
    if (e !== void 0) {
      hs.e = e;
    } else {
      hs.e = this.crypto.generateX25519KeyPair();
    }
    const ne = hs.e.publicKey;
    this.mixHash(hs.ss, ne);
    const ciphertext = this.encryptAndHash(hs.ss, payload);
    return { ne, ns, ciphertext };
  }
  writeMessageB(hs, payload) {
    hs.e = this.crypto.generateX25519KeyPair();
    const ne = hs.e.publicKey;
    this.mixHash(hs.ss, ne);
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
    const spk = hs.s.publicKey;
    const ns = this.encryptAndHash(hs.ss, spk);
    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
    const ciphertext = this.encryptAndHash(hs.ss, payload);
    return { ne, ns, ciphertext };
  }
  writeMessageC(hs, payload) {
    const spk = hs.s.publicKey;
    const ns = this.encryptAndHash(hs.ss, spk);
    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
    const ciphertext = this.encryptAndHash(hs.ss, payload);
    const ne = this.createEmptyKey();
    const messageBuffer = { ne, ns, ciphertext };
    const { cs1, cs2 } = this.split(hs.ss);
    return { h: hs.ss.h, messageBuffer, cs1, cs2 };
  }
  readMessageA(hs, message2) {
    if (isValidPublicKey(message2.ne)) {
      hs.re = message2.ne;
    }
    this.mixHash(hs.ss, hs.re);
    return this.decryptAndHash(hs.ss, message2.ciphertext);
  }
  readMessageB(hs, message2) {
    if (isValidPublicKey(message2.ne)) {
      hs.re = message2.ne;
    }
    this.mixHash(hs.ss, hs.re);
    if (!hs.e) {
      throw new Error("Handshake state `e` param is missing.");
    }
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
    const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message2.ns);
    if (valid1 && isValidPublicKey(ns)) {
      hs.rs = ns;
    }
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
    const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message2.ciphertext);
    return { plaintext, valid: valid1 && valid2 };
  }
  readMessageC(hs, message2) {
    const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message2.ns);
    if (valid1 && isValidPublicKey(ns)) {
      hs.rs = ns;
    }
    if (!hs.e) {
      throw new Error("Handshake state `e` param is missing.");
    }
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
    const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message2.ciphertext);
    const { cs1, cs2 } = this.split(hs.ss);
    return { h: hs.ss.h, plaintext, valid: valid1 && valid2, cs1, cs2 };
  }
  initSession(initiator, prologue, s) {
    const psk = this.createEmptyKey();
    const rs = new Uint8Array(32);
    let hs;
    if (initiator) {
      hs = this.initializeInitiator(prologue, s, rs, psk);
    } else {
      hs = this.initializeResponder(prologue, s, rs, psk);
    }
    return {
      hs,
      i: initiator,
      mc: 0
    };
  }
  sendMessage(session, message2, ephemeral) {
    let messageBuffer;
    if (session.mc === 0) {
      messageBuffer = this.writeMessageA(session.hs, message2, ephemeral);
    } else if (session.mc === 1) {
      messageBuffer = this.writeMessageB(session.hs, message2);
    } else if (session.mc === 2) {
      const { h, messageBuffer: resultingBuffer, cs1, cs2 } = this.writeMessageC(session.hs, message2);
      messageBuffer = resultingBuffer;
      session.h = h;
      session.cs1 = cs1;
      session.cs2 = cs2;
    } else if (session.mc > 2) {
      if (session.i) {
        if (!session.cs1) {
          throw new Error("CS1 (cipher state) is not defined");
        }
        messageBuffer = this.writeMessageRegular(session.cs1, message2);
      } else {
        if (!session.cs2) {
          throw new Error("CS2 (cipher state) is not defined");
        }
        messageBuffer = this.writeMessageRegular(session.cs2, message2);
      }
    } else {
      throw new Error("Session invalid.");
    }
    session.mc++;
    return messageBuffer;
  }
  recvMessage(session, message2) {
    let plaintext = new Uint8Array(0);
    let valid = false;
    if (session.mc === 0) {
      ({ plaintext, valid } = this.readMessageA(session.hs, message2));
    } else if (session.mc === 1) {
      ({ plaintext, valid } = this.readMessageB(session.hs, message2));
    } else if (session.mc === 2) {
      const { h, plaintext: resultingPlaintext, valid: resultingValid, cs1, cs2 } = this.readMessageC(session.hs, message2);
      plaintext = resultingPlaintext;
      valid = resultingValid;
      session.h = h;
      session.cs1 = cs1;
      session.cs2 = cs2;
    }
    session.mc++;
    return { plaintext, valid };
  }
};
var XXHandshake = class {
  constructor(isInitiator, payload, prologue, crypto4, staticKeypair, connection, remotePeer, handshake2) {
    this.remoteExtensions = { webtransportCerthashes: [] };
    this.isInitiator = isInitiator;
    this.payload = payload;
    this.prologue = prologue;
    this.staticKeypair = staticKeypair;
    this.connection = connection;
    if (remotePeer) {
      this.remotePeer = remotePeer;
    }
    this.xx = handshake2 ?? new XX(crypto4);
    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);
  }
  // stage 0
  async propose() {
    logLocalStaticKeys(this.session.hs.s);
    if (this.isInitiator) {
      log104("Stage 0 - Initiator starting to send first message.");
      const messageBuffer = this.xx.sendMessage(this.session, new Uint8Array(0));
      this.connection.writeLP(encode0(messageBuffer));
      log104("Stage 0 - Initiator finished sending first message.");
      logLocalEphemeralKeys(this.session.hs.e);
    } else {
      log104("Stage 0 - Responder waiting to receive first message...");
      const receivedMessageBuffer = decode0((await this.connection.readLP()).subarray());
      const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
      if (!valid) {
        throw new InvalidCryptoExchangeError("xx handshake stage 0 validation fail");
      }
      log104("Stage 0 - Responder received first message.");
      logRemoteEphemeralKey(this.session.hs.re);
    }
  }
  // stage 1
  async exchange() {
    if (this.isInitiator) {
      log104("Stage 1 - Initiator waiting to receive first message from responder...");
      const receivedMessageBuffer = decode1((await this.connection.readLP()).subarray());
      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
      if (!valid) {
        throw new InvalidCryptoExchangeError("xx handshake stage 1 validation fail");
      }
      log104("Stage 1 - Initiator received the message.");
      logRemoteEphemeralKey(this.session.hs.re);
      logRemoteStaticKey(this.session.hs.rs);
      log104("Initiator going to check remote's signature...");
      try {
        const decodedPayload = decodePayload2(plaintext);
        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);
        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
        this.setRemoteNoiseExtension(decodedPayload.extensions);
      } catch (e) {
        const err2 = e;
        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err2.message}`);
      }
      log104("All good with the signature!");
    } else {
      log104("Stage 1 - Responder sending out first message with signed payload and static key.");
      const messageBuffer = this.xx.sendMessage(this.session, this.payload);
      this.connection.writeLP(encode1(messageBuffer));
      log104("Stage 1 - Responder sent the second handshake message with signed payload.");
      logLocalEphemeralKeys(this.session.hs.e);
    }
  }
  // stage 2
  async finish() {
    if (this.isInitiator) {
      log104("Stage 2 - Initiator sending third handshake message.");
      const messageBuffer = this.xx.sendMessage(this.session, this.payload);
      this.connection.writeLP(encode22(messageBuffer));
      log104("Stage 2 - Initiator sent message with signed payload.");
    } else {
      log104("Stage 2 - Responder waiting for third handshake message...");
      const receivedMessageBuffer = decode22((await this.connection.readLP()).subarray());
      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
      if (!valid) {
        throw new InvalidCryptoExchangeError("xx handshake stage 2 validation fail");
      }
      log104("Stage 2 - Responder received the message, finished handshake.");
      try {
        const decodedPayload = decodePayload2(plaintext);
        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);
        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
        this.setRemoteNoiseExtension(decodedPayload.extensions);
      } catch (e) {
        const err2 = e;
        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err2.message}`);
      }
    }
    logCipherState(this.session);
  }
  encrypt(plaintext, session) {
    const cs = this.getCS(session);
    return this.xx.encryptWithAd(cs, new Uint8Array(0), plaintext);
  }
  decrypt(ciphertext, session, dst) {
    const cs = this.getCS(session, false);
    return this.xx.decryptWithAd(cs, new Uint8Array(0), ciphertext, dst);
  }
  getRemoteStaticKey() {
    return this.session.hs.rs;
  }
  getCS(session, encryption = true) {
    if (!session.cs1 || !session.cs2) {
      throw new InvalidCryptoExchangeError("Handshake not completed properly, cipher state does not exist.");
    }
    if (this.isInitiator) {
      return encryption ? session.cs1 : session.cs2;
    } else {
      return encryption ? session.cs2 : session.cs1;
    }
  }
  setRemoteNoiseExtension(e) {
    if (e) {
      this.remoteExtensions = e;
    }
  }
};
function registerMetrics(metrics) {
  return {
    xxHandshakeSuccesses: metrics.registerCounter("libp2p_noise_xxhandshake_successes_total", {
      help: "Total count of noise xxHandshakes successes_"
    }),
    xxHandshakeErrors: metrics.registerCounter("libp2p_noise_xxhandshake_error_total", {
      help: "Total count of noise xxHandshakes errors"
    }),
    encryptedPackets: metrics.registerCounter("libp2p_noise_encrypted_packets_total", {
      help: "Total count of noise encrypted packets successfully"
    }),
    decryptedPackets: metrics.registerCounter("libp2p_noise_decrypted_packets_total", {
      help: "Total count of noise decrypted packets"
    }),
    decryptErrors: metrics.registerCounter("libp2p_noise_decrypt_errors_total", {
      help: "Total count of noise decrypt errors"
    })
  };
}
var Noise = class {
  constructor(init = {}) {
    this.protocol = "/noise";
    const { staticNoiseKey, extensions, crypto: crypto4, prologueBytes, metrics } = init;
    this.crypto = crypto4 ?? stablelib;
    this.extensions = extensions;
    this.metrics = metrics ? registerMetrics(metrics) : void 0;
    if (staticNoiseKey) {
      this.staticKeys = this.crypto.generateX25519KeyPairFromSeed(staticNoiseKey);
    } else {
      this.staticKeys = this.crypto.generateX25519KeyPair();
    }
    this.prologue = prologueBytes ?? new Uint8Array(0);
  }
  /**
   * Encrypt outgoing data to the remote party (handshake as initiator)
   *
   * @param {PeerId} localPeer - PeerId of the receiving peer
   * @param {Duplex<Uint8Array>} connection - streaming iterable duplex that will be encrypted
   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.
   * @returns {Promise<SecuredConnection>}
   */
  async secureOutbound(localPeer, connection, remotePeer) {
    const wrappedConnection = pbStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake2 = await this.performHandshake({
      connection: wrappedConnection,
      isInitiator: true,
      localPeer,
      remotePeer
    });
    const conn = await this.createSecureConnection(wrappedConnection, handshake2);
    return {
      conn,
      remoteExtensions: handshake2.remoteExtensions,
      remotePeer: handshake2.remotePeer
    };
  }
  /**
   * Decrypt incoming data (handshake as responder).
   *
   * @param {PeerId} localPeer - PeerId of the receiving peer.
   * @param {Duplex<Uint8Array>} connection - streaming iterable duplex that will be encryption.
   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.
   * @returns {Promise<SecuredConnection>}
   */
  async secureInbound(localPeer, connection, remotePeer) {
    const wrappedConnection = pbStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake2 = await this.performHandshake({
      connection: wrappedConnection,
      isInitiator: false,
      localPeer,
      remotePeer
    });
    const conn = await this.createSecureConnection(wrappedConnection, handshake2);
    return {
      conn,
      remotePeer: handshake2.remotePeer,
      remoteExtensions: handshake2.remoteExtensions
    };
  }
  /**
   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.
   * If noise pipes disabled or remote peer static key is unknown, use XX.
   *
   * @param {HandshakeParams} params
   */
  async performHandshake(params) {
    const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.extensions);
    return await this.performXXHandshake(params, payload);
  }
  async performXXHandshake(params, payload) {
    const { isInitiator, remotePeer, connection } = params;
    const handshake2 = new XXHandshake(isInitiator, payload, this.prologue, this.crypto, this.staticKeys, connection, remotePeer);
    try {
      await handshake2.propose();
      await handshake2.exchange();
      await handshake2.finish();
      this.metrics?.xxHandshakeSuccesses.increment();
    } catch (e) {
      this.metrics?.xxHandshakeErrors.increment();
      if (e instanceof Error) {
        e.message = `Error occurred during XX handshake: ${e.message}`;
        throw e;
      }
    }
    return handshake2;
  }
  async createSecureConnection(connection, handshake2) {
    const [secure, user] = duplexPair();
    const network = connection.unwrap();
    await pipe(
      secure,
      // write to wrapper
      encryptStream(handshake2, this.metrics),
      // encrypt data + prefix with message length
      network,
      // send to the remote peer
      decode14({ lengthDecoder: uint16BEDecode }),
      // read message length prefix
      decryptStream(handshake2, this.metrics),
      // decrypt the incoming data
      secure
      // pipe to the wrapper
    );
    return user;
  }
};
function noise(init = {}) {
  return () => new Noise(init);
}
var mergeOptions14 = merge_options_default.bind({ ignoreUndefined: true, concatArrays: true });
function createLibp2p2({
  options = {},
  peerId,
  multiaddrs = [],
  repo,
  keychainConfig = {},
  config: config2 = {}
}) {
  const { datastore } = repo;
  const libp2pOptions = getLibp2pOptions({
    options,
    config: config2,
    datastore,
    keychainConfig,
    peerId,
    multiaddrs
  });
  if (typeof options.libp2p === "function") {
    return options.libp2p({ libp2pOptions, options, config: config2, datastore, peerId });
  }
  libp2pOptions.start = false;
  return createLibp2p(libp2pOptions);
}
function getLibp2pOptions({ options, config: config2, datastore, keychainConfig, peerId, multiaddrs }) {
  const getPubsubRouter = () => {
    const router = dlv_es_default(config2, "Pubsub.Router") || "gossipsub";
    const availableRouters = routers();
    if (!availableRouters[router]) {
      throw (0, import_err_code138.default)(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), "ERR_NOT_SUPPORTED");
    }
    return availableRouters[router];
  };
  const libp2pDefaults = {
    datastore,
    peerId
  };
  const libp2pOptions = {
    addresses: {
      listen: multiaddrs.map((ma) => ma.toString()),
      announce: dlv_es_default(options, "addresses.announce", dlv_es_default(config2, "Addresses.Announce", [])),
      noAnnounce: dlv_es_default(options, "addresses.noAnnounce", dlv_es_default(config2, "Addresses.NoAnnounce", []))
    },
    connectionManager: dlv_es_default(options, "connectionManager", {
      maxConnections: dlv_es_default(options, "config.Swarm.ConnMgr.HighWater", dlv_es_default(config2, "Swarm.ConnMgr.HighWater")),
      minConnections: dlv_es_default(options, "config.Swarm.ConnMgr.LowWater", dlv_es_default(config2, "Swarm.ConnMgr.LowWater"))
    }),
    keychain: keychainConfig,
    identify: {
      host: {
        agentVersion: `js-ipfs/${ipfsCore}`
      }
    },
    contentRouters: [],
    peerRouters: [],
    peerDiscovery: [],
    transports: [],
    streamMuxers: [
      mplex({
        maxInboundStreams: 256,
        maxOutboundStreams: 1024
      })
    ],
    connectionEncryption: [
      noise()
    ],
    relay: {
      enabled: dlv_es_default(options, "relay.enabled", dlv_es_default(config2, "relay.enabled", true)),
      hop: {
        enabled: dlv_es_default(options, "relay.hop.enabled", dlv_es_default(config2, "relay.hop.enabled", false)),
        active: dlv_es_default(options, "relay.hop.active", dlv_es_default(config2, "relay.hop.active", false))
      }
    },
    nat: {
      enabled: !dlv_es_default(config2, "Swarm.DisableNatPortMap", false)
    }
  };
  if (dlv_es_default(options, "config.Pubsub.Enabled", dlv_es_default(config2, "Pubsub.Enabled", true))) {
    libp2pOptions.pubsub = getPubsubRouter();
  }
  if (dlv_es_default(config2, "Routing.Type", "dhtclient") !== "none") {
    libp2pOptions.dht = kadDHT({
      clientMode: dlv_es_default(config2, "Routing.Type", "dht") !== "dhtserver",
      kBucketSize: dlv_es_default(options, "dht.kBucketSize", 20),
      validators: {
        ipns: ipnsValidator
      },
      selectors: {
        ipns: ipnsSelector
      }
    });
  }
  const boostrapNodes = dlv_es_default(options, "config.Bootstrap", dlv_es_default(config2, "Bootstrap", []));
  if (boostrapNodes.length > 0) {
    libp2pOptions.peerDiscovery?.push(
      bootstrap({
        list: boostrapNodes
      })
    );
  }
  let constructorOptions = dlv_es_default(options, "libp2p", void 0);
  if (typeof constructorOptions === "function") {
    constructorOptions = void 0;
  }
  const libp2pFinalConfig = mergeOptions14(
    libp2pDefaults,
    libp2pConfig(),
    libp2pOptions,
    constructorOptions
  );
  const delegateHosts = dlv_es_default(
    options,
    "config.Addresses.Delegates",
    dlv_es_default(config2, "Addresses.Delegates", [])
  );
  if (delegateHosts.length > 0) {
    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)];
    const delegateAddr = multiaddr(delegateString).toOptions();
    const delegateApiOptions = {
      host: delegateAddr.host,
      // port is a string atm, so we need to convert for the check
      // @ts-expect-error - parseInt(input:string) => number
      protocol: parseInt(delegateAddr.port) === 443 ? "https" : "http",
      port: delegateAddr.port
    };
    const delegateHttpClient = create7(delegateApiOptions);
    libp2pFinalConfig.contentRouters?.push(delegatedContentRouting(delegateHttpClient));
    libp2pFinalConfig.peerRouters?.push(delegatedPeerRouting(delegateHttpClient));
  }
  if (!dlv_es_default(options, "config.Discovery.MDNS.Enabled", dlv_es_default(config2, "Discovery.MDNS.Enabled", true))) {
    libp2pFinalConfig.peerDiscovery = libp2pFinalConfig.peerDiscovery?.filter((d) => {
      try {
        if (typeof d === "function") {
          return d({})[Symbol.toStringTag] !== "@libp2p/mdns";
        }
      } catch {
      }
      return true;
    });
  }
  if (libp2pFinalConfig.transports == null) {
    libp2pFinalConfig.transports = [];
  }
  if (libp2pFinalConfig.transports.find((t) => {
    try {
      if (typeof t === "function") {
        return t({})[Symbol.toStringTag] === "@libp2p/websockets";
      }
    } catch {
    }
    return false;
  }) == null) {
    libp2pFinalConfig.transports.push(webSockets());
  }
  return libp2pFinalConfig;
}
var import_err_code139 = __toESM(require_err_code(), 1);
var mergeOptions15 = merge_options_default.bind({ ignoreUndefined: true });
var log105 = logger("ipfs:components:peer:storage");
var Storage = class {
  /**
   * @private
   * @param {PeerId} peerId
   * @param {Keychain} keychain
   * @param {IPFSRepo} repo
   * @param {Print} print
   * @param {boolean} isNew
   */
  constructor(peerId, keychain, repo, print, isNew) {
    this.print = print;
    this.peerId = peerId;
    this.keychain = keychain;
    this.repo = repo;
    this.print = print;
    this.isNew = isNew;
  }
  /**
   * @param {Print} print
   * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs
   * @param {IPFSOptions} options
   */
  static async start(print, codecs2, options) {
    const { repoAutoMigrate, repo: inputRepo, onMigrationProgress } = options;
    const repo = typeof inputRepo === "string" || inputRepo == null ? createRepo2(print, codecs2, {
      path: inputRepo,
      autoMigrate: repoAutoMigrate,
      onMigrationProgress
    }) : inputRepo;
    const { peerId, keychain, isNew } = await loadRepo(print, repo, options);
    return new Storage(peerId, keychain, repo, print, isNew);
  }
};
var loadRepo = async (print, repo, options) => {
  if (!repo.closed) {
    return { ...await configureRepo(repo, options), isNew: false };
  }
  try {
    await repo.open();
    return { ...await configureRepo(repo, options), isNew: false };
  } catch (err2) {
    if (err2.code !== ERR_REPO_NOT_INITIALIZED) {
      throw err2;
    }
    if (options.init && options.init.allowNew === false) {
      throw new NotEnabledError("Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it");
    }
    return { ...await initRepo(print, repo, options), isNew: true };
  }
};
var initRepo = async (print, repo, options) => {
  const initOptions = options.init || {};
  const exists2 = await repo.exists();
  log105("repo exists?", exists2);
  if (exists2 === true) {
    throw new Error("repo already exists");
  }
  const peerId = initOptions.privateKey ? await decodePeerId(initOptions.privateKey) : await initPeerId(print, initOptions);
  const identity3 = peerIdToIdentity(peerId);
  log105("peer identity: %s", identity3.PeerID);
  const config2 = {
    ...mergeOptions15(applyProfiles(config_browser_default(), initOptions.profiles), options.config),
    Identity: identity3
  };
  await repo.init(config2);
  await repo.open();
  log105("repo opened");
  const keychainConfig = {
    pass: options.pass
  };
  try {
    keychainConfig.dek = await repo.config.get("Keychain.DEK");
  } catch (err2) {
    if (err2.code !== "ERR_NOT_FOUND") {
      throw err2;
    }
  }
  const libp2p = await createLibp2p2({
    options: void 0,
    multiaddrs: void 0,
    peerId,
    repo,
    config: config2,
    keychainConfig
  });
  if (!await repo.datastore.has(new Key("/info/self"))) {
    await libp2p.keychain.importPeer("self", peerId);
  }
  await repo.config.set("Keychain", {
    // @ts-expect-error private field
    DEK: libp2p.keychain.init.dek
  });
  return { peerId, keychain: libp2p.keychain };
};
var decodePeerId = async (peerId) => {
  log105("using user-supplied private-key");
  if (isPeerId(peerId)) {
    return peerId;
  }
  const rawPrivateKey = fromString3(peerId, "base64pad");
  const key = await unmarshalPrivateKey3(rawPrivateKey);
  return await peerIdFromKeys(key.public.bytes, key.bytes);
};
var initPeerId = (print, { algorithm = "Ed25519", bits: bits2 = 2048 }) => {
  print("generating %s keypair...", algorithm);
  if (algorithm === "Ed25519") {
    return createEd25519PeerId();
  }
  if (algorithm === "RSA") {
    return createRSAPeerId({ bits: bits2 });
  }
  throw (0, import_err_code139.default)(new Error("Unknown PeerId algorithm"), "ERR_UNKNOWN_PEER_ID_ALGORITHM");
};
var peerIdToIdentity = (peerId) => {
  if (peerId.privateKey == null) {
    throw (0, import_err_code139.default)(new Error("Private key missing"), "ERR_MISSING_PRIVATE_KEY");
  }
  return {
    PeerID: peerId.toString(),
    /** @type {string} */
    PrivKey: toString3(peerId.privateKey, "base64pad")
  };
};
var configureRepo = async (repo, options) => {
  const config2 = options.config;
  const profiles2 = options.init && options.init.profiles || [];
  const pass = options.pass;
  const original = await repo.config.getAll();
  const changed = mergeConfigs(applyProfiles(original, profiles2), config2);
  if (original !== changed) {
    await repo.config.replace(changed);
  }
  if (!changed.Identity || !changed.Identity.PrivKey) {
    throw new NotInitializedError("No private key was found in the config, please intialize the repo");
  }
  const buf2 = fromString3(changed.Identity.PrivKey, "base64pad");
  const key = await unmarshalPrivateKey3(buf2);
  const peerId = await peerIdFromKeys(key.public.bytes, key.bytes);
  const libp2p = await createLibp2p2({
    options: void 0,
    multiaddrs: void 0,
    peerId,
    repo,
    config: changed,
    keychainConfig: {
      pass,
      ...changed.Keychain
    }
  });
  return { peerId, keychain: libp2p.keychain };
};
var mergeConfigs = (config2, changes) => changes ? mergeOptions15(config2, changes) : config2;
var applyProfiles = (config2, profiles2) => {
  return (profiles2 || []).reduce((config3, name9) => {
    const profile = profiles[name9];
    if (!profile) {
      throw new Error(`Could not find profile with name '${name9}'`);
    }
    log105("applying profile %s", name9);
    return profile.transform(config3);
  }, config2);
};
var import_varint_decoder = __toESM(require_src4(), 1);
var varint9 = __toESM(require_varint(), 1);
function varintEncoder(buf2) {
  let out = new Uint8Array(buf2.reduce((acc, curr) => {
    return acc + varint9.default.encodingLength(curr);
  }, 0));
  let offset = 0;
  for (const num of buf2) {
    out = varint9.encode(num, out, offset);
    offset += varint9.default.encodingLength(num);
  }
  return out;
}
var varint_encoder_default = varintEncoder;
var WantListEntry = class {
  /**
   * @param {import('multiformats').CID} cid
   * @param {number} priority
   * @param {import('../message/message').Message.Wantlist.WantType} wantType
   */
  constructor(cid, priority, wantType) {
    this._refCounter = 1;
    this.cid = cid;
    this.priority = priority || 1;
    this.wantType = wantType;
  }
  inc() {
    this._refCounter += 1;
  }
  dec() {
    this._refCounter = Math.max(0, this._refCounter - 1);
  }
  hasRefs() {
    return this._refCounter > 0;
  }
  // So that console.log prints a nice description of this object
  get [Symbol.toStringTag]() {
    const cidStr = this.cid.toString(base58btc);
    return `WantlistEntry <key: ${cidStr}, priority: ${this.priority}, refs: ${this._refCounter}>`;
  }
  /**
   * @param {any} other
   */
  equals(other) {
    return this._refCounter === other._refCounter && this.cid.equals(other.cid) && this.priority === other.priority && this.wantType === other.wantType;
  }
};
var import_minimal11 = __toESM(require_minimal2(), 1);
var $Reader8 = import_minimal11.default.Reader;
var $Writer8 = import_minimal11.default.Writer;
var $util8 = import_minimal11.default.util;
var $root8 = import_minimal11.default.roots["ipfs-bitswap"] || (import_minimal11.default.roots["ipfs-bitswap"] = {});
var Message3 = $root8.Message = (() => {
  function Message4(p) {
    this.blocks = [];
    this.payload = [];
    this.blockPresences = [];
    if (p) {
      for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
        if (p[ks[i2]] != null)
          this[ks[i2]] = p[ks[i2]];
    }
  }
  Message4.prototype.wantlist = null;
  Message4.prototype.blocks = $util8.emptyArray;
  Message4.prototype.payload = $util8.emptyArray;
  Message4.prototype.blockPresences = $util8.emptyArray;
  Message4.prototype.pendingBytes = 0;
  Message4.encode = function encode21(m, w) {
    if (!w)
      w = $Writer8.create();
    if (m.wantlist != null && Object.hasOwnProperty.call(m, "wantlist"))
      $root8.Message.Wantlist.encode(m.wantlist, w.uint32(10).fork()).ldelim();
    if (m.blocks != null && m.blocks.length) {
      for (var i2 = 0; i2 < m.blocks.length; ++i2)
        w.uint32(18).bytes(m.blocks[i2]);
    }
    if (m.payload != null && m.payload.length) {
      for (var i2 = 0; i2 < m.payload.length; ++i2)
        $root8.Message.Block.encode(m.payload[i2], w.uint32(26).fork()).ldelim();
    }
    if (m.blockPresences != null && m.blockPresences.length) {
      for (var i2 = 0; i2 < m.blockPresences.length; ++i2)
        $root8.Message.BlockPresence.encode(m.blockPresences[i2], w.uint32(34).fork()).ldelim();
    }
    if (m.pendingBytes != null && Object.hasOwnProperty.call(m, "pendingBytes"))
      w.uint32(40).int32(m.pendingBytes);
    return w;
  };
  Message4.decode = function decode17(r, l) {
    if (!(r instanceof $Reader8))
      r = $Reader8.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root8.Message();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1: {
          m.wantlist = $root8.Message.Wantlist.decode(r, r.uint32());
          break;
        }
        case 2: {
          if (!(m.blocks && m.blocks.length))
            m.blocks = [];
          m.blocks.push(r.bytes());
          break;
        }
        case 3: {
          if (!(m.payload && m.payload.length))
            m.payload = [];
          m.payload.push($root8.Message.Block.decode(r, r.uint32()));
          break;
        }
        case 4: {
          if (!(m.blockPresences && m.blockPresences.length))
            m.blockPresences = [];
          m.blockPresences.push($root8.Message.BlockPresence.decode(r, r.uint32()));
          break;
        }
        case 5: {
          m.pendingBytes = r.int32();
          break;
        }
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Message4.fromObject = function fromObject(d) {
    if (d instanceof $root8.Message)
      return d;
    var m = new $root8.Message();
    if (d.wantlist != null) {
      if (typeof d.wantlist !== "object")
        throw TypeError(".Message.wantlist: object expected");
      m.wantlist = $root8.Message.Wantlist.fromObject(d.wantlist);
    }
    if (d.blocks) {
      if (!Array.isArray(d.blocks))
        throw TypeError(".Message.blocks: array expected");
      m.blocks = [];
      for (var i2 = 0; i2 < d.blocks.length; ++i2) {
        if (typeof d.blocks[i2] === "string")
          $util8.base64.decode(d.blocks[i2], m.blocks[i2] = $util8.newBuffer($util8.base64.length(d.blocks[i2])), 0);
        else if (d.blocks[i2].length >= 0)
          m.blocks[i2] = d.blocks[i2];
      }
    }
    if (d.payload) {
      if (!Array.isArray(d.payload))
        throw TypeError(".Message.payload: array expected");
      m.payload = [];
      for (var i2 = 0; i2 < d.payload.length; ++i2) {
        if (typeof d.payload[i2] !== "object")
          throw TypeError(".Message.payload: object expected");
        m.payload[i2] = $root8.Message.Block.fromObject(d.payload[i2]);
      }
    }
    if (d.blockPresences) {
      if (!Array.isArray(d.blockPresences))
        throw TypeError(".Message.blockPresences: array expected");
      m.blockPresences = [];
      for (var i2 = 0; i2 < d.blockPresences.length; ++i2) {
        if (typeof d.blockPresences[i2] !== "object")
          throw TypeError(".Message.blockPresences: object expected");
        m.blockPresences[i2] = $root8.Message.BlockPresence.fromObject(d.blockPresences[i2]);
      }
    }
    if (d.pendingBytes != null) {
      m.pendingBytes = d.pendingBytes | 0;
    }
    return m;
  };
  Message4.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.blocks = [];
      d.payload = [];
      d.blockPresences = [];
    }
    if (o.defaults) {
      d.wantlist = null;
      d.pendingBytes = 0;
    }
    if (m.wantlist != null && m.hasOwnProperty("wantlist")) {
      d.wantlist = $root8.Message.Wantlist.toObject(m.wantlist, o);
    }
    if (m.blocks && m.blocks.length) {
      d.blocks = [];
      for (var j = 0; j < m.blocks.length; ++j) {
        d.blocks[j] = o.bytes === String ? $util8.base64.encode(m.blocks[j], 0, m.blocks[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.blocks[j]) : m.blocks[j];
      }
    }
    if (m.payload && m.payload.length) {
      d.payload = [];
      for (var j = 0; j < m.payload.length; ++j) {
        d.payload[j] = $root8.Message.Block.toObject(m.payload[j], o);
      }
    }
    if (m.blockPresences && m.blockPresences.length) {
      d.blockPresences = [];
      for (var j = 0; j < m.blockPresences.length; ++j) {
        d.blockPresences[j] = $root8.Message.BlockPresence.toObject(m.blockPresences[j], o);
      }
    }
    if (m.pendingBytes != null && m.hasOwnProperty("pendingBytes")) {
      d.pendingBytes = m.pendingBytes;
    }
    return d;
  };
  Message4.prototype.toJSON = function toJSON2() {
    return this.constructor.toObject(this, import_minimal11.default.util.toJSONOptions);
  };
  Message4.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
    if (typeUrlPrefix === void 0) {
      typeUrlPrefix = "type.googleapis.com";
    }
    return typeUrlPrefix + "/Message";
  };
  Message4.Wantlist = function() {
    function Wantlist2(p) {
      this.entries = [];
      if (p) {
        for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
          if (p[ks[i2]] != null)
            this[ks[i2]] = p[ks[i2]];
      }
    }
    Wantlist2.prototype.entries = $util8.emptyArray;
    Wantlist2.prototype.full = false;
    Wantlist2.encode = function encode21(m, w) {
      if (!w)
        w = $Writer8.create();
      if (m.entries != null && m.entries.length) {
        for (var i2 = 0; i2 < m.entries.length; ++i2)
          $root8.Message.Wantlist.Entry.encode(m.entries[i2], w.uint32(10).fork()).ldelim();
      }
      if (m.full != null && Object.hasOwnProperty.call(m, "full"))
        w.uint32(16).bool(m.full);
      return w;
    };
    Wantlist2.decode = function decode17(r, l) {
      if (!(r instanceof $Reader8))
        r = $Reader8.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root8.Message.Wantlist();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1: {
            if (!(m.entries && m.entries.length))
              m.entries = [];
            m.entries.push($root8.Message.Wantlist.Entry.decode(r, r.uint32()));
            break;
          }
          case 2: {
            m.full = r.bool();
            break;
          }
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Wantlist2.fromObject = function fromObject(d) {
      if (d instanceof $root8.Message.Wantlist)
        return d;
      var m = new $root8.Message.Wantlist();
      if (d.entries) {
        if (!Array.isArray(d.entries))
          throw TypeError(".Message.Wantlist.entries: array expected");
        m.entries = [];
        for (var i2 = 0; i2 < d.entries.length; ++i2) {
          if (typeof d.entries[i2] !== "object")
            throw TypeError(".Message.Wantlist.entries: object expected");
          m.entries[i2] = $root8.Message.Wantlist.Entry.fromObject(d.entries[i2]);
        }
      }
      if (d.full != null) {
        m.full = Boolean(d.full);
      }
      return m;
    };
    Wantlist2.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.arrays || o.defaults) {
        d.entries = [];
      }
      if (o.defaults) {
        d.full = false;
      }
      if (m.entries && m.entries.length) {
        d.entries = [];
        for (var j = 0; j < m.entries.length; ++j) {
          d.entries[j] = $root8.Message.Wantlist.Entry.toObject(m.entries[j], o);
        }
      }
      if (m.full != null && m.hasOwnProperty("full")) {
        d.full = m.full;
      }
      return d;
    };
    Wantlist2.prototype.toJSON = function toJSON2() {
      return this.constructor.toObject(this, import_minimal11.default.util.toJSONOptions);
    };
    Wantlist2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Message.Wantlist";
    };
    Wantlist2.WantType = function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = "Block"] = 0;
      values[valuesById[1] = "Have"] = 1;
      return values;
    }();
    Wantlist2.Entry = function() {
      function Entry(p) {
        if (p) {
          for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
            if (p[ks[i2]] != null)
              this[ks[i2]] = p[ks[i2]];
        }
      }
      Entry.prototype.block = $util8.newBuffer([]);
      Entry.prototype.priority = 0;
      Entry.prototype.cancel = false;
      Entry.prototype.wantType = 0;
      Entry.prototype.sendDontHave = false;
      Entry.encode = function encode21(m, w) {
        if (!w)
          w = $Writer8.create();
        if (m.block != null && Object.hasOwnProperty.call(m, "block"))
          w.uint32(10).bytes(m.block);
        if (m.priority != null && Object.hasOwnProperty.call(m, "priority"))
          w.uint32(16).int32(m.priority);
        if (m.cancel != null && Object.hasOwnProperty.call(m, "cancel"))
          w.uint32(24).bool(m.cancel);
        if (m.wantType != null && Object.hasOwnProperty.call(m, "wantType"))
          w.uint32(32).int32(m.wantType);
        if (m.sendDontHave != null && Object.hasOwnProperty.call(m, "sendDontHave"))
          w.uint32(40).bool(m.sendDontHave);
        return w;
      };
      Entry.decode = function decode17(r, l) {
        if (!(r instanceof $Reader8))
          r = $Reader8.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root8.Message.Wantlist.Entry();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1: {
              m.block = r.bytes();
              break;
            }
            case 2: {
              m.priority = r.int32();
              break;
            }
            case 3: {
              m.cancel = r.bool();
              break;
            }
            case 4: {
              m.wantType = r.int32();
              break;
            }
            case 5: {
              m.sendDontHave = r.bool();
              break;
            }
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Entry.fromObject = function fromObject(d) {
        if (d instanceof $root8.Message.Wantlist.Entry)
          return d;
        var m = new $root8.Message.Wantlist.Entry();
        if (d.block != null) {
          if (typeof d.block === "string")
            $util8.base64.decode(d.block, m.block = $util8.newBuffer($util8.base64.length(d.block)), 0);
          else if (d.block.length >= 0)
            m.block = d.block;
        }
        if (d.priority != null) {
          m.priority = d.priority | 0;
        }
        if (d.cancel != null) {
          m.cancel = Boolean(d.cancel);
        }
        switch (d.wantType) {
          case "Block":
          case 0:
            m.wantType = 0;
            break;
          case "Have":
          case 1:
            m.wantType = 1;
            break;
        }
        if (d.sendDontHave != null) {
          m.sendDontHave = Boolean(d.sendDontHave);
        }
        return m;
      };
      Entry.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if (o.bytes === String)
            d.block = "";
          else {
            d.block = [];
            if (o.bytes !== Array)
              d.block = $util8.newBuffer(d.block);
          }
          d.priority = 0;
          d.cancel = false;
          d.wantType = o.enums === String ? "Block" : 0;
          d.sendDontHave = false;
        }
        if (m.block != null && m.hasOwnProperty("block")) {
          d.block = o.bytes === String ? $util8.base64.encode(m.block, 0, m.block.length) : o.bytes === Array ? Array.prototype.slice.call(m.block) : m.block;
        }
        if (m.priority != null && m.hasOwnProperty("priority")) {
          d.priority = m.priority;
        }
        if (m.cancel != null && m.hasOwnProperty("cancel")) {
          d.cancel = m.cancel;
        }
        if (m.wantType != null && m.hasOwnProperty("wantType")) {
          d.wantType = o.enums === String ? $root8.Message.Wantlist.WantType[m.wantType] : m.wantType;
        }
        if (m.sendDontHave != null && m.hasOwnProperty("sendDontHave")) {
          d.sendDontHave = m.sendDontHave;
        }
        return d;
      };
      Entry.prototype.toJSON = function toJSON2() {
        return this.constructor.toObject(this, import_minimal11.default.util.toJSONOptions);
      };
      Entry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === void 0) {
          typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Message.Wantlist.Entry";
      };
      return Entry;
    }();
    return Wantlist2;
  }();
  Message4.Block = function() {
    function Block22(p) {
      if (p) {
        for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
          if (p[ks[i2]] != null)
            this[ks[i2]] = p[ks[i2]];
      }
    }
    Block22.prototype.prefix = $util8.newBuffer([]);
    Block22.prototype.data = $util8.newBuffer([]);
    Block22.encode = function encode21(m, w) {
      if (!w)
        w = $Writer8.create();
      if (m.prefix != null && Object.hasOwnProperty.call(m, "prefix"))
        w.uint32(10).bytes(m.prefix);
      if (m.data != null && Object.hasOwnProperty.call(m, "data"))
        w.uint32(18).bytes(m.data);
      return w;
    };
    Block22.decode = function decode17(r, l) {
      if (!(r instanceof $Reader8))
        r = $Reader8.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root8.Message.Block();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1: {
            m.prefix = r.bytes();
            break;
          }
          case 2: {
            m.data = r.bytes();
            break;
          }
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Block22.fromObject = function fromObject(d) {
      if (d instanceof $root8.Message.Block)
        return d;
      var m = new $root8.Message.Block();
      if (d.prefix != null) {
        if (typeof d.prefix === "string")
          $util8.base64.decode(d.prefix, m.prefix = $util8.newBuffer($util8.base64.length(d.prefix)), 0);
        else if (d.prefix.length >= 0)
          m.prefix = d.prefix;
      }
      if (d.data != null) {
        if (typeof d.data === "string")
          $util8.base64.decode(d.data, m.data = $util8.newBuffer($util8.base64.length(d.data)), 0);
        else if (d.data.length >= 0)
          m.data = d.data;
      }
      return m;
    };
    Block22.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.prefix = "";
        else {
          d.prefix = [];
          if (o.bytes !== Array)
            d.prefix = $util8.newBuffer(d.prefix);
        }
        if (o.bytes === String)
          d.data = "";
        else {
          d.data = [];
          if (o.bytes !== Array)
            d.data = $util8.newBuffer(d.data);
        }
      }
      if (m.prefix != null && m.hasOwnProperty("prefix")) {
        d.prefix = o.bytes === String ? $util8.base64.encode(m.prefix, 0, m.prefix.length) : o.bytes === Array ? Array.prototype.slice.call(m.prefix) : m.prefix;
      }
      if (m.data != null && m.hasOwnProperty("data")) {
        d.data = o.bytes === String ? $util8.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
      }
      return d;
    };
    Block22.prototype.toJSON = function toJSON2() {
      return this.constructor.toObject(this, import_minimal11.default.util.toJSONOptions);
    };
    Block22.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Message.Block";
    };
    return Block22;
  }();
  Message4.BlockPresenceType = function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "Have"] = 0;
    values[valuesById[1] = "DontHave"] = 1;
    return values;
  }();
  Message4.BlockPresence = function() {
    function BlockPresence(p) {
      if (p) {
        for (var ks = Object.keys(p), i2 = 0; i2 < ks.length; ++i2)
          if (p[ks[i2]] != null)
            this[ks[i2]] = p[ks[i2]];
      }
    }
    BlockPresence.prototype.cid = $util8.newBuffer([]);
    BlockPresence.prototype.type = 0;
    BlockPresence.encode = function encode21(m, w) {
      if (!w)
        w = $Writer8.create();
      if (m.cid != null && Object.hasOwnProperty.call(m, "cid"))
        w.uint32(10).bytes(m.cid);
      if (m.type != null && Object.hasOwnProperty.call(m, "type"))
        w.uint32(16).int32(m.type);
      return w;
    };
    BlockPresence.decode = function decode17(r, l) {
      if (!(r instanceof $Reader8))
        r = $Reader8.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root8.Message.BlockPresence();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1: {
            m.cid = r.bytes();
            break;
          }
          case 2: {
            m.type = r.int32();
            break;
          }
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    BlockPresence.fromObject = function fromObject(d) {
      if (d instanceof $root8.Message.BlockPresence)
        return d;
      var m = new $root8.Message.BlockPresence();
      if (d.cid != null) {
        if (typeof d.cid === "string")
          $util8.base64.decode(d.cid, m.cid = $util8.newBuffer($util8.base64.length(d.cid)), 0);
        else if (d.cid.length >= 0)
          m.cid = d.cid;
      }
      switch (d.type) {
        case "Have":
        case 0:
          m.type = 0;
          break;
        case "DontHave":
        case 1:
          m.type = 1;
          break;
      }
      return m;
    };
    BlockPresence.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.cid = "";
        else {
          d.cid = [];
          if (o.bytes !== Array)
            d.cid = $util8.newBuffer(d.cid);
        }
        d.type = o.enums === String ? "Have" : 0;
      }
      if (m.cid != null && m.hasOwnProperty("cid")) {
        d.cid = o.bytes === String ? $util8.base64.encode(m.cid, 0, m.cid.length) : o.bytes === Array ? Array.prototype.slice.call(m.cid) : m.cid;
      }
      if (m.type != null && m.hasOwnProperty("type")) {
        d.type = o.enums === String ? $root8.Message.BlockPresenceType[m.type] : m.type;
      }
      return d;
    };
    BlockPresence.prototype.toJSON = function toJSON2() {
      return this.constructor.toObject(this, import_minimal11.default.util.toJSONOptions);
    };
    BlockPresence.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Message.BlockPresence";
    };
    return BlockPresence;
  }();
  return Message4;
})();
var WantType = {
  Block: Message3.Wantlist.WantType.Block,
  Have: Message3.Wantlist.WantType.Have
};
var sortBy = (fn, list) => {
  return Array.prototype.slice.call(list, 0).sort((a, b) => {
    const aa = fn(a);
    const bb = fn(b);
    return aa < bb ? -1 : aa > bb ? 1 : 0;
  });
};
var Wantlist = class {
  /**
   * @param {import('../stats').Stats} [stats]
   * @param {import('@libp2p/interface-libp2p').Libp2p} [libp2p]
   */
  constructor(stats, libp2p) {
    this.set = libp2p ? trackedMap({
      name: "ipfs_bitswap_wantlist",
      metrics: libp2p.metrics
    }) : /* @__PURE__ */ new Map();
    this._stats = stats;
  }
  get length() {
    return this.set.size;
  }
  /**
   * @param {CID} cid
   * @param {number} priority
   * @param {import('../message/message').Message.Wantlist.WantType} wantType
   */
  add(cid, priority, wantType) {
    const cidStr = cid.toString(base58btc);
    const entry = this.set.get(cidStr);
    if (entry) {
      entry.inc();
      entry.priority = priority;
      if (entry.wantType === WantType.Have && wantType === WantType.Block) {
        entry.wantType = wantType;
      }
    } else {
      this.set.set(cidStr, new WantListEntry(cid, priority, wantType));
      if (this._stats) {
        this._stats.push(null, "wantListSize", 1);
      }
    }
  }
  /**
   * @param {CID} cid
   */
  remove(cid) {
    const cidStr = cid.toString(base58btc);
    const entry = this.set.get(cidStr);
    if (!entry) {
      return;
    }
    entry.dec();
    if (entry.hasRefs()) {
      return;
    }
    this.set.delete(cidStr);
    if (this._stats) {
      this._stats.push(null, "wantListSize", -1);
    }
  }
  /**
   * @param {string} cidStr
   */
  removeForce(cidStr) {
    if (this.set.has(cidStr)) {
      this.set.delete(cidStr);
    }
  }
  /**
   * @param {(entry:Entry, key:string) => void} fn
   */
  forEach(fn) {
    return this.set.forEach(fn);
  }
  entries() {
    return this.set.entries();
  }
  sortedEntries() {
    return new Map(sortBy((o) => o[1].key, Array.from(this.set.entries())));
  }
  /**
   * @param {CID} cid
   */
  contains(cid) {
    const cidStr = cid.toString(base58btc);
    return this.set.has(cidStr);
  }
  /**
   * @param {CID} cid
   */
  get(cid) {
    const cidStr = cid.toString(base58btc);
    return this.set.get(cidStr);
  }
};
Wantlist.Entry = WantListEntry;
var WantlistEntry = Wantlist.Entry;
var BitswapMessageEntry = class {
  /**
   * @param {import('multiformats').CID} cid
   * @param {number} priority
   * @param {import('./message').Message.Wantlist.WantType} wantType
   * @param {boolean} [cancel]
   * @param {boolean} [sendDontHave]
   */
  constructor(cid, priority, wantType, cancel, sendDontHave) {
    this.entry = new WantlistEntry(cid, priority, wantType);
    this.cancel = Boolean(cancel);
    this.sendDontHave = Boolean(sendDontHave);
  }
  get cid() {
    return this.entry.cid;
  }
  set cid(cid) {
    this.entry.cid = cid;
  }
  get priority() {
    return this.entry.priority;
  }
  set priority(val) {
    this.entry.priority = val;
  }
  get wantType() {
    return this.entry.wantType;
  }
  set wantType(val) {
    this.entry.wantType = val;
  }
  get [Symbol.toStringTag]() {
    const cidStr = this.cid.toString(base58btc);
    return `BitswapMessageEntry ${cidStr} <cancel: ${this.cancel}, priority: ${this.priority}>`;
  }
  /**
   * @param {this} other
   */
  equals(other) {
    return this.cancel === other.cancel && this.sendDontHave === other.sendDontHave && this.wantType === other.wantType && this.entry.equals(other.entry);
  }
};
var logger2 = (id, subsystem) => {
  const name9 = ["bitswap"];
  if (subsystem) {
    name9.push(subsystem);
  }
  if (id) {
    name9.push(`${id.toString().slice(0, 8)}`);
  }
  return logger(name9.join(":"));
};
var isMapEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const [key, valueA] of a) {
    const valueB = b.get(key);
    if (valueB === void 0) {
      return false;
    }
    if (valueA instanceof Uint8Array && valueB instanceof Uint8Array && !equals(valueA, valueB)) {
      return false;
    }
    if (valueA instanceof BitswapMessageEntry && valueB instanceof BitswapMessageEntry && !valueA.equals(valueB)) {
      return false;
    }
  }
  return true;
};
var BitswapMessage = class {
  /**
   * @param {boolean} full
   */
  constructor(full) {
    this.full = full;
    this.wantlist = /* @__PURE__ */ new Map();
    this.blocks = /* @__PURE__ */ new Map();
    this.blockPresences = /* @__PURE__ */ new Map();
    this.pendingBytes = 0;
  }
  get empty() {
    return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;
  }
  /**
   *
   * @param {CID} cid
   * @param {number} priority
   * @param {import('./message').Message.Wantlist.WantType | null} [wantType]
   * @param {boolean} [cancel]
   * @param {boolean} [sendDontHave]
   * @returns {void}
   */
  addEntry(cid, priority, wantType, cancel, sendDontHave) {
    if (wantType == null) {
      wantType = BitswapMessage.WantType.Block;
    }
    const cidStr = cid.toString(base58btc);
    const entry = this.wantlist.get(cidStr);
    if (entry) {
      if (entry.wantType === wantType) {
        entry.priority = priority;
      }
      if (cancel) {
        entry.cancel = Boolean(cancel);
      }
      if (sendDontHave) {
        entry.sendDontHave = Boolean(sendDontHave);
      }
      if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {
        entry.wantType = wantType;
      }
    } else {
      this.wantlist.set(cidStr, new BitswapMessageEntry(cid, priority, wantType, cancel, sendDontHave));
    }
  }
  /**
   * @param {CID} cid
   * @param {Uint8Array} block
   * @returns {void}
   */
  addBlock(cid, block) {
    const cidStr = cid.toString(base58btc);
    this.blocks.set(cidStr, block);
  }
  /**
   * @param {CID} cid
   */
  addHave(cid) {
    const cidStr = cid.toString(base58btc);
    if (!this.blockPresences.has(cidStr)) {
      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);
    }
  }
  /**
   * @param {CID} cid
   */
  addDontHave(cid) {
    const cidStr = cid.toString(base58btc);
    if (!this.blockPresences.has(cidStr)) {
      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);
    }
  }
  /**
   * @param {CID} cid
   */
  cancel(cid) {
    const cidStr = cid.toString(base58btc);
    this.wantlist.delete(cidStr);
    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);
  }
  /**
   * @param {number} size
   */
  setPendingBytes(size) {
    this.pendingBytes = size;
  }
  /**
   * Serializes to Bitswap Message protobuf of
   * version 1.0.0
   *
   * @returns {Uint8Array}
   */
  serializeToBitswap100() {
    const msg = {
      wantlist: {
        entries: Array.from(this.wantlist.values()).map((entry) => {
          return {
            block: entry.cid.bytes,
            // cid
            priority: Number(entry.priority),
            cancel: Boolean(entry.cancel)
          };
        }),
        full: this.full ? true : void 0
      },
      blocks: Array.from(this.blocks.values())
    };
    return Message3.encode(msg).finish();
  }
  /**
   * Serializes to Bitswap Message protobuf of
   * version 1.1.0
   *
   * @returns {Uint8Array}
   */
  serializeToBitswap110() {
    const msg = {
      wantlist: {
        entries: Array.from(this.wantlist.values()).map((entry) => {
          return {
            block: entry.cid.bytes,
            // cid
            priority: Number(entry.priority),
            wantType: entry.wantType,
            cancel: Boolean(entry.cancel),
            sendDontHave: Boolean(entry.sendDontHave)
          };
        }),
        full: this.full ? true : void 0
      },
      /** @type {import('./message').Message.BlockPresence[]} */
      blockPresences: [],
      /** @type {{ prefix: Uint8Array, data: Uint8Array }[]} */
      payload: [],
      pendingBytes: this.pendingBytes
    };
    for (const [cidStr, data] of this.blocks.entries()) {
      const cid = CID.parse(cidStr);
      const version3 = cid.version;
      const codec = cid.code;
      const multihash = cid.multihash.code;
      const digestLength = cid.multihash.digest.length;
      const prefix = varint_encoder_default([
        version3,
        codec,
        multihash,
        digestLength
      ]);
      msg.payload.push(
        new Message3.Block({
          prefix,
          data
        })
      );
    }
    for (const [cidStr, bpType] of this.blockPresences) {
      msg.blockPresences.push(new Message3.BlockPresence({
        cid: CID.parse(cidStr).bytes,
        type: bpType
      }));
    }
    if (this.pendingBytes > 0) {
      msg.pendingBytes = this.pendingBytes;
    }
    return Message3.encode(msg).finish();
  }
  /**
   * @param {BitswapMessage} other
   * @returns {boolean}
   */
  equals(other) {
    if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !isMapEqual(this.wantlist, other.wantlist) || !isMapEqual(this.blocks, other.blocks) || // @TODO - Is this a bug ?
    // @ts-expect-error - isMap equals map values to be objects not numbers
    !isMapEqual(this.blockPresences, other.blockPresences)) {
      return false;
    }
    return true;
  }
  get [Symbol.toStringTag]() {
    const list = Array.from(this.wantlist.keys());
    const blocks = Array.from(this.blocks.keys());
    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`;
  }
};
BitswapMessage.deserialize = async (raw, hashLoader) => {
  const decoded = Message3.decode(raw);
  const isFull = decoded.wantlist && decoded.wantlist.full || false;
  const msg = new BitswapMessage(isFull);
  if (decoded.wantlist && decoded.wantlist.entries) {
    decoded.wantlist.entries.forEach((entry) => {
      if (!entry.block) {
        return;
      }
      const cid = CID.decode(entry.block);
      msg.addEntry(cid, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));
    });
  }
  if (decoded.blockPresences) {
    decoded.blockPresences.forEach((blockPresence) => {
      if (!blockPresence.cid) {
        return;
      }
      const cid = CID.decode(blockPresence.cid);
      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {
        msg.addHave(cid);
      } else {
        msg.addDontHave(cid);
      }
    });
  }
  if (decoded.blocks.length > 0) {
    await Promise.all(decoded.blocks.map(async (b) => {
      const hash3 = await sha256.digest(b);
      const cid = CID.createV0(hash3);
      msg.addBlock(cid, b);
    }));
    return msg;
  }
  if (decoded.payload.length > 0) {
    await Promise.all(decoded.payload.map(async (p) => {
      if (!p.prefix || !p.data) {
        return;
      }
      const values = (0, import_varint_decoder.default)(p.prefix);
      const cidVersion = values[0];
      const multicodec = values[1];
      const hashAlg = values[2];
      const hasher = hashAlg === sha256.code ? sha256 : hashLoader && await hashLoader.getHasher(hashAlg);
      if (!hasher) {
        throw new CodeError("Unknown hash algorithm", "ERR_UNKNOWN_HASH_ALG");
      }
      const hash3 = await hasher.digest(p.data);
      const cid = CID.create(cidVersion, multicodec, hash3);
      msg.addBlock(cid, p.data);
    }));
    msg.setPendingBytes(decoded.pendingBytes);
    return msg;
  }
  return msg;
};
BitswapMessage.blockPresenceSize = (cid) => {
  return cid.bytes.length + 1;
};
BitswapMessage.Entry = BitswapMessageEntry;
BitswapMessage.WantType = {
  Block: Message3.Wantlist.WantType.Block,
  Have: Message3.Wantlist.WantType.Have
};
BitswapMessage.BlockPresenceType = {
  Have: Message3.BlockPresenceType.Have,
  DontHave: Message3.BlockPresenceType.DontHave
};
var maxProvidersPerRequest = 3;
var kMaxPriority = Math.pow(2, 31) - 1;
var maxListeners = 1e3;
var wantlistSendDebounceMs = 1;
var functionDebounce = debounce2;
function debounce2(fn, wait, callFirst) {
  var timeout = null;
  var debouncedFn = null;
  var clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      debouncedFn = null;
      timeout = null;
    }
  };
  var flush3 = function() {
    var call = debouncedFn;
    clear();
    if (call) {
      call();
    }
  };
  var debounceWrapper = function() {
    if (!wait) {
      return fn.apply(this, arguments);
    }
    var context = this;
    var args = arguments;
    var callNow = callFirst && !timeout;
    clear();
    debouncedFn = function() {
      fn.apply(context, args);
    };
    timeout = setTimeout(function() {
      timeout = null;
      if (!callNow) {
        var call = debouncedFn;
        debouncedFn = null;
        return call();
      }
    }, wait);
    if (callNow) {
      return debouncedFn();
    }
  };
  debounceWrapper.cancel = clear;
  debounceWrapper.flush = flush3;
  return debounceWrapper;
}
var MsgQueue = class {
  /**
   * @param {PeerId} selfPeerId
   * @param {PeerId} otherPeerId
   * @param {Network} network
   */
  constructor(selfPeerId, otherPeerId, network) {
    this.peerId = otherPeerId;
    this.network = network;
    this.refcnt = 1;
    this._entries = [];
    this._log = logger2(selfPeerId, "msgqueue");
    this.sendEntries = functionDebounce(this._sendEntries.bind(this), wantlistSendDebounceMs);
  }
  /**
   * @param {Message} msg
   */
  addMessage(msg) {
    if (msg.empty) {
      return;
    }
    this.send(msg);
  }
  /**
   * @param {{cid:CID, priority:number}[]} entries
   */
  addEntries(entries) {
    this._entries = this._entries.concat(entries);
    this.sendEntries();
  }
  /**
   * @private
   */
  _sendEntries() {
    if (!this._entries.length) {
      return;
    }
    const msg = new BitswapMessage(false);
    this._entries.forEach((entry) => {
      if (entry.cancel) {
        msg.cancel(entry.cid);
      } else {
        msg.addEntry(entry.cid, entry.priority);
      }
    });
    this._entries = [];
    this.addMessage(msg);
  }
  /**
   * @param {Message} msg
   */
  async send(msg) {
    try {
      await this.network.connectTo(this.peerId);
    } catch (err2) {
      this._log.error("cant connect to peer %s: %s", this.peerId.toString(), err2.message);
      return;
    }
    this._log("sending message to peer %s", this.peerId.toString());
    this.network.sendMessage(this.peerId, msg).catch((err2) => {
      this._log.error("send error: %s", err2.message);
    });
  }
};
var WantManager = class {
  /**
   * @param {PeerId} peerId
   * @param {import('../network').Network} network
   * @param {import('../stats').Stats} stats
   * @param {import('@libp2p/interface-libp2p').Libp2p} libp2p
   */
  constructor(peerId, network, stats, libp2p) {
    this.peers = trackedMap({
      name: "ipfs_bitswap_want_manager_peers",
      metrics: libp2p.metrics
    });
    this.wantlist = new Wantlist(stats, libp2p);
    this.network = network;
    this._stats = stats;
    this._peerId = peerId;
    this._log = logger2(peerId, "want");
  }
  /**
   * @private
   * @param {CID[]} cids
   * @param {boolean} cancel
   * @param {boolean} [force]
   */
  _addEntries(cids, cancel, force) {
    const entries = cids.map((cid, i2) => {
      return new BitswapMessage.Entry(cid, kMaxPriority - i2, BitswapMessage.WantType.Block, cancel);
    });
    entries.forEach((e) => {
      if (e.cancel) {
        if (force) {
          this.wantlist.removeForce(e.cid.toString(base58btc));
        } else {
          this.wantlist.remove(e.cid);
        }
      } else {
        this._log("adding to wl");
        this.wantlist.add(e.cid, e.priority);
      }
    });
    for (const p of this.peers.values()) {
      p.addEntries(entries);
    }
  }
  /**
   * @private
   * @param {PeerId} peerId
   */
  _startPeerHandler(peerId) {
    let mq = this.peers.get(peerId.toString());
    if (mq) {
      mq.refcnt++;
      return;
    }
    mq = new MsgQueue(this._peerId, peerId, this.network);
    const fullwantlist = new BitswapMessage(true);
    for (const entry of this.wantlist.entries()) {
      fullwantlist.addEntry(entry[1].cid, entry[1].priority);
    }
    mq.addMessage(fullwantlist);
    this.peers.set(peerId.toString(), mq);
    return mq;
  }
  /**
   * @private
   * @param {PeerId} peerId
   */
  _stopPeerHandler(peerId) {
    const mq = this.peers.get(peerId.toString());
    if (!mq) {
      return;
    }
    mq.refcnt--;
    if (mq.refcnt > 0) {
      return;
    }
    this.peers.delete(peerId.toString());
  }
  /**
   * add all the cids to the wantlist
   *
   * @param {CID[]} cids
   * @param {object} [options]
   * @param {AbortSignal} [options.signal]
   */
  wantBlocks(cids, options = {}) {
    this._addEntries(cids, false);
    if (options && options.signal) {
      options.signal.addEventListener("abort", () => {
        this.cancelWants(cids);
      });
    }
  }
  /**
   * Remove blocks of all the given keys without respecting refcounts
   *
   * @param {CID[]} cids
   */
  unwantBlocks(cids) {
    this._log("unwant blocks: %s", cids.length);
    this._addEntries(cids, true, true);
  }
  /**
   * Cancel wanting all of the given keys
   *
   * @param {CID[]} cids
   */
  cancelWants(cids) {
    this._log("cancel wants: %s", cids.length);
    this._addEntries(cids, true);
  }
  /**
   * Returns a list of all currently connected peers
   */
  connectedPeers() {
    return Array.from(this.peers.keys());
  }
  /**
   * @param {PeerId} peerId
   */
  connected(peerId) {
    this._startPeerHandler(peerId);
  }
  /**
   * @param {PeerId} peerId
   */
  disconnected(peerId) {
    this._stopPeerHandler(peerId);
  }
  start() {
  }
  stop() {
    this.peers.forEach((mq) => this.disconnected(mq.peerId));
  }
};
var import_timeout_abort_controller17 = __toESM(require_timeout_abort_controller(), 1);
var BITSWAP100 = "/ipfs/bitswap/1.0.0";
var BITSWAP110 = "/ipfs/bitswap/1.1.0";
var BITSWAP120 = "/ipfs/bitswap/1.2.0";
var DEFAULT_MAX_INBOUND_STREAMS3 = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS3 = 128;
var DEFAULT_INCOMING_STREAM_TIMEOUT = 3e4;
var Network2 = class {
  /**
   * @param {import('@libp2p/interface-libp2p').Libp2p} libp2p
   * @param {import('./bitswap').Bitswap} bitswap
   * @param {import('./stats').Stats} stats
   * @param {object} [options]
   * @param {boolean} [options.b100Only]
   * @param {MultihashHasherLoader} [options.hashLoader]
   * @param {number} [options.maxInboundStreams=32]
   * @param {number} [options.maxOutboundStreams=32]
   * @param {number} [options.incomingStreamTimeout=30000]
   */
  constructor(libp2p, bitswap, stats, options = {}) {
    this._log = logger2(libp2p.peerId, "network");
    this._libp2p = libp2p;
    this._bitswap = bitswap;
    this._protocols = [BITSWAP100];
    if (!options.b100Only) {
      this._protocols.unshift(BITSWAP110);
      this._protocols.unshift(BITSWAP120);
    }
    this._stats = stats;
    this._running = false;
    this._onPeerConnect = this._onPeerConnect.bind(this);
    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);
    this._onConnection = this._onConnection.bind(this);
    this._hashLoader = options.hashLoader;
    this._maxInboundStreams = options.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS3;
    this._maxOutboundStreams = options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS3;
    this._incomingStreamTimeout = options.incomingStreamTimeout ?? DEFAULT_INCOMING_STREAM_TIMEOUT;
  }
  async start() {
    this._running = true;
    await this._libp2p.handle(this._protocols, this._onConnection, {
      maxInboundStreams: this._maxInboundStreams,
      maxOutboundStreams: this._maxOutboundStreams
    });
    const topology = createTopology({
      onConnect: this._onPeerConnect,
      onDisconnect: this._onPeerDisconnect
    });
    this._registrarIds = [];
    for (const protocol4 of this._protocols) {
      this._registrarIds.push(await this._libp2p.register(protocol4, topology));
    }
    this._libp2p.getConnections().forEach((conn) => {
      this._onPeerConnect(conn.remotePeer);
    });
  }
  async stop() {
    this._running = false;
    await this._libp2p.unhandle(this._protocols);
    if (this._registrarIds != null) {
      for (const id of this._registrarIds) {
        this._libp2p.unregister(id);
      }
      this._registrarIds = [];
    }
  }
  /**
   * Handles both types of incoming bitswap messages
   *
   * @private
   * @param {object} connection
   * @param {Stream} connection.stream - A duplex iterable stream
   * @param {Connection} connection.connection - A libp2p Connection
   */
  _onConnection({ stream, connection }) {
    if (!this._running) {
      return;
    }
    const controller = new import_timeout_abort_controller17.TimeoutController(this._incomingStreamTimeout);
    Promise.resolve().then(async () => {
      this._log("incoming new bitswap %s connection from %p", stream.stat.protocol, connection.remotePeer);
      await pipe(
        abortableSource(stream.source, controller.signal),
        decode14(),
        async (source) => {
          for await (const data of source) {
            try {
              const message2 = await BitswapMessage.deserialize(data.subarray(), this._hashLoader);
              await this._bitswap._receiveMessage(connection.remotePeer, message2);
            } catch (err2) {
              this._bitswap._receiveError(err2);
              break;
            }
            controller.reset();
          }
        }
      );
    }).catch((err2) => {
      this._log(err2);
      stream.abort(err2);
    }).finally(() => {
      controller.clear();
      stream.close();
    });
  }
  /**
   * @private
   * @param {PeerId} peerId
   */
  _onPeerConnect(peerId) {
    this._bitswap._onPeerConnected(peerId);
  }
  /**
   * @private
   * @param {PeerId} peerId
   */
  _onPeerDisconnect(peerId) {
    this._bitswap._onPeerDisconnected(peerId);
  }
  /**
   * Find providers given a `cid`.
   *
   * @param {CID} cid
   * @param {object} [options]
   * @param {AbortSignal} [options.signal]
   * @returns {AsyncIterable<Provider>}
   */
  findProviders(cid, options = {}) {
    return this._libp2p.contentRouting.findProviders(cid, options);
  }
  /**
   * Find the providers of a given `cid` and connect to them.
   *
   * @param {CID} cid
   * @param {object} [options]
   * @param {AbortSignal} [options.signal]
   */
  async findAndConnect(cid, options) {
    const connectAttempts = [];
    let found = 0;
    for await (const provider of this.findProviders(cid, options)) {
      this._log(`connecting to provider ${provider.id}`);
      connectAttempts.push(
        this.connectTo(provider.id, options).catch((err2) => {
          this._log.error(err2);
        })
      );
      found++;
      if (found === maxProvidersPerRequest) {
        break;
      }
    }
    await Promise.all(connectAttempts);
  }
  /**
   * Tell the network we can provide content for the passed CID
   *
   * @param {CID} cid
   * @param {object} [options]
   * @param {AbortSignal} [options.signal]
   */
  async provide(cid, options) {
    await this._libp2p.contentRouting.provide(cid, options);
  }
  /**
   * Connect to the given peer
   * Send the given msg (instance of Message) to the given peer
   *
   * @param {PeerId} peer
   * @param {Message} msg
   */
  async sendMessage(peer, msg) {
    if (!this._running)
      throw new Error("network isn't running");
    const stringId = peer.toString();
    this._log("sendMessage to %s", stringId, msg);
    const connection = await this._libp2p.dial(peer);
    const stream = await connection.newStream([BITSWAP120, BITSWAP110, BITSWAP100]);
    await writeMessage(stream, msg, this._log);
    this._updateSentStats(peer, msg.blocks);
  }
  /**
   * Connects to another peer
   *
   * @param {PeerId|Multiaddr} peer
   * @param {object} [options]
   * @param {AbortSignal} [options.signal]
   * @returns {Promise<Connection>}
   */
  async connectTo(peer, options) {
    if (!this._running) {
      throw new Error("network isn't running");
    }
    return this._libp2p.dial(peer, options);
  }
  /**
   * @private
   * @param {PeerId} peer
   * @param {Map<string, Uint8Array>} blocks
   */
  _updateSentStats(peer, blocks) {
    const peerId = peer.toString();
    if (this._stats) {
      for (const block of blocks.values()) {
        this._stats.push(peerId, "dataSent", block.length);
      }
      this._stats.push(peerId, "blocksSent", blocks.size);
    }
  }
};
async function writeMessage(stream, msg, log107) {
  try {
    let serialized;
    switch (stream.stat.protocol) {
      case BITSWAP100:
        serialized = msg.serializeToBitswap100();
        break;
      case BITSWAP110:
      case BITSWAP120:
        serialized = msg.serializeToBitswap110();
        break;
      default:
        throw new Error("Unknown protocol: " + stream.stat.protocol);
    }
    await pipe(
      [serialized],
      encode15(),
      stream
    );
  } catch (err2) {
    log107(err2);
  } finally {
    stream.close();
  }
}
var Ledger = class {
  /**
   * @param {import('@libp2p/interface-peer-id').PeerId} peerId
   */
  constructor(peerId) {
    this.partner = peerId;
    this.wantlist = new Wantlist();
    this.exchangeCount = 0;
    this.sentToPeer = /* @__PURE__ */ new Map();
    this.accounting = {
      bytesSent: 0,
      bytesRecv: 0
    };
  }
  /**
   * @param {number} n
   */
  sentBytes(n) {
    this.exchangeCount++;
    this.lastExchange = new Date().getTime();
    this.accounting.bytesSent += n;
  }
  /**
   * @param {number} n
   */
  receivedBytes(n) {
    this.exchangeCount++;
    this.lastExchange = new Date().getTime();
    this.accounting.bytesRecv += n;
  }
  /**
   *
   * @param {CID} cid
   * @param {number} priority
   * @param {import('../message/message').Message.Wantlist.WantType} wantType
   * @returns {void}
   */
  wants(cid, priority, wantType) {
    this.wantlist.add(cid, priority, wantType);
  }
  /**
   * @param {CID} cid
   * @returns {void}
   */
  cancelWant(cid) {
    this.wantlist.remove(cid);
  }
  /**
   * @param {CID} cid
   */
  wantlistContains(cid) {
    return this.wantlist.get(cid);
  }
  /**
   * @returns {number}
   */
  debtRatio() {
    return this.accounting.bytesSent / (this.accounting.bytesRecv + 1);
  }
};
var SortedMap = class extends Map {
  /**
   * @param {Array<[Key, Value]>} [entries]
   * @param {(a:[Key, Value], b:[Key, Value]) => number} [cmp] - compares [k1, v1] to [k2, v2]
   */
  constructor(entries, cmp) {
    super();
    this._cmp = cmp || this._defaultSort;
    this._keys = [];
    for (const [k, v] of entries || []) {
      this.set(k, v);
    }
  }
  /**
   * Call update to update the position of the key when it should change.
   * For example if the compare function sorts by the priority field, and the
   * priority changes, call update.
   * Call indexOf() to get the index _before_ the change happens.
   *
   * @param {number} i - the index of entry whose position should be updated.
   */
  update(i2) {
    if (i2 < 0 || i2 >= this._keys.length) {
      return;
    }
    const k = this._keys[i2];
    this._keys.splice(i2, 1);
    const newIdx = this._find(k);
    this._keys.splice(newIdx, 0, k);
  }
  /**
   * @param {Key} k
   * @param {Value} v
   */
  set(k, v) {
    if (this.has(k)) {
      const i3 = this.indexOf(k);
      this._keys.splice(i3, 1);
    }
    super.set(k, v);
    const i2 = this._find(k);
    this._keys.splice(i2, 0, k);
    return this;
  }
  clear() {
    super.clear();
    this._keys = [];
  }
  /**
   * @param {Key} k
   */
  delete(k) {
    if (!this.has(k)) {
      return false;
    }
    const i2 = this.indexOf(k);
    this._keys.splice(i2, 1);
    return super.delete(k);
  }
  /**
   * @param {Key} k
   */
  indexOf(k) {
    if (!this.has(k)) {
      return -1;
    }
    const i2 = this._find(k);
    if (this._keys[i2] === k) {
      return i2;
    }
    for (let j = 1; j < this._keys.length; j++) {
      if (this._keys[i2 + j] === k)
        return i2 + j;
      if (this._keys[i2 - j] === k)
        return i2 - j;
    }
    return -1;
  }
  /**
   * @private
   * @param {Key} k
   * @returns {number}
   */
  _find(k) {
    let lower = 0;
    let upper = this._keys.length;
    while (lower < upper) {
      const pivot = lower + upper >>> 1;
      const cmp = this._kCmp(this._keys[pivot], k);
      if (cmp < 0) {
        lower = pivot + 1;
      } else if (cmp > 0) {
        upper = pivot;
      } else {
        return pivot;
      }
    }
    return lower;
  }
  *keys() {
    for (const k of this._keys) {
      yield k;
    }
    return void 0;
  }
  /**
   * @returns {IterableIterator<Value>}
   */
  *values() {
    for (const k of this._keys) {
      yield this.get(k);
    }
    return void 0;
  }
  /**
   * @returns {IterableIterator<[Key, Value]>}
   */
  *entries() {
    for (const k of this._keys) {
      yield [k, this.get(k)];
    }
    return void 0;
  }
  *[Symbol.iterator]() {
    yield* this.entries();
  }
  /**
   * @template This
   * @param {(entry:[Key, Value]) => void} cb
   * @param {This} [thisArg]
   */
  // @ts-expect-error - Callback in Map forEach is (V, K, Map<K, V>) => void
  forEach(cb, thisArg) {
    if (!cb) {
      return;
    }
    for (const k of this._keys) {
      cb.apply(thisArg, [[
        k,
        /** @type {Value} */
        this.get(k)
      ]]);
    }
  }
  /**
   * @private
   * @param {[Key, Value]} a
   * @param {[Key, Value]} b
   * @returns {0|1|-1}
   */
  _defaultSort(a, b) {
    if (a[0] < b[0])
      return -1;
    if (b[0] < a[0])
      return 1;
    return 0;
  }
  /**
   * @private
   * @param {Key} a
   * @param {Key} b
   */
  _kCmp(a, b) {
    return this._cmp(
      // @ts-ignore - get may return undefined
      [a, this.get(a)],
      // @ts-ignore - get may return undefined
      [b, this.get(b)]
    );
  }
};
var DefaultTaskMerger = {
  hasNewInfo() {
    return false;
  },
  merge() {
  }
};
var RequestQueue = class {
  /**
   * @param {TaskMerger} [taskMerger]
   */
  constructor(taskMerger = DefaultTaskMerger) {
    this._taskMerger = taskMerger;
    this._byPeer = new SortedMap([], PeerTasks.compare);
  }
  /**
   * Push tasks onto the queue for the given peer
   *
   * @param {PeerId} peerId
   * @param {Task[]} tasks
   * @returns {void}
   */
  pushTasks(peerId, tasks) {
    let peerTasks = this._byPeer.get(peerId.toString());
    if (!peerTasks) {
      peerTasks = new PeerTasks(peerId, this._taskMerger);
    }
    peerTasks.pushTasks(tasks);
    this._byPeer.set(peerId.toString(), peerTasks);
  }
  /**
   * Choose the peer with the least active work (or if all have the same active
   * work, the most pending tasks) and pop off the highest priority tasks until
   * the total size is at least targetMinBytes.
   * This puts the popped tasks into the "active" state, meaning they are
   * actively being processed (and cannot be modified).
   *
   * @param {number} targetMinBytes - the minimum total size of tasks to pop
   * @returns {PopTaskResult}
   */
  popTasks(targetMinBytes) {
    const peerTasks = this._head();
    if (peerTasks === void 0) {
      return { tasks: [], pendingSize: 0 };
    }
    const { tasks, pendingSize } = peerTasks.popTasks(targetMinBytes);
    if (tasks.length === 0) {
      return { tasks, pendingSize };
    }
    const peerId = peerTasks.peerId;
    if (peerTasks.isIdle()) {
      this._byPeer.delete(peerId.toString());
    } else {
      this._byPeer.update(0);
    }
    return {
      peerId,
      tasks,
      pendingSize
    };
  }
  /**
   * @private
   * @returns {PeerTasks|undefined}
   */
  _head() {
    if (this._byPeer.size === 0) {
      return void 0;
    }
    for (const [, v] of this._byPeer) {
      return v;
    }
    return void 0;
  }
  /**
   * Remove the task with the given topic for the given peer.
   *
   * @param {string} topic
   * @param {PeerId} peerId
   * @returns {void}
   */
  remove(topic, peerId) {
    const peerTasks = this._byPeer.get(peerId.toString());
    peerTasks && peerTasks.remove(topic);
  }
  /**
   * Called when the tasks for the given peer complete.
   *
   * @param {PeerId} peerId
   * @param {Task[]} tasks
   * @returns {void}
   */
  tasksDone(peerId, tasks) {
    const peerTasks = this._byPeer.get(peerId.toString());
    if (!peerTasks) {
      return;
    }
    const i2 = this._byPeer.indexOf(peerId.toString());
    for (const task of tasks) {
      peerTasks.taskDone(task);
    }
    this._byPeer.update(i2);
  }
};
var PeerTasks = class {
  /**
   * @param {PeerId} peerId
   * @param {TaskMerger} taskMerger
   */
  constructor(peerId, taskMerger) {
    this.peerId = peerId;
    this._taskMerger = taskMerger;
    this._activeTotalSize = 0;
    this._pending = new PendingTasks();
    this._active = /* @__PURE__ */ new Set();
  }
  /**
   * Push tasks onto the queue.
   *
   * @param {Task[]} tasks
   * @returns {void}
   */
  pushTasks(tasks) {
    for (const t of tasks) {
      this._pushTask(t);
    }
  }
  /**
   * @private
   * @param {Task} task
   * @returns {void}
   */
  _pushTask(task) {
    if (!this._taskHasMoreInfoThanActiveTasks(task)) {
      return;
    }
    const existingTask = this._pending.get(task.topic);
    if (existingTask) {
      if (task.priority > existingTask.priority) {
        this._pending.updatePriority(task.topic, task.priority);
      }
      this._taskMerger.merge(task, existingTask);
      return;
    }
    this._pending.add(task);
  }
  /**
   * Indicates whether the new task adds any more information over tasks that are
   * already in the active task queue
   *
   * @private
   * @param {Task} task
   * @returns {boolean}
   */
  _taskHasMoreInfoThanActiveTasks(task) {
    const tasksWithTopic = [];
    for (const activeTask of this._active) {
      if (activeTask.topic === task.topic) {
        tasksWithTopic.push(activeTask);
      }
    }
    if (tasksWithTopic.length === 0) {
      return true;
    }
    return this._taskMerger.hasNewInfo(task, tasksWithTopic);
  }
  /**
   * Pop tasks off the queue such that the total size is at least targetMinBytes
   *
   * @param {number} targetMinBytes
   * @returns {PopTaskResult}
   */
  popTasks(targetMinBytes) {
    let size = 0;
    const tasks = [];
    const pendingTasks = this._pending.tasks();
    for (let i2 = 0; i2 < pendingTasks.length && size < targetMinBytes; i2++) {
      const task = pendingTasks[i2];
      tasks.push(task);
      size += task.size;
      this._pending.delete(task.topic);
      this._activeTotalSize += task.size;
      this._active.add(task);
    }
    return {
      tasks,
      pendingSize: this._pending.totalSize
    };
  }
  /**
   * Called when a task completes.
   * Note: must be the same reference as returned from popTasks.
   *
   * @param {Task} task
   * @returns {void}
   */
  taskDone(task) {
    if (this._active.has(task)) {
      this._activeTotalSize -= task.size;
      this._active.delete(task);
    }
  }
  /**
   * Remove pending tasks with the given topic
   *
   * @param {string} topic
   * @returns {void}
   */
  remove(topic) {
    this._pending.delete(topic);
  }
  /**
   * No work to be done, this PeerTasks object can be freed.
   *
   * @returns {boolean}
   */
  isIdle() {
    return this._pending.length === 0 && this._active.size === 0;
  }
  /**
   * Compare PeerTasks
   *
   * @template Key
   * @param {[Key, PeerTasks]} a
   * @param {[Key, PeerTasks]} b
   * @returns {number}
   */
  static compare(a, b) {
    if (a[1]._pending.length === 0) {
      return 1;
    }
    if (b[1]._pending.length === 0) {
      return -1;
    }
    if (a[1]._activeTotalSize === b[1]._activeTotalSize) {
      return b[1]._pending.length - a[1]._pending.length;
    }
    return a[1]._activeTotalSize - b[1]._activeTotalSize;
  }
};
var PendingTasks = class {
  constructor() {
    this._tasks = new SortedMap([], this._compare);
  }
  get length() {
    return this._tasks.size;
  }
  /**
   * Sum of the size of all pending tasks
   *
   * @type {number}
   **/
  get totalSize() {
    return [...this._tasks.values()].reduce((a, t) => a + t.task.size, 0);
  }
  /**
   * @param {string} topic
   * @returns {Task|void}
   */
  get(topic) {
    return (this._tasks.get(topic) || {}).task;
  }
  /**
   * @param {Task} task
   */
  add(task) {
    this._tasks.set(task.topic, {
      created: Date.now(),
      task
    });
  }
  /**
   * @param {string} topic
   * @returns {void}
   */
  delete(topic) {
    this._tasks.delete(topic);
  }
  // All pending tasks, in priority order
  tasks() {
    return [...this._tasks.values()].map((i2) => i2.task);
  }
  /**
   * Update the priority of the task with the given topic, and update the order
   *
   * @param {string} topic
   * @param {number} priority
   * @returns {void}
   **/
  updatePriority(topic, priority) {
    const obj = this._tasks.get(topic);
    if (!obj) {
      return;
    }
    const i2 = this._tasks.indexOf(topic);
    obj.task.priority = priority;
    this._tasks.update(i2);
  }
  /**
   * Sort by priority desc then FIFO
   *
   * @param {[string, PendingTask]} a
   * @param {[string, PendingTask]} b
   * @returns {number}
   * @private
   */
  _compare(a, b) {
    if (a[1].task.priority === b[1].task.priority) {
      return a[1].created - b[1].created;
    }
    return b[1].task.priority - a[1].task.priority;
  }
};
var TaskMerger = {
  /**
   * Indicates whether the given task has newer information than the active
   * tasks with the same topic.
   *
   * @param {Task} task
   * @param {Task[]} tasksWithTopic
   * @returns {boolean}
   */
  hasNewInfo(task, tasksWithTopic) {
    let haveBlock = false;
    let isWantBlock = false;
    for (const existing of tasksWithTopic) {
      if (existing.data.haveBlock) {
        haveBlock = true;
      }
      if (existing.data.isWantBlock) {
        isWantBlock = true;
      }
    }
    if (!isWantBlock && task.data.isWantBlock) {
      return true;
    }
    if (!haveBlock && task.data.haveBlock) {
      return true;
    }
    return false;
  },
  /**
   * Merge the information from the given task into the existing task (with the
   * same topic)
   *
   * @param {Task} newTask
   * @param {Task} existingTask
   */
  merge(newTask, existingTask) {
    const taskData = newTask.data;
    const existingData = existingTask.data;
    if (!existingData.haveBlock && taskData.haveBlock) {
      existingData.haveBlock = taskData.haveBlock;
      existingData.blockSize = taskData.blockSize;
    }
    if (!existingData.isWantBlock && taskData.isWantBlock) {
      existingData.isWantBlock = true;
      if (!existingData.haveBlock || taskData.haveBlock) {
        existingData.haveBlock = taskData.haveBlock;
        existingTask.size = newTask.size;
      }
    }
    if (existingData.isWantBlock && existingData.haveBlock) {
      existingTask.size = existingData.blockSize;
    }
  }
};
var WantType2 = BitswapMessage.WantType;
var TARGET_MESSAGE_SIZE = 16 * 1024;
var MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;
var DecisionEngine = class {
  /**
   * @param {PeerId} peerId
   * @param {import('interface-blockstore').Blockstore} blockstore
   * @param {import('../network').Network} network
   * @param {import('../stats').Stats} stats
   * @param {import('@libp2p/interface-libp2p').Libp2p} libp2p
   * @param {object} [opts]
   * @param {number} [opts.targetMessageSize]
   * @param {number} [opts.maxSizeReplaceHasWithBlock]
   */
  constructor(peerId, blockstore, network, stats, libp2p, opts = {}) {
    this._log = logger2(peerId, "engine");
    this.blockstore = blockstore;
    this.network = network;
    this._stats = stats;
    this._opts = this._processOpts(opts);
    this.ledgerMap = trackedMap({
      name: "ipfs_bitswap_ledger_map",
      metrics: libp2p.metrics
    });
    this._running = false;
    this._requestQueue = new RequestQueue(TaskMerger);
  }
  /**
   * @template {object} Opts
   * @param {Opts} opts
   * @returns {Opts & {maxSizeReplaceHasWithBlock:number, targetMessageSize:number}}
   * @private
   */
  _processOpts(opts) {
    return {
      maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,
      targetMessageSize: TARGET_MESSAGE_SIZE,
      ...opts
    };
  }
  _scheduleProcessTasks() {
    setTimeout(() => {
      this._processTasks();
    });
  }
  /**
   * Pull tasks off the request queue and send a message to the corresponding
   * peer
   */
  async _processTasks() {
    if (!this._running) {
      return;
    }
    const { peerId, tasks, pendingSize } = this._requestQueue.popTasks(this._opts.targetMessageSize);
    if (tasks.length === 0) {
      return;
    }
    const msg = new BitswapMessage(false);
    msg.setPendingBytes(pendingSize);
    const blockCids = [];
    const blockTasks = /* @__PURE__ */ new Map();
    for (const task of tasks) {
      const cid = CID.parse(task.topic);
      if (task.data.haveBlock) {
        if (task.data.isWantBlock) {
          blockCids.push(cid);
          blockTasks.set(task.topic, task.data);
        } else {
          msg.addHave(cid);
        }
      } else {
        msg.addDontHave(cid);
      }
    }
    const blocks = await this._getBlocks(blockCids);
    for (const [topic, taskData] of blockTasks) {
      const cid = CID.parse(topic);
      const blk = blocks.get(topic);
      if (blk) {
        msg.addBlock(cid, blk);
      } else {
        if (taskData.sendDontHave) {
          msg.addDontHave(cid);
        }
      }
    }
    if (msg.empty) {
      peerId && this._requestQueue.tasksDone(peerId, tasks);
      this._scheduleProcessTasks();
      return;
    }
    try {
      peerId && await this.network.sendMessage(peerId, msg);
      for (const [cidStr, block] of blocks.entries()) {
        peerId && this.messageSent(peerId, CID.parse(cidStr), block);
      }
    } catch (err2) {
      this._log.error(err2);
    }
    peerId && this._requestQueue.tasksDone(peerId, tasks);
    this._scheduleProcessTasks();
  }
  /**
   * @param {PeerId} peerId
   * @returns {Map<string, import('../wantlist/entry').WantListEntry>}
   */
  wantlistForPeer(peerId) {
    const peerIdStr = peerId.toString();
    const ledger = this.ledgerMap.get(peerIdStr);
    return ledger ? ledger.wantlist.sortedEntries() : /* @__PURE__ */ new Map();
  }
  /**
   * @param {PeerId} peerId
   */
  ledgerForPeer(peerId) {
    const peerIdStr = peerId.toString();
    const ledger = this.ledgerMap.get(peerIdStr);
    if (!ledger) {
      return null;
    }
    return {
      peer: ledger.partner,
      value: ledger.debtRatio(),
      sent: ledger.accounting.bytesSent,
      recv: ledger.accounting.bytesRecv,
      exchanged: ledger.exchangeCount
    };
  }
  /**
   * @returns {PeerId[]}
   */
  peers() {
    return Array.from(this.ledgerMap.values()).map((l) => l.partner);
  }
  /**
   * Receive blocks either from an incoming message from the network, or from
   * blocks being added by the client on the localhost (eg IPFS add)
   *
   * @param {{ cid: CID, data: Uint8Array }[]} blocks
   */
  receivedBlocks(blocks) {
    if (!blocks.length) {
      return;
    }
    for (const ledger of this.ledgerMap.values()) {
      for (const block of blocks) {
        const want = ledger.wantlistContains(block.cid);
        if (!want) {
          continue;
        }
        const blockSize = block.data.length;
        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);
        let entrySize = blockSize;
        if (!isWantBlock) {
          entrySize = BitswapMessage.blockPresenceSize(want.cid);
        }
        this._requestQueue.pushTasks(ledger.partner, [{
          topic: want.cid.toString(base58btc),
          priority: want.priority,
          size: entrySize,
          data: {
            blockSize,
            isWantBlock,
            haveBlock: true,
            sendDontHave: false
          }
        }]);
      }
    }
    this._scheduleProcessTasks();
  }
  /**
   * Handle incoming messages
   *
   * @param {PeerId} peerId
   * @param {Message} msg
   * @returns {Promise<void>}
   */
  async messageReceived(peerId, msg) {
    const ledger = this._findOrCreate(peerId);
    if (msg.empty) {
      return;
    }
    if (msg.full) {
      ledger.wantlist = new Wantlist();
    }
    this._updateBlockAccounting(msg.blocks, ledger);
    if (msg.wantlist.size === 0) {
      this._scheduleProcessTasks();
      return;
    }
    const cancels = [];
    const wants = [];
    msg.wantlist.forEach((entry) => {
      if (entry.cancel) {
        ledger.cancelWant(entry.cid);
        cancels.push(entry.cid);
      } else {
        ledger.wants(entry.cid, entry.priority, entry.wantType);
        wants.push(entry);
      }
    });
    this._cancelWants(peerId, cancels);
    await this._addWants(peerId, wants);
    this._scheduleProcessTasks();
  }
  /**
   * @private
   * @param {PeerId} peerId
   * @param {CID[]} cids
   * @returns {void}
   */
  _cancelWants(peerId, cids) {
    for (const c of cids) {
      this._requestQueue.remove(c.toString(base58btc), peerId);
    }
  }
  /**
   * @private
   * @param {PeerId} peerId
   * @param {BitswapMessageEntry[]} wants
   * @returns {Promise<void>}
   */
  async _addWants(peerId, wants) {
    const blockSizes = await this._getBlockSizes(wants.map((w) => w.cid));
    const tasks = [];
    for (const want of wants) {
      const id = want.cid.toString(base58btc);
      const blockSize = blockSizes.get(id);
      if (blockSize == null) {
        if (want.sendDontHave) {
          tasks.push({
            topic: id,
            priority: want.priority,
            size: BitswapMessage.blockPresenceSize(want.cid),
            data: {
              isWantBlock: want.wantType === WantType2.Block,
              blockSize: 0,
              haveBlock: false,
              sendDontHave: want.sendDontHave
            }
          });
        }
      } else {
        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);
        let entrySize = blockSize;
        if (!isWantBlock) {
          entrySize = BitswapMessage.blockPresenceSize(want.cid);
        }
        tasks.push({
          topic: id,
          priority: want.priority,
          size: entrySize,
          data: {
            isWantBlock,
            blockSize,
            haveBlock: true,
            sendDontHave: want.sendDontHave
          }
        });
      }
      this._requestQueue.pushTasks(peerId, tasks);
    }
  }
  /**
   * @private
   * @param {import('../message/message').Message.Wantlist.WantType} wantType
   * @param {number} blockSize
   */
  _sendAsBlock(wantType, blockSize) {
    return wantType === WantType2.Block || blockSize <= this._opts.maxSizeReplaceHasWithBlock;
  }
  /**
   * @private
   * @param {CID[]} cids
   * @returns {Promise<Map<string, number>>}
   */
  async _getBlockSizes(cids) {
    const blocks = await this._getBlocks(cids);
    return new Map([...blocks].map(([k, v]) => [k, v.length]));
  }
  /**
   * @private
   * @param {CID[]} cids
   * @returns {Promise<Map<string, Uint8Array>>}
   */
  async _getBlocks(cids) {
    const res = /* @__PURE__ */ new Map();
    await Promise.all(cids.map(async (cid) => {
      try {
        const block = await this.blockstore.get(cid);
        res.set(cid.toString(base58btc), block);
      } catch (e) {
        if (e.code !== "ERR_NOT_FOUND") {
          this._log.error("failed to query blockstore for %s: %s", cid, e);
        }
      }
    }));
    return res;
  }
  /**
   * @private
   * @param {Map<string, Uint8Array>} blocksMap
   * @param {Ledger} ledger
   */
  _updateBlockAccounting(blocksMap, ledger) {
    for (const block of blocksMap.values()) {
      this._log("got block (%s bytes)", block.length);
      ledger.receivedBytes(block.length);
    }
  }
  /**
   * Clear up all accounting things after message was sent
   *
   * @param {PeerId} peerId
   * @param {CID} cid
   * @param {Uint8Array} block
   */
  messageSent(peerId, cid, block) {
    const ledger = this._findOrCreate(peerId);
    ledger.sentBytes(block.length);
    ledger.wantlist.remove(cid);
  }
  /**
   * @param {PeerId} peerId
   * @returns {number}
   */
  numBytesSentTo(peerId) {
    return this._findOrCreate(peerId).accounting.bytesSent;
  }
  /**
   * @param {PeerId} peerId
   * @returns {number}
   */
  numBytesReceivedFrom(peerId) {
    return this._findOrCreate(peerId).accounting.bytesRecv;
  }
  /**
   *
   * @param {PeerId} peerId
   */
  peerDisconnected(peerId) {
    this.ledgerMap.delete(peerId.toString());
  }
  /**
   * @private
   * @param {PeerId} peerId
   * @returns {Ledger}
   */
  _findOrCreate(peerId) {
    const peerIdStr = peerId.toString();
    const ledger = this.ledgerMap.get(peerIdStr);
    if (ledger) {
      return ledger;
    }
    const l = new Ledger(peerId);
    this.ledgerMap.set(peerIdStr, l);
    if (this._stats) {
      this._stats.push(peerIdStr, "peerCount", 1);
    }
    return l;
  }
  start() {
    this._running = true;
  }
  stop() {
    this._running = false;
  }
};
var import_events46 = __toESM(require_events(), 1);
var unwantEvent = (cid) => `unwant:${toString3(cid.multihash.bytes, "base64")}`;
var blockEvent = (cid) => `block:${toString3(cid.multihash.bytes, "base64")}`;
var Notifications = class extends import_events46.EventEmitter {
  /**
   * Internal module used to track events about incoming blocks,
   * wants and unwants.
   *
   * @param {PeerId} peerId
   */
  constructor(peerId) {
    super();
    this.setMaxListeners(maxListeners);
    this._log = logger2(peerId, "notif");
  }
  /**
   * Signal the system that we received `block`.
   *
   * @param {CID} cid
   * @param {Uint8Array} block
   * @returns {void}
   */
  hasBlock(cid, block) {
    const event = blockEvent(cid);
    this._log(event);
    this.emit(event, block);
  }
  /**
   * Signal the system that we are waiting to receive the
   * block associated with the given `cid`.
   * Returns a Promise that resolves to the block when it is received,
   * or undefined when the block is unwanted.
   *
   * @param {CID} cid
   * @param {object} [options]
   * @param {AbortSignal} [options.signal]
   * @returns {Promise<Uint8Array>}
   */
  wantBlock(cid, options = {}) {
    if (!cid) {
      throw new Error("Not a valid cid");
    }
    const blockEvt = blockEvent(cid);
    const unwantEvt = unwantEvent(cid);
    this._log(`wantBlock:${cid}`);
    return new Promise((resolve7, reject) => {
      const onUnwant = () => {
        this.removeListener(blockEvt, onBlock);
        reject(new Error(`Block for ${cid} unwanted`));
      };
      const onBlock = (data) => {
        this.removeListener(unwantEvt, onUnwant);
        resolve7(data);
      };
      this.once(unwantEvt, onUnwant);
      this.once(blockEvt, onBlock);
      if (options && options.signal) {
        options.signal.addEventListener("abort", () => {
          this.removeListener(blockEvt, onBlock);
          this.removeListener(unwantEvt, onUnwant);
          reject(new Error(`Want for ${cid} aborted`));
        });
      }
    });
  }
  /**
   * Signal that the block is not wanted anymore.
   *
   * @param {CID} cid - the CID of the block that is not wanted anymore.
   * @returns {void}
   */
  unwantBlock(cid) {
    const event = unwantEvent(cid);
    this._log(event);
    this.emit(event);
  }
};
var import_events48 = __toESM(require_events(), 1);
var import_events47 = __toESM(require_events(), 1);
var import_moving_average = __toESM(require_moving_average(), 1);
var Stat = class extends import_events47.EventEmitter {
  /**
   *
   * @param {string[]} initialCounters
   * @param {object} options
   * @param {boolean} options.enabled
   * @param {number} options.computeThrottleTimeout
   * @param {number} options.computeThrottleMaxQueueSize
   * @param {import('.').AverageIntervals} options.movingAverageIntervals
   */
  constructor(initialCounters, options) {
    super();
    this._options = options;
    this._queue = [];
    this._stats = {};
    this._frequencyLastTime = Date.now();
    this._frequencyAccumulators = {};
    this._movingAverages = {};
    this._update = this._update.bind(this);
    initialCounters.forEach((key) => {
      this._stats[key] = BigInt(0);
      this._movingAverages[key] = {};
      this._options.movingAverageIntervals.forEach((interval) => {
        const ma = this._movingAverages[key][interval] = (0, import_moving_average.default)(interval);
        ma.push(this._frequencyLastTime, 0);
      });
    });
    this._enabled = this._options.enabled;
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._disabled = true;
  }
  stop() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
  }
  get snapshot() {
    return Object.assign({}, this._stats);
  }
  get movingAverages() {
    return Object.assign({}, this._movingAverages);
  }
  /**
   * @param {string} counter
   * @param {number} inc
   */
  push(counter, inc) {
    if (this._enabled) {
      this._queue.push([counter, inc, Date.now()]);
      this._resetComputeTimeout();
    }
  }
  /**
   * @private
   */
  _resetComputeTimeout() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    this._timeout = setTimeout(this._update, this._nextTimeout());
  }
  /**
   * @private
   * @returns {number}
   */
  _nextTimeout() {
    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;
    return Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);
  }
  /**
   * @private
   */
  _update() {
    this._timeout = null;
    if (this._queue.length) {
      let last2;
      while (this._queue.length) {
        const op = last2 = this._queue.shift();
        op && this._applyOp(op);
      }
      last2 && this._updateFrequency(last2[2]);
      this.emit("update", this._stats);
    }
  }
  /**
   * @private
   * @param {number} latestTime
   */
  _updateFrequency(latestTime) {
    const timeDiff = latestTime - this._frequencyLastTime;
    if (timeDiff) {
      Object.keys(this._stats).forEach((key) => {
        this._updateFrequencyFor(key, timeDiff, latestTime);
      });
    }
    this._frequencyLastTime = latestTime;
  }
  /**
   * @private
   * @param {string} key
   * @param {number} timeDiffMS
   * @param {number} latestTime
   * @returns {void}
   */
  _updateFrequencyFor(key, timeDiffMS, latestTime) {
    const count = this._frequencyAccumulators[key] || 0;
    this._frequencyAccumulators[key] = 0;
    const hz = count / timeDiffMS * 1e3;
    let movingAverages = this._movingAverages[key];
    if (!movingAverages) {
      movingAverages = this._movingAverages[key] = {};
    }
    this._options.movingAverageIntervals.forEach((movingAverageInterval) => {
      let movingAverage = movingAverages[movingAverageInterval];
      if (!movingAverage) {
        movingAverage = movingAverages[movingAverageInterval] = (0, import_moving_average.default)(movingAverageInterval);
      }
      movingAverage.push(latestTime, hz);
    });
  }
  /**
   * @private
   * @param {Op} op
   */
  _applyOp(op) {
    const key = op[0];
    const inc = op[1];
    if (typeof inc !== "number") {
      throw new Error(`invalid increment number: ${inc}`);
    }
    if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {
      this._stats[key] = BigInt(0);
    }
    this._stats[key] = BigInt(this._stats[key]) + BigInt(inc);
    if (!this._frequencyAccumulators[key]) {
      this._frequencyAccumulators[key] = 0;
    }
    this._frequencyAccumulators[key] += inc;
  }
};
var defaultOptions19 = {
  enabled: false,
  computeThrottleTimeout: 1e3,
  computeThrottleMaxQueueSize: 1e3,
  movingAverageIntervals: (
    /** @type {AverageIntervals} */
    [
      60 * 1e3,
      // 1 minute
      5 * 60 * 1e3,
      // 5 minutes
      15 * 60 * 1e3
      // 15 minutes
    ]
  )
};
var Stats = class extends import_events48.EventEmitter {
  /**
   * @param {import('@libp2p/interface-libp2p').Libp2p} libp2p
   * @param {string[]} [initialCounters]
   * @param {object} _options
   * @param {boolean} _options.enabled
   * @param {number} _options.computeThrottleTimeout
   * @param {number} _options.computeThrottleMaxQueueSize
   */
  constructor(libp2p, initialCounters = [], _options = defaultOptions19) {
    super();
    const options = Object.assign({}, defaultOptions19, _options);
    if (typeof options.computeThrottleTimeout !== "number") {
      throw new Error("need computeThrottleTimeout");
    }
    if (typeof options.computeThrottleMaxQueueSize !== "number") {
      throw new Error("need computeThrottleMaxQueueSize");
    }
    this._initialCounters = initialCounters;
    this._options = options;
    this._enabled = this._options.enabled;
    this._global = new Stat(initialCounters, options);
    this._global.on("update", (stats) => this.emit("update", stats));
    this._peers = trackedMap({
      name: "ipfs_bitswap_stats_peers",
      metrics: libp2p.metrics
    });
  }
  enable() {
    this._enabled = true;
    this._options.enabled = true;
    this._global.enable();
  }
  disable() {
    this._enabled = false;
    this._options.enabled = false;
    this._global.disable();
  }
  stop() {
    this._enabled = false;
    this._global.stop();
    for (const peerStat of this._peers) {
      peerStat[1].stop();
    }
  }
  get snapshot() {
    return this._global.snapshot;
  }
  get movingAverages() {
    return this._global.movingAverages;
  }
  /**
   * @param {PeerId|string} peerId
   * @returns {Stat|undefined}
   */
  forPeer(peerId) {
    const peerIdStr = typeof peerId !== "string" && peerId.toString ? peerId.toString() : `${peerId}`;
    return this._peers.get(peerIdStr);
  }
  /**
   *
   * @param {string|null} peer
   * @param {string} counter
   * @param {number} inc
   */
  push(peer, counter, inc) {
    if (this._enabled) {
      this._global.push(counter, inc);
      if (peer) {
        let peerStats = this._peers.get(peer);
        if (!peerStats) {
          peerStats = new Stat(this._initialCounters, this._options);
          this._peers.set(peer, peerStats);
        }
        peerStats.push(counter, inc);
      }
    }
  }
  /**
   * @param {PeerId} peer
   */
  disconnected(peer) {
    const peerId = peer.toString();
    const peerStats = this._peers.get(peerId);
    if (peerStats) {
      peerStats.stop();
      this._peers.delete(peerId);
    }
  }
};
var import_any_signal13 = __toESM(require_any_signal(), 1);
var defaultOptions20 = {
  statsEnabled: false,
  statsComputeThrottleTimeout: 1e3,
  statsComputeThrottleMaxQueueSize: 1e3
};
var statsKeys = [
  "blocksReceived",
  "dataReceived",
  "dupBlksReceived",
  "dupDataReceived",
  "blocksSent",
  "dataSent",
  "providesBufferLength",
  "wantListLength",
  "peerCount"
];
var Bitswap = class extends BaseBlockstore {
  /**
   * @param {import('@libp2p/interface-libp2p').Libp2p} libp2p
   * @param {Blockstore} blockstore
   * @param {object} [options]
   * @param {boolean} [options.statsEnabled=false]
   * @param {number} [options.statsComputeThrottleTimeout=1000]
   * @param {number} [options.statsComputeThrottleMaxQueueSize=1000]
   * @param {number} [options.maxInboundStreams=32]
   * @param {number} [options.maxOutboundStreams=32]
   * @param {number} [options.incomingStreamTimeout=30000]
   * @param {MultihashHasherLoader} [options.hashLoader]
   */
  constructor(libp2p, blockstore, options = {}) {
    super();
    this._libp2p = libp2p;
    this._log = logger2(this.peerId);
    this._options = Object.assign({}, defaultOptions20, options);
    this._stats = new Stats(libp2p, statsKeys, {
      enabled: this._options.statsEnabled,
      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,
      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize
    });
    this.network = new Network2(libp2p, this, this._stats, {
      hashLoader: options.hashLoader,
      maxInboundStreams: options.maxInboundStreams,
      maxOutboundStreams: options.maxOutboundStreams,
      incomingStreamTimeout: options.incomingStreamTimeout
    });
    this.blockstore = blockstore;
    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats, libp2p);
    this.wm = new WantManager(this.peerId, this.network, this._stats, libp2p);
    this.notifications = new Notifications(this.peerId);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  /**
   * @type {PeerId}
   */
  get peerId() {
    return this._libp2p.peerId;
  }
  /**
   * handle messages received through the network
   *
   * @param {PeerId} peerId
   * @param {BitswapMessage} incoming
   */
  async _receiveMessage(peerId, incoming) {
    try {
      await this.engine.messageReceived(peerId, incoming);
    } catch (err2) {
      this._log("failed to receive message", incoming);
    }
    if (incoming.blocks.size === 0) {
      return;
    }
    const received = [];
    for (const [cidStr, data] of incoming.blocks.entries()) {
      const cid = CID.parse(cidStr);
      received.push({
        wasWanted: this.wm.wantlist.contains(cid),
        cid,
        data
      });
    }
    this.wm.cancelWants(
      received.filter(({ wasWanted }) => wasWanted).map(({ cid }) => cid)
    );
    await Promise.all(
      received.map(
        ({ cid, wasWanted, data }) => this._handleReceivedBlock(peerId, cid, data, wasWanted)
      )
    );
  }
  /**
   * @private
   * @param {PeerId} peerId
   * @param {CID} cid
   * @param {Uint8Array} data
   * @param {boolean} wasWanted
   */
  async _handleReceivedBlock(peerId, cid, data, wasWanted) {
    this._log("received block");
    const has = await this.blockstore.has(cid);
    this._updateReceiveCounters(peerId.toString(), cid, data, has);
    if (!wasWanted) {
      return;
    }
    await this.put(cid, data);
  }
  /**
   * @private
   * @param {string} peerIdStr
   * @param {CID} cid
   * @param {Uint8Array} data
   * @param {boolean} exists
   */
  _updateReceiveCounters(peerIdStr, cid, data, exists2) {
    this._stats.push(peerIdStr, "blocksReceived", 1);
    this._stats.push(peerIdStr, "dataReceived", data.length);
    if (exists2) {
      this._stats.push(peerIdStr, "dupBlksReceived", 1);
      this._stats.push(peerIdStr, "dupDataReceived", data.length);
    }
  }
  /**
   * handle errors on the receiving channel
   *
   * @param {Error} err
   */
  _receiveError(err2) {
    this._log.error("ReceiveError: %s", err2.message);
  }
  /**
   * handle new peers
   *
   * @param {PeerId} peerId
   */
  _onPeerConnected(peerId) {
    this.wm.connected(peerId);
  }
  /**
   * handle peers being disconnected
   *
   * @param {PeerId} peerId
   */
  _onPeerDisconnected(peerId) {
    this.wm.disconnected(peerId);
    this.engine.peerDisconnected(peerId);
    this._stats.disconnected(peerId);
  }
  enableStats() {
    this._stats.enable();
  }
  disableStats() {
    this._stats.disable();
  }
  /**
   * Return the current wantlist for a given `peerId`
   *
   * @param {PeerId} peerId
   * @param {any} [_options]
   */
  wantlistForPeer(peerId, _options) {
    return this.engine.wantlistForPeer(peerId);
  }
  /**
   * Return ledger information for a given `peerId`
   *
   * @param {PeerId} peerId
   */
  ledgerForPeer(peerId) {
    return this.engine.ledgerForPeer(peerId);
  }
  /**
   * Fetch a given block by cid. If the block is in the local
   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.
   *
   * @param {CID} cid
   * @param {object} [options]
   * @param {AbortSignal} [options.signal]
   */
  async get(cid, options = {}) {
    const fetchFromNetwork = (cid2, options2) => {
      this.wm.wantBlocks([cid2], options2);
      return this.notifications.wantBlock(cid2, options2);
    };
    let promptedNetwork = false;
    const loadOrFetchFromNetwork = async (cid2, options2) => {
      try {
        const block = await this.blockstore.get(cid2, options2);
        return block;
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
        if (!promptedNetwork) {
          promptedNetwork = true;
          this.network.findAndConnect(cid2, options2).catch((err3) => this._log.error(err3));
        }
        return fetchFromNetwork(cid2, options2);
      }
    };
    const controller = new AbortController();
    const signal = options.signal ? (0, import_any_signal13.anySignal)([options.signal, controller.signal]) : controller.signal;
    try {
      const block = await Promise.race([
        this.notifications.wantBlock(cid, {
          signal
        }),
        loadOrFetchFromNetwork(cid, {
          signal
        })
      ]);
      return block;
    } finally {
      controller.abort();
    }
  }
  /**
   * Fetch a a list of blocks by cid. If the blocks are in the local
   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.
   *
   * @param {AsyncIterable<CID>|Iterable<CID>} cids
   * @param {object} [options]
   * @param {AbortSignal} [options.signal]
   */
  async *getMany(cids, options = {}) {
    for await (const cid of cids) {
      yield this.get(cid, options);
    }
  }
  /**
   * Removes the given CIDs from the wantlist independent of any ref counts.
   *
   * This will cause all outstanding promises for a given block to reject.
   *
   * If you want to cancel the want for a block without doing that, pass an
   * AbortSignal in to `.get` or `.getMany` and abort it.
   *
   * @param {CID[]|CID} cids
   */
  unwant(cids) {
    const cidsArray = Array.isArray(cids) ? cids : [cids];
    this.wm.unwantBlocks(cidsArray);
    cidsArray.forEach((cid) => this.notifications.unwantBlock(cid));
  }
  /**
   * Removes the given keys from the want list. This may cause pending promises
   * for blocks to never resolve.  If you wish these promises to abort instead
   * call `unwant(cids)` instead.
   *
   * @param {CID[]|CID} cids
   */
  cancelWants(cids) {
    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids]);
  }
  /**
   * Put the given block to the underlying blockstore and
   * send it to nodes that have it in their wantlist.
   *
   * @param {CID} cid
   * @param {Uint8Array} block
   * @param {any} [_options]
   */
  async put(cid, block, _options) {
    await this.blockstore.put(cid, block);
    this._sendHaveBlockNotifications(cid, block);
  }
  /**
   * Put the given blocks to the underlying blockstore and
   * send it to nodes that have it them their wantlist.
   *
   * @param {Iterable<Pair> | AsyncIterable<Pair>} source
   * @param {Options} [options]
   */
  async *putMany(source, options) {
    for await (const { key, value: value2 } of this.blockstore.putMany(source, options)) {
      this._sendHaveBlockNotifications(key, value2);
      yield { key, value: value2 };
    }
  }
  /**
   * Sends notifications about the arrival of a block
   *
   * @private
   * @param {CID} cid
   * @param {Uint8Array} data
   */
  _sendHaveBlockNotifications(cid, data) {
    this.notifications.hasBlock(cid, data);
    this.engine.receivedBlocks([{ cid, data }]);
    this.network.provide(cid).catch((err2) => {
      this._log.error("Failed to provide: %s", err2.message);
    });
  }
  /**
   * Get the current list of wants
   */
  getWantlist() {
    return this.wm.wantlist.entries();
  }
  /**
   * Get the current list of partners
   */
  peers() {
    return this.engine.peers();
  }
  /**
   * Get stats about the bitswap node
   */
  stat() {
    return this._stats;
  }
  /**
   * Start the bitswap node
   */
  async start() {
    this.wm.start();
    await this.network.start();
    this.engine.start();
    this.started = true;
  }
  /**
   * Stop the bitswap node
   */
  async stop() {
    this._stats.stop();
    this.wm.stop();
    await this.network.stop();
    this.engine.stop();
    this.started = false;
  }
  unwrap() {
    return this.blockstore;
  }
};
var createBitswap2 = (libp2p, blockstore, options = {}) => {
  return new Bitswap(libp2p, blockstore, options);
};
var import_err_code141 = __toESM(require_err_code(), 1);
var errors_exports5 = {};
__export(errors_exports5, {
  abortedError: () => abortedError2,
  notFoundError: () => notFoundError2
});
var import_err_code140 = __toESM(require_err_code(), 1);
function notFoundError2(err2) {
  err2 = err2 || new Error("Not Found");
  return (0, import_err_code140.default)(err2, "ERR_NOT_FOUND");
}
function abortedError2(err2) {
  err2 = err2 || new Error("Aborted");
  return (0, import_err_code140.default)(err2, "ERR_ABORTED");
}
({
  ...errors_exports5
});
var BlockStorage = class extends BaseBlockstore {
  /**
   * Create a new BlockStorage
   *
   * @param {Blockstore} blockstore
   * @param {Bitswap} bitswap
   */
  constructor(blockstore, bitswap) {
    super();
    this.child = blockstore;
    this.bitswap = bitswap;
  }
  open() {
    return this.child.open();
  }
  close() {
    return this.child.close();
  }
  unwrap() {
    return this.child;
  }
  /**
   * Put a block to the underlying datastore
   *
   * @param {CID} cid
   * @param {Uint8Array} block
   * @param {AbortOptions} [options]
   */
  async put(cid, block, options = {}) {
    if (await this.has(cid)) {
      return;
    }
    if (this.bitswap.isStarted()) {
      await this.bitswap.put(cid, block, options);
    } else {
      await this.child.put(cid, block, options);
    }
  }
  /**
   * Put a multiple blocks to the underlying datastore
   *
   * @param {AsyncIterable<{ key: CID, value: Uint8Array }> | Iterable<{ key: CID, value: Uint8Array }>} blocks
   * @param {AbortOptions} [options]
   */
  async *putMany(blocks, options = {}) {
    const missingBlocks = filter(blocks, async ({ key }) => {
      return !await this.has(key);
    });
    if (this.bitswap.isStarted()) {
      yield* this.bitswap.putMany(missingBlocks, options);
    } else {
      yield* this.child.putMany(missingBlocks, options);
    }
  }
  /**
   * Get a block by cid
   *
   * @param {CID} cid
   * @param {AbortOptions} [options]
   */
  async get(cid, options = {}) {
    if (!await this.has(cid) && this.bitswap.isStarted()) {
      return this.bitswap.get(cid, options);
    } else {
      return this.child.get(cid, options);
    }
  }
  /**
   * Get multiple blocks back from an array of cids
   *
   * @param {AsyncIterable<CID> | Iterable<CID>} cids
   * @param {AbortOptions} [options]
   */
  async *getMany(cids, options = {}) {
    const getFromBitswap = pushable({ objectMode: true });
    const getFromChild = pushable({ objectMode: true });
    Promise.resolve().then(async () => {
      for await (const cid of cids) {
        if (!await this.has(cid) && this.bitswap.isStarted()) {
          getFromBitswap.push(cid);
        } else {
          getFromChild.push(cid);
        }
      }
      getFromBitswap.end();
      getFromChild.end();
    });
    yield* merge$1(
      this.bitswap.getMany(getFromBitswap, options),
      this.child.getMany(getFromChild, options)
    );
  }
  /**
   * Delete a block from the blockstore
   *
   * @param {CID} cid
   * @param {RmOptions} [options]
   */
  async delete(cid, options) {
    await this.child.delete(cid, options);
  }
  /**
   * Delete multiple blocks from the blockstore
   *
   * @param {AsyncIterable<CID> | Iterable<CID>} cids
   * @param {RmOptions} [options]
   */
  async *deleteMany(cids, options) {
    yield* this.child.deleteMany(cids, options);
  }
  /**
   * @param {CID} cid
   * @param {AbortOptions} options
   */
  async has(cid, options = {}) {
    return this.child.has(cid, options);
  }
  /**
   * @param {Query} q
   * @param {AbortOptions} options
   */
  async *query(q, options = {}) {
    yield* this.child.query(q, options);
  }
  /**
   * @param {KeyQuery} q
   * @param {AbortOptions} options
   */
  async *queryKeys(q, options = {}) {
    yield* this.child.queryKeys(q, options);
  }
};
var Network3 = class {
  /**
   * @param {PeerId} peerId
   * @param {libp2p} libp2p
   * @param {Bitswap} bitswap
   * @param {Repo} repo
   * @param {BlockStorage} blockstore
   */
  constructor(peerId, libp2p, bitswap, repo, blockstore) {
    this.peerId = peerId;
    this.libp2p = libp2p;
    this.bitswap = bitswap;
    this.repo = repo;
    this.blockstore = blockstore;
  }
  /**
   * @param {Options} options
   */
  static async start({ peerId, repo, print, hashers, options }) {
    if (repo.closed) {
      await repo.open();
    }
    const config2 = await repo.config.getAll();
    const libp2p = await createLibp2p2({
      options,
      repo,
      peerId,
      multiaddrs: readAddrs(peerId, config2),
      config: config2,
      keychainConfig: void 0
    });
    await libp2p.start();
    for (const ma of libp2p.getMultiaddrs()) {
      print(`Swarm listening on ${ma.toString()}`);
    }
    const bitswap = createBitswap2(libp2p, repo.blocks, {
      statsEnabled: true,
      hashLoader: hashers,
      maxInboundStreams: 1024,
      maxOutboundStreams: 1024
    });
    await bitswap.start();
    const blockstore = new BlockStorage(repo.blocks, bitswap);
    repo.blocks = blockstore;
    repo.pins.blockstore = blockstore;
    return new Network3(peerId, libp2p, bitswap, repo, blockstore);
  }
  /**
   * @param {Network} network
   */
  static async stop(network) {
    network.repo.blocks = network.blockstore.unwrap();
    network.repo.pins.blockstore = network.blockstore.unwrap();
    await network.bitswap.stop();
    await network.libp2p.stop();
  }
};
var readAddrs = (peerId, config2) => {
  const peerIdStr = peerId.toString();
  const addrs = [];
  const swarm = config2.Addresses && config2.Addresses.Swarm || [];
  for (const addr of swarm) {
    let ma = multiaddr(addr);
    if (ma.protoCodes().includes(WEBSOCKET_STAR_PROTO_CODE)) {
      throw (0, import_err_code141.default)(new Error("websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779"), "ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED");
    }
    const maId = ma.getPeerId();
    if (maId && maId !== peerIdStr) {
      ma = ma.encapsulate(`/p2p/${peerIdStr}`);
    }
    addrs.push(ma);
  }
  return addrs;
};
var WEBSOCKET_STAR_PROTO_CODE = 479;
function createAddrs2({ network }) {
  async function addrs(options = {}) {
    const peers = [];
    const { libp2p } = await network.use(options);
    await libp2p.peerStore.forEach((peer) => {
      peers.push({
        id: peer.id,
        addrs: peer.addresses.map((mi) => mi.multiaddr)
      });
    });
    return peers;
  }
  return withTimeoutOption(addrs);
}
function createConnect2({ network }) {
  async function connect2(multiaddrOrPeerId, options = {}) {
    const { libp2p } = await network.use(options);
    await libp2p.dial(multiaddrOrPeerId, options);
  }
  return withTimeoutOption(connect2);
}
function createDisconnect2({ network }) {
  async function disconnect(addr, options = {}) {
    const { libp2p } = await network.use(options);
    await libp2p.hangUp(addr);
  }
  return withTimeoutOption(disconnect);
}
function createLocalAddrs2({ network }) {
  async function localAddrs(options = {}) {
    const { libp2p } = await network.use(options);
    return libp2p.getMultiaddrs();
  }
  return withTimeoutOption(localAddrs);
}
function createPeers3({ network }) {
  async function peers(options = {}) {
    const { libp2p } = await network.use(options);
    if (options.verbose) {
      const peers3 = [];
      for (const connection of libp2p.getConnections()) {
        const peer = {
          addr: connection.remoteAddr,
          peer: connection.remotePeer
        };
        if (options.verbose || options.direction) {
          peer.direction = connection.stat.direction;
        }
        if (options.verbose) {
          peer.muxer = connection.stat.multiplexer;
          peer.latency = "n/a";
          peer.streams = [];
        }
        peers3.push(peer);
      }
      return peers3;
    }
    const peers2 = /* @__PURE__ */ new Map();
    for (const connection of libp2p.getConnections()) {
      const peer = {
        addr: connection.remoteAddr,
        peer: connection.remotePeer
      };
      peers2.set(connection.remotePeer.toString(), peer);
    }
    return Array.from(peers2.values());
  }
  return withTimeoutOption(peers);
}
var SwarmAPI = class {
  /**
   * @param {object} config
   * @param {import('../../types').NetworkService} config.network
   */
  constructor({ network }) {
    this.addrs = createAddrs2({ network });
    this.connect = createConnect2({ network });
    this.disconnect = createDisconnect2({ network });
    this.localAddrs = createLocalAddrs2({ network });
    this.peers = createPeers3({ network });
  }
};
var basePacket = { success: true, time: 0, text: "" };
function createPing2({ network }) {
  async function* ping(peerId, options = {}) {
    const { libp2p } = await network.use();
    options.count = options.count || 10;
    const storedPeer = await libp2p.peerStore.get(peerId);
    let id = storedPeer && storedPeer.id;
    if (!id) {
      yield { ...basePacket, text: `Looking up peer ${peerId}` };
      const remotePeer = await libp2p.peerRouting.findPeer(peerId);
      id = remotePeer && remotePeer.id;
    }
    if (!id) {
      throw new Error("Peer was not found");
    }
    yield { ...basePacket, text: `PING ${id.toString()}` };
    let packetCount = 0;
    let totalTime = 0;
    for (let i2 = 0; i2 < options.count; i2++) {
      try {
        const time = await libp2p.ping(id);
        totalTime += time;
        packetCount++;
        yield { ...basePacket, time };
      } catch (err2) {
        yield { ...basePacket, success: false, text: err2.toString() };
      }
    }
    if (packetCount) {
      const average = totalTime / packetCount;
      yield { ...basePacket, text: `Average latency: ${average}ms` };
    }
  }
  return withTimeoutOption(ping);
}
var import_err_code142 = __toESM(require_err_code(), 1);
var IPNS_PREFIX2 = "/ipns/";
function toDHTKey(str) {
  if (str.startsWith(IPNS_PREFIX2)) {
    str = str.substring(IPNS_PREFIX2.length);
  }
  let buf2;
  if (str[0] === "1" || str[0] === "Q") {
    str = `z${str}`;
  }
  if (str[0] === "z") {
    buf2 = base58btc.decode(str);
  }
  if (str[0] === "k") {
    buf2 = base36.decode(str);
  }
  if (!buf2) {
    throw new Error("Could not parse string");
  }
  if (buf2[0] !== 1 && buf2[1] !== 114) {
    buf2 = concat([
      [1, 114],
      buf2
    ]);
  }
  if (buf2.length !== 40) {
    throw new Error("Incorrect length " + buf2.length);
  }
  return concat([
    fromString3(IPNS_PREFIX2),
    buf2.subarray(2)
  ]);
}
function createDht2({ network, repo, peerId }) {
  const { get: get3, put, findProvs, findPeer: findPeer2, provide, query } = {
    /**
     * @type {import('ipfs-core-types/src/dht').API<{}>["get"]}
     */
    async *get(key, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);
      if (libp2p.dht == null) {
        throw (0, import_err_code142.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.get(dhtKey, options);
    },
    /**
     * @type {import('ipfs-core-types/src/dht').API<{}>["put"]}
     */
    async *put(key, value2, options) {
      const { libp2p } = await use(network, peerId, options);
      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);
      if (libp2p.dht == null) {
        throw (0, import_err_code142.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.put(dhtKey, value2, options);
    },
    /**
     * @type {import('ipfs-core-types/src/dht').API<{}>["findProvs"]}
     */
    async *findProvs(cid, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      if (libp2p.dht == null) {
        throw (0, import_err_code142.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.findProviders(cid, {
        signal: options.signal
      });
    },
    /**
     * @type {import('ipfs-core-types/src/dht').API<{}>["findPeer"]}
     */
    async *findPeer(peerIdToFind, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      if (libp2p.dht == null) {
        throw (0, import_err_code142.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.findPeer(peerIdToFind, {
        signal: options.signal
      });
    },
    /**
     * @type {import('ipfs-core-types/src/dht').API<{}>["provide"]}
     */
    async *provide(cid, options = { recursive: false }) {
      const { libp2p } = await use(network, peerId, options);
      const hasBlock = await repo.blocks.has(cid);
      if (!hasBlock) {
        throw (0, import_err_code142.default)(new Error("block(s) not found locally, cannot provide"), "ERR_BLOCK_NOT_FOUND");
      }
      if (options.recursive) {
        throw (0, import_err_code142.default)(new Error("not implemented yet"), "ERR_NOT_IMPLEMENTED_YET");
      }
      if (libp2p.dht == null) {
        throw (0, import_err_code142.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.provide(cid);
    },
    /**
     * @type {import('ipfs-core-types/src/dht').API<{}>["query"]}
     */
    async *query(peerIdToQuery, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      let bytes2;
      const asCid = CID.asCID(peerIdToQuery);
      if (asCid != null) {
        bytes2 = asCid.multihash.bytes;
      } else {
        bytes2 = peerIdFromString(peerIdToQuery.toString()).toBytes();
      }
      if (libp2p.dht == null) {
        throw (0, import_err_code142.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.getClosestPeers(bytes2, options);
    }
  };
  return {
    get: withTimeoutOption(get3),
    put: withTimeoutOption(put),
    findProvs: withTimeoutOption(findProvs),
    findPeer: withTimeoutOption(findPeer2),
    provide: withTimeoutOption(provide),
    query: withTimeoutOption(query)
  };
}
var use = async (network, peerId, options) => {
  const net = await network.use(options);
  if (net.libp2p.dht != null) {
    return net;
  } else {
    const fn = async function* () {
      yield {
        from: peerId,
        name: "QUERY_ERROR",
        type: 3,
        error: new NotEnabledError("dht not enabled")
      };
    };
    return {
      libp2p: {
        dht: {
          // @ts-expect-error incomplete implementation
          get: fn,
          // @ts-expect-error incomplete implementation
          put: fn,
          // @ts-expect-error incomplete implementation
          findProviders: fn,
          // @ts-expect-error incomplete implementation
          findPeer: fn,
          // @ts-expect-error incomplete implementation
          provide: fn,
          // @ts-expect-error incomplete implementation
          getClosestPeers: fn
        }
      }
    };
  }
};
var import_err_code143 = __toESM(require_err_code(), 1);
function createPubsub3({ network, config: config2 }) {
  const isEnabled = dlv_es_default(config2 || {}, "Pubsub.Enabled", true);
  const handlers = {};
  let onMessage;
  return {
    subscribe: isEnabled ? withTimeoutOption(subscribe) : notEnabled,
    unsubscribe: isEnabled ? withTimeoutOption(unsubscribe) : notEnabled,
    publish: isEnabled ? withTimeoutOption(publish) : notEnabled,
    ls: isEnabled ? withTimeoutOption(ls) : notEnabled,
    peers: isEnabled ? withTimeoutOption(peers) : notEnabled
  };
  async function subscribe(topic, handler, options = {}) {
    const { libp2p } = await network.use(options);
    libp2p.pubsub.subscribe(topic);
    if (onMessage == null) {
      onMessage = (evt) => {
        const msg = evt.detail;
        if (handlers[msg.topic]) {
          handlers[msg.topic].forEach((handler2) => {
            if (typeof handler2 === "function") {
              handler2(msg);
              return;
            }
            if (handler2 != null && handler2.handleEvent != null) {
              handler2.handleEvent(msg);
            }
          });
        }
      };
      libp2p.pubsub.addEventListener("message", onMessage);
    }
    if (handler != null) {
      if (handlers[topic] == null) {
        handlers[topic] = [];
      }
      handlers[topic].push(handler);
    }
  }
  async function unsubscribe(topic, handler, options = {}) {
    const { libp2p } = await network.use(options);
    if (handler != null && handlers[topic] != null) {
      handlers[topic] = handlers[topic].filter((h) => h !== handler);
      if (handlers[topic].length === 0) {
        delete handlers[topic];
      }
    }
    if (typeof handler !== "function") {
      delete handlers[topic];
    }
    if (handlers[topic] == null) {
      libp2p.pubsub.unsubscribe(topic);
    }
    if (Object.keys(handlers).length === 0) {
      libp2p.pubsub.removeEventListener("message", onMessage);
      onMessage = void 0;
    }
  }
  async function publish(topic, data, options = {}) {
    const { libp2p } = await network.use(options);
    if (!data) {
      throw (0, import_err_code143.default)(new Error('argument "data" is required'), "ERR_ARG_REQUIRED");
    }
    await libp2p.pubsub.publish(topic, data);
  }
  async function ls(options = {}) {
    const { libp2p } = await network.use(options);
    return libp2p.pubsub.getTopics();
  }
  async function peers(topic, options = {}) {
    const { libp2p } = await network.use(options);
    return libp2p.pubsub.getSubscribers(topic);
  }
}
var notEnabled = async () => {
  throw new NotEnabledError("pubsub not enabled");
};
var mergeOptions16 = merge_options_default.bind({ ignoreUndefined: true });
var log106 = logger("ipfs");
var IPNS_INIT_KEYSPACE_TIMEOUT = 3e4;
var IPFS2 = class {
  /**
   * @param {object} config
   * @param {Print} config.print
   * @param {Storage} config.storage
   * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs
   * @param {Options} config.options
   */
  constructor({ print, storage, codecs: codecs2, options }) {
    const { peerId, repo, keychain } = storage;
    const network = Service.create(Network3);
    const preload2 = createPreloader(options.preload);
    const dns = createDns();
    const isOnline = createIsOnline({ network });
    const ipns = new IPNSAPI(options);
    const multihashHashers = Object.values(hashes);
    (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach((hasher) => multihashHashers.push(hasher));
    this.hashers = new Multihashes({
      hashers: multihashHashers,
      loadHasher: options.ipld && options.ipld.loadHasher
    });
    const multibaseCodecs = Object.values(bases);
    (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach((base3) => multibaseCodecs.push(base3));
    this.bases = new Multibases({
      bases: multibaseCodecs,
      loadBase: options.ipld && options.ipld.loadBase
    });
    const pin = new PinAPI({ repo, codecs: codecs2 });
    const block = new BlockAPI({ codecs: codecs2, hashers: this.hashers, preload: preload2, repo });
    const name9 = new NameAPI({
      dns,
      ipns,
      repo,
      codecs: codecs2,
      peerId,
      isOnline,
      keychain,
      options
    });
    const resolve7 = createResolve({ repo, codecs: codecs2, bases: this.bases, name: name9 });
    const dag = new DagAPI({ repo, codecs: codecs2, hashers: this.hashers, preload: preload2 });
    const refs = Object.assign(createRefs({ repo, codecs: codecs2, resolve: resolve7, preload: preload2 }), {
      local: createLocal({ repo: storage.repo })
    });
    const { add, addAll, cat, get: get3, ls } = new RootAPI({
      preload: preload2,
      repo,
      options: options.EXPERIMENTAL,
      hashers: this.hashers
    });
    const files = createFiles({
      repo,
      preload: preload2,
      hashers: this.hashers,
      options
    });
    const mfsPreload = createMfsPreloader({
      files,
      preload: preload2,
      options: options.preload
    });
    this.preload = preload2;
    this.name = name9;
    this.ipns = ipns;
    this.pin = pin;
    this.resolve = resolve7;
    this.block = block;
    this.refs = refs;
    this.start = createStart({
      network,
      peerId,
      repo,
      preload: preload2,
      ipns,
      mfsPreload,
      print,
      keychain,
      hashers: this.hashers,
      options
    });
    this.stop = createStop({
      network,
      preload: preload2,
      mfsPreload,
      ipns,
      repo
    });
    this.dht = createDht2({ network, repo, peerId });
    this.pubsub = createPubsub3({ network, config: options.config });
    this.dns = dns;
    this.isOnline = isOnline;
    this.id = createId({ network, peerId });
    this.version = createVersion({ repo });
    this.bitswap = new BitswapAPI({ network });
    this.bootstrap = new BootstrapAPI({ repo });
    this.config = createConfig({ repo });
    this.ping = createPing2({ network });
    this.add = add;
    this.addAll = addAll;
    this.cat = cat;
    this.get = get3;
    this.ls = ls;
    this.dag = dag;
    this.files = files;
    this.key = new KeyAPI({ keychain });
    this.object = new ObjectAPI({ preload: preload2, codecs: codecs2, repo });
    this.repo = new RepoAPI({ repo, hashers: this.hashers });
    this.stats = new StatsAPI({ repo, network });
    this.swarm = new SwarmAPI({ network });
    Object.defineProperty(this, "libp2p", {
      get() {
        const net = network.try();
        return net ? net.libp2p : void 0;
      }
    });
    const notImplemented = () => Promise.reject((0, import_err_code144.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED"));
    const notImplementedIter = async function* () {
      throw (0, import_err_code144.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
    };
    this.commands = notImplemented;
    this.diag = {
      cmds: notImplemented,
      net: notImplemented,
      sys: notImplemented
    };
    this.log = {
      level: notImplemented,
      ls: notImplemented,
      tail: notImplementedIter
    };
    this.mount = notImplemented;
    this.codecs = codecs2;
  }
  /**
   * `IPFS.create` will do the initialization. Keep this around for backwards
   * compatibility.
   *
   * @deprecated
   */
  async init() {
    throw new AlreadyInitializedError();
  }
};
var addEmptyDir2 = async (ipfs2) => {
  const buf2 = encode$1({
    Data: new UnixFS({ type: "directory" }).marshal(),
    Links: []
  });
  const cid = await ipfs2.block.put(buf2, {
    mhtype: "sha2-256",
    format: "dag-pb"
  });
  await ipfs2.pin.add(cid);
  return cid;
};
var getDefaultOptions = () => ({
  start: true,
  EXPERIMENTAL: {},
  preload: {
    enabled: !import_env2.isTest,
    // preload by default, unless in test env
    addresses: [
      "/dns4/node0.preload.ipfs.io/https",
      "/dns4/node1.preload.ipfs.io/https",
      "/dns4/node2.preload.ipfs.io/https",
      "/dns4/node3.preload.ipfs.io/https"
    ]
  }
});
async function create8(options = {}) {
  options = mergeOptions16(getDefaultOptions(), options);
  const initOptions = options.init || {};
  const id = {
    name: identity.name,
    code: identity.code,
    encode: (id2) => id2,
    decode: (id2) => id2
  };
  const blockCodecs = Object.values(codecs);
  [src_exports, src_exports2, src_exports3, lib_exports, id].concat(options.ipld && options.ipld.codecs || []).forEach((codec) => blockCodecs.push(codec));
  const multicodecs = new Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  });
  const print = options.silent ? log106 : console.log;
  log106("creating repo");
  const storage = await Storage.start(print, multicodecs, options);
  log106("getting repo config");
  const config2 = await storage.repo.config.getAll();
  const ipfs2 = new IPFS2({
    storage,
    print,
    codecs: multicodecs,
    options: { ...options, config: config2 }
  });
  log106("starting preload");
  await ipfs2.preload.start();
  log106("starting storage");
  ipfs2.ipns.startOffline(storage);
  if (storage.isNew && !initOptions.emptyRepo) {
    const cid = await addEmptyDir2(ipfs2);
    log106("adding default assets");
    await initAssets({ addAll: ipfs2.addAll, print });
    log106("initializing IPNS keyspace");
    if (storage.peerId.publicKey == null) {
      throw (0, import_err_code144.default)(new Error("Public key missing"), "ERR_MISSING_PUBLIC_KEY");
    }
    const timeoutController = new import_timeout_abort_controller18.TimeoutController(IPNS_INIT_KEYSPACE_TIMEOUT);
    try {
      await ipfs2.ipns.initializeKeyspace(storage.peerId, fromString3(`/ipfs/${cid}`), {
        signal: timeoutController.signal
      });
    } finally {
      timeoutController.clear();
    }
  }
  if (options.start !== false) {
    log106("starting node");
    await ipfs2.start();
  }
  return ipfs2;
}
var import_glob_source2 = __toESM(require_glob_source());
var import_url_source2 = __toESM(require_url_source());
var create9 = create8;
import_glob_source2.default;
import_url_source2.default;
/*! Bundled license information:

bytes/index.js:
  (*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   *)

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

run-parallel-limit/index.js:
  (*! run-parallel-limit. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@noble/secp256k1/lib/esm/index.js:
  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)

@noble/ed25519/lib/esm/index.js:
  (*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)
*/
var require_browser = __commonJS({
  "node_modules/form-data/lib/browser.js"(exports2, module2) {
    module2.exports = typeof self == "object" ? self.FormData : window.FormData;
  }
});
function bind(fn, thisArg) {
  return function wrap2() {
    return fn.apply(thisArg, arguments);
  };
}
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache3) => (thing) => {
  const str = toString.call(thing);
  return cache3[str] || (cache3[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  const pattern = "[object FormData]";
  return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i2 = 0, l = obj.length; i2 < l; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys[i2];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i2 = keys.length;
  let _key;
  while (i2-- > 0) {
    _key = keys[i2];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : globalThis;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l = arguments.length; i2 < l; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter22, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter22 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter22 || filter22(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i2 = thing.length;
  if (!isNumber(i2))
    return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair2 = result.value;
    fn.call(obj, pair2[0], pair2[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[_-\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name9) => {
    if (reducer(descriptor, name9, obj) !== false) {
      reducedDescriptors[name9] = descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name9) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name9) !== -1) {
      return false;
    }
    const value2 = obj[name9];
    if (!isFunction(value2))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name9 + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value2) => {
      obj[value2] = true;
    });
  };
  isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value2, defaultValue) => {
  value2 = +value2;
  return Number.isFinite(value2) ? value2 : defaultValue;
};
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i2) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i2] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value2, key) => {
          const reducedValue = visit(value2, i2 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  globalThis: _global,
  isContextDefined,
  toJSONObject
};
function AxiosError(message2, code8, config2, request2, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message2;
  this.name = "AxiosError";
  code8 && (this.code = code8);
  config2 && (this.config = config2);
  request2 && (this.request = request2);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code8) => {
  descriptors[code8] = { value: code8 };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code8, config2, request2, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter22(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code8, config2, request2, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;
var import_form_data = __toESM(require_browser(), 1);
var FormData_default = import_form_data.default;
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2)
    return key;
  return path2.concat(key).map(function each(token, i2) {
    token = removeBrackets(token);
    return !dots && i2 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter3(prop) {
  return /^is[A-Z]/.test(prop);
});
function isSpecCompliant(thing) {
  return thing && utils_default.isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator];
}
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && isSpecCompliant(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value2) {
    if (value2 === null)
      return "";
    if (utils_default.isDate(value2)) {
      return value2.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value2)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value2) || utils_default.isTypedArray(value2)) {
      return useBlob && typeof Blob === "function" ? new Blob([value2]) : Buffer.from(value2);
    }
    return value2;
  }
  function defaultVisitor(value2, key, path2) {
    let arr = value2;
    if (value2 && !path2 && typeof value2 === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value2 = JSON.stringify(value2);
      } else if (utils_default.isArray(value2) && isFlatArray(value2) || (utils_default.isFileList(value2) || utils_default.endsWith(key, "[]") && (arr = utils_default.toArray(value2)))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index2) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value2)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value2));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value2, path2) {
    if (utils_default.isUndefined(value2))
      return;
    if (stack.indexOf(value2) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value2);
    utils_default.forEach(value2, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name9, value2) {
  this._pairs.push([name9, value2]);
};
prototype2.toString = function toString22(encoder2) {
  const _encode = encoder2 ? function(value2) {
    return encoder2.call(this, value2, encode);
  } : encode;
  return this._pairs.map(function each(pair2) {
    return _encode(pair2[0]) + "=" + _encode(pair2[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;
function encode2$1(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode2$1;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;
var FormData_default2 = FormData;
var isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
var isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default2,
    Blob
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new browser_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value2, key, path2, helpers) {
      if (browser_default.isNode && utils_default.isBuffer(value2)) {
        this.append(key, value2.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name9) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name9).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i2;
  const len = keys.length;
  let key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys[i2];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value2, target, index2) {
    let name9 = path2[index2++];
    const isNumericKey = Number.isFinite(+name9);
    const isLast = index2 >= path2.length;
    name9 = !name9 && utils_default.isArray(target) ? target.length : name9;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name9)) {
        target[name9] = [target[name9], value2];
      } else {
        target[name9] = value2;
      }
      return !isNumericKey;
    }
    if (!target[name9] || !utils_default.isObject(target[name9])) {
      target[name9] = [];
    }
    const result = buildPath(path2, value2, target[name9], index2);
    if (result && utils_default.isArray(target[name9])) {
      target[name9] = arrayToObject(target[name9]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name9, value2) => {
      buildPath(parsePropPath(name9), value2, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0
};
function stringifySafely(rawValue, parser2, encoder2) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser2 || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder2 || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: browser_default.classes.FormData,
    Blob: browser_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils_default.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults.headers[method] = utils_default.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_default = defaults;
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser2(line) {
    i2 = line.indexOf(":");
    key = line.substring(0, i2).trim().toLowerCase();
    val = line.substring(i2 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value2) {
  if (value2 === false || value2 == null) {
    return value2;
  }
  return utils_default.isArray(value2) ? value2.map(normalizeValue) : String(value2);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
function isValidHeaderName(str) {
  return /^[-_a-zA-Z]+$/.test(str.trim());
}
function matchHeaderValue(context, value2, header, filter22) {
  if (utils_default.isFunction(filter22)) {
    return filter22.call(this, value2, header);
  }
  if (!utils_default.isString(value2))
    return;
  if (utils_default.isString(filter22)) {
    return value2.indexOf(filter22) !== -1;
  }
  if (utils_default.isRegExp(filter22)) {
    return filter22.test(value2);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders2 = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders2(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders2(parseHeaders_default(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser2) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value2 = this[key];
        if (!parser2) {
          return value2;
        }
        if (parser2 === true) {
          return parseTokens(value2);
        }
        if (utils_default.isFunction(parser2)) {
          return parser2.call(this, value2, key);
        }
        if (utils_default.isRegExp(parser2)) {
          return parser2.exec(value2);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear() {
    return Object.keys(this).forEach(this.delete.bind(this));
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value2, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value2);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value2);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value2, header) => {
      value2 != null && value2 !== false && (obj[header] = asStrings && utils_default.isArray(value2) ? value2.join(", ") : value2);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value2]) => header + ": " + value2).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first2, ...targets) {
    const computed = new this(first2);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent"]);
utils_default.freezeMethods(AxiosHeaders.prototype);
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;
function transformData(fns, response) {
  const config2 = this || defaults_default;
  const context = response || config2;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value2) {
  return !!(value2 && value2.__CANCEL__);
}
function CanceledError(message2, config2, request2) {
  AxiosError_default.call(this, message2 == null ? "canceled" : message2, AxiosError_default.ERR_CANCELED, config2, request2);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;
var null_default = null;
function settle(resolve7, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve7(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
var cookies_default = browser_default.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write3(name9, value2, expires, path2, domain, secure) {
        const cookie = [];
        cookie.push(name9 + "=" + encodeURIComponent(value2));
        if (utils_default.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils_default.isString(path2)) {
          cookie.push("path=" + path2);
        }
        if (utils_default.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read2(name9) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name9 + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name9) {
        this.write(name9, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write3() {
      },
      read: function read2() {
        return null;
      },
      remove: function remove() {
      }
    };
  }()
);
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
var isURLSameOrigin_default = browser_default.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv2() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url2) {
      let href = url2;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv2() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve7, reject) {
    let requestData = config2.data;
    const requestHeaders = AxiosHeaders_default.from(config2.headers).normalize();
    const responseType = config2.responseType;
    let onCanceled;
    function done() {
      if (config2.cancelToken) {
        config2.cancelToken.unsubscribe(onCanceled);
      }
      if (config2.signal) {
        config2.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils_default.isFormData(requestData) && (browser_default.isStandardBrowserEnv || browser_default.isStandardBrowserWebWorkerEnv)) {
      requestHeaders.setContentType(false);
    }
    let request2 = new XMLHttpRequest();
    if (config2.auth) {
      const username = config2.auth.username || "";
      const password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    request2.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
    request2.timeout = config2.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config: config2,
        request: request2
      };
      settle(function _resolve(value2) {
        resolve7(value2);
        done();
      }, function _reject(err2) {
        reject(err2);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config2, request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config2, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config2.transitional || transitional_default;
      if (config2.timeoutErrorMessage) {
        timeoutErrorMessage = config2.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config2,
        request2
      ));
      request2 = null;
    };
    if (browser_default.isStandardBrowserEnv) {
      const xsrfValue = (config2.withCredentials || isURLSameOrigin_default(fullPath)) && config2.xsrfCookieName && cookies_default.read(config2.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config2.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config2.withCredentials)) {
      request2.withCredentials = !!config2.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = config2.responseType;
    }
    if (typeof config2.onDownloadProgress === "function") {
      request2.addEventListener("progress", progressEventReducer(config2.onDownloadProgress, true));
    }
    if (typeof config2.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", progressEventReducer(config2.onUploadProgress));
    }
    if (config2.cancelToken || config2.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config2, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
      if (config2.signal) {
        config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol2 = parseProtocol(fullPath);
    if (protocol2 && browser_default.protocols.indexOf(protocol2) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol2 + ":", AxiosError_default.ERR_BAD_REQUEST, config2));
      return;
    }
    request2.send(requestData || null);
  });
};
var knownAdapters = {
  http: null_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value2) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value: value2 });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value: value2 });
  }
});
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length: length3 } = adapters;
    let nameOrAdapter;
    let adapter;
    for (let i2 = 0; i2 < length3; i2++) {
      nameOrAdapter = adapters[i2];
      if (adapter = utils_default.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError_default(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          "ERR_NOT_SUPPORT"
        );
      }
      throw new Error(
        utils_default.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
      );
    }
    if (!utils_default.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError_default(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders_default.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config2.adapter || defaults_default.adapter);
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils_default.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    const merge22 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge22(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge22 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}
var VERSION = "1.2.4";
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version3, message2) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
  }
  return (value2, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version3 ? " in " + version3 : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version3 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version3 + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value2, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i2 = keys.length;
  while (i2-- > 0) {
    const opt = keys[i2];
    const validator = schema[opt];
    if (validator) {
      const value2 = options[opt];
      const result = value2 === void 0 || validator(value2, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer !== void 0) {
      validator_default.assertOptions(paramsSerializer, {
        encode: validators2.function,
        serialize: validators2.function
      }, true);
    }
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders;
    contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config2.method]
    );
    contextHeaders && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i2 < len) {
        promise = promise.then(chain[i2++], chain[i2++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i2 = 0;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios.prototype[method] = function(url2, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url: url2,
      data: (config2 || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;
var CancelToken = class {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve7) {
      resolvePromise = resolve7;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i2 = token._listeners.length;
      while (i2-- > 0) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve7) => {
        token.subscribe(resolve7);
        _resolve = resolve7;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message2, config2, request2) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message2, config2, request2);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;
function spread(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value2]) => {
  HttpStatusCode[value2] = key;
});
var HttpStatusCode_default = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create5(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all3(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports2, module2) {
    (function(nacl2) {
      var gf = function(init) {
        var i2, r = new Float64Array(16);
        if (init)
          for (i2 = 0; i2 < init.length; i2++)
            r[i2] = init[i2];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i2, h, l) {
        x[i2] = h >> 24 & 255;
        x[i2 + 1] = h >> 16 & 255;
        x[i2 + 2] = h >> 8 & 255;
        x[i2 + 3] = h & 255;
        x[i2 + 4] = l >> 24 & 255;
        x[i2 + 5] = l >> 16 & 255;
        x[i2 + 6] = l >> 8 & 255;
        x[i2 + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i2, d = 0;
        for (i2 = 0; i2 < n; i2++)
          d |= x[xi + i2] ^ y[yi + i2];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i2;
        for (i2 = 0; i2 < 16; i2++)
          z[i2] = 0;
        for (i2 = 0; i2 < 8; i2++)
          z[i2] = n[i2];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i2 = 0; i2 < 64; i2++)
            c[cpos + i2] = m[mpos + i2] ^ x[i2];
          u = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u = u + (z[i2] & 255) | 0;
            z[i2] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i2 = 0; i2 < b; i2++)
            c[cpos + i2] = m[mpos + i2] ^ x[i2];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i2;
        for (i2 = 0; i2 < 16; i2++)
          z[i2] = 0;
        for (i2 = 0; i2 < 8; i2++)
          z[i2] = n[i2];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i2 = 0; i2 < 64; i2++)
            c[cpos + i2] = x[i2];
          u = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u = u + (z[i2] & 255) | 0;
            z[i2] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i2 = 0; i2 < b; i2++)
            c[cpos + i2] = x[i2];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++)
          sn[i2] = n[i2 + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++)
          sn[i2] = n[i2 + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d32, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d32 = c;
          d32 += h0 * r3;
          d32 += h1 * r2;
          d32 += h2 * r1;
          d32 += h3 * r0;
          d32 += h4 * (5 * r9);
          c = d32 >>> 13;
          d32 &= 8191;
          d32 += h5 * (5 * r8);
          d32 += h6 * (5 * r7);
          d32 += h7 * (5 * r6);
          d32 += h8 * (5 * r5);
          d32 += h9 * (5 * r4);
          c += d32 >>> 13;
          d32 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d32;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i2;
        if (this.leftover) {
          i2 = this.leftover;
          this.buffer[i2++] = 1;
          for (; i2 < 16; i2++)
            this.buffer[i2] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i2 = 2; i2 < 10; i2++) {
          this.h[i2] += c;
          c = this.h[i2] >>> 13;
          this.h[i2] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i2 = 1; i2 < 10; i2++) {
          g[i2] = this.h[i2] + c;
          c = g[i2] >>> 13;
          g[i2] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i2 = 0; i2 < 10; i2++)
          g[i2] &= mask;
        mask = ~mask;
        for (i2 = 0; i2 < 10; i2++)
          this.h[i2] = this.h[i2] & mask | g[i2];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i2 = 1; i2 < 8; i2++) {
          f = (this.h[i2] + this.pad[i2] | 0) + (f >>> 16) | 0;
          this.h[i2] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i2, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i2 = 0; i2 < want; i2++)
            this.buffer[this.leftover + i2] = m[mpos + i2];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i2 = 0; i2 < bytes; i2++)
            this.buffer[this.leftover + i2] = m[mpos + i2];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i2;
        if (d < 32)
          return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i2 = 0; i2 < 16; i2++)
          c[i2] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i2;
        var x = new Uint8Array(32);
        if (d < 32)
          return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
          return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i2 = 0; i2 < 32; i2++)
          m[i2] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i2;
        for (i2 = 0; i2 < 16; i2++)
          r[i2] = a[i2] | 0;
      }
      function car25519(o) {
        var i2, v, c = 1;
        for (i2 = 0; i2 < 16; i2++) {
          v = o[i2] + c + 65535;
          c = Math.floor(v / 65536);
          o[i2] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i2 = 0; i2 < 16; i2++) {
          t = c & (p[i2] ^ q[i2]);
          p[i2] ^= t;
          q[i2] ^= t;
        }
      }
      function pack25519(o, n) {
        var i2, j, b;
        var m = gf(), t = gf();
        for (i2 = 0; i2 < 16; i2++)
          t[i2] = n[i2];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i2 = 1; i2 < 15; i2++) {
            m[i2] = t[i2] - 65535 - (m[i2 - 1] >> 16 & 1);
            m[i2 - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i2 = 0; i2 < 16; i2++) {
          o[2 * i2] = t[i2] & 255;
          o[2 * i2 + 1] = t[i2] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i2;
        for (i2 = 0; i2 < 16; i2++)
          o[i2] = n[2 * i2] + (n[2 * i2 + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i2 = 0; i2 < 16; i2++)
          o[i2] = a[i2] + b[i2];
      }
      function Z(o, a, b) {
        for (var i2 = 0; i2 < 16; i2++)
          o[i2] = a[i2] - b[i2];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i2) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i2[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4)
            M(c, c, i2);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function pow2523(o, i2) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i2[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1)
            M(c, c, i2);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i2;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i2 = 0; i2 < 31; i2++)
          z[i2] = n[i2];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i2 = 0; i2 < 16; i2++) {
          b[i2] = x[i2];
          d[i2] = a[i2] = c[i2] = 0;
        }
        a[0] = d[0] = 1;
        for (i2 = 254; i2 >= 0; --i2) {
          r = z[i2 >>> 3] >>> (i2 & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i2 = 0; i2 < 16; i2++) {
          x[i2 + 16] = a[i2];
          x[i2 + 32] = c[i2];
          x[i2 + 48] = b[i2];
          x[i2 + 64] = d[i2];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K2 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i2, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i2 = 0; i2 < 16; i2++) {
            j = 8 * i2 + pos;
            wh[i2] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i2] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i2 = 0; i2 < 80; i2++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K2[i2 * 2];
            l = K2[i2 * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i2 % 16];
            l = wl[i2 % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i2 % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i2, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i2 = 0; i2 < n; i2++)
          x[i2] = m[b - n + i2];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i2 = 0; i2 < 8; i2++)
          ts64(out, 8 * i2, hh[i2], hl[i2]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i2;
        for (i2 = 0; i2 < 4; i2++) {
          sel25519(p[i2], q[i2], b);
        }
      }
      function pack2(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i2;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i2 = 255; i2 >= 0; --i2) {
          b = s[i2 / 8 | 0] >> (i2 & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i2;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack2(pk, p);
        for (i2 = 0; i2 < 32; i2++)
          sk[i2 + 32] = pk[i2];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i2, j, k;
        for (i2 = 63; i2 >= 32; --i2) {
          carry = 0;
          for (j = i2 - 32, k = i2 - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i2] * L[j - (i2 - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i2] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++)
          x[j] -= carry * L[j];
        for (i2 = 0; i2 < 32; i2++) {
          x[i2 + 1] += x[i2] >> 8;
          r[i2] = x[i2] & 255;
        }
      }
      function reduce2(r) {
        var x = new Float64Array(64), i2;
        for (i2 = 0; i2 < 64; i2++)
          x[i2] = r[i2];
        for (i2 = 0; i2 < 64; i2++)
          r[i2] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i2, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i2 = 0; i2 < n; i2++)
          sm[64 + i2] = m[i2];
        for (i2 = 0; i2 < 32; i2++)
          sm[32 + i2] = d[32 + i2];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce2(r);
        scalarbase(p, r);
        pack2(sm, p);
        for (i2 = 32; i2 < 64; i2++)
          sm[i2] = sk[i2];
        crypto_hash(h, sm, n + 64);
        reduce2(h);
        for (i2 = 0; i2 < 64; i2++)
          x[i2] = 0;
        for (i2 = 0; i2 < 32; i2++)
          x[i2] = r[i2];
        for (i2 = 0; i2 < 32; i2++) {
          for (j = 0; j < 32; j++) {
            x[i2 + j] += h[i2] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r[0]) === p[31] >> 7)
          Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i2;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64)
          return -1;
        if (unpackneg(q, pk))
          return -1;
        for (i2 = 0; i2 < n; i2++)
          m[i2] = sm[i2];
        for (i2 = 0; i2 < 32; i2++)
          m[i2 + 32] = pk[i2];
        crypto_hash(h, m, n);
        reduce2(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack2(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i2 = 0; i2 < n; i2++)
            m[i2] = 0;
          return -1;
        }
        for (i2 = 0; i2 < n; i2++)
          m[i2] = sm[i2 + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl2.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L,
        pack25519,
        unpack25519,
        M,
        A,
        S,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i2 = 0; i2 < arguments.length; i2++) {
          if (!(arguments[i2] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i2 = 0; i2 < arr.length; i2++)
          arr[i2] = 0;
      }
      nacl2.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl2.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i2 = 0; i2 < msg.length; i2++)
          m[i2 + crypto_secretbox_ZEROBYTES] = msg[i2];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl2.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i2 = 0; i2 < box.length; i2++)
          c[i2 + crypto_secretbox_BOXZEROBYTES] = box[i2];
        if (c.length < 32)
          return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
          return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl2.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl2.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl2.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl2.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl2.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl2.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl2.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl2.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox(msg, nonce, k);
      };
      nacl2.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl2.box.after = nacl2.secretbox;
      nacl2.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox.open(msg, nonce, k);
      };
      nacl2.box.open.after = nacl2.secretbox.open;
      nacl2.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl2.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl2.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl2.box.nonceLength = crypto_box_NONCEBYTES;
      nacl2.box.overheadLength = nacl2.secretbox.overheadLength;
      nacl2.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl2.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m = new Uint8Array(mlen);
        for (var i2 = 0; i2 < m.length; i2++)
          m[i2] = tmp[i2];
        return m;
      };
      nacl2.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl2.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i2 = 0; i2 < sig.length; i2++)
          sig[i2] = signedMsg[i2];
        return sig;
      };
      nacl2.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i2;
        for (i2 = 0; i2 < crypto_sign_BYTES; i2++)
          sm[i2] = sig[i2];
        for (i2 = 0; i2 < msg.length; i2++)
          sm[i2 + crypto_sign_BYTES] = msg[i2];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl2.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i2 = 0; i2 < pk.length; i2++)
          pk[i2] = secretKey[32 + i2];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.sign.keyPair.fromSeed = function(seed2) {
        checkArrayTypes(seed2);
        if (seed2.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i2 = 0; i2 < 32; i2++)
          sk[i2] = seed2[i2];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl2.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl2.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl2.sign.signatureLength = crypto_sign_BYTES;
      nacl2.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl2.hash.hashLength = crypto_hash_BYTES;
      nacl2.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0)
          return false;
        if (x.length !== y.length)
          return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl2.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto22 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto22 && crypto22.getRandomValues) {
          var QUOTA = 65536;
          nacl2.setPRNG(function(x, n) {
            var i2, v = new Uint8Array(n);
            for (i2 = 0; i2 < n; i2 += QUOTA) {
              crypto22.getRandomValues(v.subarray(i2, i2 + Math.min(n - i2, QUOTA)));
            }
            for (i2 = 0; i2 < n; i2++)
              x[i2] = v[i2];
            cleanup(v);
          });
        } else if (typeof __require !== "undefined") {
          crypto22 = require_crypto();
          if (crypto22 && crypto22.randomBytes) {
            nacl2.setPRNG(function(x, n) {
              var i2, v = crypto22.randomBytes(n);
              for (i2 = 0; i2 < n; i2++)
                x[i2] = v[i2];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module2 !== "undefined" && module2.exports ? module2.exports : self.nacl = self.nacl || {});
  }
});
var require_sha512 = __commonJS({
  "node_modules/js-sha512/src/sha512.js"(exports2, module2) {
    (function() {
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root2 = WINDOW ? window : {};
      if (root2.JS_SHA512_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root2.JS_SHA512_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root2 = globalThis;
      } else if (WEB_WORKER) {
        root2 = self;
      }
      var COMMON_JS = !root2.JS_SHA512_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root2.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA2 = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K2 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      if (root2.JS_SHA512_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root2.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(outputType, bits2) {
        return function(message2) {
          return new Sha512(bits2, true).update(message2)[outputType]();
        };
      };
      var createMethod = function(bits2) {
        var method = createOutputMethod("hex", bits2);
        method.create = function() {
          return new Sha512(bits2);
        };
        method.update = function(message2) {
          return method.create().update(message2);
        };
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createOutputMethod(type, bits2);
        }
        return method;
      };
      var createHmacOutputMethod = function(outputType, bits2) {
        return function(key, message2) {
          return new HmacSha512(key, bits2, true).update(message2)[outputType]();
        };
      };
      var createHmacMethod = function(bits2) {
        var method = createHmacOutputMethod("hex", bits2);
        method.create = function(key) {
          return new HmacSha512(key, bits2);
        };
        method.update = function(key, message2) {
          return method.create(key).update(message2);
        };
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createHmacOutputMethod(type, bits2);
        }
        return method;
      };
      function Sha512(bits2, sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = blocks[16] = blocks[17] = blocks[18] = blocks[19] = blocks[20] = blocks[21] = blocks[22] = blocks[23] = blocks[24] = blocks[25] = blocks[26] = blocks[27] = blocks[28] = blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (bits2 == 384) {
          this.h0h = 3418070365;
          this.h0l = 3238371032;
          this.h1h = 1654270250;
          this.h1l = 914150663;
          this.h2h = 2438529370;
          this.h2l = 812702999;
          this.h3h = 355462360;
          this.h3l = 4144912697;
          this.h4h = 1731405415;
          this.h4l = 4290775857;
          this.h5h = 2394180231;
          this.h5l = 1750603025;
          this.h6h = 3675008525;
          this.h6l = 1694076839;
          this.h7h = 1203062813;
          this.h7l = 3204075428;
        } else if (bits2 == 256) {
          this.h0h = 573645204;
          this.h0l = 4230739756;
          this.h1h = 2673172387;
          this.h1l = 3360449730;
          this.h2h = 596883563;
          this.h2l = 1867755857;
          this.h3h = 2520282905;
          this.h3l = 1497426621;
          this.h4h = 2519219938;
          this.h4l = 2827943907;
          this.h5h = 3193839141;
          this.h5l = 1401305490;
          this.h6h = 721525244;
          this.h6l = 746961066;
          this.h7h = 246885852;
          this.h7l = 2177182882;
        } else if (bits2 == 224) {
          this.h0h = 2352822216;
          this.h0l = 424955298;
          this.h1h = 1944164710;
          this.h1l = 2312950998;
          this.h2h = 502970286;
          this.h2l = 855612546;
          this.h3h = 1738396948;
          this.h3l = 1479516111;
          this.h4h = 258812777;
          this.h4l = 2077511080;
          this.h5h = 2011393907;
          this.h5l = 79989058;
          this.h6h = 1067287976;
          this.h6l = 1780299464;
          this.h7h = 286451373;
          this.h7l = 2446758561;
        } else {
          this.h0h = 1779033703;
          this.h0l = 4089235720;
          this.h1h = 3144134277;
          this.h1l = 2227873595;
          this.h2h = 1013904242;
          this.h2l = 4271175723;
          this.h3h = 2773480762;
          this.h3l = 1595750129;
          this.h4h = 1359893119;
          this.h4l = 2917565137;
          this.h5h = 2600822924;
          this.h5l = 725511199;
          this.h6h = 528734635;
          this.h6l = 4215389547;
          this.h7h = 1541459225;
          this.h7l = 327033209;
        }
        this.bits = bits2;
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
      }
      Sha512.prototype.update = function(message2) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message2;
        if (type !== "string") {
          if (type === "object") {
            if (message2 === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message2.constructor === ArrayBuffer) {
              message2 = new Uint8Array(message2);
            } else if (!Array.isArray(message2)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message2)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var code8, index2 = 0, i2, length3 = message2.length, blocks2 = this.blocks;
        while (index2 < length3) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
          }
          if (notString) {
            for (i2 = this.start; index2 < length3 && i2 < 128; ++index2) {
              blocks2[i2 >> 2] |= message2[index2] << SHIFT[i2++ & 3];
            }
          } else {
            for (i2 = this.start; index2 < length3 && i2 < 128; ++index2) {
              code8 = message2.charCodeAt(index2);
              if (code8 < 128) {
                blocks2[i2 >> 2] |= code8 << SHIFT[i2++ & 3];
              } else if (code8 < 2048) {
                blocks2[i2 >> 2] |= (192 | code8 >> 6) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code8 & 63) << SHIFT[i2++ & 3];
              } else if (code8 < 55296 || code8 >= 57344) {
                blocks2[i2 >> 2] |= (224 | code8 >> 12) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code8 >> 6 & 63) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code8 & 63) << SHIFT[i2++ & 3];
              } else {
                code8 = 65536 + ((code8 & 1023) << 10 | message2.charCodeAt(++index2) & 1023);
                blocks2[i2 >> 2] |= (240 | code8 >> 18) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code8 >> 12 & 63) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code8 >> 6 & 63) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code8 & 63) << SHIFT[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          this.bytes += i2 - this.start;
          if (i2 >= 128) {
            this.block = blocks2[32];
            this.start = i2 - 128;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i2;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha512.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i2 = this.lastByteIndex;
        blocks2[32] = this.block;
        blocks2[i2 >> 2] |= EXTRA2[i2 & 3];
        this.block = blocks2[32];
        if (i2 >= 112) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
        }
        blocks2[30] = this.hBytes << 3 | this.bytes >>> 29;
        blocks2[31] = this.bytes << 3;
        this.hash();
      };
      Sha512.prototype.hash = function() {
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, blocks2 = this.blocks, j, s0h, s0l, s1h, s1l, c1, c2, c3, c4, abh, abl, dah, dal, cdh, cdl, bch, bcl, majh, majl, t1h, t1l, t2h, t2l, chh, chl;
        for (j = 32; j < 160; j += 2) {
          t1h = blocks2[j - 30];
          t1l = blocks2[j - 29];
          s0h = (t1h >>> 1 | t1l << 31) ^ (t1h >>> 8 | t1l << 24) ^ t1h >>> 7;
          s0l = (t1l >>> 1 | t1h << 31) ^ (t1l >>> 8 | t1h << 24) ^ (t1l >>> 7 | t1h << 25);
          t1h = blocks2[j - 4];
          t1l = blocks2[j - 3];
          s1h = (t1h >>> 19 | t1l << 13) ^ (t1l >>> 29 | t1h << 3) ^ t1h >>> 6;
          s1l = (t1l >>> 19 | t1h << 13) ^ (t1h >>> 29 | t1l << 3) ^ (t1l >>> 6 | t1h << 26);
          t1h = blocks2[j - 32];
          t1l = blocks2[j - 31];
          t2h = blocks2[j - 14];
          t2l = blocks2[j - 13];
          c1 = (t2l & 65535) + (t1l & 65535) + (s0l & 65535) + (s1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (s0h & 65535) + (s1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16);
          blocks2[j] = c4 << 16 | c3 & 65535;
          blocks2[j + 1] = c2 << 16 | c1 & 65535;
        }
        var ah = h0h, al = h0l, bh = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl = h3l, eh = h4h, el = h4l, fh = h5h, fl = h5l, gh = h6h, gl = h6l, hh = h7h, hl = h7l;
        bch = bh & ch;
        bcl = bl & cl;
        for (j = 0; j < 160; j += 8) {
          s0h = (ah >>> 28 | al << 4) ^ (al >>> 2 | ah << 30) ^ (al >>> 7 | ah << 25);
          s0l = (al >>> 28 | ah << 4) ^ (ah >>> 2 | al << 30) ^ (ah >>> 7 | al << 25);
          s1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (el >>> 9 | eh << 23);
          s1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (eh >>> 9 | el << 23);
          abh = ah & bh;
          abl = al & bl;
          majh = abh ^ ah & ch ^ bch;
          majl = abl ^ al & cl ^ bcl;
          chh = eh & fh ^ ~eh & gh;
          chl = el & fl ^ ~el & gl;
          t1h = blocks2[j];
          t1l = blocks2[j + 1];
          t2h = K2[j];
          t2l = K2[j + 1];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (hl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (hh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (dl & 65535) + (t1l & 65535);
          c2 = (dl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (dh & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (dh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          hh = c4 << 16 | c3 & 65535;
          hl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          dh = c4 << 16 | c3 & 65535;
          dl = c2 << 16 | c1 & 65535;
          s0h = (dh >>> 28 | dl << 4) ^ (dl >>> 2 | dh << 30) ^ (dl >>> 7 | dh << 25);
          s0l = (dl >>> 28 | dh << 4) ^ (dh >>> 2 | dl << 30) ^ (dh >>> 7 | dl << 25);
          s1h = (hh >>> 14 | hl << 18) ^ (hh >>> 18 | hl << 14) ^ (hl >>> 9 | hh << 23);
          s1l = (hl >>> 14 | hh << 18) ^ (hl >>> 18 | hh << 14) ^ (hh >>> 9 | hl << 23);
          dah = dh & ah;
          dal = dl & al;
          majh = dah ^ dh & bh ^ abh;
          majl = dal ^ dl & bl ^ abl;
          chh = hh & eh ^ ~hh & fh;
          chl = hl & el ^ ~hl & fl;
          t1h = blocks2[j + 2];
          t1l = blocks2[j + 3];
          t2h = K2[j + 2];
          t2l = K2[j + 3];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (gl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (gh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (cl & 65535) + (t1l & 65535);
          c2 = (cl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (ch & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (ch >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          gh = c4 << 16 | c3 & 65535;
          gl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          ch = c4 << 16 | c3 & 65535;
          cl = c2 << 16 | c1 & 65535;
          s0h = (ch >>> 28 | cl << 4) ^ (cl >>> 2 | ch << 30) ^ (cl >>> 7 | ch << 25);
          s0l = (cl >>> 28 | ch << 4) ^ (ch >>> 2 | cl << 30) ^ (ch >>> 7 | cl << 25);
          s1h = (gh >>> 14 | gl << 18) ^ (gh >>> 18 | gl << 14) ^ (gl >>> 9 | gh << 23);
          s1l = (gl >>> 14 | gh << 18) ^ (gl >>> 18 | gh << 14) ^ (gh >>> 9 | gl << 23);
          cdh = ch & dh;
          cdl = cl & dl;
          majh = cdh ^ ch & ah ^ dah;
          majl = cdl ^ cl & al ^ dal;
          chh = gh & hh ^ ~gh & eh;
          chl = gl & hl ^ ~gl & el;
          t1h = blocks2[j + 4];
          t1l = blocks2[j + 5];
          t2h = K2[j + 4];
          t2l = K2[j + 5];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (fl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (fh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (bl & 65535) + (t1l & 65535);
          c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (bh & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (bh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          fh = c4 << 16 | c3 & 65535;
          fl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          bh = c4 << 16 | c3 & 65535;
          bl = c2 << 16 | c1 & 65535;
          s0h = (bh >>> 28 | bl << 4) ^ (bl >>> 2 | bh << 30) ^ (bl >>> 7 | bh << 25);
          s0l = (bl >>> 28 | bh << 4) ^ (bh >>> 2 | bl << 30) ^ (bh >>> 7 | bl << 25);
          s1h = (fh >>> 14 | fl << 18) ^ (fh >>> 18 | fl << 14) ^ (fl >>> 9 | fh << 23);
          s1l = (fl >>> 14 | fh << 18) ^ (fl >>> 18 | fh << 14) ^ (fh >>> 9 | fl << 23);
          bch = bh & ch;
          bcl = bl & cl;
          majh = bch ^ bh & dh ^ cdh;
          majl = bcl ^ bl & dl ^ cdl;
          chh = fh & gh ^ ~fh & hh;
          chl = fl & gl ^ ~fl & hl;
          t1h = blocks2[j + 6];
          t1l = blocks2[j + 7];
          t2h = K2[j + 6];
          t2l = K2[j + 7];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (el & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (eh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (al & 65535) + (t1l & 65535);
          c2 = (al >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (ah & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (ah >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          eh = c4 << 16 | c3 & 65535;
          el = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          ah = c4 << 16 | c3 & 65535;
          al = c2 << 16 | c1 & 65535;
        }
        c1 = (h0l & 65535) + (al & 65535);
        c2 = (h0l >>> 16) + (al >>> 16) + (c1 >>> 16);
        c3 = (h0h & 65535) + (ah & 65535) + (c2 >>> 16);
        c4 = (h0h >>> 16) + (ah >>> 16) + (c3 >>> 16);
        this.h0h = c4 << 16 | c3 & 65535;
        this.h0l = c2 << 16 | c1 & 65535;
        c1 = (h1l & 65535) + (bl & 65535);
        c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16);
        c3 = (h1h & 65535) + (bh & 65535) + (c2 >>> 16);
        c4 = (h1h >>> 16) + (bh >>> 16) + (c3 >>> 16);
        this.h1h = c4 << 16 | c3 & 65535;
        this.h1l = c2 << 16 | c1 & 65535;
        c1 = (h2l & 65535) + (cl & 65535);
        c2 = (h2l >>> 16) + (cl >>> 16) + (c1 >>> 16);
        c3 = (h2h & 65535) + (ch & 65535) + (c2 >>> 16);
        c4 = (h2h >>> 16) + (ch >>> 16) + (c3 >>> 16);
        this.h2h = c4 << 16 | c3 & 65535;
        this.h2l = c2 << 16 | c1 & 65535;
        c1 = (h3l & 65535) + (dl & 65535);
        c2 = (h3l >>> 16) + (dl >>> 16) + (c1 >>> 16);
        c3 = (h3h & 65535) + (dh & 65535) + (c2 >>> 16);
        c4 = (h3h >>> 16) + (dh >>> 16) + (c3 >>> 16);
        this.h3h = c4 << 16 | c3 & 65535;
        this.h3l = c2 << 16 | c1 & 65535;
        c1 = (h4l & 65535) + (el & 65535);
        c2 = (h4l >>> 16) + (el >>> 16) + (c1 >>> 16);
        c3 = (h4h & 65535) + (eh & 65535) + (c2 >>> 16);
        c4 = (h4h >>> 16) + (eh >>> 16) + (c3 >>> 16);
        this.h4h = c4 << 16 | c3 & 65535;
        this.h4l = c2 << 16 | c1 & 65535;
        c1 = (h5l & 65535) + (fl & 65535);
        c2 = (h5l >>> 16) + (fl >>> 16) + (c1 >>> 16);
        c3 = (h5h & 65535) + (fh & 65535) + (c2 >>> 16);
        c4 = (h5h >>> 16) + (fh >>> 16) + (c3 >>> 16);
        this.h5h = c4 << 16 | c3 & 65535;
        this.h5l = c2 << 16 | c1 & 65535;
        c1 = (h6l & 65535) + (gl & 65535);
        c2 = (h6l >>> 16) + (gl >>> 16) + (c1 >>> 16);
        c3 = (h6h & 65535) + (gh & 65535) + (c2 >>> 16);
        c4 = (h6h >>> 16) + (gh >>> 16) + (c3 >>> 16);
        this.h6h = c4 << 16 | c3 & 65535;
        this.h6l = c2 << 16 | c1 & 65535;
        c1 = (h7l & 65535) + (hl & 65535);
        c2 = (h7l >>> 16) + (hl >>> 16) + (c1 >>> 16);
        c3 = (h7h & 65535) + (hh & 65535) + (c2 >>> 16);
        c4 = (h7h >>> 16) + (hh >>> 16) + (c3 >>> 16);
        this.h7h = c4 << 16 | c3 & 65535;
        this.h7l = c2 << 16 | c1 & 65535;
      };
      Sha512.prototype.hex = function() {
        this.finalize();
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits2 = this.bits;
        var hex = HEX_CHARS[h0h >> 28 & 15] + HEX_CHARS[h0h >> 24 & 15] + HEX_CHARS[h0h >> 20 & 15] + HEX_CHARS[h0h >> 16 & 15] + HEX_CHARS[h0h >> 12 & 15] + HEX_CHARS[h0h >> 8 & 15] + HEX_CHARS[h0h >> 4 & 15] + HEX_CHARS[h0h & 15] + HEX_CHARS[h0l >> 28 & 15] + HEX_CHARS[h0l >> 24 & 15] + HEX_CHARS[h0l >> 20 & 15] + HEX_CHARS[h0l >> 16 & 15] + HEX_CHARS[h0l >> 12 & 15] + HEX_CHARS[h0l >> 8 & 15] + HEX_CHARS[h0l >> 4 & 15] + HEX_CHARS[h0l & 15] + HEX_CHARS[h1h >> 28 & 15] + HEX_CHARS[h1h >> 24 & 15] + HEX_CHARS[h1h >> 20 & 15] + HEX_CHARS[h1h >> 16 & 15] + HEX_CHARS[h1h >> 12 & 15] + HEX_CHARS[h1h >> 8 & 15] + HEX_CHARS[h1h >> 4 & 15] + HEX_CHARS[h1h & 15] + HEX_CHARS[h1l >> 28 & 15] + HEX_CHARS[h1l >> 24 & 15] + HEX_CHARS[h1l >> 20 & 15] + HEX_CHARS[h1l >> 16 & 15] + HEX_CHARS[h1l >> 12 & 15] + HEX_CHARS[h1l >> 8 & 15] + HEX_CHARS[h1l >> 4 & 15] + HEX_CHARS[h1l & 15] + HEX_CHARS[h2h >> 28 & 15] + HEX_CHARS[h2h >> 24 & 15] + HEX_CHARS[h2h >> 20 & 15] + HEX_CHARS[h2h >> 16 & 15] + HEX_CHARS[h2h >> 12 & 15] + HEX_CHARS[h2h >> 8 & 15] + HEX_CHARS[h2h >> 4 & 15] + HEX_CHARS[h2h & 15] + HEX_CHARS[h2l >> 28 & 15] + HEX_CHARS[h2l >> 24 & 15] + HEX_CHARS[h2l >> 20 & 15] + HEX_CHARS[h2l >> 16 & 15] + HEX_CHARS[h2l >> 12 & 15] + HEX_CHARS[h2l >> 8 & 15] + HEX_CHARS[h2l >> 4 & 15] + HEX_CHARS[h2l & 15] + HEX_CHARS[h3h >> 28 & 15] + HEX_CHARS[h3h >> 24 & 15] + HEX_CHARS[h3h >> 20 & 15] + HEX_CHARS[h3h >> 16 & 15] + HEX_CHARS[h3h >> 12 & 15] + HEX_CHARS[h3h >> 8 & 15] + HEX_CHARS[h3h >> 4 & 15] + HEX_CHARS[h3h & 15];
        if (bits2 >= 256) {
          hex += HEX_CHARS[h3l >> 28 & 15] + HEX_CHARS[h3l >> 24 & 15] + HEX_CHARS[h3l >> 20 & 15] + HEX_CHARS[h3l >> 16 & 15] + HEX_CHARS[h3l >> 12 & 15] + HEX_CHARS[h3l >> 8 & 15] + HEX_CHARS[h3l >> 4 & 15] + HEX_CHARS[h3l & 15];
        }
        if (bits2 >= 384) {
          hex += HEX_CHARS[h4h >> 28 & 15] + HEX_CHARS[h4h >> 24 & 15] + HEX_CHARS[h4h >> 20 & 15] + HEX_CHARS[h4h >> 16 & 15] + HEX_CHARS[h4h >> 12 & 15] + HEX_CHARS[h4h >> 8 & 15] + HEX_CHARS[h4h >> 4 & 15] + HEX_CHARS[h4h & 15] + HEX_CHARS[h4l >> 28 & 15] + HEX_CHARS[h4l >> 24 & 15] + HEX_CHARS[h4l >> 20 & 15] + HEX_CHARS[h4l >> 16 & 15] + HEX_CHARS[h4l >> 12 & 15] + HEX_CHARS[h4l >> 8 & 15] + HEX_CHARS[h4l >> 4 & 15] + HEX_CHARS[h4l & 15] + HEX_CHARS[h5h >> 28 & 15] + HEX_CHARS[h5h >> 24 & 15] + HEX_CHARS[h5h >> 20 & 15] + HEX_CHARS[h5h >> 16 & 15] + HEX_CHARS[h5h >> 12 & 15] + HEX_CHARS[h5h >> 8 & 15] + HEX_CHARS[h5h >> 4 & 15] + HEX_CHARS[h5h & 15] + HEX_CHARS[h5l >> 28 & 15] + HEX_CHARS[h5l >> 24 & 15] + HEX_CHARS[h5l >> 20 & 15] + HEX_CHARS[h5l >> 16 & 15] + HEX_CHARS[h5l >> 12 & 15] + HEX_CHARS[h5l >> 8 & 15] + HEX_CHARS[h5l >> 4 & 15] + HEX_CHARS[h5l & 15];
        }
        if (bits2 == 512) {
          hex += HEX_CHARS[h6h >> 28 & 15] + HEX_CHARS[h6h >> 24 & 15] + HEX_CHARS[h6h >> 20 & 15] + HEX_CHARS[h6h >> 16 & 15] + HEX_CHARS[h6h >> 12 & 15] + HEX_CHARS[h6h >> 8 & 15] + HEX_CHARS[h6h >> 4 & 15] + HEX_CHARS[h6h & 15] + HEX_CHARS[h6l >> 28 & 15] + HEX_CHARS[h6l >> 24 & 15] + HEX_CHARS[h6l >> 20 & 15] + HEX_CHARS[h6l >> 16 & 15] + HEX_CHARS[h6l >> 12 & 15] + HEX_CHARS[h6l >> 8 & 15] + HEX_CHARS[h6l >> 4 & 15] + HEX_CHARS[h6l & 15] + HEX_CHARS[h7h >> 28 & 15] + HEX_CHARS[h7h >> 24 & 15] + HEX_CHARS[h7h >> 20 & 15] + HEX_CHARS[h7h >> 16 & 15] + HEX_CHARS[h7h >> 12 & 15] + HEX_CHARS[h7h >> 8 & 15] + HEX_CHARS[h7h >> 4 & 15] + HEX_CHARS[h7h & 15] + HEX_CHARS[h7l >> 28 & 15] + HEX_CHARS[h7l >> 24 & 15] + HEX_CHARS[h7l >> 20 & 15] + HEX_CHARS[h7l >> 16 & 15] + HEX_CHARS[h7l >> 12 & 15] + HEX_CHARS[h7l >> 8 & 15] + HEX_CHARS[h7l >> 4 & 15] + HEX_CHARS[h7l & 15];
        }
        return hex;
      };
      Sha512.prototype.toString = Sha512.prototype.hex;
      Sha512.prototype.digest = function() {
        this.finalize();
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits2 = this.bits;
        var arr = [
          h0h >> 24 & 255,
          h0h >> 16 & 255,
          h0h >> 8 & 255,
          h0h & 255,
          h0l >> 24 & 255,
          h0l >> 16 & 255,
          h0l >> 8 & 255,
          h0l & 255,
          h1h >> 24 & 255,
          h1h >> 16 & 255,
          h1h >> 8 & 255,
          h1h & 255,
          h1l >> 24 & 255,
          h1l >> 16 & 255,
          h1l >> 8 & 255,
          h1l & 255,
          h2h >> 24 & 255,
          h2h >> 16 & 255,
          h2h >> 8 & 255,
          h2h & 255,
          h2l >> 24 & 255,
          h2l >> 16 & 255,
          h2l >> 8 & 255,
          h2l & 255,
          h3h >> 24 & 255,
          h3h >> 16 & 255,
          h3h >> 8 & 255,
          h3h & 255
        ];
        if (bits2 >= 256) {
          arr.push(h3l >> 24 & 255, h3l >> 16 & 255, h3l >> 8 & 255, h3l & 255);
        }
        if (bits2 >= 384) {
          arr.push(
            h4h >> 24 & 255,
            h4h >> 16 & 255,
            h4h >> 8 & 255,
            h4h & 255,
            h4l >> 24 & 255,
            h4l >> 16 & 255,
            h4l >> 8 & 255,
            h4l & 255,
            h5h >> 24 & 255,
            h5h >> 16 & 255,
            h5h >> 8 & 255,
            h5h & 255,
            h5l >> 24 & 255,
            h5l >> 16 & 255,
            h5l >> 8 & 255,
            h5l & 255
          );
        }
        if (bits2 == 512) {
          arr.push(
            h6h >> 24 & 255,
            h6h >> 16 & 255,
            h6h >> 8 & 255,
            h6h & 255,
            h6l >> 24 & 255,
            h6l >> 16 & 255,
            h6l >> 8 & 255,
            h6l & 255,
            h7h >> 24 & 255,
            h7h >> 16 & 255,
            h7h >> 8 & 255,
            h7h & 255,
            h7l >> 24 & 255,
            h7l >> 16 & 255,
            h7l >> 8 & 255,
            h7l & 255
          );
        }
        return arr;
      };
      Sha512.prototype.array = Sha512.prototype.digest;
      Sha512.prototype.arrayBuffer = function() {
        this.finalize();
        var bits2 = this.bits;
        var buffer2 = new ArrayBuffer(bits2 / 8);
        var dataView2 = new DataView(buffer2);
        dataView2.setUint32(0, this.h0h);
        dataView2.setUint32(4, this.h0l);
        dataView2.setUint32(8, this.h1h);
        dataView2.setUint32(12, this.h1l);
        dataView2.setUint32(16, this.h2h);
        dataView2.setUint32(20, this.h2l);
        dataView2.setUint32(24, this.h3h);
        if (bits2 >= 256) {
          dataView2.setUint32(28, this.h3l);
        }
        if (bits2 >= 384) {
          dataView2.setUint32(32, this.h4h);
          dataView2.setUint32(36, this.h4l);
          dataView2.setUint32(40, this.h5h);
          dataView2.setUint32(44, this.h5l);
        }
        if (bits2 == 512) {
          dataView2.setUint32(48, this.h6h);
          dataView2.setUint32(52, this.h6l);
          dataView2.setUint32(56, this.h7h);
          dataView2.setUint32(60, this.h7l);
        }
        return buffer2;
      };
      Sha512.prototype.clone = function() {
        var hash2 = new Sha512(this.bits, false);
        this.copyTo(hash2);
        return hash2;
      };
      Sha512.prototype.copyTo = function(hash2) {
        var i2 = 0, attrs = [
          "h0h",
          "h0l",
          "h1h",
          "h1l",
          "h2h",
          "h2l",
          "h3h",
          "h3l",
          "h4h",
          "h4l",
          "h5h",
          "h5l",
          "h6h",
          "h6l",
          "h7h",
          "h7l",
          "start",
          "bytes",
          "hBytes",
          "finalized",
          "hashed",
          "lastByteIndex"
        ];
        for (i2 = 0; i2 < attrs.length; ++i2) {
          hash2[attrs[i2]] = this[attrs[i2]];
        }
        for (i2 = 0; i2 < this.blocks.length; ++i2) {
          hash2.blocks[i2] = this.blocks[i2];
        }
      };
      function HmacSha512(key, bits2, sharedMemory) {
        var notString, type = typeof key;
        if (type !== "string") {
          if (type === "object") {
            if (key === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
              key = new Uint8Array(key);
            } else if (!Array.isArray(key)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var length3 = key.length;
        if (!notString) {
          var bytes = [], length3 = key.length, index2 = 0, code8;
          for (var i2 = 0; i2 < length3; ++i2) {
            code8 = key.charCodeAt(i2);
            if (code8 < 128) {
              bytes[index2++] = code8;
            } else if (code8 < 2048) {
              bytes[index2++] = 192 | code8 >> 6;
              bytes[index2++] = 128 | code8 & 63;
            } else if (code8 < 55296 || code8 >= 57344) {
              bytes[index2++] = 224 | code8 >> 12;
              bytes[index2++] = 128 | code8 >> 6 & 63;
              bytes[index2++] = 128 | code8 & 63;
            } else {
              code8 = 65536 + ((code8 & 1023) << 10 | key.charCodeAt(++i2) & 1023);
              bytes[index2++] = 240 | code8 >> 18;
              bytes[index2++] = 128 | code8 >> 12 & 63;
              bytes[index2++] = 128 | code8 >> 6 & 63;
              bytes[index2++] = 128 | code8 & 63;
            }
          }
          key = bytes;
        }
        if (key.length > 128) {
          key = new Sha512(bits2, true).update(key).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (var i2 = 0; i2 < 128; ++i2) {
          var b = key[i2] || 0;
          oKeyPad[i2] = 92 ^ b;
          iKeyPad[i2] = 54 ^ b;
        }
        Sha512.call(this, bits2, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha512.prototype = new Sha512();
      HmacSha512.prototype.finalize = function() {
        Sha512.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha512.call(this, this.bits, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha512.prototype.finalize.call(this);
        }
      };
      HmacSha512.prototype.clone = function() {
        var hash2 = new HmacSha512([], this.bits, false);
        this.copyTo(hash2);
        hash2.inner = this.inner;
        for (var i2 = 0; i2 < this.oKeyPad.length; ++i2) {
          hash2.oKeyPad[i2] = this.oKeyPad[i2];
        }
        return hash2;
      };
      var exports22 = createMethod(512);
      exports22.sha512 = exports22;
      exports22.sha384 = createMethod(384);
      exports22.sha512_256 = createMethod(256);
      exports22.sha512_224 = createMethod(224);
      exports22.sha512.hmac = createHmacMethod(512);
      exports22.sha384.hmac = createHmacMethod(384);
      exports22.sha512_256.hmac = createHmacMethod(256);
      exports22.sha512_224.hmac = createHmacMethod(224);
      if (COMMON_JS) {
        module2.exports = exports22;
      } else {
        root2.sha512 = exports22.sha512;
        root2.sha384 = exports22.sha384;
        root2.sha512_256 = exports22.sha512_256;
        root2.sha512_224 = exports22.sha512_224;
        if (AMD) {
          define(function() {
            return exports22;
          });
        }
      }
    })();
  }
});
var require_base32 = __commonJS({
  "node_modules/hi-base32/src/base32.js"(exports2, module2) {
    (function() {
      var root2 = typeof window === "object" ? window : {};
      var NODE_JS = !root2.HI_BASE32_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root2 = globalThis;
      }
      var COMMON_JS = !root2.HI_BASE32_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var BASE32_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split("");
      var BASE32_DECODE_CHAR = {
        "A": 0,
        "B": 1,
        "C": 2,
        "D": 3,
        "E": 4,
        "F": 5,
        "G": 6,
        "H": 7,
        "I": 8,
        "J": 9,
        "K": 10,
        "L": 11,
        "M": 12,
        "N": 13,
        "O": 14,
        "P": 15,
        "Q": 16,
        "R": 17,
        "S": 18,
        "T": 19,
        "U": 20,
        "V": 21,
        "W": 22,
        "X": 23,
        "Y": 24,
        "Z": 25,
        "2": 26,
        "3": 27,
        "4": 28,
        "5": 29,
        "6": 30,
        "7": 31
      };
      var blocks = [0, 0, 0, 0, 0, 0, 0, 0];
      var throwInvalidUtf8 = function(position, partial) {
        if (partial.length > 10) {
          partial = "..." + partial.substr(-10);
        }
        var err2 = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + position + " bytes: " + partial + " <-");
        err2.position = position;
        throw err2;
      };
      var toUtf8String = function(bytes) {
        var str = "", length3 = bytes.length, i2 = 0, followingChars = 0, b, c;
        while (i2 < length3) {
          b = bytes[i2++];
          if (b <= 127) {
            str += String.fromCharCode(b);
            continue;
          } else if (b > 191 && b <= 223) {
            c = b & 31;
            followingChars = 1;
          } else if (b <= 239) {
            c = b & 15;
            followingChars = 2;
          } else if (b <= 247) {
            c = b & 7;
            followingChars = 3;
          } else {
            throwInvalidUtf8(i2, str);
          }
          for (var j = 0; j < followingChars; ++j) {
            b = bytes[i2++];
            if (b < 128 || b > 191) {
              throwInvalidUtf8(i2, str);
            }
            c <<= 6;
            c += b & 63;
          }
          if (c >= 55296 && c <= 57343) {
            throwInvalidUtf8(i2, str);
          }
          if (c > 1114111) {
            throwInvalidUtf8(i2, str);
          }
          if (c <= 65535) {
            str += String.fromCharCode(c);
          } else {
            c -= 65536;
            str += String.fromCharCode((c >> 10) + 55296);
            str += String.fromCharCode((c & 1023) + 56320);
          }
        }
        return str;
      };
      var decodeAsBytes = function(base32Str) {
        if (base32Str === "") {
          return [];
        } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
          throw new Error("Invalid base32 characters");
        }
        base32Str = base32Str.replace(/=/g, "");
        var v1, v2, v3, v42, v5, v62, v7, v8, bytes = [], index2 = 0, length3 = base32Str.length;
        for (var i2 = 0, count = length3 >> 3 << 3; i2 < count; ) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v62 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v8 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index2++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index2++] = (v2 << 6 | v3 << 1 | v42 >>> 4) & 255;
          bytes[index2++] = (v42 << 4 | v5 >>> 1) & 255;
          bytes[index2++] = (v5 << 7 | v62 << 2 | v7 >>> 3) & 255;
          bytes[index2++] = (v7 << 5 | v8) & 255;
        }
        var remain = length3 - count;
        if (remain === 2) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index2++] = (v1 << 3 | v2 >>> 2) & 255;
        } else if (remain === 4) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index2++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index2++] = (v2 << 6 | v3 << 1 | v42 >>> 4) & 255;
        } else if (remain === 5) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index2++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index2++] = (v2 << 6 | v3 << 1 | v42 >>> 4) & 255;
          bytes[index2++] = (v42 << 4 | v5 >>> 1) & 255;
        } else if (remain === 7) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v62 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index2++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index2++] = (v2 << 6 | v3 << 1 | v42 >>> 4) & 255;
          bytes[index2++] = (v42 << 4 | v5 >>> 1) & 255;
          bytes[index2++] = (v5 << 7 | v62 << 2 | v7 >>> 3) & 255;
        }
        return bytes;
      };
      var encodeAscii = function(str) {
        var v1, v2, v3, v42, v5, base32Str = "", length3 = str.length;
        for (var i2 = 0, count = parseInt(length3 / 5) * 5; i2 < count; ) {
          v1 = str.charCodeAt(i2++);
          v2 = str.charCodeAt(i2++);
          v3 = str.charCodeAt(i2++);
          v42 = str.charCodeAt(i2++);
          v5 = str.charCodeAt(i2++);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v42 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
        }
        var remain = length3 - count;
        if (remain === 1) {
          v1 = str.charCodeAt(i2);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
        } else if (remain === 2) {
          v1 = str.charCodeAt(i2++);
          v2 = str.charCodeAt(i2);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (remain === 3) {
          v1 = str.charCodeAt(i2++);
          v2 = str.charCodeAt(i2++);
          v3 = str.charCodeAt(i2);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
        } else if (remain === 4) {
          v1 = str.charCodeAt(i2++);
          v2 = str.charCodeAt(i2++);
          v3 = str.charCodeAt(i2++);
          v42 = str.charCodeAt(i2);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[v42 << 3 & 31] + "=";
        }
        return base32Str;
      };
      var encodeUtf8 = function(str) {
        var v1, v2, v3, v42, v5, code8, end = false, base32Str = "", index2 = 0, i2, start = 0, length3 = str.length;
        if (str === "") {
          return base32Str;
        }
        do {
          blocks[0] = blocks[5];
          blocks[1] = blocks[6];
          blocks[2] = blocks[7];
          for (i2 = start; index2 < length3 && i2 < 5; ++index2) {
            code8 = str.charCodeAt(index2);
            if (code8 < 128) {
              blocks[i2++] = code8;
            } else if (code8 < 2048) {
              blocks[i2++] = 192 | code8 >> 6;
              blocks[i2++] = 128 | code8 & 63;
            } else if (code8 < 55296 || code8 >= 57344) {
              blocks[i2++] = 224 | code8 >> 12;
              blocks[i2++] = 128 | code8 >> 6 & 63;
              blocks[i2++] = 128 | code8 & 63;
            } else {
              code8 = 65536 + ((code8 & 1023) << 10 | str.charCodeAt(++index2) & 1023);
              blocks[i2++] = 240 | code8 >> 18;
              blocks[i2++] = 128 | code8 >> 12 & 63;
              blocks[i2++] = 128 | code8 >> 6 & 63;
              blocks[i2++] = 128 | code8 & 63;
            }
          }
          start = i2 - 5;
          if (index2 === length3) {
            ++index2;
          }
          if (index2 > length3 && i2 < 6) {
            end = true;
          }
          v1 = blocks[0];
          if (i2 > 4) {
            v2 = blocks[1];
            v3 = blocks[2];
            v42 = blocks[3];
            v5 = blocks[4];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v42 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
          } else if (i2 === 1) {
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
          } else if (i2 === 2) {
            v2 = blocks[1];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
          } else if (i2 === 3) {
            v2 = blocks[1];
            v3 = blocks[2];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
          } else {
            v2 = blocks[1];
            v3 = blocks[2];
            v42 = blocks[3];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[v42 << 3 & 31] + "=";
          }
        } while (!end);
        return base32Str;
      };
      var encodeBytes2 = function(bytes) {
        var v1, v2, v3, v42, v5, base32Str = "", length3 = bytes.length;
        for (var i2 = 0, count = parseInt(length3 / 5) * 5; i2 < count; ) {
          v1 = bytes[i2++];
          v2 = bytes[i2++];
          v3 = bytes[i2++];
          v42 = bytes[i2++];
          v5 = bytes[i2++];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v42 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
        }
        var remain = length3 - count;
        if (remain === 1) {
          v1 = bytes[i2];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
        } else if (remain === 2) {
          v1 = bytes[i2++];
          v2 = bytes[i2];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (remain === 3) {
          v1 = bytes[i2++];
          v2 = bytes[i2++];
          v3 = bytes[i2];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
        } else if (remain === 4) {
          v1 = bytes[i2++];
          v2 = bytes[i2++];
          v3 = bytes[i2++];
          v42 = bytes[i2];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[v42 << 3 & 31] + "=";
        }
        return base32Str;
      };
      var encode32 = function(input, asciiOnly) {
        var notString = typeof input !== "string";
        if (notString && input.constructor === ArrayBuffer) {
          input = new Uint8Array(input);
        }
        if (notString) {
          return encodeBytes2(input);
        } else if (asciiOnly) {
          return encodeAscii(input);
        } else {
          return encodeUtf8(input);
        }
      };
      var decode42 = function(base32Str, asciiOnly) {
        if (!asciiOnly) {
          return toUtf8String(decodeAsBytes(base32Str));
        }
        if (base32Str === "") {
          return "";
        } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
          throw new Error("Invalid base32 characters");
        }
        var v1, v2, v3, v42, v5, v62, v7, v8, str = "", length3 = base32Str.indexOf("=");
        if (length3 === -1) {
          length3 = base32Str.length;
        }
        for (var i2 = 0, count = length3 >> 3 << 3; i2 < count; ) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v62 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v8 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v42 >>> 4) & 255) + String.fromCharCode((v42 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v62 << 2 | v7 >>> 3) & 255) + String.fromCharCode((v7 << 5 | v8) & 255);
        }
        var remain = length3 - count;
        if (remain === 2) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255);
        } else if (remain === 4) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v42 >>> 4) & 255);
        } else if (remain === 5) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v42 >>> 4) & 255) + String.fromCharCode((v42 << 4 | v5 >>> 1) & 255);
        } else if (remain === 7) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v62 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v42 >>> 4) & 255) + String.fromCharCode((v42 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v62 << 2 | v7 >>> 3) & 255);
        }
        return str;
      };
      var exports22 = {
        encode: encode32,
        decode: decode42
      };
      decode42.asBytes = decodeAsBytes;
      if (COMMON_JS) {
        module2.exports = exports22;
      } else {
        root2.base32 = exports22;
        if (AMD) {
          define(function() {
            return exports22;
          });
        }
      }
    })();
  }
});
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports2, module2) {
    (function(globalObject) {
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: " ",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet3, c, caseChanged, e, i2, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2))
            return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i2 = v; i2 >= 10; i2 /= 10, e++)
                  ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v)))
                return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            if ((i2 = str.search(/e/i)) > 0) {
              if (e < 0)
                e = i2;
              e += +str.slice(i2 + 1);
              str = str.substring(0, i2);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0)
                return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet3 = ALPHABET.slice(0, b);
            e = i2 = 0;
            for (len = str.length; i2 < len; i2++) {
              if (alphabet3.indexOf(c = str.charAt(i2)) < 0) {
                if (c == ".") {
                  if (i2 > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i2 = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            else
              e = str.length;
          }
          for (i2 = 0; str.charCodeAt(i2) === 48; i2++)
            ;
          for (len = str.length; str.charCodeAt(--len) === 48; )
            ;
          if (str = str.slice(i2, ++len)) {
            len -= i2;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i2 - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i2 = (e + 1) % LOG_BASE;
              if (e < 0)
                i2 += LOG_BASE;
              if (i2 < len) {
                if (i2)
                  x.c.push(+str.slice(0, i2));
                for (len -= LOG_BASE; i2 < len; ) {
                  x.c.push(+str.slice(i2, i2 += LOG_BASE));
                }
                i2 = LOG_BASE - (str = str.slice(i2)).length;
              } else {
                i2 -= len;
              }
              for (; i2--; str += "0")
                ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object")
                  FORMAT = v;
                else
                  throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true)
            return false;
          if (!BigNumber2.DEBUG)
            return true;
          var i2, n, c = v.c, e = v.e, s = v.s;
          out:
            if ({}.toString.call(c) == "[object Array]") {
              if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                if (c[0] === 0) {
                  if (e === 0 && c.length === 1)
                    return true;
                  break out;
                }
                i2 = (e + 1) % LOG_BASE;
                if (i2 < 1)
                  i2 += LOG_BASE;
                if (String(c[0]).length == i2) {
                  for (i2 = 0; i2 < c.length; i2++) {
                    n = c[i2];
                    if (n < 0 || n >= BASE || n !== mathfloor(n))
                      break out;
                  }
                  if (n !== 0)
                    return true;
                }
              }
            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
              return true;
            }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, P.lt);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, P.gt);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i2 = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null)
              dp = DECIMAL_PLACES;
            else
              intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i2 < k; ) {
                  v = a[i2] * 131072 + (a[i2 + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i2] = b[0];
                    a[i2 + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i2 += 2;
                  }
                }
                i2 = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i2 < k; ) {
                  v = (a[i2] & 31) * 281474976710656 + a[i2 + 1] * 1099511627776 + a[i2 + 2] * 4294967296 + a[i2 + 3] * 16777216 + (a[i2 + 4] << 16) + (a[i2 + 5] << 8) + a[i2 + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i2);
                  } else {
                    c.push(v % 1e14);
                    i2 += 7;
                  }
                }
                i2 = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i2 < k; ) {
                v = random53bitInt();
                if (v < 9e15)
                  c[i2++] = v % 1e14;
              }
            }
            k = c[--i2];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i2] = mathfloor(k / v) * v;
            }
            for (; c[i2] === 0; c.pop(), i2--)
              ;
            if (i2 < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
                ;
              for (i2 = 1, v = c[0]; v >= 10; v /= 10, i2++)
                ;
              if (i2 < LOG_BASE)
                e -= LOG_BASE - i2;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i2 = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i2 < args.length; )
            sum = sum.plus(args[i2++]);
          return sum;
        };
        convertBase = function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet3) {
            var j, arr = [0], arrL, i2 = 0, len = str.length;
            for (; i2 < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                ;
              arr[0] += alphabet3.indexOf(str.charAt(i2++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null)
                    arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign22, callerIsToString) {
            var alphabet3, d, e, k, r, x, xc, y, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i2 >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i2);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet3 = ALPHABET, decimal) : (alphabet3 = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop())
              ;
            if (!xc[0])
              return alphabet3.charAt(0);
            if (i2 < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign22;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i2 = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i2 != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i2 > k || i2 == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet3.charAt(1), -dp, alphabet3.charAt(0)) : alphabet3.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; )
                ;
              for (i2 = 0, str = ""; i2 <= k; str += alphabet3.charAt(xc[i2++]))
                ;
              str = toFixedPoint(str, e, alphabet3.charAt(0));
            }
            return str;
          };
        }();
        div = function() {
          function multiply(x, k, base3) {
            var m, temp, xlo, xhi, carry = 0, i2 = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i2--; ) {
              xlo = x[i2] % SQRT_BASE;
              xhi = x[i2] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base3 | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i2] = temp % base3;
            }
            if (carry)
              x = [carry].concat(x);
            return x;
          }
          function compare22(a, b, aL, bL) {
            var i2, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i2 = cmp = 0; i2 < aL; i2++) {
                if (a[i2] != b[i2]) {
                  cmp = a[i2] > b[i2] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base3) {
            var i2 = 0;
            for (; aL--; ) {
              a[aL] -= i2;
              i2 = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i2 * base3 + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1))
              ;
          }
          return function(x, y, dp, rm, base3) {
            var cmp, e, i2, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base3) {
              base3 = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i2 = 0; yc[i2] == (xc[i2] || 0); i2++)
              ;
            if (yc[i2] > (xc[i2] || 0))
              e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i2 = 0;
              s += 2;
              n = mathfloor(base3 / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base3);
                xc = multiply(xc, n, base3);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0)
                ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base3 / 2)
                yc0++;
              do {
                n = 0;
                cmp = compare22(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base3 + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base3)
                      n = base3 - 1;
                    prod = multiply(yc, n, base3);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare22(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base3);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL)
                    prod = [0].concat(prod);
                  subtract(rem, prod, remL, base3);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare22(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base3);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i2++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0])
                qc.splice(0, 1);
            }
            if (base3 == BASE) {
              for (i2 = 1, s = qc[0]; s >= 10; s /= 10, i2++)
                ;
              round(q, dp + (q.e = i2 + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format2(n, i2, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          if (!n.c)
            return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i2 == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i2, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i2 <= e || e <= TO_EXP_NEG)) {
              for (; len < i2; str += "0", len++)
                ;
              str = toExponential(str, e);
            } else {
              i2 -= ne;
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i2 > 0)
                  for (str += "."; i2--; str += "0")
                    ;
              } else {
                i2 += e - len;
                if (i2 > 0) {
                  if (e + 1 == len)
                    str += ".";
                  for (; i2--; str += "0")
                    ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, method) {
          var n, i2 = 1, m = new BigNumber2(args[0]);
          for (; i2 < args.length; i2++) {
            n = new BigNumber2(args[i2]);
            if (!n.s) {
              m = n;
              break;
            } else if (method.call(m, n)) {
              m = n;
            }
          }
          return m;
        }
        function normalise(n, c, e) {
          var i2 = 1, j = c.length;
          for (; !c[--j]; c.pop())
            ;
          for (j = c[0]; j >= 10; j /= 10, i2++)
            ;
          if ((e = i2 + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base3, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base3 = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base3 ? p1 : m;
                });
                if (b) {
                  base3 = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s)
                  return new BigNumber2(s, base3);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i2, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                ;
              i2 = sd - d;
              if (i2 < 0) {
                i2 += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = n / pows10[d - j - 1] % 10 | 0;
              } else {
                ni = mathceil((i2 + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0))
                      ;
                    n = rd = 0;
                    d = 1;
                    i2 %= LOG_BASE;
                    j = i2 - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++)
                    ;
                  i2 %= LOG_BASE;
                  j = i2 - LOG_BASE + d;
                  rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i2 > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i2 == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i2];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i2 = 1, j = xc[0]; j >= 10; j /= 10, i2++)
                      ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++)
                      ;
                    if (i2 != k) {
                      x.e++;
                      if (xc[0] == BASE)
                        xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE)
                      break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i2 = xc.length; xc[--i2] === 0; xc.pop())
                ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null)
            return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0)
            x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare3(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c))
            return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v])
            for (; v % 10 == 0; v /= 10, n--)
              ;
          if (n < 0)
            n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i2, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null)
            m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s)
              return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp)
              x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1)
              k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg)
              n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i2 = Math.abs(+valueOf(n));
            nIsOdd = i2 % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c)
                break;
              if (k) {
                if (y.c.length > k)
                  y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i2) {
              i2 = mathfloor(i2 / 2);
              if (i2 === 0)
                break;
              nIsOdd = i2 % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i2 = +valueOf(n);
                if (i2 === 0)
                  break;
                nIsOdd = i2 % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k)
                x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp)
            return y;
          if (nIsNeg)
            y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare3(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare3(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare3(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare3(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare3(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i2, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0))
              ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i2 = xc.length);
          if (b > 0)
            for (; b--; xc[i2++] = 0)
              ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i2 = j; i2 && !xc[--i2]; xc[i2] = b)
                ;
              --xc[i2];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye)
            ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1)
            y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i2, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base3, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i2 = xcL;
            xcL = ycL;
            ycL = i2;
          }
          for (i2 = xcL + ycL, zc = []; i2--; zc.push(0))
            ;
          base3 = BASE;
          sqrtBase = SQRT_BASE;
          for (i2 = ycL; --i2 >= 0; ) {
            c = 0;
            ylo = yc[i2] % sqrtBase;
            yhi = yc[i2] / sqrtBase | 0;
            for (k = xcL, j = i2 + k; j > i2; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base3 | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base3;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0])
              return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0))
              ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c))
            return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--)
              ;
            for (v = c[0]; v >= 10; v /= 10, n++)
              ;
          }
          if (sd && x.e + 1 > n)
            n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0)
              n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3)
              s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e)
                  --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format2(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format2(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format22) {
          var str, x = this;
          if (format22 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format22 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format22 = dp;
              dp = rm = null;
            } else {
              format22 = FORMAT;
            }
          } else if (typeof format22 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format22);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i2, arr = str.split("."), g1 = +format22.groupSize, g2 = +format22.secondaryGroupSize, groupSeparator = format22.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i2 = g1;
              g1 = g2;
              g2 = i2;
              len -= i2;
            }
            if (g1 > 0 && len > 0) {
              i2 = len % g1 || g1;
              intPart = intDigits.substr(0, i2);
              for (; i2 < len; i2 += g1)
                intPart += groupSeparator + intDigits.substr(i2, g1);
              if (g2 > 0)
                intPart += groupSeparator + intDigits.slice(i2);
              if (isNeg)
                intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format22.decimalSeparator || "") + ((g2 = +format22.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format22.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format22.prefix || "") + str + (format22.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc)
            return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1)
              break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null)
            intCheck(sd, 1, MAX);
          return format2(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0)
                str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0])
              str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null)
          BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i2 = n | 0;
        return n > 0 || n === i2 ? i2 : i2 - 1;
      }
      function coeffToString(a) {
        var s, z, i2 = 1, j = a.length, r = a[0] + "";
        for (; i2 < j; ) {
          s = a[i2++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s)
            ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; )
          ;
        return r.slice(0, j + 1 || 1);
      }
      function compare3(x, y) {
        var a, b, xc = x.c, yc = y.c, i2 = x.s, j = y.s, k = x.e, l = y.e;
        if (!i2 || !j)
          return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b)
          return a ? b ? 0 : -j : i2;
        if (i2 != j)
          return i2;
        a = i2 < 0;
        b = k == l;
        if (!xc || !yc)
          return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b)
          return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i2 = 0; i2 < j; i2++)
          if (xc[i2] != yc[i2])
            return xc[i2] > yc[i2] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name9) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name9 || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z)
            ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z)
              ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports2);
  }
});
var require_stringify = __commonJS({
  "node_modules/json-bigint/lib/stringify.js"(exports2, module2) {
    var BigNumber = require_bignumber();
    var JSON2 = module2.exports;
    (function() {
      var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        // table of character substitutions
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string2) {
        escapable.lastIndex = 0;
        return escapable.test(string2) ? '"' + string2.replace(escapable, function(a) {
          var c = meta[a];
          return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string2 + '"';
      }
      function str(key, holder) {
        var i2, k, v, length3, mind = gap, partial, value2 = holder[key], isBigNumber = value2 != null && (value2 instanceof BigNumber || BigNumber.isBigNumber(value2));
        if (value2 && typeof value2 === "object" && typeof value2.toJSON === "function") {
          value2 = value2.toJSON(key);
        }
        if (typeof rep === "function") {
          value2 = rep.call(holder, key, value2);
        }
        switch (typeof value2) {
          case "string":
            if (isBigNumber) {
              return value2;
            } else {
              return quote(value2);
            }
          case "number":
            return isFinite(value2) ? String(value2) : "null";
          case "boolean":
          case "null":
          case "bigint":
            return String(value2);
          case "object":
            if (!value2) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value2) === "[object Array]") {
              length3 = value2.length;
              for (i2 = 0; i2 < length3; i2 += 1) {
                partial[i2] = str(i2, value2) || "null";
              }
              v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v;
            }
            if (rep && typeof rep === "object") {
              length3 = rep.length;
              for (i2 = 0; i2 < length3; i2 += 1) {
                if (typeof rep[i2] === "string") {
                  k = rep[i2];
                  v = str(k, value2);
                  if (v) {
                    partial.push(quote(k) + (gap ? ": " : ":") + v);
                  }
                }
              }
            } else {
              Object.keys(value2).forEach(function(k2) {
                var v2 = str(k2, value2);
                if (v2) {
                  partial.push(quote(k2) + (gap ? ": " : ":") + v2);
                }
              });
            }
            v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
      }
      if (typeof JSON2.stringify !== "function") {
        JSON2.stringify = function(value2, replacer, space) {
          var i2;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i2 = 0; i2 < space; i2 += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value2 });
        };
      }
    })();
  }
});
var require_parse = __commonJS({
  "node_modules/json-bigint/lib/parse.js"(exports2, module2) {
    var BigNumber = null;
    var suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
    var suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
    var json_parse = function(options) {
      var _options = {
        strict: false,
        // not being strict means do not generate syntax errors for "duplicate key"
        storeAsString: false,
        // toggles whether the values should be stored as BigNumber (default) or a string
        alwaysParseAsBig: false,
        // toggles whether all numbers should be Big
        useNativeBigInt: false,
        // toggles whether to use native BigInt instead of bignumber.js
        protoAction: "error",
        constructorAction: "error"
      };
      if (options !== void 0 && options !== null) {
        if (options.strict === true) {
          _options.strict = true;
        }
        if (options.storeAsString === true) {
          _options.storeAsString = true;
        }
        _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
        _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
        if (typeof options.constructorAction !== "undefined") {
          if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
            _options.constructorAction = options.constructorAction;
          } else {
            throw new Error(
              `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
            );
          }
        }
        if (typeof options.protoAction !== "undefined") {
          if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
            _options.protoAction = options.protoAction;
          } else {
            throw new Error(
              `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
            );
          }
        }
      }
      var at, ch, escapee = {
        '"': '"',
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
      }, text, error = function(m) {
        throw {
          name: "SyntaxError",
          message: m,
          at,
          text
        };
      }, next = function(c) {
        if (c && c !== ch) {
          error("Expected '" + c + "' instead of '" + ch + "'");
        }
        ch = text.charAt(at);
        at += 1;
        return ch;
      }, number = function() {
        var number2, string22 = "";
        if (ch === "-") {
          string22 = "-";
          next("-");
        }
        while (ch >= "0" && ch <= "9") {
          string22 += ch;
          next();
        }
        if (ch === ".") {
          string22 += ".";
          while (next() && ch >= "0" && ch <= "9") {
            string22 += ch;
          }
        }
        if (ch === "e" || ch === "E") {
          string22 += ch;
          next();
          if (ch === "-" || ch === "+") {
            string22 += ch;
            next();
          }
          while (ch >= "0" && ch <= "9") {
            string22 += ch;
            next();
          }
        }
        number2 = +string22;
        if (!isFinite(number2)) {
          error("Bad number");
        } else {
          if (BigNumber == null)
            BigNumber = require_bignumber();
          if (string22.length > 15)
            return _options.storeAsString ? string22 : _options.useNativeBigInt ? BigInt(string22) : new BigNumber(string22);
          else
            return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
        }
      }, string2 = function() {
        var hex, i2, string22 = "", uffff;
        if (ch === '"') {
          var startAt = at;
          while (next()) {
            if (ch === '"') {
              if (at - 1 > startAt)
                string22 += text.substring(startAt, at - 1);
              next();
              return string22;
            }
            if (ch === "\\") {
              if (at - 1 > startAt)
                string22 += text.substring(startAt, at - 1);
              next();
              if (ch === "u") {
                uffff = 0;
                for (i2 = 0; i2 < 4; i2 += 1) {
                  hex = parseInt(next(), 16);
                  if (!isFinite(hex)) {
                    break;
                  }
                  uffff = uffff * 16 + hex;
                }
                string22 += String.fromCharCode(uffff);
              } else if (typeof escapee[ch] === "string") {
                string22 += escapee[ch];
              } else {
                break;
              }
              startAt = at;
            }
          }
        }
        error("Bad string");
      }, white = function() {
        while (ch && ch <= " ") {
          next();
        }
      }, word2 = function() {
        switch (ch) {
          case "t":
            next("t");
            next("r");
            next("u");
            next("e");
            return true;
          case "f":
            next("f");
            next("a");
            next("l");
            next("s");
            next("e");
            return false;
          case "n":
            next("n");
            next("u");
            next("l");
            next("l");
            return null;
        }
        error("Unexpected '" + ch + "'");
      }, value2, array = function() {
        var array2 = [];
        if (ch === "[") {
          next("[");
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          while (ch) {
            array2.push(value2());
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            next(",");
            white();
          }
        }
        error("Bad array");
      }, object = function() {
        var key, object2 = /* @__PURE__ */ Object.create(null);
        if (ch === "{") {
          next("{");
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          while (ch) {
            key = string2();
            white();
            next(":");
            if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
              error('Duplicate key "' + key + '"');
            }
            if (suspectProtoRx.test(key) === true) {
              if (_options.protoAction === "error") {
                error("Object contains forbidden prototype property");
              } else if (_options.protoAction === "ignore") {
                value2();
              } else {
                object2[key] = value2();
              }
            } else if (suspectConstructorRx.test(key) === true) {
              if (_options.constructorAction === "error") {
                error("Object contains forbidden constructor property");
              } else if (_options.constructorAction === "ignore") {
                value2();
              } else {
                object2[key] = value2();
              }
            } else {
              object2[key] = value2();
            }
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            next(",");
            white();
          }
        }
        error("Bad object");
      };
      value2 = function() {
        white();
        switch (ch) {
          case "{":
            return object();
          case "[":
            return array();
          case '"':
            return string2();
          case "-":
            return number();
          default:
            return ch >= "0" && ch <= "9" ? number() : word2();
        }
      };
      return function(source, reviver) {
        var result;
        text = source + "";
        at = 0;
        ch = " ";
        result = value2();
        white();
        if (ch) {
          error("Syntax error");
        }
        return typeof reviver === "function" ? function walk2(holder, key) {
          var v, value22 = holder[key];
          if (value22 && typeof value22 === "object") {
            Object.keys(value22).forEach(function(k2) {
              v = walk2(value22, k2);
              if (v !== void 0) {
                value22[k2] = v;
              } else {
                delete value22[k2];
              }
            });
          }
          return reviver.call(holder, key, value22);
        }({ "": result }, "") : result;
      };
    };
    module2.exports = json_parse;
  }
});
var require_json_bigint = __commonJS({
  "node_modules/json-bigint/index.js"(exports2, module2) {
    var json_stringify = require_stringify().stringify;
    var json_parse = require_parse();
    module2.exports = function(options) {
      return {
        parse: json_parse(options),
        stringify: json_stringify
      };
    };
    module2.exports.parse = json_parse();
    module2.exports.stringify = json_stringify;
  }
});
var require_msgpack_min = __commonJS({
  "node_modules/algo-msgpack-with-bigint/dist.es5/msgpack.min.js"(exports2, module2) {
    !function(t, e) {
      "object" == typeof exports2 && "object" == typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports2 ? exports2.MessagePack = e() : t.MessagePack = e();
    }(exports2, function() {
      return function(t) {
        var e = {};
        function r(n) {
          if (e[n])
            return e[n].exports;
          var i2 = e[n] = { i: n, l: false, exports: {} };
          return t[n].call(i2.exports, i2, i2.exports, r), i2.l = true, i2.exports;
        }
        return r.m = t, r.c = e, r.d = function(t2, e2, n) {
          r.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: n });
        }, r.r = function(t2) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
        }, r.t = function(t2, e2) {
          if (1 & e2 && (t2 = r(t2)), 8 & e2)
            return t2;
          if (4 & e2 && "object" == typeof t2 && t2 && t2.__esModule)
            return t2;
          var n = /* @__PURE__ */ Object.create(null);
          if (r.r(n), Object.defineProperty(n, "default", { enumerable: true, value: t2 }), 2 & e2 && "string" != typeof t2)
            for (var i2 in t2)
              r.d(n, i2, function(e3) {
                return t2[e3];
              }.bind(null, i2));
          return n;
        }, r.n = function(t2) {
          var e2 = t2 && t2.__esModule ? function() {
            return t2.default;
          } : function() {
            return t2;
          };
          return r.d(e2, "a", e2), e2;
        }, r.o = function(t2, e2) {
          return Object.prototype.hasOwnProperty.call(t2, e2);
        }, r.p = "", r(r.s = 0);
      }([function(t, e, r) {
        r.r(e), r.d(e, "encode", function() {
          return T;
        }), r.d(e, "decode", function() {
          return V2;
        }), r.d(e, "decodeAsync", function() {
          return Y;
        }), r.d(e, "decodeArrayStream", function() {
          return Z;
        }), r.d(e, "decodeStream", function() {
          return $2;
        }), r.d(e, "Decoder", function() {
          return O;
        }), r.d(e, "Encoder", function() {
          return I;
        }), r.d(e, "ExtensionCodec", function() {
          return S;
        }), r.d(e, "ExtData", function() {
          return p;
        }), r.d(e, "EXT_TIMESTAMP", function() {
          return w;
        }), r.d(e, "encodeDateToTimeSpec", function() {
          return g;
        }), r.d(e, "encodeTimeSpecToTimestamp", function() {
          return v;
        }), r.d(e, "decodeTimestampToTimeSpec", function() {
          return U;
        }), r.d(e, "encodeTimestampExtension", function() {
          return b;
        }), r.d(e, "decodeTimestampExtension", function() {
          return m;
        });
        var n = function(t2, e2) {
          var r2 = "function" == typeof Symbol && t2[Symbol.iterator];
          if (!r2)
            return t2;
          var n2, i22, o2 = r2.call(t2), s2 = [];
          try {
            for (; (void 0 === e2 || e2-- > 0) && !(n2 = o2.next()).done; )
              s2.push(n2.value);
          } catch (t3) {
            i22 = { error: t3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i22)
                throw i22.error;
            }
          }
          return s2;
        }, i2 = function() {
          for (var t2 = [], e2 = 0; e2 < arguments.length; e2++)
            t2 = t2.concat(n(arguments[e2]));
          return t2;
        }, o = "undefined" != typeof process && "undefined" != typeof TextEncoder && "undefined" != typeof TextDecoder;
        function s(t2) {
          for (var e2 = t2.length, r2 = 0, n2 = 0; n2 < e2; ) {
            var i22 = t2.charCodeAt(n2++);
            if (0 != (4294967168 & i22))
              if (0 == (4294965248 & i22))
                r2 += 2;
              else {
                if (i22 >= 55296 && i22 <= 56319 && n2 < e2) {
                  var o2 = t2.charCodeAt(n2);
                  56320 == (64512 & o2) && (++n2, i22 = ((1023 & i22) << 10) + (1023 & o2) + 65536);
                }
                r2 += 0 == (4294901760 & i22) ? 3 : 4;
              }
            else
              r2++;
          }
          return r2;
        }
        var a = o ? new TextEncoder() : void 0, h = "undefined" != typeof process ? 200 : 0;
        var u = (null == a ? void 0 : a.encodeInto) ? function(t2, e2, r2) {
          a.encodeInto(t2, e2.subarray(r2));
        } : function(t2, e2, r2) {
          e2.set(a.encode(t2), r2);
        };
        function c(t2, e2, r2) {
          for (var n2 = e2, o2 = n2 + r2, s2 = [], a2 = ""; n2 < o2; ) {
            var h2 = t2[n2++];
            if (0 == (128 & h2))
              s2.push(h2);
            else if (192 == (224 & h2)) {
              var u2 = 63 & t2[n2++];
              s2.push((31 & h2) << 6 | u2);
            } else if (224 == (240 & h2)) {
              u2 = 63 & t2[n2++];
              var c2 = 63 & t2[n2++];
              s2.push((31 & h2) << 12 | u2 << 6 | c2);
            } else if (240 == (248 & h2)) {
              var f2 = (7 & h2) << 18 | (u2 = 63 & t2[n2++]) << 12 | (c2 = 63 & t2[n2++]) << 6 | 63 & t2[n2++];
              f2 > 65535 && (f2 -= 65536, s2.push(f2 >>> 10 & 1023 | 55296), f2 = 56320 | 1023 & f2), s2.push(f2);
            } else
              s2.push(h2);
            s2.length >= 4096 && (a2 += String.fromCharCode.apply(String, i2(s2)), s2.length = 0);
          }
          return s2.length > 0 && (a2 += String.fromCharCode.apply(String, i2(s2))), a2;
        }
        var f = o ? new TextDecoder() : null, l = "undefined" != typeof process ? 200 : 0;
        var p = function(t2, e2) {
          this.type = t2, this.data = e2;
        };
        function d(t2, e2, r2) {
          var n2 = Math.floor(r2 / 4294967296), i22 = r2;
          t2.setUint32(e2, n2), t2.setUint32(e2 + 4, i22);
        }
        function y(t2, e2) {
          var r2 = t2.getInt32(e2), n2 = t2.getUint32(e2 + 4), i22 = r2 < Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) || r2 === Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) && 0 === n2, o2 = r2 > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296);
          return i22 || o2 ? BigInt(r2) * BigInt(4294967296) + BigInt(n2) : 4294967296 * r2 + n2;
        }
        var w = -1;
        function v(t2) {
          var e2 = t2.sec, r2 = t2.nsec;
          if (e2 >= 0 && r2 >= 0 && e2 <= 17179869183) {
            if (0 === r2 && e2 <= 4294967295) {
              var n2 = new Uint8Array(4);
              return (s2 = new DataView(n2.buffer)).setUint32(0, e2), n2;
            }
            var i22 = e2 / 4294967296, o2 = 4294967295 & e2;
            n2 = new Uint8Array(8);
            return (s2 = new DataView(n2.buffer)).setUint32(0, r2 << 2 | 3 & i22), s2.setUint32(4, o2), n2;
          }
          var s2;
          n2 = new Uint8Array(12);
          return (s2 = new DataView(n2.buffer)).setUint32(0, r2), d(s2, 4, e2), n2;
        }
        function g(t2) {
          var e2 = t2.getTime(), r2 = Math.floor(e2 / 1e3), n2 = 1e6 * (e2 - 1e3 * r2), i22 = Math.floor(n2 / 1e9);
          return { sec: r2 + i22, nsec: n2 - 1e9 * i22 };
        }
        function b(t2) {
          return t2 instanceof Date ? v(g(t2)) : null;
        }
        function U(t2) {
          var e2 = new DataView(t2.buffer, t2.byteOffset, t2.byteLength);
          switch (t2.byteLength) {
            case 4:
              return { sec: e2.getUint32(0), nsec: 0 };
            case 8:
              var r2 = e2.getUint32(0);
              return { sec: 4294967296 * (3 & r2) + e2.getUint32(4), nsec: r2 >>> 2 };
            case 12:
              return { sec: y(e2, 4), nsec: e2.getUint32(0) };
            default:
              throw new Error("Unrecognized data size for timestamp: " + t2.length);
          }
        }
        function m(t2) {
          var e2 = U(t2);
          return new Date(1e3 * e2.sec + e2.nsec / 1e6);
        }
        var x = { type: w, encode: b, decode: m }, S = function() {
          function t2() {
            this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(x);
          }
          return t2.prototype.register = function(t3) {
            var e2 = t3.type, r2 = t3.encode, n2 = t3.decode;
            if (e2 >= 0)
              this.encoders[e2] = r2, this.decoders[e2] = n2;
            else {
              var i22 = 1 + e2;
              this.builtInEncoders[i22] = r2, this.builtInDecoders[i22] = n2;
            }
          }, t2.prototype.tryToEncode = function(t3, e2) {
            for (var r2 = 0; r2 < this.builtInEncoders.length; r2++) {
              if (null != (n2 = this.builtInEncoders[r2])) {
                if (null != (i22 = n2(t3, e2)))
                  return new p(-1 - r2, i22);
              }
            }
            for (r2 = 0; r2 < this.encoders.length; r2++) {
              var n2, i22;
              if (null != (n2 = this.encoders[r2])) {
                if (null != (i22 = n2(t3, e2)))
                  return new p(r2, i22);
              }
            }
            return t3 instanceof p ? t3 : null;
          }, t2.prototype.decode = function(t3, e2, r2) {
            var n2 = e2 < 0 ? this.builtInDecoders[-1 - e2] : this.decoders[e2];
            return n2 ? n2(t3, e2, r2) : new p(e2, t3);
          }, t2.defaultCodec = new t2(), t2;
        }();
        function B(t2) {
          return t2 instanceof Uint8Array ? t2 : ArrayBuffer.isView(t2) ? new Uint8Array(t2.buffer, t2.byteOffset, t2.byteLength) : t2 instanceof ArrayBuffer ? new Uint8Array(t2) : Uint8Array.from(t2);
        }
        var E = function(t2) {
          var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
          if (r2)
            return r2.call(t2);
          if (t2 && "number" == typeof t2.length)
            return { next: function() {
              return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
            } };
          throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, I = function() {
          function t2(t3, e2, r2, n2, i22, o2, s2, a2) {
            void 0 === t3 && (t3 = S.defaultCodec), void 0 === e2 && (e2 = void 0), void 0 === r2 && (r2 = 100), void 0 === n2 && (n2 = 2048), void 0 === i22 && (i22 = false), void 0 === o2 && (o2 = false), void 0 === s2 && (s2 = false), void 0 === a2 && (a2 = false), this.extensionCodec = t3, this.context = e2, this.maxDepth = r2, this.initialBufferSize = n2, this.sortKeys = i22, this.forceFloat32 = o2, this.ignoreUndefined = s2, this.forceIntegerToFloat = a2, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer);
          }
          return t2.prototype.getUint8Array = function() {
            return this.bytes.subarray(0, this.pos);
          }, t2.prototype.reinitializeState = function() {
            this.pos = 0;
          }, t2.prototype.encode = function(t3) {
            return this.reinitializeState(), this.doEncode(t3, 1), this.getUint8Array();
          }, t2.prototype.doEncode = function(t3, e2) {
            if (e2 > this.maxDepth)
              throw new Error("Too deep objects in depth " + e2);
            null == t3 ? this.encodeNil() : "boolean" == typeof t3 ? this.encodeBoolean(t3) : "number" == typeof t3 ? this.encodeNumber(t3) : "string" == typeof t3 ? this.encodeString(t3) : "bigint" == typeof t3 ? this.encodebigint(t3) : this.encodeObject(t3, e2);
          }, t2.prototype.ensureBufferSizeToWrite = function(t3) {
            var e2 = this.pos + t3;
            this.view.byteLength < e2 && this.resizeBuffer(2 * e2);
          }, t2.prototype.resizeBuffer = function(t3) {
            var e2 = new ArrayBuffer(t3), r2 = new Uint8Array(e2), n2 = new DataView(e2);
            r2.set(this.bytes), this.view = n2, this.bytes = r2;
          }, t2.prototype.encodeNil = function() {
            this.writeU8(192);
          }, t2.prototype.encodeBoolean = function(t3) {
            false === t3 ? this.writeU8(194) : this.writeU8(195);
          }, t2.prototype.encodeNumber = function(t3) {
            Number.isSafeInteger(t3) && !this.forceIntegerToFloat ? t3 >= 0 ? t3 < 128 ? this.writeU8(t3) : t3 < 256 ? (this.writeU8(204), this.writeU8(t3)) : t3 < 65536 ? (this.writeU8(205), this.writeU16(t3)) : t3 < 4294967296 ? (this.writeU8(206), this.writeU32(t3)) : (this.writeU8(207), this.writeU64(t3)) : t3 >= -32 ? this.writeU8(224 | t3 + 32) : t3 >= -128 ? (this.writeU8(208), this.writeI8(t3)) : t3 >= -32768 ? (this.writeU8(209), this.writeI16(t3)) : t3 >= -2147483648 ? (this.writeU8(210), this.writeI32(t3)) : (this.writeU8(211), this.writeI64(t3)) : this.forceFloat32 ? (this.writeU8(202), this.writeF32(t3)) : (this.writeU8(203), this.writeF64(t3));
          }, t2.prototype.encodebigint = function(t3) {
            t3 >= BigInt(0) ? t3 < BigInt(128) ? this.writeU8(Number(t3)) : t3 < BigInt(256) ? (this.writeU8(204), this.writeU8(Number(t3))) : t3 < BigInt(65536) ? (this.writeU8(205), this.writeU16(Number(t3))) : t3 < BigInt(4294967296) ? (this.writeU8(206), this.writeU32(Number(t3))) : (this.writeU8(207), this.writeBig64(t3)) : t3 >= BigInt(-32) ? this.writeU8(224 | Number(t3) + 32) : t3 >= BigInt(-128) ? (this.writeU8(208), this.writeI8(Number(t3))) : t3 >= BigInt(-32768) ? (this.writeU8(209), this.writeI16(Number(t3))) : t3 >= BigInt(-2147483648) ? (this.writeU8(210), this.writeI32(Number(t3))) : (this.writeU8(211), this.writeBig64(t3));
          }, t2.prototype.writeStringHeader = function(t3) {
            if (t3 < 32)
              this.writeU8(160 + t3);
            else if (t3 < 256)
              this.writeU8(217), this.writeU8(t3);
            else if (t3 < 65536)
              this.writeU8(218), this.writeU16(t3);
            else {
              if (!(t3 < 4294967296))
                throw new Error("Too long string: " + t3 + " bytes in UTF-8");
              this.writeU8(219), this.writeU32(t3);
            }
          }, t2.prototype.encodeString = function(t3) {
            var e2 = t3.length;
            if (o && e2 > h) {
              var r2 = s(t3);
              this.ensureBufferSizeToWrite(5 + r2), this.writeStringHeader(r2), u(t3, this.bytes, this.pos), this.pos += r2;
            } else {
              r2 = s(t3);
              this.ensureBufferSizeToWrite(5 + r2), this.writeStringHeader(r2), function(t4, e3, r3) {
                for (var n2 = t4.length, i22 = r3, o2 = 0; o2 < n2; ) {
                  var s2 = t4.charCodeAt(o2++);
                  if (0 != (4294967168 & s2)) {
                    if (0 == (4294965248 & s2))
                      e3[i22++] = s2 >> 6 & 31 | 192;
                    else {
                      if (s2 >= 55296 && s2 <= 56319 && o2 < n2) {
                        var a2 = t4.charCodeAt(o2);
                        56320 == (64512 & a2) && (++o2, s2 = ((1023 & s2) << 10) + (1023 & a2) + 65536);
                      }
                      0 == (4294901760 & s2) ? (e3[i22++] = s2 >> 12 & 15 | 224, e3[i22++] = s2 >> 6 & 63 | 128) : (e3[i22++] = s2 >> 18 & 7 | 240, e3[i22++] = s2 >> 12 & 63 | 128, e3[i22++] = s2 >> 6 & 63 | 128);
                    }
                    e3[i22++] = 63 & s2 | 128;
                  } else
                    e3[i22++] = s2;
                }
              }(t3, this.bytes, this.pos), this.pos += r2;
            }
          }, t2.prototype.encodeObject = function(t3, e2) {
            var r2 = this.extensionCodec.tryToEncode(t3, this.context);
            if (null != r2)
              this.encodeExtension(r2);
            else if (Array.isArray(t3))
              this.encodeArray(t3, e2);
            else if (ArrayBuffer.isView(t3))
              this.encodeBinary(t3);
            else {
              if ("object" != typeof t3)
                throw new Error("Unrecognized object: " + Object.prototype.toString.apply(t3));
              this.encodeMap(t3, e2);
            }
          }, t2.prototype.encodeBinary = function(t3) {
            var e2 = t3.byteLength;
            if (e2 < 256)
              this.writeU8(196), this.writeU8(e2);
            else if (e2 < 65536)
              this.writeU8(197), this.writeU16(e2);
            else {
              if (!(e2 < 4294967296))
                throw new Error("Too large binary: " + e2);
              this.writeU8(198), this.writeU32(e2);
            }
            var r2 = B(t3);
            this.writeU8a(r2);
          }, t2.prototype.encodeArray = function(t3, e2) {
            var r2, n2, i22 = t3.length;
            if (i22 < 16)
              this.writeU8(144 + i22);
            else if (i22 < 65536)
              this.writeU8(220), this.writeU16(i22);
            else {
              if (!(i22 < 4294967296))
                throw new Error("Too large array: " + i22);
              this.writeU8(221), this.writeU32(i22);
            }
            try {
              for (var o2 = E(t3), s2 = o2.next(); !s2.done; s2 = o2.next()) {
                var a2 = s2.value;
                this.doEncode(a2, e2 + 1);
              }
            } catch (t4) {
              r2 = { error: t4 };
            } finally {
              try {
                s2 && !s2.done && (n2 = o2.return) && n2.call(o2);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
          }, t2.prototype.countWithoutUndefined = function(t3, e2) {
            var r2, n2, i22 = 0;
            try {
              for (var o2 = E(e2), s2 = o2.next(); !s2.done; s2 = o2.next()) {
                void 0 !== t3[s2.value] && i22++;
              }
            } catch (t4) {
              r2 = { error: t4 };
            } finally {
              try {
                s2 && !s2.done && (n2 = o2.return) && n2.call(o2);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
            return i22;
          }, t2.prototype.encodeMap = function(t3, e2) {
            var r2, n2, i22 = Object.keys(t3);
            this.sortKeys && i22.sort();
            var o2 = this.ignoreUndefined ? this.countWithoutUndefined(t3, i22) : i22.length;
            if (o2 < 16)
              this.writeU8(128 + o2);
            else if (o2 < 65536)
              this.writeU8(222), this.writeU16(o2);
            else {
              if (!(o2 < 4294967296))
                throw new Error("Too large map object: " + o2);
              this.writeU8(223), this.writeU32(o2);
            }
            try {
              for (var s2 = E(i22), a2 = s2.next(); !a2.done; a2 = s2.next()) {
                var h2 = a2.value, u2 = t3[h2];
                this.ignoreUndefined && void 0 === u2 || (this.encodeString(h2), this.doEncode(u2, e2 + 1));
              }
            } catch (t4) {
              r2 = { error: t4 };
            } finally {
              try {
                a2 && !a2.done && (n2 = s2.return) && n2.call(s2);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
          }, t2.prototype.encodeExtension = function(t3) {
            var e2 = t3.data.length;
            if (1 === e2)
              this.writeU8(212);
            else if (2 === e2)
              this.writeU8(213);
            else if (4 === e2)
              this.writeU8(214);
            else if (8 === e2)
              this.writeU8(215);
            else if (16 === e2)
              this.writeU8(216);
            else if (e2 < 256)
              this.writeU8(199), this.writeU8(e2);
            else if (e2 < 65536)
              this.writeU8(200), this.writeU16(e2);
            else {
              if (!(e2 < 4294967296))
                throw new Error("Too large extension object: " + e2);
              this.writeU8(201), this.writeU32(e2);
            }
            this.writeI8(t3.type), this.writeU8a(t3.data);
          }, t2.prototype.writeU8 = function(t3) {
            this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, t3), this.pos++;
          }, t2.prototype.writeU8a = function(t3) {
            var e2 = t3.length;
            this.ensureBufferSizeToWrite(e2), this.bytes.set(t3, this.pos), this.pos += e2;
          }, t2.prototype.writeI8 = function(t3) {
            this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, t3), this.pos++;
          }, t2.prototype.writeU16 = function(t3) {
            this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, t3), this.pos += 2;
          }, t2.prototype.writeI16 = function(t3) {
            this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, t3), this.pos += 2;
          }, t2.prototype.writeU32 = function(t3) {
            this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, t3), this.pos += 4;
          }, t2.prototype.writeI32 = function(t3) {
            this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, t3), this.pos += 4;
          }, t2.prototype.writeF32 = function(t3) {
            this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, t3), this.pos += 4;
          }, t2.prototype.writeF64 = function(t3) {
            this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, t3), this.pos += 8;
          }, t2.prototype.writeU64 = function(t3) {
            this.ensureBufferSizeToWrite(8), function(t4, e2, r2) {
              var n2 = r2 / 4294967296, i22 = r2;
              t4.setUint32(e2, n2), t4.setUint32(e2 + 4, i22);
            }(this.view, this.pos, t3), this.pos += 8;
          }, t2.prototype.writeI64 = function(t3) {
            this.ensureBufferSizeToWrite(8), d(this.view, this.pos, t3), this.pos += 8;
          }, t2.prototype.writeBig64 = function(t3) {
            this.ensureBufferSizeToWrite(8), function(t4, e2, r2) {
              var n2 = Number(r2 / BigInt(4294967296)), i22 = Number(r2 % BigInt(4294967296));
              n2 < 0 && 0 !== i22 && (n2 -= 1), t4.setUint32(e2, n2), t4.setUint32(e2 + 4, i22);
            }(this.view, this.pos, t3), this.pos += 8;
          }, t2;
        }(), A = {};
        function T(t2, e2) {
          return void 0 === e2 && (e2 = A), new I(e2.extensionCodec, e2.context, e2.maxDepth, e2.initialBufferSize, e2.sortKeys, e2.forceFloat32, e2.ignoreUndefined, e2.forceIntegerToFloat).encode(t2);
        }
        function L(t2) {
          return (t2 < 0 ? "-" : "") + "0x" + Math.abs(t2).toString(16).padStart(2, "0");
        }
        var M = function() {
          function t2(t3, e2) {
            void 0 === t3 && (t3 = 16), void 0 === e2 && (e2 = 16), this.maxKeyLength = t3, this.maxLengthPerKey = e2, this.hit = 0, this.miss = 0, this.caches = [];
            for (var r2 = 0; r2 < this.maxKeyLength; r2++)
              this.caches.push([]);
          }
          return t2.prototype.canBeCached = function(t3) {
            return t3 > 0 && t3 <= this.maxKeyLength;
          }, t2.prototype.get = function(t3, e2, r2) {
            var n2 = this.caches[r2 - 1], i22 = n2.length;
            t:
              for (var o2 = 0; o2 < i22; o2++) {
                for (var s2 = n2[o2], a2 = s2.bytes, h2 = 0; h2 < r2; h2++)
                  if (a2[h2] !== t3[e2 + h2])
                    continue t;
                return s2.value;
              }
            return null;
          }, t2.prototype.store = function(t3, e2) {
            var r2 = this.caches[t3.length - 1], n2 = { bytes: t3, value: e2 };
            r2.length >= this.maxLengthPerKey ? r2[Math.random() * r2.length | 0] = n2 : r2.push(n2);
          }, t2.prototype.decode = function(t3, e2, r2) {
            var n2 = this.get(t3, e2, r2);
            if (null != n2)
              return this.hit++, n2;
            this.miss++;
            var i22 = c(t3, e2, r2), o2 = Uint8Array.prototype.slice.call(t3, e2, e2 + r2);
            return this.store(o2, i22), i22;
          }, t2;
        }(), k = function(t2, e2, r2, n2) {
          return new (r2 || (r2 = Promise))(function(i22, o2) {
            function s2(t3) {
              try {
                h2(n2.next(t3));
              } catch (t4) {
                o2(t4);
              }
            }
            function a2(t3) {
              try {
                h2(n2.throw(t3));
              } catch (t4) {
                o2(t4);
              }
            }
            function h2(t3) {
              var e3;
              t3.done ? i22(t3.value) : (e3 = t3.value, e3 instanceof r2 ? e3 : new r2(function(t4) {
                t4(e3);
              })).then(s2, a2);
            }
            h2((n2 = n2.apply(t2, e2 || [])).next());
          });
        }, z = function(t2, e2) {
          var r2, n2, i22, o2, s2 = { label: 0, sent: function() {
            if (1 & i22[0])
              throw i22[1];
            return i22[1];
          }, trys: [], ops: [] };
          return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function a2(o3) {
            return function(a3) {
              return function(o4) {
                if (r2)
                  throw new TypeError("Generator is already executing.");
                for (; s2; )
                  try {
                    if (r2 = 1, n2 && (i22 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i22 = n2.return) && i22.call(n2), 0) : n2.next) && !(i22 = i22.call(n2, o4[1])).done)
                      return i22;
                    switch (n2 = 0, i22 && (o4 = [2 & o4[0], i22.value]), o4[0]) {
                      case 0:
                      case 1:
                        i22 = o4;
                        break;
                      case 4:
                        return s2.label++, { value: o4[1], done: false };
                      case 5:
                        s2.label++, n2 = o4[1], o4 = [0];
                        continue;
                      case 7:
                        o4 = s2.ops.pop(), s2.trys.pop();
                        continue;
                      default:
                        if (!(i22 = s2.trys, (i22 = i22.length > 0 && i22[i22.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                          s2 = 0;
                          continue;
                        }
                        if (3 === o4[0] && (!i22 || o4[1] > i22[0] && o4[1] < i22[3])) {
                          s2.label = o4[1];
                          break;
                        }
                        if (6 === o4[0] && s2.label < i22[1]) {
                          s2.label = i22[1], i22 = o4;
                          break;
                        }
                        if (i22 && s2.label < i22[2]) {
                          s2.label = i22[2], s2.ops.push(o4);
                          break;
                        }
                        i22[2] && s2.ops.pop(), s2.trys.pop();
                        continue;
                    }
                    o4 = e2.call(t2, s2);
                  } catch (t3) {
                    o4 = [6, t3], n2 = 0;
                  } finally {
                    r2 = i22 = 0;
                  }
                if (5 & o4[0])
                  throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, a3]);
            };
          }
        }, D = function(t2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var e2, r2 = t2[Symbol.asyncIterator];
          return r2 ? r2.call(t2) : (t2 = "function" == typeof __values ? __values(t2) : t2[Symbol.iterator](), e2 = {}, n2("next"), n2("throw"), n2("return"), e2[Symbol.asyncIterator] = function() {
            return this;
          }, e2);
          function n2(r3) {
            e2[r3] = t2[r3] && function(e3) {
              return new Promise(function(n3, i22) {
                (function(t3, e4, r4, n4) {
                  Promise.resolve(n4).then(function(e5) {
                    t3({ value: e5, done: r4 });
                  }, e4);
                })(n3, i22, (e3 = t2[r3](e3)).done, e3.value);
              });
            };
          }
        }, N = function(t2) {
          return this instanceof N ? (this.v = t2, this) : new N(t2);
        }, C = function(t2, e2, r2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var n2, i22 = r2.apply(t2, e2 || []), o2 = [];
          return n2 = {}, s2("next"), s2("throw"), s2("return"), n2[Symbol.asyncIterator] = function() {
            return this;
          }, n2;
          function s2(t3) {
            i22[t3] && (n2[t3] = function(e3) {
              return new Promise(function(r3, n3) {
                o2.push([t3, e3, r3, n3]) > 1 || a2(t3, e3);
              });
            });
          }
          function a2(t3, e3) {
            try {
              (r3 = i22[t3](e3)).value instanceof N ? Promise.resolve(r3.value.v).then(h2, u2) : c2(o2[0][2], r3);
            } catch (t4) {
              c2(o2[0][3], t4);
            }
            var r3;
          }
          function h2(t3) {
            a2("next", t3);
          }
          function u2(t3) {
            a2("throw", t3);
          }
          function c2(t3, e3) {
            t3(e3), o2.shift(), o2.length && a2(o2[0][0], o2[0][1]);
          }
        }, P = new DataView(new ArrayBuffer(0)), F = new Uint8Array(P.buffer), j = function() {
          try {
            P.getInt8(0);
          } catch (t2) {
            return t2.constructor;
          }
          throw new Error("never reached");
        }(), _ = new j("Insufficient data"), W = new M(), O = function() {
          function t2(t3, e2, r2, n2, i22, o2, s2, a2) {
            void 0 === t3 && (t3 = S.defaultCodec), void 0 === e2 && (e2 = void 0), void 0 === r2 && (r2 = 4294967295), void 0 === n2 && (n2 = 4294967295), void 0 === i22 && (i22 = 4294967295), void 0 === o2 && (o2 = 4294967295), void 0 === s2 && (s2 = 4294967295), void 0 === a2 && (a2 = W), this.extensionCodec = t3, this.context = e2, this.maxStrLength = r2, this.maxBinLength = n2, this.maxArrayLength = i22, this.maxMapLength = o2, this.maxExtLength = s2, this.keyDecoder = a2, this.totalPos = 0, this.pos = 0, this.view = P, this.bytes = F, this.headByte = -1, this.stack = [];
          }
          return t2.prototype.reinitializeState = function() {
            this.totalPos = 0, this.headByte = -1;
          }, t2.prototype.setBuffer = function(t3) {
            this.bytes = B(t3), this.view = function(t4) {
              if (t4 instanceof ArrayBuffer)
                return new DataView(t4);
              var e2 = B(t4);
              return new DataView(e2.buffer, e2.byteOffset, e2.byteLength);
            }(this.bytes), this.pos = 0;
          }, t2.prototype.appendBuffer = function(t3) {
            if (-1 !== this.headByte || this.hasRemaining()) {
              var e2 = this.bytes.subarray(this.pos), r2 = B(t3), n2 = new Uint8Array(e2.length + r2.length);
              n2.set(e2), n2.set(r2, e2.length), this.setBuffer(n2);
            } else
              this.setBuffer(t3);
          }, t2.prototype.hasRemaining = function(t3) {
            return void 0 === t3 && (t3 = 1), this.view.byteLength - this.pos >= t3;
          }, t2.prototype.createNoExtraBytesError = function(t3) {
            var e2 = this.view, r2 = this.pos;
            return new RangeError("Extra " + (e2.byteLength - r2) + " of " + e2.byteLength + " byte(s) found at buffer[" + t3 + "]");
          }, t2.prototype.decode = function(t3) {
            return this.reinitializeState(), this.setBuffer(t3), this.doDecodeSingleSync();
          }, t2.prototype.doDecodeSingleSync = function() {
            var t3 = this.doDecodeSync();
            if (this.hasRemaining())
              throw this.createNoExtraBytesError(this.pos);
            return t3;
          }, t2.prototype.decodeAsync = function(t3) {
            var e2, r2, n2, i22;
            return k(this, void 0, void 0, function() {
              var o2, s2, a2, h2, u2, c2, f2, l2;
              return z(this, function(p2) {
                switch (p2.label) {
                  case 0:
                    o2 = false, p2.label = 1;
                  case 1:
                    p2.trys.push([1, 6, 7, 12]), e2 = D(t3), p2.label = 2;
                  case 2:
                    return [4, e2.next()];
                  case 3:
                    if ((r2 = p2.sent()).done)
                      return [3, 5];
                    if (a2 = r2.value, o2)
                      throw this.createNoExtraBytesError(this.totalPos);
                    this.appendBuffer(a2);
                    try {
                      s2 = this.doDecodeSync(), o2 = true;
                    } catch (t4) {
                      if (!(t4 instanceof j))
                        throw t4;
                    }
                    this.totalPos += this.pos, p2.label = 4;
                  case 4:
                    return [3, 2];
                  case 5:
                    return [3, 12];
                  case 6:
                    return h2 = p2.sent(), n2 = { error: h2 }, [3, 12];
                  case 7:
                    return p2.trys.push([7, , 10, 11]), r2 && !r2.done && (i22 = e2.return) ? [4, i22.call(e2)] : [3, 9];
                  case 8:
                    p2.sent(), p2.label = 9;
                  case 9:
                    return [3, 11];
                  case 10:
                    if (n2)
                      throw n2.error;
                    return [7];
                  case 11:
                    return [7];
                  case 12:
                    if (o2) {
                      if (this.hasRemaining())
                        throw this.createNoExtraBytesError(this.totalPos);
                      return [2, s2];
                    }
                    throw c2 = (u2 = this).headByte, f2 = u2.pos, l2 = u2.totalPos, new RangeError("Insufficient data in parcing " + L(c2) + " at " + l2 + " (" + f2 + " in the current buffer)");
                }
              });
            });
          }, t2.prototype.decodeArrayStream = function(t3) {
            return this.decodeMultiAsync(t3, true);
          }, t2.prototype.decodeStream = function(t3) {
            return this.decodeMultiAsync(t3, false);
          }, t2.prototype.decodeMultiAsync = function(t3, e2) {
            return C(this, arguments, function() {
              var r2, n2, i22, o2, s2, a2, h2, u2, c2;
              return z(this, function(f2) {
                switch (f2.label) {
                  case 0:
                    r2 = e2, n2 = -1, f2.label = 1;
                  case 1:
                    f2.trys.push([1, 13, 14, 19]), i22 = D(t3), f2.label = 2;
                  case 2:
                    return [4, N(i22.next())];
                  case 3:
                    if ((o2 = f2.sent()).done)
                      return [3, 12];
                    if (s2 = o2.value, e2 && 0 === n2)
                      throw this.createNoExtraBytesError(this.totalPos);
                    this.appendBuffer(s2), r2 && (n2 = this.readArraySize(), r2 = false, this.complete()), f2.label = 4;
                  case 4:
                    f2.trys.push([4, 9, , 10]), f2.label = 5;
                  case 5:
                    return [4, N(this.doDecodeSync())];
                  case 6:
                    return [4, f2.sent()];
                  case 7:
                    return f2.sent(), 0 == --n2 ? [3, 8] : [3, 5];
                  case 8:
                    return [3, 10];
                  case 9:
                    if (!((a2 = f2.sent()) instanceof j))
                      throw a2;
                    return [3, 10];
                  case 10:
                    this.totalPos += this.pos, f2.label = 11;
                  case 11:
                    return [3, 2];
                  case 12:
                    return [3, 19];
                  case 13:
                    return h2 = f2.sent(), u2 = { error: h2 }, [3, 19];
                  case 14:
                    return f2.trys.push([14, , 17, 18]), o2 && !o2.done && (c2 = i22.return) ? [4, N(c2.call(i22))] : [3, 16];
                  case 15:
                    f2.sent(), f2.label = 16;
                  case 16:
                    return [3, 18];
                  case 17:
                    if (u2)
                      throw u2.error;
                    return [7];
                  case 18:
                    return [7];
                  case 19:
                    return [2];
                }
              });
            });
          }, t2.prototype.doDecodeSync = function() {
            t:
              for (; ; ) {
                var t3 = this.readHeadByte(), e2 = void 0;
                if (t3 >= 224)
                  e2 = t3 - 256;
                else if (t3 < 192)
                  if (t3 < 128)
                    e2 = t3;
                  else if (t3 < 144) {
                    if (0 !== (n2 = t3 - 128)) {
                      this.pushMapState(n2), this.complete();
                      continue t;
                    }
                    e2 = {};
                  } else if (t3 < 160) {
                    if (0 !== (n2 = t3 - 144)) {
                      this.pushArrayState(n2), this.complete();
                      continue t;
                    }
                    e2 = [];
                  } else {
                    var r2 = t3 - 160;
                    e2 = this.decodeUtf8String(r2, 0);
                  }
                else if (192 === t3)
                  e2 = null;
                else if (194 === t3)
                  e2 = false;
                else if (195 === t3)
                  e2 = true;
                else if (202 === t3)
                  e2 = this.readF32();
                else if (203 === t3)
                  e2 = this.readF64();
                else if (204 === t3)
                  e2 = this.readU8();
                else if (205 === t3)
                  e2 = this.readU16();
                else if (206 === t3)
                  e2 = this.readU32();
                else if (207 === t3)
                  e2 = this.readU64();
                else if (208 === t3)
                  e2 = this.readI8();
                else if (209 === t3)
                  e2 = this.readI16();
                else if (210 === t3)
                  e2 = this.readI32();
                else if (211 === t3)
                  e2 = this.readI64();
                else if (217 === t3) {
                  r2 = this.lookU8();
                  e2 = this.decodeUtf8String(r2, 1);
                } else if (218 === t3) {
                  r2 = this.lookU16();
                  e2 = this.decodeUtf8String(r2, 2);
                } else if (219 === t3) {
                  r2 = this.lookU32();
                  e2 = this.decodeUtf8String(r2, 4);
                } else if (220 === t3) {
                  if (0 !== (n2 = this.readU16())) {
                    this.pushArrayState(n2), this.complete();
                    continue t;
                  }
                  e2 = [];
                } else if (221 === t3) {
                  if (0 !== (n2 = this.readU32())) {
                    this.pushArrayState(n2), this.complete();
                    continue t;
                  }
                  e2 = [];
                } else if (222 === t3) {
                  if (0 !== (n2 = this.readU16())) {
                    this.pushMapState(n2), this.complete();
                    continue t;
                  }
                  e2 = {};
                } else if (223 === t3) {
                  if (0 !== (n2 = this.readU32())) {
                    this.pushMapState(n2), this.complete();
                    continue t;
                  }
                  e2 = {};
                } else if (196 === t3) {
                  var n2 = this.lookU8();
                  e2 = this.decodeBinary(n2, 1);
                } else if (197 === t3) {
                  n2 = this.lookU16();
                  e2 = this.decodeBinary(n2, 2);
                } else if (198 === t3) {
                  n2 = this.lookU32();
                  e2 = this.decodeBinary(n2, 4);
                } else if (212 === t3)
                  e2 = this.decodeExtension(1, 0);
                else if (213 === t3)
                  e2 = this.decodeExtension(2, 0);
                else if (214 === t3)
                  e2 = this.decodeExtension(4, 0);
                else if (215 === t3)
                  e2 = this.decodeExtension(8, 0);
                else if (216 === t3)
                  e2 = this.decodeExtension(16, 0);
                else if (199 === t3) {
                  n2 = this.lookU8();
                  e2 = this.decodeExtension(n2, 1);
                } else if (200 === t3) {
                  n2 = this.lookU16();
                  e2 = this.decodeExtension(n2, 2);
                } else {
                  if (201 !== t3)
                    throw new Error("Unrecognized type byte: " + L(t3));
                  n2 = this.lookU32();
                  e2 = this.decodeExtension(n2, 4);
                }
                this.complete();
                for (var i22 = this.stack; i22.length > 0; ) {
                  var o2 = i22[i22.length - 1];
                  if (0 === o2.type) {
                    if (o2.array[o2.position] = e2, o2.position++, o2.position !== o2.size)
                      continue t;
                    i22.pop(), e2 = o2.array;
                  } else {
                    if (1 === o2.type) {
                      if (s2 = void 0, "string" !== (s2 = typeof e2) && "number" !== s2)
                        throw new Error("The type of key must be string or number but " + typeof e2);
                      o2.key = e2, o2.type = 2;
                      continue t;
                    }
                    if (o2.map[o2.key] = e2, o2.readCount++, o2.readCount !== o2.size) {
                      o2.key = null, o2.type = 1;
                      continue t;
                    }
                    i22.pop(), e2 = o2.map;
                  }
                }
                return e2;
              }
            var s2;
          }, t2.prototype.readHeadByte = function() {
            return -1 === this.headByte && (this.headByte = this.readU8()), this.headByte;
          }, t2.prototype.complete = function() {
            this.headByte = -1;
          }, t2.prototype.readArraySize = function() {
            var t3 = this.readHeadByte();
            switch (t3) {
              case 220:
                return this.readU16();
              case 221:
                return this.readU32();
              default:
                if (t3 < 160)
                  return t3 - 144;
                throw new Error("Unrecognized array type byte: " + L(t3));
            }
          }, t2.prototype.pushMapState = function(t3) {
            if (t3 > this.maxMapLength)
              throw new Error("Max length exceeded: map length (" + t3 + ") > maxMapLengthLength (" + this.maxMapLength + ")");
            this.stack.push({ type: 1, size: t3, key: null, readCount: 0, map: {} });
          }, t2.prototype.pushArrayState = function(t3) {
            if (t3 > this.maxArrayLength)
              throw new Error("Max length exceeded: array length (" + t3 + ") > maxArrayLength (" + this.maxArrayLength + ")");
            this.stack.push({ type: 0, size: t3, array: new Array(t3), position: 0 });
          }, t2.prototype.decodeUtf8String = function(t3, e2) {
            var r2;
            if (t3 > this.maxStrLength)
              throw new Error("Max length exceeded: UTF-8 byte length (" + t3 + ") > maxStrLength (" + this.maxStrLength + ")");
            if (this.bytes.byteLength < this.pos + e2 + t3)
              throw _;
            var n2, i22 = this.pos + e2;
            return n2 = this.stateIsMapKey() && (null === (r2 = this.keyDecoder) || void 0 === r2 ? void 0 : r2.canBeCached(t3)) ? this.keyDecoder.decode(this.bytes, i22, t3) : o && t3 > l ? function(t4, e3, r3) {
              var n3 = t4.subarray(e3, e3 + r3);
              return f.decode(n3);
            }(this.bytes, i22, t3) : c(this.bytes, i22, t3), this.pos += e2 + t3, n2;
          }, t2.prototype.stateIsMapKey = function() {
            return this.stack.length > 0 && 1 === this.stack[this.stack.length - 1].type;
          }, t2.prototype.decodeBinary = function(t3, e2) {
            if (t3 > this.maxBinLength)
              throw new Error("Max length exceeded: bin length (" + t3 + ") > maxBinLength (" + this.maxBinLength + ")");
            if (!this.hasRemaining(t3 + e2))
              throw _;
            var r2 = this.pos + e2, n2 = this.bytes.subarray(r2, r2 + t3);
            return this.pos += e2 + t3, n2;
          }, t2.prototype.decodeExtension = function(t3, e2) {
            if (t3 > this.maxExtLength)
              throw new Error("Max length exceeded: ext length (" + t3 + ") > maxExtLength (" + this.maxExtLength + ")");
            var r2 = this.view.getInt8(this.pos + e2), n2 = this.decodeBinary(t3, e2 + 1);
            return this.extensionCodec.decode(n2, r2, this.context);
          }, t2.prototype.lookU8 = function() {
            return this.view.getUint8(this.pos);
          }, t2.prototype.lookU16 = function() {
            return this.view.getUint16(this.pos);
          }, t2.prototype.lookU32 = function() {
            return this.view.getUint32(this.pos);
          }, t2.prototype.readU8 = function() {
            var t3 = this.view.getUint8(this.pos);
            return this.pos++, t3;
          }, t2.prototype.readI8 = function() {
            var t3 = this.view.getInt8(this.pos);
            return this.pos++, t3;
          }, t2.prototype.readU16 = function() {
            var t3 = this.view.getUint16(this.pos);
            return this.pos += 2, t3;
          }, t2.prototype.readI16 = function() {
            var t3 = this.view.getInt16(this.pos);
            return this.pos += 2, t3;
          }, t2.prototype.readU32 = function() {
            var t3 = this.view.getUint32(this.pos);
            return this.pos += 4, t3;
          }, t2.prototype.readI32 = function() {
            var t3 = this.view.getInt32(this.pos);
            return this.pos += 4, t3;
          }, t2.prototype.readU64 = function() {
            var t3, e2, r2, n2, i22 = (t3 = this.view, e2 = this.pos, r2 = t3.getUint32(e2), n2 = t3.getUint32(e2 + 4), r2 > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296) ? BigInt(r2) * BigInt(4294967296) + BigInt(n2) : 4294967296 * r2 + n2);
            return this.pos += 8, i22;
          }, t2.prototype.readI64 = function() {
            var t3 = y(this.view, this.pos);
            return this.pos += 8, t3;
          }, t2.prototype.readF32 = function() {
            var t3 = this.view.getFloat32(this.pos);
            return this.pos += 4, t3;
          }, t2.prototype.readF64 = function() {
            var t3 = this.view.getFloat64(this.pos);
            return this.pos += 8, t3;
          }, t2;
        }(), R = {};
        function V2(t2, e2) {
          return void 0 === e2 && (e2 = R), new O(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decode(t2);
        }
        var K2 = function(t2, e2) {
          var r2, n2, i22, o2, s2 = { label: 0, sent: function() {
            if (1 & i22[0])
              throw i22[1];
            return i22[1];
          }, trys: [], ops: [] };
          return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function a2(o3) {
            return function(a3) {
              return function(o4) {
                if (r2)
                  throw new TypeError("Generator is already executing.");
                for (; s2; )
                  try {
                    if (r2 = 1, n2 && (i22 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i22 = n2.return) && i22.call(n2), 0) : n2.next) && !(i22 = i22.call(n2, o4[1])).done)
                      return i22;
                    switch (n2 = 0, i22 && (o4 = [2 & o4[0], i22.value]), o4[0]) {
                      case 0:
                      case 1:
                        i22 = o4;
                        break;
                      case 4:
                        return s2.label++, { value: o4[1], done: false };
                      case 5:
                        s2.label++, n2 = o4[1], o4 = [0];
                        continue;
                      case 7:
                        o4 = s2.ops.pop(), s2.trys.pop();
                        continue;
                      default:
                        if (!(i22 = s2.trys, (i22 = i22.length > 0 && i22[i22.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                          s2 = 0;
                          continue;
                        }
                        if (3 === o4[0] && (!i22 || o4[1] > i22[0] && o4[1] < i22[3])) {
                          s2.label = o4[1];
                          break;
                        }
                        if (6 === o4[0] && s2.label < i22[1]) {
                          s2.label = i22[1], i22 = o4;
                          break;
                        }
                        if (i22 && s2.label < i22[2]) {
                          s2.label = i22[2], s2.ops.push(o4);
                          break;
                        }
                        i22[2] && s2.ops.pop(), s2.trys.pop();
                        continue;
                    }
                    o4 = e2.call(t2, s2);
                  } catch (t3) {
                    o4 = [6, t3], n2 = 0;
                  } finally {
                    r2 = i22 = 0;
                  }
                if (5 & o4[0])
                  throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, a3]);
            };
          }
        }, G = function(t2) {
          return this instanceof G ? (this.v = t2, this) : new G(t2);
        }, H = function(t2, e2, r2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var n2, i22 = r2.apply(t2, e2 || []), o2 = [];
          return n2 = {}, s2("next"), s2("throw"), s2("return"), n2[Symbol.asyncIterator] = function() {
            return this;
          }, n2;
          function s2(t3) {
            i22[t3] && (n2[t3] = function(e3) {
              return new Promise(function(r3, n3) {
                o2.push([t3, e3, r3, n3]) > 1 || a2(t3, e3);
              });
            });
          }
          function a2(t3, e3) {
            try {
              (r3 = i22[t3](e3)).value instanceof G ? Promise.resolve(r3.value.v).then(h2, u2) : c2(o2[0][2], r3);
            } catch (t4) {
              c2(o2[0][3], t4);
            }
            var r3;
          }
          function h2(t3) {
            a2("next", t3);
          }
          function u2(t3) {
            a2("throw", t3);
          }
          function c2(t3, e3) {
            t3(e3), o2.shift(), o2.length && a2(o2[0][0], o2[0][1]);
          }
        };
        function X(t2) {
          if (null == t2)
            throw new Error("Assertion Failure: value must not be null nor undefined");
        }
        function q(t2) {
          return null != t2[Symbol.asyncIterator] ? t2 : function(t3) {
            return H(this, arguments, function() {
              var e2, r2, n2, i22;
              return K2(this, function(o2) {
                switch (o2.label) {
                  case 0:
                    e2 = t3.getReader(), o2.label = 1;
                  case 1:
                    o2.trys.push([1, , 9, 10]), o2.label = 2;
                  case 2:
                    return [4, G(e2.read())];
                  case 3:
                    return r2 = o2.sent(), n2 = r2.done, i22 = r2.value, n2 ? [4, G(void 0)] : [3, 5];
                  case 4:
                    return [2, o2.sent()];
                  case 5:
                    return X(i22), [4, G(i22)];
                  case 6:
                    return [4, o2.sent()];
                  case 7:
                    return o2.sent(), [3, 2];
                  case 8:
                    return [3, 10];
                  case 9:
                    return e2.releaseLock(), [7];
                  case 10:
                    return [2];
                }
              });
            });
          }(t2);
        }
        var J = function(t2, e2, r2, n2) {
          return new (r2 || (r2 = Promise))(function(i22, o2) {
            function s2(t3) {
              try {
                h2(n2.next(t3));
              } catch (t4) {
                o2(t4);
              }
            }
            function a2(t3) {
              try {
                h2(n2.throw(t3));
              } catch (t4) {
                o2(t4);
              }
            }
            function h2(t3) {
              var e3;
              t3.done ? i22(t3.value) : (e3 = t3.value, e3 instanceof r2 ? e3 : new r2(function(t4) {
                t4(e3);
              })).then(s2, a2);
            }
            h2((n2 = n2.apply(t2, e2 || [])).next());
          });
        }, Q = function(t2, e2) {
          var r2, n2, i22, o2, s2 = { label: 0, sent: function() {
            if (1 & i22[0])
              throw i22[1];
            return i22[1];
          }, trys: [], ops: [] };
          return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function a2(o3) {
            return function(a3) {
              return function(o4) {
                if (r2)
                  throw new TypeError("Generator is already executing.");
                for (; s2; )
                  try {
                    if (r2 = 1, n2 && (i22 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i22 = n2.return) && i22.call(n2), 0) : n2.next) && !(i22 = i22.call(n2, o4[1])).done)
                      return i22;
                    switch (n2 = 0, i22 && (o4 = [2 & o4[0], i22.value]), o4[0]) {
                      case 0:
                      case 1:
                        i22 = o4;
                        break;
                      case 4:
                        return s2.label++, { value: o4[1], done: false };
                      case 5:
                        s2.label++, n2 = o4[1], o4 = [0];
                        continue;
                      case 7:
                        o4 = s2.ops.pop(), s2.trys.pop();
                        continue;
                      default:
                        if (!(i22 = s2.trys, (i22 = i22.length > 0 && i22[i22.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                          s2 = 0;
                          continue;
                        }
                        if (3 === o4[0] && (!i22 || o4[1] > i22[0] && o4[1] < i22[3])) {
                          s2.label = o4[1];
                          break;
                        }
                        if (6 === o4[0] && s2.label < i22[1]) {
                          s2.label = i22[1], i22 = o4;
                          break;
                        }
                        if (i22 && s2.label < i22[2]) {
                          s2.label = i22[2], s2.ops.push(o4);
                          break;
                        }
                        i22[2] && s2.ops.pop(), s2.trys.pop();
                        continue;
                    }
                    o4 = e2.call(t2, s2);
                  } catch (t3) {
                    o4 = [6, t3], n2 = 0;
                  } finally {
                    r2 = i22 = 0;
                  }
                if (5 & o4[0])
                  throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, a3]);
            };
          }
        };
        function Y(t2, e2) {
          return void 0 === e2 && (e2 = R), J(this, void 0, void 0, function() {
            var r2;
            return Q(this, function(n2) {
              return r2 = q(t2), [2, new O(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decodeAsync(r2)];
            });
          });
        }
        function Z(t2, e2) {
          void 0 === e2 && (e2 = R);
          var r2 = q(t2);
          return new O(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decodeArrayStream(r2);
        }
        function $2(t2, e2) {
          void 0 === e2 && (e2 = R);
          var r2 = q(t2);
          return new O(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decodeStream(r2);
        }
      }]);
    });
  }
});
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports2, module2) {
    var global2 = typeof self !== "undefined" ? self : exports2;
    var __self__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F.prototype = global2;
      return new F();
    }();
    (function(self2) {
      (function(exports22) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView2 = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name9) {
          if (typeof name9 !== "string") {
            name9 = String(name9);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name9)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name9.toLowerCase();
        }
        function normalizeValue2(value2) {
          if (typeof value2 !== "string") {
            value2 = String(value2);
          }
          return value2;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value2 = items.shift();
              return { done: value2 === void 0, value: value2 };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value2, name9) {
              this.append(name9, value2);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name9) {
              this.append(name9, headers[name9]);
            }, this);
          }
        }
        Headers.prototype.append = function(name9, value2) {
          name9 = normalizeName(name9);
          value2 = normalizeValue2(value2);
          var oldValue = this.map[name9];
          this.map[name9] = oldValue ? oldValue + ", " + value2 : value2;
        };
        Headers.prototype["delete"] = function(name9) {
          delete this.map[normalizeName(name9)];
        };
        Headers.prototype.get = function(name9) {
          name9 = normalizeName(name9);
          return this.has(name9) ? this.map[name9] : null;
        };
        Headers.prototype.has = function(name9) {
          return this.map.hasOwnProperty(normalizeName(name9));
        };
        Headers.prototype.set = function(name9, value2) {
          this.map[normalizeName(name9)] = normalizeValue2(value2);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name9 in this.map) {
            if (this.map.hasOwnProperty(name9)) {
              callback.call(thisArg, this.map[name9], name9, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value2, name9) {
            items.push(name9);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value2) {
            items.push(value2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value2, name9) {
            items.push([name9, value2]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader3) {
          return new Promise(function(resolve7, reject) {
            reader3.onload = function() {
              resolve7(reader3.result);
            };
            reader3.onerror = function() {
              reject(reader3.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader3 = new FileReader();
          var promise = fileReaderReady(reader3);
          reader3.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader3 = new FileReader();
          var promise = fileReaderReady(reader3);
          reader3.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf2) {
          var view = new Uint8Array(buf2);
          var chars2 = new Array(view.length);
          for (var i2 = 0; i2 < view.length; i2++) {
            chars2[i2] = String.fromCharCode(view[i2]);
          }
          return chars2.join("");
        }
        function bufferClone(buf2) {
          if (buf2.slice) {
            return buf2.slice(0);
          } else {
            var view = new Uint8Array(buf2.byteLength);
            view.set(new Uint8Array(buf2));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView2(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode42);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods2 = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods2.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request2(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request2) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request2.prototype.clone = function() {
          return new Request2(this, { body: this._bodyInit });
        };
        function decode42(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name9 = split.shift().replace(/\+/g, " ");
              var value2 = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name9), decodeURIComponent(value2));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts2 = line.split(":");
            var key = parts2.shift().trim();
            if (key) {
              var value2 = parts2.join(":").trim();
              headers.append(key, value2);
            }
          });
          return headers;
        }
        Body.call(Request2.prototype);
        function Response2(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response2.prototype);
        Response2.prototype.clone = function() {
          return new Response2(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response2.error = function() {
          var response = new Response2(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response2.redirect = function(url2, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response2(null, { status, headers: { location: url2 } });
        };
        exports22.DOMException = self2.DOMException;
        try {
          new exports22.DOMException();
        } catch (err2) {
          exports22.DOMException = function(message2, name9) {
            this.message = message2;
            this.name = name9;
            var error = Error(message2);
            this.stack = error.stack;
          };
          exports22.DOMException.prototype = Object.create(Error.prototype);
          exports22.DOMException.prototype.constructor = exports22.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve7, reject) {
            var request2 = new Request2(input, init);
            if (request2.signal && request2.signal.aborted) {
              return reject(new exports22.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve7(new Response2(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports22.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request2.method, request2.url, true);
            if (request2.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request2.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request2.headers.forEach(function(value2, name9) {
              xhr.setRequestHeader(name9, value2);
            });
            if (request2.signal) {
              request2.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request2.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request2._bodyInit === "undefined" ? null : request2._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch2;
          self2.Headers = Headers;
          self2.Request = Request2;
          self2.Response = Response2;
        }
        exports22.Headers = Headers;
        exports22.Request = Request2;
        exports22.Response = Response2;
        exports22.fetch = fetch2;
        Object.defineProperty(exports22, "__esModule", { value: true });
        return exports22;
      })({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports2 = ctx.fetch;
    exports2.default = ctx.fetch;
    exports2.fetch = ctx.fetch;
    exports2.Headers = ctx.Headers;
    exports2.Request = ctx.Request;
    exports2.Response = ctx.Response;
    module2.exports = exports2;
  }
});
var main_exports = {};
__export(main_exports, {
  ABIAddressType: () => ABIAddressType,
  ABIArrayDynamicType: () => ABIArrayDynamicType,
  ABIArrayStaticType: () => ABIArrayStaticType,
  ABIBoolType: () => ABIBoolType,
  ABIByteType: () => ABIByteType,
  ABIContract: () => ABIContract,
  ABIInterface: () => ABIInterface,
  ABIMethod: () => ABIMethod,
  ABIReferenceType: () => ABIReferenceType,
  ABIStringType: () => ABIStringType,
  ABITransactionType: () => ABITransactionType,
  ABITupleType: () => ABITupleType,
  ABIType: () => ABIType,
  ABIUfixedType: () => ABIUfixedType,
  ABIUintType: () => ABIUintType,
  ADDR_BYTE_SIZE: () => ADDR_BYTE_SIZE,
  ALGORAND_MIN_TX_FEE: () => ALGORAND_MIN_TX_FEE,
  Algodv2: () => AlgodClient,
  AtomicTransactionComposer: () => AtomicTransactionComposer,
  AtomicTransactionComposerStatus: () => AtomicTransactionComposerStatus,
  DryrunResult: () => DryrunResult,
  ERROR_INVALID_MICROALGOS: () => ERROR_INVALID_MICROALGOS,
  ERROR_MULTISIG_BAD_SENDER: () => ERROR_MULTISIG_BAD_SENDER,
  INVALID_MICROALGOS_ERROR_MSG: () => INVALID_MICROALGOS_ERROR_MSG,
  Indexer: () => IndexerClient,
  IntDecoding: () => intDecoding_default,
  Kmd: () => Kmd,
  LENGTH_ENCODE_BYTE_SIZE: () => LENGTH_ENCODE_BYTE_SIZE,
  LogicSig: () => LogicSig,
  LogicSigAccount: () => LogicSigAccount,
  MAX_LEN: () => MAX_LEN,
  MULTISIG_BAD_SENDER_ERROR_MSG: () => MULTISIG_BAD_SENDER_ERROR_MSG,
  OnApplicationComplete: () => OnApplicationComplete,
  SINGLE_BOOL_SIZE: () => SINGLE_BOOL_SIZE,
  SINGLE_BYTE_SIZE: () => SINGLE_BYTE_SIZE,
  SourceMap: () => SourceMap,
  Transaction: () => Transaction,
  TransactionType: () => TransactionType,
  abiCheckTransactionType: () => abiCheckTransactionType,
  abiTypeIsReference: () => abiTypeIsReference,
  abiTypeIsTransaction: () => abiTypeIsTransaction,
  algosToMicroalgos: () => algosToMicroalgos,
  appendSignMultisigTransaction: () => appendSignMultisigTransaction,
  appendSignRawMultisigSignature: () => appendSignRawMultisigSignature,
  assignGroupID: () => assignGroupID,
  bigIntToBytes: () => bigIntToBytes,
  bytesToBigInt: () => bytesToBigInt,
  computeGroupID: () => computeGroupID,
  createDryrun: () => createDryrun,
  createMultisigTransaction: () => createMultisigTransaction,
  decodeAddress: () => decodeAddress,
  decodeObj: () => decodeObj,
  decodeSignedTransaction: () => decodeSignedTransaction,
  decodeUint64: () => decodeUint64,
  decodeUnsignedTransaction: () => decodeUnsignedTransaction,
  encodeAddress: () => encodeAddress,
  encodeObj: () => encodeObj,
  encodeUint64: () => encodeUint64,
  encodeUnsignedTransaction: () => encodeUnsignedTransaction,
  generateAccount: () => generateAccount,
  getApplicationAddress: () => getApplicationAddress,
  getMethodByName: () => getMethodByName,
  indexerModels: () => types_exports2,
  instantiateTxnIfNeeded: () => instantiateTxnIfNeeded,
  isTransactionWithSigner: () => isTransactionWithSigner,
  isValidAddress: () => isValidAddress,
  logicSigFromByte: () => logicSigFromByte,
  makeApplicationCallTxnFromObject: () => makeApplicationCallTxnFromObject,
  makeApplicationClearStateTxn: () => makeApplicationClearStateTxn,
  makeApplicationClearStateTxnFromObject: () => makeApplicationClearStateTxnFromObject,
  makeApplicationCloseOutTxn: () => makeApplicationCloseOutTxn,
  makeApplicationCloseOutTxnFromObject: () => makeApplicationCloseOutTxnFromObject,
  makeApplicationCreateTxn: () => makeApplicationCreateTxn,
  makeApplicationCreateTxnFromObject: () => makeApplicationCreateTxnFromObject,
  makeApplicationDeleteTxn: () => makeApplicationDeleteTxn,
  makeApplicationDeleteTxnFromObject: () => makeApplicationDeleteTxnFromObject,
  makeApplicationNoOpTxn: () => makeApplicationNoOpTxn,
  makeApplicationNoOpTxnFromObject: () => makeApplicationNoOpTxnFromObject,
  makeApplicationOptInTxn: () => makeApplicationOptInTxn,
  makeApplicationOptInTxnFromObject: () => makeApplicationOptInTxnFromObject,
  makeApplicationUpdateTxn: () => makeApplicationUpdateTxn,
  makeApplicationUpdateTxnFromObject: () => makeApplicationUpdateTxnFromObject,
  makeAssetConfigTxnWithSuggestedParams: () => makeAssetConfigTxnWithSuggestedParams,
  makeAssetConfigTxnWithSuggestedParamsFromObject: () => makeAssetConfigTxnWithSuggestedParamsFromObject,
  makeAssetCreateTxnWithSuggestedParams: () => makeAssetCreateTxnWithSuggestedParams,
  makeAssetCreateTxnWithSuggestedParamsFromObject: () => makeAssetCreateTxnWithSuggestedParamsFromObject,
  makeAssetDestroyTxnWithSuggestedParams: () => makeAssetDestroyTxnWithSuggestedParams,
  makeAssetDestroyTxnWithSuggestedParamsFromObject: () => makeAssetDestroyTxnWithSuggestedParamsFromObject,
  makeAssetFreezeTxnWithSuggestedParams: () => makeAssetFreezeTxnWithSuggestedParams,
  makeAssetFreezeTxnWithSuggestedParamsFromObject: () => makeAssetFreezeTxnWithSuggestedParamsFromObject,
  makeAssetTransferTxnWithSuggestedParams: () => makeAssetTransferTxnWithSuggestedParams,
  makeAssetTransferTxnWithSuggestedParamsFromObject: () => makeAssetTransferTxnWithSuggestedParamsFromObject,
  makeBasicAccountTransactionSigner: () => makeBasicAccountTransactionSigner,
  makeKeyRegistrationTxnWithSuggestedParams: () => makeKeyRegistrationTxnWithSuggestedParams,
  makeKeyRegistrationTxnWithSuggestedParamsFromObject: () => makeKeyRegistrationTxnWithSuggestedParamsFromObject,
  makeLogicSigAccountTransactionSigner: () => makeLogicSigAccountTransactionSigner,
  makeMultiSigAccountTransactionSigner: () => makeMultiSigAccountTransactionSigner,
  makePaymentTxnWithSuggestedParams: () => makePaymentTxnWithSuggestedParams,
  makePaymentTxnWithSuggestedParamsFromObject: () => makePaymentTxnWithSuggestedParamsFromObject,
  masterDerivationKeyToMnemonic: () => masterDerivationKeyToMnemonic,
  mergeMultisigTransactions: () => mergeMultisigTransactions,
  microalgosToAlgos: () => microalgosToAlgos,
  mnemonicFromSeed: () => mnemonicFromSeed,
  mnemonicToMasterDerivationKey: () => mnemonicToMasterDerivationKey,
  mnemonicToSecretKey: () => mnemonicToSecretKey,
  modelsv2: () => types_exports,
  multisigAddress: () => multisigAddress,
  secretKeyToMnemonic: () => secretKeyToMnemonic,
  seedFromMnemonic: () => seedFromMnemonic,
  signBid: () => signBid,
  signBytes: () => signBytes,
  signLogicSigTransaction: () => signLogicSigTransaction,
  signLogicSigTransactionObject: () => signLogicSigTransactionObject,
  signMultisigTransaction: () => signMultisigTransaction,
  signTransaction: () => signTransaction,
  tealSign: () => tealSign,
  tealSignFromProgram: () => tealSignFromProgram,
  verifyBytes: () => verifyBytes,
  verifyMultisig: () => verifyMultisig,
  waitForConfirmation: () => waitForConfirmation
});
var import_tweetnacl = __toESM(require_nacl_fast());
var import_js_sha512 = __toESM(require_sha512());
function genericHash(arr) {
  return import_js_sha512.default.sha512_256.array(arr);
}
function randomBytes(length3) {
  return import_tweetnacl.default.randomBytes(length3);
}
function keyPairFromSeed(seed2) {
  return import_tweetnacl.default.sign.keyPair.fromSeed(seed2);
}
function keyPair() {
  const seed2 = randomBytes(import_tweetnacl.default.box.secretKeyLength);
  return keyPairFromSeed(seed2);
}
function isValidSignatureLength(len) {
  return len === import_tweetnacl.default.sign.signatureLength;
}
function keyPairFromSecretKey(sk) {
  return import_tweetnacl.default.sign.keyPair.fromSecretKey(sk);
}
function sign(msg, secretKey) {
  return import_tweetnacl.default.sign.detached(msg, secretKey);
}
function bytesEqual(a, b) {
  return import_tweetnacl.default.verify(a, b);
}
function verify(message2, signature, verifyKey) {
  return import_tweetnacl.default.sign.detached.verify(message2, signature, verifyKey);
}
var PUBLIC_KEY_LENGTH = import_tweetnacl.default.sign.publicKeyLength;
import_tweetnacl.default.sign.secretKeyLength;
var HASH_BYTES_LENGTH = 32;
var SEED_BTYES_LENGTH = 32;
var import_hi_base32 = __toESM(require_base32());
var import_json_bigint = __toESM(require_json_bigint());
var IntDecoding;
(function(IntDecoding2) {
  IntDecoding2["DEFAULT"] = "default";
  IntDecoding2["SAFE"] = "safe";
  IntDecoding2["MIXED"] = "mixed";
  IntDecoding2["BIGINT"] = "bigint";
})(IntDecoding || (IntDecoding = {}));
var intDecoding_default = IntDecoding;
var JSONbig = (0, import_json_bigint.default)({ useNativeBigInt: true, strict: true });
function parseJSON(str, options) {
  const intDecoding = options && options.intDecoding ? options.intDecoding : intDecoding_default.DEFAULT;
  return JSONbig.parse(str, (_, value2) => {
    if (value2 != null && typeof value2 === "object" && Object.getPrototypeOf(value2) == null) {
      Object.setPrototypeOf(value2, Object.prototype);
    }
    if (typeof value2 === "bigint") {
      if (intDecoding === "safe" && value2 > Number.MAX_SAFE_INTEGER) {
        throw new Error(`Integer exceeds maximum safe integer: ${value2.toString()}. Try parsing with a different intDecoding option.`);
      }
      if (intDecoding === "bigint" || intDecoding === "mixed" && value2 > Number.MAX_SAFE_INTEGER) {
        return value2;
      }
      return Number(value2);
    }
    if (typeof value2 === "number") {
      if (intDecoding === "bigint" && Number.isInteger(value2)) {
        return BigInt(value2);
      }
    }
    return value2;
  });
}
function arrayEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  return Array.from(a).every((val, i2) => val === b[i2]);
}
function concatArrays(...arrs) {
  const size = arrs.reduce((sum, arr) => sum + arr.length, 0);
  const c = new Uint8Array(size);
  let offset = 0;
  for (let i2 = 0; i2 < arrs.length; i2++) {
    c.set(arrs[i2], offset);
    offset += arrs[i2].length;
  }
  return c;
}
function removeUndefinedProperties(obj) {
  const mutableCopy = { ...obj };
  Object.keys(mutableCopy).forEach((key) => {
    if (typeof mutableCopy[key] === "undefined")
      delete mutableCopy[key];
  });
  return mutableCopy;
}
function encodeUint64(num) {
  const isInteger = typeof num === "bigint" || Number.isInteger(num);
  if (!isInteger || num < 0 || num > BigInt("0xffffffffffffffff")) {
    throw new Error("Input is not a 64-bit unsigned integer");
  }
  const buf2 = Buffer.allocUnsafe(8);
  buf2.writeBigUInt64BE(BigInt(num));
  return new Uint8Array(buf2);
}
function decodeUint64(data, decodingMode = "safe") {
  if (decodingMode !== "safe" && decodingMode !== "mixed" && decodingMode !== "bigint") {
    throw new Error(`Unknown decodingMode option: ${decodingMode}`);
  }
  if (data.byteLength === 0 || data.byteLength > 8) {
    throw new Error(`Data has unacceptable length. Expected length is between 1 and 8, got ${data.byteLength}`);
  }
  const padding = Buffer.allocUnsafe(8 - data.byteLength);
  padding.fill(0);
  const buf2 = Buffer.concat([padding, Buffer.from(data)]);
  const num = buf2.readBigUInt64BE();
  const isBig = num > Number.MAX_SAFE_INTEGER;
  if (decodingMode === "safe") {
    if (isBig) {
      throw new Error(`Integer exceeds maximum safe integer: ${num.toString()}. Try decoding with "mixed" or "safe" decodingMode.`);
    }
    return Number(num);
  }
  if (decodingMode === "mixed" && !isBig) {
    return Number(num);
  }
  return num;
}
var ALGORAND_ADDRESS_BYTE_LENGTH = 36;
var ALGORAND_CHECKSUM_BYTE_LENGTH = 4;
var ALGORAND_ADDRESS_LENGTH = 58;
var ALGORAND_ZERO_ADDRESS_STRING = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ";
var MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([
  77,
  117,
  108,
  116,
  105,
  115,
  105,
  103,
  65,
  100,
  100,
  114
]);
var APP_ID_PREFIX = Buffer.from("appID");
var MALFORMED_ADDRESS_ERROR_MSG = "address seems to be malformed";
var CHECKSUM_ADDRESS_ERROR_MSG = "wrong checksum for address";
var INVALID_MSIG_VERSION_ERROR_MSG = "invalid multisig version";
var INVALID_MSIG_THRESHOLD_ERROR_MSG = "bad multisig threshold";
var INVALID_MSIG_PK_ERROR_MSG = "bad multisig public key - wrong length";
var UNEXPECTED_PK_LEN_ERROR_MSG = "nacl public key length is not 32 bytes";
function decodeAddress(address) {
  if (typeof address !== "string" || address.length !== ALGORAND_ADDRESS_LENGTH)
    throw new Error(MALFORMED_ADDRESS_ERROR_MSG);
  const decoded = import_hi_base32.default.decode.asBytes(address.toString());
  if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH)
    throw new Error(MALFORMED_ADDRESS_ERROR_MSG);
  const pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));
  const cs = new Uint8Array(decoded.slice(PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));
  const checksum = genericHash(pk).slice(HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, HASH_BYTES_LENGTH);
  if (!arrayEqual(checksum, cs))
    throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);
  return { publicKey: pk, checksum: cs };
}
function isValidAddress(address) {
  try {
    decodeAddress(address);
  } catch (e) {
    return false;
  }
  return true;
}
function encodeAddress(address) {
  const checksum = genericHash(address).slice(PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, PUBLIC_KEY_LENGTH);
  const addr = import_hi_base32.default.encode(concatArrays(address, checksum));
  return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH);
}
function fromMultisigPreImg({ version: version3, threshold, pks }) {
  if (version3 !== 1 || version3 > 255 || version3 < 0) {
    throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);
  }
  if (threshold === 0 || pks.length === 0 || threshold > pks.length || threshold > 255) {
    throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);
  }
  const pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;
  if (pkLen !== PUBLIC_KEY_LENGTH) {
    throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);
  }
  const merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length);
  merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);
  merged.set([version3], MULTISIG_PREIMG2ADDR_PREFIX.length);
  merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);
  for (let i2 = 0; i2 < pks.length; i2++) {
    if (pks[i2].length !== pkLen) {
      throw new Error(INVALID_MSIG_PK_ERROR_MSG);
    }
    merged.set(pks[i2], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i2 * pkLen);
  }
  return new Uint8Array(genericHash(merged));
}
function fromMultisigPreImgAddrs({ version: version3, threshold, addrs }) {
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  return encodeAddress(fromMultisigPreImg({ version: version3, threshold, pks }));
}
function getApplicationAddress(appID) {
  const toBeSigned = concatArrays(APP_ID_PREFIX, encodeUint64(appID));
  const hash2 = genericHash(toBeSigned);
  return encodeAddress(new Uint8Array(hash2));
}
var msgpack = __toESM(require_msgpack_min());
var ERROR_CONTAINS_EMPTY_STRING = "The object contains empty or 0 values. First empty or 0 value encountered during encoding: ";
function containsEmpty(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (!obj[key] || obj[key].length === 0) {
        return { containsEmpty: true, firstEmptyKey: key };
      }
    }
  }
  return { containsEmpty: false, firstEmptyKey: void 0 };
}
function encode2(obj) {
  const emptyCheck = containsEmpty(obj);
  if (emptyCheck.containsEmpty) {
    throw new Error(ERROR_CONTAINS_EMPTY_STRING + emptyCheck.firstEmptyKey);
  }
  const options = { sortKeys: true };
  return msgpack.encode(obj, options);
}
function decode2(buffer2) {
  return msgpack.decode(buffer2);
}
var import_hi_base322 = __toESM(require_base32());
function translateBoxReference(reference, foreignApps, appIndex) {
  const referenceId = reference.appIndex;
  const referenceName = reference.name;
  const isOwnReference = referenceId === 0 || referenceId === appIndex;
  let index2 = 0;
  if (foreignApps != null) {
    index2 = foreignApps.indexOf(referenceId) + 1;
  }
  if (index2 === 0 && !isOwnReference) {
    throw new Error(`Box ref with appId ${referenceId} not in foreign-apps`);
  }
  return { i: index2, n: referenceName };
}
function translateBoxReferences(references, foreignApps, appIndex) {
  if (references == null)
    return [];
  return references.map((bx) => translateBoxReference(bx, foreignApps, appIndex));
}
var TransactionType;
(function(TransactionType2) {
  TransactionType2["pay"] = "pay";
  TransactionType2["keyreg"] = "keyreg";
  TransactionType2["acfg"] = "acfg";
  TransactionType2["axfer"] = "axfer";
  TransactionType2["afrz"] = "afrz";
  TransactionType2["appl"] = "appl";
  TransactionType2["stpf"] = "stpf";
})(TransactionType || (TransactionType = {}));
function isTransactionType(s) {
  return s === TransactionType.pay || s === TransactionType.keyreg || s === TransactionType.acfg || s === TransactionType.axfer || s === TransactionType.afrz || s === TransactionType.appl || s === TransactionType.stpf;
}
var OnApplicationComplete;
(function(OnApplicationComplete2) {
  OnApplicationComplete2[OnApplicationComplete2["NoOpOC"] = 0] = "NoOpOC";
  OnApplicationComplete2[OnApplicationComplete2["OptInOC"] = 1] = "OptInOC";
  OnApplicationComplete2[OnApplicationComplete2["CloseOutOC"] = 2] = "CloseOutOC";
  OnApplicationComplete2[OnApplicationComplete2["ClearStateOC"] = 3] = "ClearStateOC";
  OnApplicationComplete2[OnApplicationComplete2["UpdateApplicationOC"] = 4] = "UpdateApplicationOC";
  OnApplicationComplete2[OnApplicationComplete2["DeleteApplicationOC"] = 5] = "DeleteApplicationOC";
})(OnApplicationComplete || (OnApplicationComplete = {}));
var ALGORAND_TRANSACTION_LENGTH = 52;
var ALGORAND_MIN_TX_FEE = 1e3;
var ALGORAND_TRANSACTION_LEASE_LENGTH = 32;
var ALGORAND_MAX_ASSET_DECIMALS = 19;
var NUM_ADDL_BYTES_AFTER_SIGNING = 75;
var ALGORAND_TRANSACTION_LEASE_LABEL_LENGTH = 5;
var ALGORAND_TRANSACTION_ADDRESS_LENGTH = 32;
var ALGORAND_TRANSACTION_REKEY_LABEL_LENGTH = 5;
var ASSET_METADATA_HASH_LENGTH = 32;
var KEYREG_VOTE_KEY_LENGTH = 32;
var KEYREG_SELECTION_KEY_LENGTH = 32;
var KEYREG_STATE_PROOF_KEY_LENGTH = 64;
function getKeyregKey(input, inputName, length3) {
  if (input == null) {
    return void 0;
  }
  let inputAsBuffer;
  if (typeof input === "string") {
    inputAsBuffer = Buffer.from(input, "base64");
  } else if (input.constructor === Uint8Array) {
    inputAsBuffer = Buffer.from(input);
  } else if (Buffer.isBuffer(input)) {
    inputAsBuffer = input;
  }
  if (inputAsBuffer == null || inputAsBuffer.byteLength !== length3) {
    throw Error(`${inputName} must be a ${length3} byte Uint8Array or Buffer or base64 string.`);
  }
  return inputAsBuffer;
}
var Transaction = class {
  constructor({ ...transaction }) {
    this.name = "Transaction";
    this.tag = Buffer.from("TX");
    const defaults2 = {
      type: TransactionType.pay,
      flatFee: false,
      nonParticipation: false
    };
    if (typeof transaction.type === "undefined") {
      transaction.type = defaults2.type;
    }
    if (typeof transaction.flatFee === "undefined") {
      transaction.flatFee = defaults2.flatFee;
    }
    if (transaction.type === TransactionType.keyreg && typeof transaction.voteKey !== "undefined" && typeof transaction.nonParticipation === "undefined") {
      transaction.nonParticipation = defaults2.nonParticipation;
    }
    if (transaction.suggestedParams !== void 0) {
      const reference = transaction;
      reference.genesisHash = reference.suggestedParams.genesisHash;
      reference.fee = reference.suggestedParams.fee;
      if (reference.suggestedParams.flatFee !== void 0)
        reference.flatFee = reference.suggestedParams.flatFee;
      reference.firstRound = reference.suggestedParams.firstRound;
      reference.lastRound = reference.suggestedParams.lastRound;
      reference.genesisID = reference.suggestedParams.genesisID;
    }
    const txn = transaction;
    txn.from = decodeAddress(txn.from);
    if (txn.to !== void 0)
      txn.to = decodeAddress(txn.to);
    if (txn.closeRemainderTo !== void 0)
      txn.closeRemainderTo = decodeAddress(txn.closeRemainderTo);
    if (txn.assetManager !== void 0)
      txn.assetManager = decodeAddress(txn.assetManager);
    if (txn.assetReserve !== void 0)
      txn.assetReserve = decodeAddress(txn.assetReserve);
    if (txn.assetFreeze !== void 0)
      txn.assetFreeze = decodeAddress(txn.assetFreeze);
    if (txn.assetClawback !== void 0)
      txn.assetClawback = decodeAddress(txn.assetClawback);
    if (txn.assetRevocationTarget !== void 0)
      txn.assetRevocationTarget = decodeAddress(txn.assetRevocationTarget);
    if (txn.freezeAccount !== void 0)
      txn.freezeAccount = decodeAddress(txn.freezeAccount);
    if (txn.reKeyTo !== void 0)
      txn.reKeyTo = decodeAddress(txn.reKeyTo);
    if (txn.genesisHash === void 0)
      throw Error("genesis hash must be specified and in a base64 string.");
    txn.genesisHash = Buffer.from(txn.genesisHash, "base64");
    if (txn.amount !== void 0 && (!(Number.isSafeInteger(txn.amount) || typeof txn.amount === "bigint" && txn.amount <= BigInt("0xffffffffffffffff")) || txn.amount < 0))
      throw Error("Amount must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
    if (!Number.isSafeInteger(txn.fee) || txn.fee < 0)
      throw Error("fee must be a positive number and smaller than 2^53-1");
    if (!Number.isSafeInteger(txn.firstRound) || txn.firstRound < 0)
      throw Error("firstRound must be a positive number");
    if (!Number.isSafeInteger(txn.lastRound) || txn.lastRound < 0)
      throw Error("lastRound must be a positive number");
    if (txn.extraPages !== void 0 && (!Number.isInteger(txn.extraPages) || txn.extraPages < 0 || txn.extraPages > 3))
      throw Error("extraPages must be an Integer between and including 0 to 3");
    if (txn.assetTotal !== void 0 && (!(Number.isSafeInteger(txn.assetTotal) || typeof txn.assetTotal === "bigint" && txn.assetTotal <= BigInt("0xffffffffffffffff")) || txn.assetTotal < 0))
      throw Error("Total asset issuance must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
    if (txn.assetDecimals !== void 0 && (!Number.isSafeInteger(txn.assetDecimals) || txn.assetDecimals < 0 || txn.assetDecimals > ALGORAND_MAX_ASSET_DECIMALS))
      throw Error(`assetDecimals must be a positive number and smaller than ${ALGORAND_MAX_ASSET_DECIMALS.toString()}`);
    if (txn.assetIndex !== void 0 && (!Number.isSafeInteger(txn.assetIndex) || txn.assetIndex < 0))
      throw Error("Asset index must be a positive number and smaller than 2^53-1");
    if (txn.appIndex !== void 0 && (!Number.isSafeInteger(txn.appIndex) || txn.appIndex < 0))
      throw Error("Application index must be a positive number and smaller than 2^53-1");
    if (txn.appLocalInts !== void 0 && (!Number.isSafeInteger(txn.appLocalInts) || txn.appLocalInts < 0))
      throw Error("Application local ints count must be a positive number and smaller than 2^53-1");
    if (txn.appLocalByteSlices !== void 0 && (!Number.isSafeInteger(txn.appLocalByteSlices) || txn.appLocalByteSlices < 0))
      throw Error("Application local byte slices count must be a positive number and smaller than 2^53-1");
    if (txn.appGlobalInts !== void 0 && (!Number.isSafeInteger(txn.appGlobalInts) || txn.appGlobalInts < 0))
      throw Error("Application globalThis ints count must be a positive number and smaller than 2^53-1");
    if (txn.appGlobalByteSlices !== void 0 && (!Number.isSafeInteger(txn.appGlobalByteSlices) || txn.appGlobalByteSlices < 0))
      throw Error("Application globalThis byte slices count must be a positive number and smaller than 2^53-1");
    if (txn.appApprovalProgram !== void 0) {
      if (txn.appApprovalProgram.constructor !== Uint8Array)
        throw Error("appApprovalProgram must be a Uint8Array.");
    }
    if (txn.appClearProgram !== void 0) {
      if (txn.appClearProgram.constructor !== Uint8Array)
        throw Error("appClearProgram must be a Uint8Array.");
    }
    if (txn.appArgs !== void 0) {
      if (!Array.isArray(txn.appArgs))
        throw Error("appArgs must be an Array of Uint8Array.");
      txn.appArgs = txn.appArgs.slice();
      txn.appArgs.forEach((arg) => {
        if (arg.constructor !== Uint8Array)
          throw Error("each element of AppArgs must be a Uint8Array.");
      });
    } else {
      txn.appArgs = [];
    }
    if (txn.appAccounts !== void 0) {
      if (!Array.isArray(txn.appAccounts))
        throw Error("appAccounts must be an Array of addresses.");
      txn.appAccounts = txn.appAccounts.map((addressAsString) => decodeAddress(addressAsString));
    }
    if (txn.appForeignApps !== void 0) {
      if (!Array.isArray(txn.appForeignApps))
        throw Error("appForeignApps must be an Array of integers.");
      txn.appForeignApps = txn.appForeignApps.slice();
      txn.appForeignApps.forEach((foreignAppIndex) => {
        if (!Number.isSafeInteger(foreignAppIndex) || foreignAppIndex < 0)
          throw Error("each foreign application index must be a positive number and smaller than 2^53-1");
      });
    }
    if (txn.appForeignAssets !== void 0) {
      if (!Array.isArray(txn.appForeignAssets))
        throw Error("appForeignAssets must be an Array of integers.");
      txn.appForeignAssets = txn.appForeignAssets.slice();
      txn.appForeignAssets.forEach((foreignAssetIndex) => {
        if (!Number.isSafeInteger(foreignAssetIndex) || foreignAssetIndex < 0)
          throw Error("each foreign asset index must be a positive number and smaller than 2^53-1");
      });
    }
    if (txn.boxes !== void 0) {
      if (!Array.isArray(txn.boxes))
        throw Error("boxes must be an Array of BoxReference.");
      txn.boxes = txn.boxes.slice();
      txn.boxes.forEach((box) => {
        if (!Number.isSafeInteger(box.appIndex) || box.name.constructor !== Uint8Array)
          throw Error("box app index must be a number and name must be an Uint8Array.");
      });
    }
    if (txn.assetMetadataHash !== void 0 && txn.assetMetadataHash.length !== 0) {
      if (typeof txn.assetMetadataHash === "string") {
        txn.assetMetadataHash = new Uint8Array(Buffer.from(txn.assetMetadataHash));
      }
      if (txn.assetMetadataHash.constructor !== Uint8Array || txn.assetMetadataHash.byteLength !== ASSET_METADATA_HASH_LENGTH) {
        throw Error(`assetMetadataHash must be a ${ASSET_METADATA_HASH_LENGTH} byte Uint8Array or string.`);
      }
      if (txn.assetMetadataHash.every((value2) => value2 === 0)) {
        txn.assetMetadataHash = void 0;
      }
    } else {
      txn.assetMetadataHash = void 0;
    }
    if (txn.note !== void 0) {
      if (txn.note.constructor !== Uint8Array)
        throw Error("note must be a Uint8Array.");
    } else {
      txn.note = new Uint8Array(0);
    }
    if (txn.lease !== void 0) {
      if (txn.lease.constructor !== Uint8Array)
        throw Error("lease must be a Uint8Array.");
      if (txn.lease.length !== ALGORAND_TRANSACTION_LEASE_LENGTH)
        throw Error(`lease must be of length ${ALGORAND_TRANSACTION_LEASE_LENGTH.toString()}.`);
      if (txn.lease.every((value2) => value2 === 0)) {
        txn.lease = new Uint8Array(0);
      }
    } else {
      txn.lease = new Uint8Array(0);
    }
    txn.voteKey = getKeyregKey(txn.voteKey, "voteKey", KEYREG_VOTE_KEY_LENGTH);
    txn.selectionKey = getKeyregKey(txn.selectionKey, "selectionKey", KEYREG_SELECTION_KEY_LENGTH);
    txn.stateProofKey = getKeyregKey(txn.stateProofKey, "stateProofKey", KEYREG_STATE_PROOF_KEY_LENGTH);
    if (txn.nonParticipation && (txn.voteKey || txn.selectionKey || txn.voteFirst || txn.stateProofKey || txn.voteLast || txn.voteKeyDilution)) {
      throw new Error("nonParticipation is true but participation params are present.");
    }
    if (!txn.nonParticipation && (txn.voteKey || txn.selectionKey || txn.stateProofKey || txn.voteFirst || txn.voteLast || txn.voteKeyDilution) && !(txn.voteKey && txn.selectionKey && txn.voteFirst && txn.voteLast && txn.voteKeyDilution)) {
      throw new Error("online key registration missing at least one of the following fields: voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution");
    }
    delete txn.suggestedParams;
    Object.assign(this, removeUndefinedProperties(txn));
    if (!txn.flatFee) {
      this.fee *= this.estimateSize();
      if (this.fee < ALGORAND_MIN_TX_FEE) {
        this.fee = ALGORAND_MIN_TX_FEE;
      }
    }
    this.group = void 0;
    if (txn.stateProofType !== void 0 && (!Number.isSafeInteger(txn.stateProofType) || txn.stateProofType < 0))
      throw Error("State Proof type must be a positive number and smaller than 2^53-1");
    if (txn.stateProofMessage !== void 0) {
      if (txn.stateProofMessage.constructor !== Uint8Array)
        throw Error("stateProofMessage must be a Uint8Array.");
    } else {
      txn.stateProofMessage = new Uint8Array(0);
    }
    if (txn.stateProof !== void 0) {
      if (txn.stateProof.constructor !== Uint8Array)
        throw Error("stateProof must be a Uint8Array.");
    } else {
      txn.stateProof = new Uint8Array(0);
    }
  }
  // eslint-disable-next-line camelcase
  get_obj_for_encoding() {
    if (this.type === "pay") {
      const txn = {
        amt: this.amount,
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: Buffer.from(this.note),
        snd: Buffer.from(this.from.publicKey),
        type: "pay",
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: Buffer.from(this.lease),
        grp: this.group
      };
      if (this.closeRemainderTo !== void 0 && encodeAddress(this.closeRemainderTo.publicKey) !== ALGORAND_ZERO_ADDRESS_STRING) {
        txn.close = Buffer.from(this.closeRemainderTo.publicKey);
      }
      if (this.reKeyTo !== void 0) {
        txn.rekey = Buffer.from(this.reKeyTo.publicKey);
      }
      if (this.to !== void 0)
        txn.rcv = Buffer.from(this.to.publicKey);
      if (!txn.note.length)
        delete txn.note;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (txn.grp === void 0)
        delete txn.grp;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.rekey)
        delete txn.rekey;
      return txn;
    }
    if (this.type === "keyreg") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: Buffer.from(this.note),
        snd: Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: Buffer.from(this.lease),
        grp: this.group,
        votekey: this.voteKey,
        selkey: this.selectionKey,
        sprfkey: this.stateProofKey,
        votefst: this.voteFirst,
        votelst: this.voteLast,
        votekd: this.voteKeyDilution
      };
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (txn.grp === void 0)
        delete txn.grp;
      if (this.reKeyTo !== void 0) {
        txn.rekey = Buffer.from(this.reKeyTo.publicKey);
      }
      if (this.nonParticipation) {
        txn.nonpart = true;
      }
      if (!txn.selkey)
        delete txn.selkey;
      if (!txn.votekey)
        delete txn.votekey;
      if (!txn.sprfkey)
        delete txn.sprfkey;
      if (!txn.votefst)
        delete txn.votefst;
      if (!txn.votelst)
        delete txn.votelst;
      if (!txn.votekd)
        delete txn.votekd;
      return txn;
    }
    if (this.type === "acfg") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: Buffer.from(this.note),
        snd: Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: Buffer.from(this.lease),
        grp: this.group,
        caid: this.assetIndex,
        apar: {
          t: this.assetTotal,
          df: this.assetDefaultFrozen,
          dc: this.assetDecimals
        }
      };
      if (this.assetManager !== void 0)
        txn.apar.m = Buffer.from(this.assetManager.publicKey);
      if (this.assetReserve !== void 0)
        txn.apar.r = Buffer.from(this.assetReserve.publicKey);
      if (this.assetFreeze !== void 0)
        txn.apar.f = Buffer.from(this.assetFreeze.publicKey);
      if (this.assetClawback !== void 0)
        txn.apar.c = Buffer.from(this.assetClawback.publicKey);
      if (this.assetName !== void 0)
        txn.apar.an = this.assetName;
      if (this.assetUnitName !== void 0)
        txn.apar.un = this.assetUnitName;
      if (this.assetURL !== void 0)
        txn.apar.au = this.assetURL;
      if (this.assetMetadataHash !== void 0)
        txn.apar.am = Buffer.from(this.assetMetadataHash);
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (this.reKeyTo !== void 0) {
        txn.rekey = Buffer.from(this.reKeyTo.publicKey);
      }
      if (!txn.caid)
        delete txn.caid;
      if (!txn.apar.t && !txn.apar.un && !txn.apar.an && !txn.apar.df && !txn.apar.m && !txn.apar.r && !txn.apar.f && !txn.apar.c && !txn.apar.au && !txn.apar.am && !txn.apar.dc) {
        delete txn.apar;
      } else {
        if (!txn.apar.t)
          delete txn.apar.t;
        if (!txn.apar.dc)
          delete txn.apar.dc;
        if (!txn.apar.un)
          delete txn.apar.un;
        if (!txn.apar.an)
          delete txn.apar.an;
        if (!txn.apar.df)
          delete txn.apar.df;
        if (!txn.apar.m)
          delete txn.apar.m;
        if (!txn.apar.r)
          delete txn.apar.r;
        if (!txn.apar.f)
          delete txn.apar.f;
        if (!txn.apar.c)
          delete txn.apar.c;
        if (!txn.apar.au)
          delete txn.apar.au;
        if (!txn.apar.am)
          delete txn.apar.am;
      }
      if (txn.grp === void 0)
        delete txn.grp;
      return txn;
    }
    if (this.type === "axfer") {
      const txn = {
        aamt: this.amount,
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: Buffer.from(this.note),
        snd: Buffer.from(this.from.publicKey),
        arcv: Buffer.from(this.to.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: Buffer.from(this.lease),
        grp: this.group,
        xaid: this.assetIndex
      };
      if (this.closeRemainderTo !== void 0)
        txn.aclose = Buffer.from(this.closeRemainderTo.publicKey);
      if (this.assetRevocationTarget !== void 0)
        txn.asnd = Buffer.from(this.assetRevocationTarget.publicKey);
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.aamt)
        delete txn.aamt;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (txn.grp === void 0)
        delete txn.grp;
      if (!txn.aclose)
        delete txn.aclose;
      if (!txn.asnd)
        delete txn.asnd;
      if (!txn.rekey)
        delete txn.rekey;
      if (this.reKeyTo !== void 0) {
        txn.rekey = Buffer.from(this.reKeyTo.publicKey);
      }
      return txn;
    }
    if (this.type === "afrz") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: Buffer.from(this.note),
        snd: Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: Buffer.from(this.lease),
        grp: this.group,
        faid: this.assetIndex,
        afrz: this.freezeState
      };
      if (this.freezeAccount !== void 0)
        txn.fadd = Buffer.from(this.freezeAccount.publicKey);
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (!txn.afrz)
        delete txn.afrz;
      if (txn.grp === void 0)
        delete txn.grp;
      if (this.reKeyTo !== void 0) {
        txn.rekey = Buffer.from(this.reKeyTo.publicKey);
      }
      return txn;
    }
    if (this.type === "appl") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: Buffer.from(this.note),
        snd: Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: Buffer.from(this.lease),
        grp: this.group,
        apid: this.appIndex,
        apan: this.appOnComplete,
        apls: {
          nui: this.appLocalInts,
          nbs: this.appLocalByteSlices
        },
        apgs: {
          nui: this.appGlobalInts,
          nbs: this.appGlobalByteSlices
        },
        apfa: this.appForeignApps,
        apas: this.appForeignAssets,
        apep: this.extraPages,
        apbx: translateBoxReferences(this.boxes, this.appForeignApps, this.appIndex)
      };
      if (this.reKeyTo !== void 0) {
        txn.rekey = Buffer.from(this.reKeyTo.publicKey);
      }
      if (this.appApprovalProgram !== void 0) {
        txn.apap = Buffer.from(this.appApprovalProgram);
      }
      if (this.appClearProgram !== void 0) {
        txn.apsu = Buffer.from(this.appClearProgram);
      }
      if (this.appArgs !== void 0) {
        txn.apaa = this.appArgs.map((arg) => Buffer.from(arg));
      }
      if (this.appAccounts !== void 0) {
        txn.apat = this.appAccounts.map((decodedAddress) => Buffer.from(decodedAddress.publicKey));
      }
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (!txn.apid)
        delete txn.apid;
      if (!txn.apls.nui)
        delete txn.apls.nui;
      if (!txn.apls.nbs)
        delete txn.apls.nbs;
      if (!txn.apls.nui && !txn.apls.nbs)
        delete txn.apls;
      if (!txn.apgs.nui)
        delete txn.apgs.nui;
      if (!txn.apgs.nbs)
        delete txn.apgs.nbs;
      if (!txn.apaa || !txn.apaa.length)
        delete txn.apaa;
      if (!txn.apgs.nui && !txn.apgs.nbs)
        delete txn.apgs;
      if (!txn.apap)
        delete txn.apap;
      if (!txn.apsu)
        delete txn.apsu;
      if (!txn.apan)
        delete txn.apan;
      if (!txn.apfa || !txn.apfa.length)
        delete txn.apfa;
      if (!txn.apas || !txn.apas.length)
        delete txn.apas;
      for (const box of txn.apbx) {
        if (!box.i)
          delete box.i;
        if (!box.n || !box.n.length)
          delete box.n;
      }
      if (!txn.apbx || !txn.apbx.length)
        delete txn.apbx;
      if (!txn.apat || !txn.apat.length)
        delete txn.apat;
      if (!txn.apep)
        delete txn.apep;
      if (txn.grp === void 0)
        delete txn.grp;
      return txn;
    }
    if (this.type === "stpf") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: Buffer.from(this.note),
        snd: Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: Buffer.from(this.lease),
        sptype: this.stateProofType,
        spmsg: Buffer.from(this.stateProofMessage),
        sp: Buffer.from(this.stateProof)
      };
      if (!txn.sptype)
        delete txn.sptype;
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (!txn.apid)
        delete txn.apid;
      if (!txn.apaa || !txn.apaa.length)
        delete txn.apaa;
      if (!txn.apap)
        delete txn.apap;
      if (!txn.apsu)
        delete txn.apsu;
      if (!txn.apan)
        delete txn.apan;
      if (!txn.apfa || !txn.apfa.length)
        delete txn.apfa;
      if (!txn.apas || !txn.apas.length)
        delete txn.apas;
      if (!txn.apat || !txn.apat.length)
        delete txn.apat;
      if (!txn.apep)
        delete txn.apep;
      if (txn.grp === void 0)
        delete txn.grp;
      return txn;
    }
    return void 0;
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(txnForEnc) {
    const txn = Object.create(this.prototype);
    txn.name = "Transaction";
    txn.tag = Buffer.from("TX");
    txn.genesisID = txnForEnc.gen;
    txn.genesisHash = Buffer.from(txnForEnc.gh);
    if (!isTransactionType(txnForEnc.type)) {
      throw new Error(`Unrecognized transaction type: ${txnForEnc.type}`);
    }
    txn.type = txnForEnc.type;
    txn.fee = txnForEnc.fee;
    txn.firstRound = txnForEnc.fv;
    txn.lastRound = txnForEnc.lv;
    txn.note = new Uint8Array(txnForEnc.note);
    txn.lease = new Uint8Array(txnForEnc.lx);
    txn.from = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.snd)));
    if (txnForEnc.grp !== void 0)
      txn.group = Buffer.from(txnForEnc.grp);
    if (txnForEnc.rekey !== void 0)
      txn.reKeyTo = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.rekey)));
    if (txnForEnc.type === "pay") {
      txn.amount = txnForEnc.amt;
      txn.to = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.rcv)));
      if (txnForEnc.close !== void 0)
        txn.closeRemainderTo = decodeAddress(encodeAddress(txnForEnc.close));
    } else if (txnForEnc.type === "keyreg") {
      if (txnForEnc.votekey !== void 0) {
        txn.voteKey = Buffer.from(txnForEnc.votekey);
      }
      if (txnForEnc.selkey !== void 0) {
        txn.selectionKey = Buffer.from(txnForEnc.selkey);
      }
      if (txnForEnc.sprfkey !== void 0) {
        txn.stateProofKey = Buffer.from(txnForEnc.sprfkey);
      }
      if (txnForEnc.votekd !== void 0) {
        txn.voteKeyDilution = txnForEnc.votekd;
      }
      if (txnForEnc.votefst !== void 0) {
        txn.voteFirst = txnForEnc.votefst;
      }
      if (txnForEnc.votelst !== void 0) {
        txn.voteLast = txnForEnc.votelst;
      }
      if (txnForEnc.nonpart !== void 0) {
        txn.nonParticipation = txnForEnc.nonpart;
      }
    } else if (txnForEnc.type === "acfg") {
      if (txnForEnc.caid !== void 0) {
        txn.assetIndex = txnForEnc.caid;
      }
      if (txnForEnc.apar !== void 0) {
        txn.assetTotal = txnForEnc.apar.t;
        txn.assetDefaultFrozen = txnForEnc.apar.df;
        if (txnForEnc.apar.dc !== void 0)
          txn.assetDecimals = txnForEnc.apar.dc;
        if (txnForEnc.apar.m !== void 0)
          txn.assetManager = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.m)));
        if (txnForEnc.apar.r !== void 0)
          txn.assetReserve = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.r)));
        if (txnForEnc.apar.f !== void 0)
          txn.assetFreeze = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.f)));
        if (txnForEnc.apar.c !== void 0)
          txn.assetClawback = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.c)));
        if (txnForEnc.apar.un !== void 0)
          txn.assetUnitName = txnForEnc.apar.un;
        if (txnForEnc.apar.an !== void 0)
          txn.assetName = txnForEnc.apar.an;
        if (txnForEnc.apar.au !== void 0)
          txn.assetURL = txnForEnc.apar.au;
        if (txnForEnc.apar.am !== void 0)
          txn.assetMetadataHash = txnForEnc.apar.am;
      }
    } else if (txnForEnc.type === "axfer") {
      if (txnForEnc.xaid !== void 0) {
        txn.assetIndex = txnForEnc.xaid;
      }
      if (txnForEnc.aamt !== void 0)
        txn.amount = txnForEnc.aamt;
      if (txnForEnc.aclose !== void 0) {
        txn.closeRemainderTo = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.aclose)));
      }
      if (txnForEnc.asnd !== void 0) {
        txn.assetRevocationTarget = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.asnd)));
      }
      txn.to = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.arcv)));
    } else if (txnForEnc.type === "afrz") {
      if (txnForEnc.afrz !== void 0) {
        txn.freezeState = txnForEnc.afrz;
      }
      if (txnForEnc.faid !== void 0) {
        txn.assetIndex = txnForEnc.faid;
      }
      txn.freezeAccount = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.fadd)));
    } else if (txnForEnc.type === "appl") {
      if (txnForEnc.apid !== void 0) {
        txn.appIndex = txnForEnc.apid;
      }
      if (txnForEnc.apan !== void 0) {
        txn.appOnComplete = txnForEnc.apan;
      }
      if (txnForEnc.apls !== void 0) {
        if (txnForEnc.apls.nui !== void 0)
          txn.appLocalInts = txnForEnc.apls.nui;
        if (txnForEnc.apls.nbs !== void 0)
          txn.appLocalByteSlices = txnForEnc.apls.nbs;
      }
      if (txnForEnc.apgs !== void 0) {
        if (txnForEnc.apgs.nui !== void 0)
          txn.appGlobalInts = txnForEnc.apgs.nui;
        if (txnForEnc.apgs.nbs !== void 0)
          txn.appGlobalByteSlices = txnForEnc.apgs.nbs;
      }
      if (txnForEnc.apep !== void 0) {
        txn.extraPages = txnForEnc.apep;
      }
      if (txnForEnc.apap !== void 0) {
        txn.appApprovalProgram = new Uint8Array(txnForEnc.apap);
      }
      if (txnForEnc.apsu !== void 0) {
        txn.appClearProgram = new Uint8Array(txnForEnc.apsu);
      }
      if (txnForEnc.apaa !== void 0) {
        txn.appArgs = txnForEnc.apaa.map((arg) => new Uint8Array(arg));
      }
      if (txnForEnc.apat !== void 0) {
        txn.appAccounts = txnForEnc.apat.map((addressBytes) => decodeAddress(encodeAddress(new Uint8Array(addressBytes))));
      }
      if (txnForEnc.apfa !== void 0) {
        txn.appForeignApps = txnForEnc.apfa;
      }
      if (txnForEnc.apas !== void 0) {
        txn.appForeignAssets = txnForEnc.apas;
      }
      if (txnForEnc.apbx !== void 0) {
        txn.boxes = txnForEnc.apbx.map((box) => ({
          // We return 0 for the app ID so that it's guaranteed translateBoxReferences will
          // translate the app index back to 0. If we instead returned the called app ID,
          // translateBoxReferences would translate the app index to a nonzero value if the called
          // app is also in the foreign app array.
          appIndex: box.i ? txn.appForeignApps[box.i - 1] : 0,
          name: box.n
        }));
      }
    } else if (txnForEnc.type === "stpf") {
      if (txnForEnc.sptype !== void 0) {
        txn.stateProofType = txnForEnc.sptype;
      }
      if (txnForEnc.sp !== void 0) {
        txn.stateProof = txnForEnc.sp;
      }
      if (txnForEnc.spmsg !== void 0) {
        txn.stateProofMessage = txnForEnc.spmsg;
      }
    }
    return txn;
  }
  estimateSize() {
    return this.toByte().length + NUM_ADDL_BYTES_AFTER_SIGNING;
  }
  bytesToSign() {
    const encodedMsg = this.toByte();
    return Buffer.from(concatArrays(this.tag, encodedMsg));
  }
  toByte() {
    return encode2(this.get_obj_for_encoding());
  }
  // returns the raw signature
  rawSignTxn(sk) {
    const toBeSigned = this.bytesToSign();
    const sig = sign(toBeSigned, sk);
    return Buffer.from(sig);
  }
  signTxn(sk) {
    const sTxn = {
      sig: this.rawSignTxn(sk),
      txn: this.get_obj_for_encoding()
    };
    const keypair = keyPairFromSecretKey(sk);
    const pubKeyFromSk = keypair.publicKey;
    if (encodeAddress(pubKeyFromSk) !== encodeAddress(this.from.publicKey)) {
      sTxn.sgnr = Buffer.from(pubKeyFromSk);
    }
    return new Uint8Array(encode2(sTxn));
  }
  attachSignature(signerAddr, signature) {
    if (!isValidSignatureLength(signature.length)) {
      throw new Error("Invalid signature length");
    }
    const sTxn = {
      sig: Buffer.from(signature),
      txn: this.get_obj_for_encoding()
    };
    if (signerAddr !== encodeAddress(this.from.publicKey)) {
      const signerPublicKey = decodeAddress(signerAddr).publicKey;
      sTxn.sgnr = Buffer.from(signerPublicKey);
    }
    return new Uint8Array(encode2(sTxn));
  }
  rawTxID() {
    const enMsg = this.toByte();
    const gh = Buffer.from(concatArrays(this.tag, enMsg));
    return Buffer.from(genericHash(gh));
  }
  txID() {
    const hash2 = this.rawTxID();
    return import_hi_base322.default.encode(hash2).slice(0, ALGORAND_TRANSACTION_LENGTH);
  }
  // add a lease to a transaction not yet having
  // supply feePerByte to increment fee accordingly
  addLease(lease, feePerByte = 0) {
    let mutableLease;
    if (lease !== void 0) {
      if (lease.constructor !== Uint8Array)
        throw Error("lease must be a Uint8Array.");
      if (lease.length !== ALGORAND_TRANSACTION_LEASE_LENGTH)
        throw Error(`lease must be of length ${ALGORAND_TRANSACTION_LEASE_LENGTH.toString()}.`);
      mutableLease = new Uint8Array(lease);
    } else {
      mutableLease = new Uint8Array(0);
    }
    this.lease = mutableLease;
    if (feePerByte !== 0) {
      this.fee += (ALGORAND_TRANSACTION_LEASE_LABEL_LENGTH + ALGORAND_TRANSACTION_LEASE_LENGTH) * feePerByte;
    }
  }
  // add the rekey-to field to a transaction not yet having it
  // supply feePerByte to increment fee accordingly
  addRekey(reKeyTo, feePerByte = 0) {
    if (reKeyTo !== void 0) {
      this.reKeyTo = decodeAddress(reKeyTo);
    }
    if (feePerByte !== 0) {
      this.fee += (ALGORAND_TRANSACTION_REKEY_LABEL_LENGTH + ALGORAND_TRANSACTION_ADDRESS_LENGTH) * feePerByte;
    }
  }
  // build display dict for prettyPrint and toString
  // eslint-disable-next-line no-underscore-dangle
  _getDictForDisplay() {
    const forPrinting = {
      ...this
    };
    forPrinting.tag = forPrinting.tag.toString();
    forPrinting.from = encodeAddress(forPrinting.from.publicKey);
    if (forPrinting.to !== void 0)
      forPrinting.to = encodeAddress(forPrinting.to.publicKey);
    if (forPrinting.freezeAccount !== void 0)
      forPrinting.freezeAccount = encodeAddress(forPrinting.freezeAccount.publicKey);
    if (forPrinting.closeRemainderTo !== void 0)
      forPrinting.closeRemainderTo = encodeAddress(forPrinting.closeRemainderTo.publicKey);
    if (forPrinting.assetManager !== void 0)
      forPrinting.assetManager = encodeAddress(forPrinting.assetManager.publicKey);
    if (forPrinting.assetReserve !== void 0)
      forPrinting.assetReserve = encodeAddress(forPrinting.assetReserve.publicKey);
    if (forPrinting.assetFreeze !== void 0)
      forPrinting.assetFreeze = encodeAddress(forPrinting.assetFreeze.publicKey);
    if (forPrinting.assetClawback !== void 0)
      forPrinting.assetClawback = encodeAddress(forPrinting.assetClawback.publicKey);
    if (forPrinting.assetRevocationTarget !== void 0)
      forPrinting.assetRevocationTarget = encodeAddress(forPrinting.assetRevocationTarget.publicKey);
    if (forPrinting.reKeyTo !== void 0)
      forPrinting.reKeyTo = encodeAddress(forPrinting.reKeyTo.publicKey);
    forPrinting.genesisHash = forPrinting.genesisHash.toString("base64");
    return forPrinting;
  }
  // pretty print the transaction to console
  prettyPrint() {
    console.log(this._getDictForDisplay());
  }
  // get string representation
  toString() {
    return JSON.stringify(this._getDictForDisplay());
  }
};
function encodeUnsignedTransaction(transactionObject) {
  const objToEncode = transactionObject.get_obj_for_encoding();
  return encode2(objToEncode);
}
function decodeUnsignedTransaction(transactionBuffer) {
  const partlyDecodedObject = decode2(transactionBuffer);
  return Transaction.from_obj_for_encoding(partlyDecodedObject);
}
function decodeSignedTransaction(transactionBuffer) {
  const stxnDecoded = decode2(transactionBuffer);
  const stxn = {
    ...stxnDecoded,
    txn: Transaction.from_obj_for_encoding(stxnDecoded.txn)
  };
  return stxn;
}
function instantiateTxnIfNeeded(transactionLike) {
  return transactionLike instanceof Transaction ? transactionLike : new Transaction(transactionLike);
}
var Bid = class {
  constructor({ bidderKey, bidAmount, bidID, auctionKey, auctionID, maxPrice }) {
    this.name = "Bid";
    this.tag = Buffer.from([97, 66]);
    const decodedBidderKey = decodeAddress(bidderKey);
    const decodedAuctionKey = decodeAddress(auctionKey);
    if (!Number.isSafeInteger(bidAmount) || bidAmount < 0)
      throw Error("Bid amount must be positive and 2^53-1");
    if (!Number.isSafeInteger(bidID) || bidID < 0)
      throw Error("BidID must be positive and 2^53-1");
    if (!Number.isSafeInteger(auctionID) || auctionID < 0)
      throw Error("auctionID must be positive");
    Object.assign(this, {
      bidderKey: decodedBidderKey,
      bidAmount,
      bidID,
      auctionKey: decodedAuctionKey,
      auctionID,
      maxPrice
    });
  }
  // eslint-disable-next-line camelcase
  get_obj_for_encoding() {
    return {
      bidder: Buffer.from(this.bidderKey.publicKey),
      cur: this.bidAmount,
      price: this.maxPrice,
      id: this.bidID,
      auc: Buffer.from(this.auctionKey.publicKey),
      aid: this.auctionID
    };
  }
  signBid(sk) {
    const encodedMsg = encode2(this.get_obj_for_encoding());
    const toBeSigned = Buffer.from(concatArrays(this.tag, encodedMsg));
    const sig = sign(toBeSigned, sk);
    const sBid = {
      sig: Buffer.from(sig),
      bid: this.get_obj_for_encoding()
    };
    const note = {
      t: "b",
      b: sBid
    };
    return new Uint8Array(encode2(note));
  }
};
var MICROALGOS_TO_ALGOS_RATIO = 1e6;
var INVALID_MICROALGOS_ERROR_MSG = "Microalgos should be positive and less than 2^53 - 1.";
function microalgosToAlgos(microalgos) {
  if (microalgos < 0 || !Number.isSafeInteger(microalgos)) {
    throw new Error(INVALID_MICROALGOS_ERROR_MSG);
  }
  return microalgos / MICROALGOS_TO_ALGOS_RATIO;
}
function algosToMicroalgos(algos) {
  const microalgos = algos * MICROALGOS_TO_ALGOS_RATIO;
  return Math.round(microalgos);
}
var import_cross_fetch = __toESM(require_browser_ponyfill());
var URLTokenBaseHTTPError = class extends Error {
  constructor(message2, response) {
    super(message2);
    this.response = response;
    this.name = "URLTokenBaseHTTPError";
    this.response = response;
  }
};
var URLTokenBaseHTTPClient = class {
  constructor(tokenHeader, baseServer, port, defaultHeaders = {}) {
    this.defaultHeaders = defaultHeaders;
    const fixedBaseServer = baseServer.endsWith("/") ? baseServer : `${baseServer}/`;
    const baseServerURL = new URL(fixedBaseServer);
    if (typeof port !== "undefined") {
      baseServerURL.port = port.toString();
    }
    if (baseServerURL.protocol.length === 0) {
      throw new Error("Invalid base server URL, protocol must be defined.");
    }
    this.baseURL = baseServerURL;
    this.tokenHeader = tokenHeader;
  }
  /**
   * Compute the URL for a path relative to the instance's address
   * @param relativePath - A path string
   * @param query - An optional key-value object of query parameters to add to the URL. If the
   *   relativePath already has query parameters on it, the additional parameters defined here will
   *   be added to the URL without modifying those (unless a key collision occurs).
   * @returns A URL string
   */
  getURL(relativePath, query) {
    let fixedRelativePath;
    if (relativePath.startsWith("./")) {
      fixedRelativePath = relativePath;
    } else if (relativePath.startsWith("/")) {
      fixedRelativePath = `.${relativePath}`;
    } else {
      fixedRelativePath = `./${relativePath}`;
    }
    const address = new URL(fixedRelativePath, this.baseURL);
    if (query) {
      for (const [key, value2] of Object.entries(query)) {
        address.searchParams.set(key, value2);
      }
    }
    return address.toString();
  }
  static formatFetchResponseHeaders(headers) {
    const headersObj = {};
    headers.forEach((key, value2) => {
      headersObj[key] = value2;
    });
    return headersObj;
  }
  static async checkHttpError(res) {
    if (res.ok) {
      return;
    }
    let body = null;
    let bodyErrorMessage = null;
    try {
      body = new Uint8Array(await res.arrayBuffer());
      const decoded = JSON.parse(Buffer.from(body).toString());
      if (decoded.message) {
        bodyErrorMessage = decoded.message;
      }
    } catch (_) {
    }
    let message2 = `Network request error. Received status ${res.status} (${res.statusText})`;
    if (bodyErrorMessage) {
      message2 += `: ${bodyErrorMessage}`;
    }
    throw new URLTokenBaseHTTPError(message2, {
      body,
      status: res.status,
      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)
    });
  }
  static async formatFetchResponse(res) {
    await this.checkHttpError(res);
    return {
      body: new Uint8Array(await res.arrayBuffer()),
      status: res.status,
      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)
    };
  }
  async get(relativePath, query, requestHeaders = {}) {
    const headers = {
      ...this.tokenHeader,
      ...this.defaultHeaders,
      ...requestHeaders
    };
    const res = await (0, import_cross_fetch.fetch)(this.getURL(relativePath, query), {
      mode: "cors",
      headers
    });
    return URLTokenBaseHTTPClient.formatFetchResponse(res);
  }
  async post(relativePath, data, query, requestHeaders = {}) {
    const headers = {
      ...this.tokenHeader,
      ...this.defaultHeaders,
      ...requestHeaders
    };
    const res = await (0, import_cross_fetch.fetch)(this.getURL(relativePath, query), {
      method: "POST",
      mode: "cors",
      body: data,
      headers
    });
    return URLTokenBaseHTTPClient.formatFetchResponse(res);
  }
  async delete(relativePath, data, query, requestHeaders = {}) {
    const headers = {
      ...this.tokenHeader,
      ...this.defaultHeaders,
      ...requestHeaders
    };
    const res = await (0, import_cross_fetch.fetch)(this.getURL(relativePath, query), {
      method: "DELETE",
      mode: "cors",
      body: data,
      headers
    });
    return URLTokenBaseHTTPClient.formatFetchResponse(res);
  }
};
function removeFalsyOrEmpty(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (!obj[key] || obj[key].length === 0)
        delete obj[key];
    }
  }
  return obj;
}
function tolowerCaseKeys(o) {
  return Object.keys(o).reduce((c, k) => (c[k.toLowerCase()] = o[k], c), {});
}
function getAcceptFormat(query) {
  if (query !== void 0 && Object.prototype.hasOwnProperty.call(query, "format")) {
    switch (query.format) {
      case "msgpack":
        return "application/msgpack";
      case "json":
      default:
        return "application/json";
    }
  } else
    return "application/json";
}
var HTTPClient = class {
  constructor(bcOrTokenHeader, baseServer, port, defaultHeaders = {}) {
    if (baseServer !== void 0) {
      this.bc = new URLTokenBaseHTTPClient(bcOrTokenHeader, baseServer, port, defaultHeaders);
    } else {
      this.bc = bcOrTokenHeader;
    }
  }
  /**
   * Parse JSON using either the built-in JSON.parse or utils.parseJSON
   * depending on whether jsonOptions are provided or not
   *
   * @param text - JSON data
   * @param status - Status of the response (used in case parseJSON fails)
   * @param jsonOptions - Options object to use to decode JSON responses. See
   *   utils.parseJSON for the options available.
   */
  static parseJSON(text, status, jsonOptions = {}) {
    try {
      if (Object.keys(jsonOptions).length === 0) {
        return text && JSON.parse(text);
      }
      return text && parseJSON(text, jsonOptions);
    } catch (err_) {
      const err2 = err_;
      err2.rawResponse = text || null;
      err2.statusCode = status;
      throw err2;
    }
  }
  /**
   * Serialize the data according to the requestHeaders
   * Assumes that requestHeaders contain a key "content-type"
   * If the content-type is "application/json", data is JSON serialized
   * Otherwise, data needs to be either an UTF-8 string that is converted to an Uint8Array
   * or an Uint8Array
   * @private
   */
  static serializeData(data, requestHeaders) {
    if (!data) {
      return new Uint8Array(0);
    }
    if (requestHeaders["content-type"] === "application/json") {
      return new Uint8Array(Buffer.from(JSON.stringify(data)));
    }
    if (typeof data === "string") {
      return new Uint8Array(Buffer.from(data));
    }
    if (data instanceof Uint8Array) {
      return data;
    }
    throw new Error("provided data is neither a string nor a Uint8Array and content-type is not application/json");
  }
  /**
   * Convert a BaseHTTPClientResponse into a full HTTPClientResponse
   * Parse the body in
   * Modifies in place res and return the result
   */
  static prepareResponse(res, format2, parseBody, jsonOptions = {}) {
    let { body } = res;
    let text;
    if (format2 !== "application/msgpack") {
      text = body && Buffer.from(body).toString() || "";
    }
    if (parseBody && format2 === "application/json") {
      body = HTTPClient.parseJSON(text, res.status, jsonOptions);
    }
    return {
      ...res,
      body,
      text,
      ok: Math.trunc(res.status / 100) === 2
    };
  }
  /**
   * Prepare an error with a response
   * (the type of errors BaseHTTPClient are supposed to throw)
   * by adding the status and preparing the internal response
   * @private
   */
  static prepareResponseError(err2) {
    if (err2.response) {
      err2.response = HTTPClient.prepareResponse(err2.response, "application/json", true);
      err2.status = err2.response.status;
    }
    return err2;
  }
  /**
   * Send a GET request.
   * @param relativePath - The path of the request.
   * @param query - An object containing the query parameters of the request.
   * @param requestHeaders - An object containing additional request headers to use.
   * @param jsonOptions - Options object to use to decode JSON responses. See
   *   utils.parseJSON for the options available.
   * @param parseBody - An optional boolean indicating whether the response body should be parsed
   *   or not.
   * @returns Response object.
   */
  async get(relativePath, query, requestHeaders = {}, jsonOptions = {}, parseBody = true) {
    const format2 = getAcceptFormat(query);
    const fullHeaders = { ...requestHeaders, accept: format2 };
    try {
      const res = await this.bc.get(relativePath, removeFalsyOrEmpty(query), fullHeaders);
      return HTTPClient.prepareResponse(res, format2, parseBody, jsonOptions);
    } catch (err2) {
      throw HTTPClient.prepareResponseError(err2);
    }
  }
  /**
   * Send a POST request.
   * If no content-type present, adds the header "content-type: application/json"
   * and data is serialized in JSON (if not empty)
   */
  async post(relativePath, data, requestHeaders = {}, query, parseBody = true) {
    const fullHeaders = {
      "content-type": "application/json",
      ...tolowerCaseKeys(requestHeaders)
    };
    try {
      const res = await this.bc.post(relativePath, HTTPClient.serializeData(data, fullHeaders), query, fullHeaders);
      return HTTPClient.prepareResponse(res, "application/json", parseBody);
    } catch (err2) {
      throw HTTPClient.prepareResponseError(err2);
    }
  }
  /**
   * Send a DELETE request.
   * If no content-type present, adds the header "content-type: application/json"
   * and data is serialized in JSON (if not empty)
   */
  async delete(relativePath, data, requestHeaders = {}, parseBody = true) {
    const fullHeaders = {
      "content-type": "application/json",
      ...tolowerCaseKeys(requestHeaders)
    };
    const res = await this.bc.delete(relativePath, HTTPClient.serializeData(data, fullHeaders), void 0, fullHeaders);
    return HTTPClient.prepareResponse(res, "application/json", parseBody);
  }
};
function convertTokenStringToTokenHeader(token = "", headerIdentifier) {
  const tokenHeader = {};
  tokenHeader[headerIdentifier] = token;
  return tokenHeader;
}
function isBaseHTTPClient(tbc) {
  return typeof tbc.get === "function";
}
var ServiceClient = class {
  constructor(tokenHeaderIdentifier, tokenHeaderOrStrOrBaseClient, baseServer, port, defaultHeaders = {}) {
    if (isBaseHTTPClient(tokenHeaderOrStrOrBaseClient)) {
      this.c = new HTTPClient(tokenHeaderOrStrOrBaseClient);
    } else {
      let tokenHeader;
      if (typeof tokenHeaderOrStrOrBaseClient === "string") {
        tokenHeader = convertTokenStringToTokenHeader(tokenHeaderOrStrOrBaseClient, tokenHeaderIdentifier);
      } else {
        tokenHeader = tokenHeaderOrStrOrBaseClient;
      }
      this.c = new HTTPClient(tokenHeader, baseServer, port, defaultHeaders);
    }
    this.intDecoding = intDecoding_default.DEFAULT;
  }
  /**
   * Set the default int decoding method for all JSON requests this client creates.
   * @param method - \{"default" | "safe" | "mixed" | "bigint"\} method The method to use when parsing the
   *   response for request. Must be one of "default", "safe", "mixed", or "bigint". See
   *   JSONRequest.setIntDecoding for more details about what each method does.
   */
  setIntEncoding(method) {
    this.intDecoding = method;
  }
  /**
   * Get the default int decoding method for all JSON requests this client creates.
   */
  getIntEncoding() {
    return this.intDecoding;
  }
};
var JSONRequest = class {
  /**
   * @param client - HTTPClient object.
   * @param intDecoding - The method to use
   *   for decoding integers from this request's response. See the setIntDecoding method for more
   *   details.
   */
  constructor(client, intDecoding) {
    this.c = client;
    this.query = {};
    this.intDecoding = intDecoding || intDecoding_default.DEFAULT;
  }
  /**
   * Prepare a JSON response before returning it.
   *
   * Use this method to change and restructure response
   * data as needed after receiving it from the `do()` method.
   * @param body - Response body received
   * @category JSONRequest
   */
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    return body;
  }
  /**
   * Execute the request.
   * @param headers - Additional headers to send in the request. Optional.
   * @returns A promise which resolves to the parsed response data.
   * @category JSONRequest
   */
  async do(headers = {}) {
    const jsonOptions = {};
    if (this.intDecoding !== "default") {
      jsonOptions.intDecoding = this.intDecoding;
    }
    const res = await this.c.get(this.path(), this.query, headers, jsonOptions);
    return this.prepare(res.body);
  }
  /**
   * Execute the request, but do not process the response data in any way.
   * @param headers - Additional headers to send in the request. Optional.
   * @returns A promise which resolves to the raw response data, exactly as returned by the server.
   * @category JSONRequest
   */
  async doRaw(headers = {}) {
    const res = await this.c.get(this.path(), this.query, headers, {}, false);
    return res.body;
  }
  /**
   * Configure how integers in this request's JSON response will be decoded.
   *
   * The options are:
   * * "default": Integers will be decoded according to JSON.parse, meaning they will all be
   *   Numbers and any values greater than Number.MAX_SAFE_INTEGER will lose precision.
   * * "safe": All integers will be decoded as Numbers, but if any values are greater than
   *   Number.MAX_SAFE_INTEGER an error will be thrown.
   * * "mixed": Integers will be decoded as Numbers if they are less than or equal to
   *   Number.MAX_SAFE_INTEGER, otherwise they will be decoded as BigInts.
   * * "bigint": All integers will be decoded as BigInts.
   *
   * @param method - The method to use when parsing the
   *   response for this request. Must be one of "default", "safe", "mixed", or "bigint".
   * @category JSONRequest
   */
  setIntDecoding(method) {
    if (method !== "default" && method !== "safe" && method !== "mixed" && method !== "bigint")
      throw new Error(`Invalid method for int decoding: ${method}`);
    this.intDecoding = method;
    return this;
  }
};
var AccountInformation = class extends JSONRequest {
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  path() {
    return `/v2/accounts/${this.account}`;
  }
  /**
   * Exclude assets and application data from results
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await algodClient.accountInformation(address)
   *        .exclude('all')
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  exclude(exclude) {
    this.query.exclude = exclude;
    return this;
  }
};
var AccountAssetInformation = class extends JSONRequest {
  constructor(c, intDecoding, account, assetID) {
    super(c, intDecoding);
    this.account = account;
    this.assetID = assetID;
    this.account = account;
    this.assetID = assetID;
  }
  path() {
    return `/v2/accounts/${this.account}/assets/${this.assetID}`;
  }
};
var AccountApplicationInformation = class extends JSONRequest {
  constructor(c, intDecoding, account, applicationID) {
    super(c, intDecoding);
    this.account = account;
    this.applicationID = applicationID;
    this.account = account;
    this.applicationID = applicationID;
  }
  path() {
    return `/v2/accounts/${this.account}/applications/${this.applicationID}`;
  }
};
var Block = class extends JSONRequest {
  constructor(c, roundNumber) {
    super(c);
    if (!Number.isInteger(roundNumber))
      throw Error("roundNumber should be an integer");
    this.round = roundNumber;
    this.query = { format: "msgpack" };
  }
  path() {
    return `/v2/blocks/${this.round}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    if (body && body.byteLength > 0) {
      return decode2(body);
    }
    return void 0;
  }
};
function setHeaders(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "text/plain";
  }
  return hdrs;
}
var Compile = class extends JSONRequest {
  constructor(c, source) {
    super(c);
    this.source = source;
    this.source = source;
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/teal/compile`;
  }
  sourcemap(map4 = true) {
    this.query.sourcemap = map4;
    return this;
  }
  /**
   * Executes compile
   * @param headers - A headers object
   */
  async do(headers = {}) {
    const txHeaders = setHeaders(headers);
    const res = await this.c.post(this.path(), Buffer.from(this.source), txHeaders, this.query);
    return res.body;
  }
};
var Dryrun = class extends JSONRequest {
  constructor(c, dr) {
    super(c);
    this.blob = encode2(dr.get_obj_for_encoding(true));
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/teal/dryrun";
  }
  /**
   * Executes dryrun
   * @param headers - A headers object
   */
  async do(headers = {}) {
    const txHeaders = setHeaders(headers);
    const res = await this.c.post(this.path(), Buffer.from(this.blob), txHeaders);
    return res.body;
  }
};
var Genesis = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/genesis";
  }
};
var GetAssetByID = class extends JSONRequest {
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  path() {
    return `/v2/assets/${this.index}`;
  }
};
var GetApplicationByID = class extends JSONRequest {
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  path() {
    return `/v2/applications/${this.index}`;
  }
};
var GetBlockHash = class extends JSONRequest {
  constructor(c, intDecoding, roundNumber) {
    super(c, intDecoding);
    if (!Number.isInteger(roundNumber))
      throw Error("roundNumber should be an integer");
    this.round = roundNumber;
  }
  path() {
    return `/v2/blocks/${this.round}/hash`;
  }
};
var types_exports = {};
__export(types_exports, {
  Account: () => Account,
  AccountApplicationResponse: () => AccountApplicationResponse,
  AccountAssetResponse: () => AccountAssetResponse,
  AccountParticipation: () => AccountParticipation,
  AccountStateDelta: () => AccountStateDelta,
  Application: () => Application,
  ApplicationLocalState: () => ApplicationLocalState,
  ApplicationParams: () => ApplicationParams,
  ApplicationStateSchema: () => ApplicationStateSchema,
  Asset: () => Asset,
  AssetHolding: () => AssetHolding,
  AssetParams: () => AssetParams,
  BlockHashResponse: () => BlockHashResponse,
  BlockResponse: () => BlockResponse,
  Box: () => Box,
  BoxDescriptor: () => BoxDescriptor,
  BoxesResponse: () => BoxesResponse,
  BuildVersion: () => BuildVersion,
  CompileResponse: () => CompileResponse,
  DisassembleResponse: () => DisassembleResponse,
  DryrunRequest: () => DryrunRequest,
  DryrunResponse: () => DryrunResponse,
  DryrunSource: () => DryrunSource,
  DryrunState: () => DryrunState,
  DryrunTxnResult: () => DryrunTxnResult,
  ErrorResponse: () => ErrorResponse,
  EvalDelta: () => EvalDelta,
  EvalDeltaKeyValue: () => EvalDeltaKeyValue,
  LightBlockHeaderProof: () => LightBlockHeaderProof,
  NodeStatusResponse: () => NodeStatusResponse,
  PendingTransactionResponse: () => PendingTransactionResponse,
  PendingTransactionsResponse: () => PendingTransactionsResponse,
  PostTransactionsResponse: () => PostTransactionsResponse,
  StateProof: () => StateProof,
  StateProofMessage: () => StateProofMessage,
  SupplyResponse: () => SupplyResponse,
  TealKeyValue: () => TealKeyValue,
  TealValue: () => TealValue,
  TransactionParametersResponse: () => TransactionParametersResponse,
  TransactionProofResponse: () => TransactionProofResponse,
  Version: () => Version
});
function _is_primitive(val) {
  return val === void 0 || val == null || typeof val !== "object" && typeof val !== "function";
}
function _get_obj_for_encoding(val, binary) {
  let targetPropValue;
  if (val instanceof Uint8Array) {
    targetPropValue = binary ? val : Buffer.from(val).toString("base64");
  } else if (typeof val.get_obj_for_encoding === "function") {
    targetPropValue = val.get_obj_for_encoding(binary);
  } else if (Array.isArray(val)) {
    targetPropValue = [];
    for (const elem of val) {
      targetPropValue.push(_get_obj_for_encoding(elem, binary));
    }
  } else if (typeof val === "object") {
    const obj = {};
    for (const prop of Object.keys(val)) {
      obj[prop] = _get_obj_for_encoding(val[prop], binary);
    }
    targetPropValue = obj;
  } else if (_is_primitive(val)) {
    targetPropValue = val;
  } else {
    throw new Error(`Unsupported value: ${String(val)}`);
  }
  return targetPropValue;
}
var BaseModel = class {
  /**
   * Get an object ready for encoding to either JSON or msgpack.
   * @param binary - Use true to indicate that the encoding can handle raw binary objects
   *   (Uint8Arrays). Use false to indicate that raw binary objects should be converted to base64
   *   strings. True should be used for objects that will be encoded with msgpack, and false should
   *   be used for objects that will be encoded with JSON.
   */
  get_obj_for_encoding(binary = false) {
    const obj = {};
    for (const prop of Object.keys(this.attribute_map)) {
      const name9 = this.attribute_map[prop];
      const value2 = this[prop];
      if (typeof value2 !== "undefined") {
        obj[name9] = value2 === null ? null : _get_obj_for_encoding(value2, binary);
      }
    }
    return obj;
  }
};
var Account = class extends BaseModel {
  /**
   * Creates a new `Account` object.
   * @param address - the account public key
   * @param amount - (algo) total number of MicroAlgos in the account
   * @param amountWithoutPendingRewards - specifies the amount of MicroAlgos in the account, without the pending rewards.
   * @param minBalance - MicroAlgo balance required by the account.
   * The requirement grows based on asset and application usage.
   * @param pendingRewards - amount of MicroAlgos of pending rewards in this account.
   * @param rewards - (ern) total rewards of MicroAlgos the account has received, including pending
   * rewards.
   * @param round - The round for which this information is relevant.
   * @param status - (onl) delegation status of the account's MicroAlgos
   * * Offline - indicates that the associated account is delegated.
   * * Online - indicates that the associated account used as part of the delegation
   * pool.
   * * NotParticipating - indicates that the associated account is neither a
   * delegator nor a delegate.
   * @param totalAppsOptedIn - The count of all applications that have been opted in, equivalent to the count
   * of application local data (AppLocalState objects) stored in this account.
   * @param totalAssetsOptedIn - The count of all assets that have been opted in, equivalent to the count of
   * AssetHolding objects held by this account.
   * @param totalCreatedApps - The count of all apps (AppParams objects) created by this account.
   * @param totalCreatedAssets - The count of all assets (AssetParams objects) created by this account.
   * @param appsLocalState - (appl) applications local data stored in this account.
   * Note the raw object uses `map[int] -> AppLocalState` for this type.
   * @param appsTotalExtraPages - (teap) the sum of all extra application program pages for this account.
   * @param appsTotalSchema - (tsch) stores the sum of all of the local schemas and globalThis schemas in this
   * account.
   * Note: the raw account uses `StateSchema` for this type.
   * @param assets - (asset) assets held by this account.
   * Note the raw object uses `map[int] -> AssetHolding` for this type.
   * @param authAddr - (spend) the address against which signing should be checked. If empty, the
   * address of the current account is used. This field can be updated in any
   * transaction by setting the RekeyTo field.
   * @param createdApps - (appp) parameters of applications created by this account including app globalThis
   * data.
   * Note: the raw account uses `map[int] -> AppParams` for this type.
   * @param createdAssets - (apar) parameters of assets created by this account.
   * Note: the raw account uses `map[int] -> Asset` for this type.
   * @param participation - AccountParticipation describes the parameters used by this account in consensus
   * protocol.
   * @param rewardBase - (ebase) used as part of the rewards computation. Only applicable to accounts
   * which are participating.
   * @param sigType - Indicates what type of signature is used by this account, must be one of:
   * * sig
   * * msig
   * * lsig
   * @param totalBoxBytes - (tbxb) The total number of bytes used by this account's app's box keys and
   * values.
   * @param totalBoxes - (tbx) The number of existing boxes created by this account's app.
   */
  constructor({ address, amount, amountWithoutPendingRewards, minBalance, pendingRewards, rewards, round, status, totalAppsOptedIn, totalAssetsOptedIn, totalCreatedApps, totalCreatedAssets, appsLocalState, appsTotalExtraPages, appsTotalSchema, assets, authAddr, createdApps, createdAssets, participation, rewardBase, sigType, totalBoxBytes, totalBoxes }) {
    super();
    this.address = address;
    this.amount = amount;
    this.amountWithoutPendingRewards = amountWithoutPendingRewards;
    this.minBalance = minBalance;
    this.pendingRewards = pendingRewards;
    this.rewards = rewards;
    this.round = round;
    this.status = status;
    this.totalAppsOptedIn = totalAppsOptedIn;
    this.totalAssetsOptedIn = totalAssetsOptedIn;
    this.totalCreatedApps = totalCreatedApps;
    this.totalCreatedAssets = totalCreatedAssets;
    this.appsLocalState = appsLocalState;
    this.appsTotalExtraPages = appsTotalExtraPages;
    this.appsTotalSchema = appsTotalSchema;
    this.assets = assets;
    this.authAddr = authAddr;
    this.createdApps = createdApps;
    this.createdAssets = createdAssets;
    this.participation = participation;
    this.rewardBase = rewardBase;
    this.sigType = sigType;
    this.totalBoxBytes = totalBoxBytes;
    this.totalBoxes = totalBoxes;
    this.attribute_map = {
      address: "address",
      amount: "amount",
      amountWithoutPendingRewards: "amount-without-pending-rewards",
      minBalance: "min-balance",
      pendingRewards: "pending-rewards",
      rewards: "rewards",
      round: "round",
      status: "status",
      totalAppsOptedIn: "total-apps-opted-in",
      totalAssetsOptedIn: "total-assets-opted-in",
      totalCreatedApps: "total-created-apps",
      totalCreatedAssets: "total-created-assets",
      appsLocalState: "apps-local-state",
      appsTotalExtraPages: "apps-total-extra-pages",
      appsTotalSchema: "apps-total-schema",
      assets: "assets",
      authAddr: "auth-addr",
      createdApps: "created-apps",
      createdAssets: "created-assets",
      participation: "participation",
      rewardBase: "reward-base",
      sigType: "sig-type",
      totalBoxBytes: "total-box-bytes",
      totalBoxes: "total-boxes"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["address"] === "undefined")
      throw new Error(`Response is missing required field 'address': ${data}`);
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["amount-without-pending-rewards"] === "undefined")
      throw new Error(`Response is missing required field 'amount-without-pending-rewards': ${data}`);
    if (typeof data["min-balance"] === "undefined")
      throw new Error(`Response is missing required field 'min-balance': ${data}`);
    if (typeof data["pending-rewards"] === "undefined")
      throw new Error(`Response is missing required field 'pending-rewards': ${data}`);
    if (typeof data["rewards"] === "undefined")
      throw new Error(`Response is missing required field 'rewards': ${data}`);
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    if (typeof data["status"] === "undefined")
      throw new Error(`Response is missing required field 'status': ${data}`);
    if (typeof data["total-apps-opted-in"] === "undefined")
      throw new Error(`Response is missing required field 'total-apps-opted-in': ${data}`);
    if (typeof data["total-assets-opted-in"] === "undefined")
      throw new Error(`Response is missing required field 'total-assets-opted-in': ${data}`);
    if (typeof data["total-created-apps"] === "undefined")
      throw new Error(`Response is missing required field 'total-created-apps': ${data}`);
    if (typeof data["total-created-assets"] === "undefined")
      throw new Error(`Response is missing required field 'total-created-assets': ${data}`);
    return new Account({
      address: data["address"],
      amount: data["amount"],
      amountWithoutPendingRewards: data["amount-without-pending-rewards"],
      minBalance: data["min-balance"],
      pendingRewards: data["pending-rewards"],
      rewards: data["rewards"],
      round: data["round"],
      status: data["status"],
      totalAppsOptedIn: data["total-apps-opted-in"],
      totalAssetsOptedIn: data["total-assets-opted-in"],
      totalCreatedApps: data["total-created-apps"],
      totalCreatedAssets: data["total-created-assets"],
      appsLocalState: typeof data["apps-local-state"] !== "undefined" ? data["apps-local-state"].map(ApplicationLocalState.from_obj_for_encoding) : void 0,
      appsTotalExtraPages: data["apps-total-extra-pages"],
      appsTotalSchema: typeof data["apps-total-schema"] !== "undefined" ? ApplicationStateSchema.from_obj_for_encoding(data["apps-total-schema"]) : void 0,
      assets: typeof data["assets"] !== "undefined" ? data["assets"].map(AssetHolding.from_obj_for_encoding) : void 0,
      authAddr: data["auth-addr"],
      createdApps: typeof data["created-apps"] !== "undefined" ? data["created-apps"].map(Application.from_obj_for_encoding) : void 0,
      createdAssets: typeof data["created-assets"] !== "undefined" ? data["created-assets"].map(Asset.from_obj_for_encoding) : void 0,
      participation: typeof data["participation"] !== "undefined" ? AccountParticipation.from_obj_for_encoding(data["participation"]) : void 0,
      rewardBase: data["reward-base"],
      sigType: data["sig-type"],
      totalBoxBytes: data["total-box-bytes"],
      totalBoxes: data["total-boxes"]
    });
  }
};
var AccountApplicationResponse = class extends BaseModel {
  /**
   * Creates a new `AccountApplicationResponse` object.
   * @param round - The round for which this information is relevant.
   * @param appLocalState - (appl) the application local data stored in this account.
   * The raw account uses `AppLocalState` for this type.
   * @param createdApp - (appp) parameters of the application created by this account including app
   * globalThis data.
   * The raw account uses `AppParams` for this type.
   */
  constructor({ round, appLocalState, createdApp }) {
    super();
    this.round = round;
    this.appLocalState = appLocalState;
    this.createdApp = createdApp;
    this.attribute_map = {
      round: "round",
      appLocalState: "app-local-state",
      createdApp: "created-app"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    return new AccountApplicationResponse({
      round: data["round"],
      appLocalState: typeof data["app-local-state"] !== "undefined" ? ApplicationLocalState.from_obj_for_encoding(data["app-local-state"]) : void 0,
      createdApp: typeof data["created-app"] !== "undefined" ? ApplicationParams.from_obj_for_encoding(data["created-app"]) : void 0
    });
  }
};
var AccountAssetResponse = class extends BaseModel {
  /**
   * Creates a new `AccountAssetResponse` object.
   * @param round - The round for which this information is relevant.
   * @param assetHolding - (asset) Details about the asset held by this account.
   * The raw account uses `AssetHolding` for this type.
   * @param createdAsset - (apar) parameters of the asset created by this account.
   * The raw account uses `AssetParams` for this type.
   */
  constructor({ round, assetHolding, createdAsset }) {
    super();
    this.round = round;
    this.assetHolding = assetHolding;
    this.createdAsset = createdAsset;
    this.attribute_map = {
      round: "round",
      assetHolding: "asset-holding",
      createdAsset: "created-asset"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    return new AccountAssetResponse({
      round: data["round"],
      assetHolding: typeof data["asset-holding"] !== "undefined" ? AssetHolding.from_obj_for_encoding(data["asset-holding"]) : void 0,
      createdAsset: typeof data["created-asset"] !== "undefined" ? AssetParams.from_obj_for_encoding(data["created-asset"]) : void 0
    });
  }
};
var AccountParticipation = class extends BaseModel {
  /**
   * Creates a new `AccountParticipation` object.
   * @param selectionParticipationKey - (sel) Selection public key (if any) currently registered for this round.
   * @param voteFirstValid - (voteFst) First round for which this participation is valid.
   * @param voteKeyDilution - (voteKD) Number of subkeys in each batch of participation keys.
   * @param voteLastValid - (voteLst) Last round for which this participation is valid.
   * @param voteParticipationKey - (vote) root participation public key (if any) currently registered for this
   * round.
   * @param stateProofKey - (stprf) Root of the state proof key (if any)
   */
  constructor({ selectionParticipationKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey, stateProofKey }) {
    super();
    this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? new Uint8Array(Buffer.from(selectionParticipationKey, "base64")) : selectionParticipationKey;
    this.voteFirstValid = voteFirstValid;
    this.voteKeyDilution = voteKeyDilution;
    this.voteLastValid = voteLastValid;
    this.voteParticipationKey = typeof voteParticipationKey === "string" ? new Uint8Array(Buffer.from(voteParticipationKey, "base64")) : voteParticipationKey;
    this.stateProofKey = typeof stateProofKey === "string" ? new Uint8Array(Buffer.from(stateProofKey, "base64")) : stateProofKey;
    this.attribute_map = {
      selectionParticipationKey: "selection-participation-key",
      voteFirstValid: "vote-first-valid",
      voteKeyDilution: "vote-key-dilution",
      voteLastValid: "vote-last-valid",
      voteParticipationKey: "vote-participation-key",
      stateProofKey: "state-proof-key"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["selection-participation-key"] === "undefined")
      throw new Error(`Response is missing required field 'selection-participation-key': ${data}`);
    if (typeof data["vote-first-valid"] === "undefined")
      throw new Error(`Response is missing required field 'vote-first-valid': ${data}`);
    if (typeof data["vote-key-dilution"] === "undefined")
      throw new Error(`Response is missing required field 'vote-key-dilution': ${data}`);
    if (typeof data["vote-last-valid"] === "undefined")
      throw new Error(`Response is missing required field 'vote-last-valid': ${data}`);
    if (typeof data["vote-participation-key"] === "undefined")
      throw new Error(`Response is missing required field 'vote-participation-key': ${data}`);
    return new AccountParticipation({
      selectionParticipationKey: data["selection-participation-key"],
      voteFirstValid: data["vote-first-valid"],
      voteKeyDilution: data["vote-key-dilution"],
      voteLastValid: data["vote-last-valid"],
      voteParticipationKey: data["vote-participation-key"],
      stateProofKey: data["state-proof-key"]
    });
  }
};
var AccountStateDelta = class extends BaseModel {
  /**
   * Creates a new `AccountStateDelta` object.
   * @param address -
   * @param delta - Application state delta.
   */
  constructor({ address, delta }) {
    super();
    this.address = address;
    this.delta = delta;
    this.attribute_map = {
      address: "address",
      delta: "delta"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["address"] === "undefined")
      throw new Error(`Response is missing required field 'address': ${data}`);
    if (!Array.isArray(data["delta"]))
      throw new Error(`Response is missing required array field 'delta': ${data}`);
    return new AccountStateDelta({
      address: data["address"],
      delta: data["delta"].map(EvalDeltaKeyValue.from_obj_for_encoding)
    });
  }
};
var Application = class extends BaseModel {
  /**
   * Creates a new `Application` object.
   * @param id - (appidx) application index.
   * @param params - (appparams) application parameters.
   */
  constructor({ id, params }) {
    super();
    this.id = id;
    this.params = params;
    this.attribute_map = {
      id: "id",
      params: "params"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["id"] === "undefined")
      throw new Error(`Response is missing required field 'id': ${data}`);
    if (typeof data["params"] === "undefined")
      throw new Error(`Response is missing required field 'params': ${data}`);
    return new Application({
      id: data["id"],
      params: ApplicationParams.from_obj_for_encoding(data["params"])
    });
  }
};
var ApplicationLocalState = class extends BaseModel {
  /**
   * Creates a new `ApplicationLocalState` object.
   * @param id - The application which this local state is for.
   * @param schema - (hsch) schema.
   * @param keyValue - (tkv) storage.
   */
  constructor({ id, schema, keyValue }) {
    super();
    this.id = id;
    this.schema = schema;
    this.keyValue = keyValue;
    this.attribute_map = {
      id: "id",
      schema: "schema",
      keyValue: "key-value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["id"] === "undefined")
      throw new Error(`Response is missing required field 'id': ${data}`);
    if (typeof data["schema"] === "undefined")
      throw new Error(`Response is missing required field 'schema': ${data}`);
    return new ApplicationLocalState({
      id: data["id"],
      schema: ApplicationStateSchema.from_obj_for_encoding(data["schema"]),
      keyValue: typeof data["key-value"] !== "undefined" ? data["key-value"].map(TealKeyValue.from_obj_for_encoding) : void 0
    });
  }
};
var ApplicationParams = class extends BaseModel {
  /**
   * Creates a new `ApplicationParams` object.
   * @param approvalProgram - (approv) approval program.
   * @param clearStateProgram - (clearp) approval program.
   * @param creator - The address that created this application. This is the address where the
   * parameters and globalThis state for this application can be found.
   * @param extraProgramPages - (epp) the amount of extra program pages available to this app.
   * @param globalState - [\gs) globalThis schema
   * @param globalStateSchema - [\gsch) globalThis schema
   * @param localStateSchema - [\lsch) local schema
   */
  constructor({ approvalProgram, clearStateProgram, creator, extraProgramPages, globalState, globalStateSchema, localStateSchema }) {
    super();
    this.approvalProgram = typeof approvalProgram === "string" ? new Uint8Array(Buffer.from(approvalProgram, "base64")) : approvalProgram;
    this.clearStateProgram = typeof clearStateProgram === "string" ? new Uint8Array(Buffer.from(clearStateProgram, "base64")) : clearStateProgram;
    this.creator = creator;
    this.extraProgramPages = extraProgramPages;
    this.globalState = globalState;
    this.globalStateSchema = globalStateSchema;
    this.localStateSchema = localStateSchema;
    this.attribute_map = {
      approvalProgram: "approval-program",
      clearStateProgram: "clear-state-program",
      creator: "creator",
      extraProgramPages: "extra-program-pages",
      globalState: "globalThis-state",
      globalStateSchema: "globalThis-state-schema",
      localStateSchema: "local-state-schema"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["approval-program"] === "undefined")
      throw new Error(`Response is missing required field 'approval-program': ${data}`);
    if (typeof data["clear-state-program"] === "undefined")
      throw new Error(`Response is missing required field 'clear-state-program': ${data}`);
    if (typeof data["creator"] === "undefined")
      throw new Error(`Response is missing required field 'creator': ${data}`);
    return new ApplicationParams({
      approvalProgram: data["approval-program"],
      clearStateProgram: data["clear-state-program"],
      creator: data["creator"],
      extraProgramPages: data["extra-program-pages"],
      globalState: typeof data["globalThis-state"] !== "undefined" ? data["globalThis-state"].map(TealKeyValue.from_obj_for_encoding) : void 0,
      globalStateSchema: typeof data["globalThis-state-schema"] !== "undefined" ? ApplicationStateSchema.from_obj_for_encoding(data["globalThis-state-schema"]) : void 0,
      localStateSchema: typeof data["local-state-schema"] !== "undefined" ? ApplicationStateSchema.from_obj_for_encoding(data["local-state-schema"]) : void 0
    });
  }
};
var ApplicationStateSchema = class extends BaseModel {
  /**
   * Creates a new `ApplicationStateSchema` object.
   * @param numUint - (nui) num of uints.
   * @param numByteSlice - (nbs) num of byte slices.
   */
  constructor({ numUint, numByteSlice }) {
    super();
    this.numUint = numUint;
    this.numByteSlice = numByteSlice;
    this.attribute_map = {
      numUint: "num-uint",
      numByteSlice: "num-byte-slice"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["num-uint"] === "undefined")
      throw new Error(`Response is missing required field 'num-uint': ${data}`);
    if (typeof data["num-byte-slice"] === "undefined")
      throw new Error(`Response is missing required field 'num-byte-slice': ${data}`);
    return new ApplicationStateSchema({
      numUint: data["num-uint"],
      numByteSlice: data["num-byte-slice"]
    });
  }
};
var Asset = class extends BaseModel {
  /**
   * Creates a new `Asset` object.
   * @param index - unique asset identifier
   * @param params - AssetParams specifies the parameters for an asset.
   * (apar) when part of an AssetConfig transaction.
   * Definition:
   * data/transactions/asset.go : AssetParams
   */
  constructor({ index: index2, params }) {
    super();
    this.index = index2;
    this.params = params;
    this.attribute_map = {
      index: "index",
      params: "params"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["index"] === "undefined")
      throw new Error(`Response is missing required field 'index': ${data}`);
    if (typeof data["params"] === "undefined")
      throw new Error(`Response is missing required field 'params': ${data}`);
    return new Asset({
      index: data["index"],
      params: AssetParams.from_obj_for_encoding(data["params"])
    });
  }
};
var AssetHolding = class extends BaseModel {
  /**
   * Creates a new `AssetHolding` object.
   * @param amount - (a) number of units held.
   * @param assetId - Asset ID of the holding.
   * @param isFrozen - (f) whether or not the holding is frozen.
   */
  constructor({ amount, assetId, isFrozen }) {
    super();
    this.amount = amount;
    this.assetId = assetId;
    this.isFrozen = isFrozen;
    this.attribute_map = {
      amount: "amount",
      assetId: "asset-id",
      isFrozen: "is-frozen"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["asset-id"] === "undefined")
      throw new Error(`Response is missing required field 'asset-id': ${data}`);
    if (typeof data["is-frozen"] === "undefined")
      throw new Error(`Response is missing required field 'is-frozen': ${data}`);
    return new AssetHolding({
      amount: data["amount"],
      assetId: data["asset-id"],
      isFrozen: data["is-frozen"]
    });
  }
};
var AssetParams = class extends BaseModel {
  /**
   * Creates a new `AssetParams` object.
   * @param creator - The address that created this asset. This is the address where the parameters
   * for this asset can be found, and also the address where unwanted asset units can
   * be sent in the worst case.
   * @param decimals - (dc) The number of digits to use after the decimal point when displaying this
   * asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in
   * tenths. If 2, the base unit of the asset is in hundredths, and so on. This value
   * must be between 0 and 19 (inclusive).
   * @param total - (t) The total number of units of this asset.
   * @param clawback - (c) Address of account used to clawback holdings of this asset. If empty,
   * clawback is not permitted.
   * @param defaultFrozen - (df) Whether holdings of this asset are frozen by default.
   * @param freeze - (f) Address of account used to freeze holdings of this asset. If empty, freezing
   * is not permitted.
   * @param manager - (m) Address of account used to manage the keys of this asset and to destroy it.
   * @param metadataHash - (am) A commitment to some unspecified asset metadata. The format of this
   * metadata is up to the application.
   * @param name - (an) Name of this asset, as supplied by the creator. Included only when the
   * asset name is composed of printable utf-8 characters.
   * @param nameB64 - Base64 encoded name of this asset, as supplied by the creator.
   * @param reserve - (r) Address of account holding reserve (non-minted) units of this asset.
   * @param unitName - (un) Name of a unit of this asset, as supplied by the creator. Included only
   * when the name of a unit of this asset is composed of printable utf-8 characters.
   * @param unitNameB64 - Base64 encoded name of a unit of this asset, as supplied by the creator.
   * @param url - (au) URL where more information about the asset can be retrieved. Included only
   * when the URL is composed of printable utf-8 characters.
   * @param urlB64 - Base64 encoded URL where more information about the asset can be retrieved.
   */
  constructor({ creator, decimals, total, clawback, defaultFrozen, freeze, manager, metadataHash, name: name9, nameB64, reserve, unitName, unitNameB64, url: url2, urlB64 }) {
    super();
    this.creator = creator;
    this.decimals = decimals;
    this.total = total;
    this.clawback = clawback;
    this.defaultFrozen = defaultFrozen;
    this.freeze = freeze;
    this.manager = manager;
    this.metadataHash = typeof metadataHash === "string" ? new Uint8Array(Buffer.from(metadataHash, "base64")) : metadataHash;
    this.name = name9;
    this.nameB64 = typeof nameB64 === "string" ? new Uint8Array(Buffer.from(nameB64, "base64")) : nameB64;
    this.reserve = reserve;
    this.unitName = unitName;
    this.unitNameB64 = typeof unitNameB64 === "string" ? new Uint8Array(Buffer.from(unitNameB64, "base64")) : unitNameB64;
    this.url = url2;
    this.urlB64 = typeof urlB64 === "string" ? new Uint8Array(Buffer.from(urlB64, "base64")) : urlB64;
    this.attribute_map = {
      creator: "creator",
      decimals: "decimals",
      total: "total",
      clawback: "clawback",
      defaultFrozen: "default-frozen",
      freeze: "freeze",
      manager: "manager",
      metadataHash: "metadata-hash",
      name: "name",
      nameB64: "name-b64",
      reserve: "reserve",
      unitName: "unit-name",
      unitNameB64: "unit-name-b64",
      url: "url",
      urlB64: "url-b64"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["creator"] === "undefined")
      throw new Error(`Response is missing required field 'creator': ${data}`);
    if (typeof data["decimals"] === "undefined")
      throw new Error(`Response is missing required field 'decimals': ${data}`);
    if (typeof data["total"] === "undefined")
      throw new Error(`Response is missing required field 'total': ${data}`);
    return new AssetParams({
      creator: data["creator"],
      decimals: data["decimals"],
      total: data["total"],
      clawback: data["clawback"],
      defaultFrozen: data["default-frozen"],
      freeze: data["freeze"],
      manager: data["manager"],
      metadataHash: data["metadata-hash"],
      name: data["name"],
      nameB64: data["name-b64"],
      reserve: data["reserve"],
      unitName: data["unit-name"],
      unitNameB64: data["unit-name-b64"],
      url: data["url"],
      urlB64: data["url-b64"]
    });
  }
};
var BlockHashResponse = class extends BaseModel {
  /**
   * Creates a new `BlockHashResponse` object.
   * @param blockhash - Block header hash.
   */
  constructor({ blockhash }) {
    super();
    this.blockhash = blockhash;
    this.attribute_map = {
      blockhash: "blockHash"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["blockHash"] === "undefined")
      throw new Error(`Response is missing required field 'blockHash': ${data}`);
    return new BlockHashResponse({
      blockhash: data["blockHash"]
    });
  }
};
var BlockResponse = class extends BaseModel {
  /**
   * Creates a new `BlockResponse` object.
   * @param block - Block header data.
   * @param cert - Optional certificate object. This is only included when the format is set to
   * message pack.
   */
  constructor({ block, cert }) {
    super();
    this.block = block;
    this.cert = cert;
    this.attribute_map = {
      block: "block",
      cert: "cert"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["block"] === "undefined")
      throw new Error(`Response is missing required field 'block': ${data}`);
    return new BlockResponse({
      block: data["block"],
      cert: data["cert"]
    });
  }
};
var Box = class extends BaseModel {
  /**
   * Creates a new `Box` object.
   * @param name - (name) box name, base64 encoded
   * @param value - (value) box value, base64 encoded.
   */
  constructor({ name: name9, value: value2 }) {
    super();
    this.name = typeof name9 === "string" ? new Uint8Array(Buffer.from(name9, "base64")) : name9;
    this.value = typeof value2 === "string" ? new Uint8Array(Buffer.from(value2, "base64")) : value2;
    this.attribute_map = {
      name: "name",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["name"] === "undefined")
      throw new Error(`Response is missing required field 'name': ${data}`);
    if (typeof data["value"] === "undefined")
      throw new Error(`Response is missing required field 'value': ${data}`);
    return new Box({
      name: data["name"],
      value: data["value"]
    });
  }
};
var BoxDescriptor = class extends BaseModel {
  /**
   * Creates a new `BoxDescriptor` object.
   * @param name - Base64 encoded box name
   */
  constructor({ name: name9 }) {
    super();
    this.name = typeof name9 === "string" ? new Uint8Array(Buffer.from(name9, "base64")) : name9;
    this.attribute_map = {
      name: "name"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["name"] === "undefined")
      throw new Error(`Response is missing required field 'name': ${data}`);
    return new BoxDescriptor({
      name: data["name"]
    });
  }
};
var BoxesResponse = class extends BaseModel {
  /**
   * Creates a new `BoxesResponse` object.
   * @param boxes -
   */
  constructor({ boxes }) {
    super();
    this.boxes = boxes;
    this.attribute_map = {
      boxes: "boxes"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["boxes"]))
      throw new Error(`Response is missing required array field 'boxes': ${data}`);
    return new BoxesResponse({
      boxes: data["boxes"].map(BoxDescriptor.from_obj_for_encoding)
    });
  }
};
var BuildVersion = class extends BaseModel {
  /**
   * Creates a new `BuildVersion` object.
   * @param branch -
   * @param buildNumber -
   * @param channel -
   * @param commitHash -
   * @param major -
   * @param minor -
   */
  constructor({ branch, buildNumber, channel, commitHash, major, minor }) {
    super();
    this.branch = branch;
    this.buildNumber = buildNumber;
    this.channel = channel;
    this.commitHash = commitHash;
    this.major = major;
    this.minor = minor;
    this.attribute_map = {
      branch: "branch",
      buildNumber: "build_number",
      channel: "channel",
      commitHash: "commit_hash",
      major: "major",
      minor: "minor"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["branch"] === "undefined")
      throw new Error(`Response is missing required field 'branch': ${data}`);
    if (typeof data["build_number"] === "undefined")
      throw new Error(`Response is missing required field 'build_number': ${data}`);
    if (typeof data["channel"] === "undefined")
      throw new Error(`Response is missing required field 'channel': ${data}`);
    if (typeof data["commit_hash"] === "undefined")
      throw new Error(`Response is missing required field 'commit_hash': ${data}`);
    if (typeof data["major"] === "undefined")
      throw new Error(`Response is missing required field 'major': ${data}`);
    if (typeof data["minor"] === "undefined")
      throw new Error(`Response is missing required field 'minor': ${data}`);
    return new BuildVersion({
      branch: data["branch"],
      buildNumber: data["build_number"],
      channel: data["channel"],
      commitHash: data["commit_hash"],
      major: data["major"],
      minor: data["minor"]
    });
  }
};
var CompileResponse = class extends BaseModel {
  /**
   * Creates a new `CompileResponse` object.
   * @param hash - base32 SHA512_256 of program bytes (Address style)
   * @param result - base64 encoded program bytes
   * @param sourcemap - JSON of the source map
   */
  constructor({ hash: hash2, result, sourcemap }) {
    super();
    this.hash = hash2;
    this.result = result;
    this.sourcemap = sourcemap;
    this.attribute_map = {
      hash: "hash",
      result: "result",
      sourcemap: "sourcemap"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["hash"] === "undefined")
      throw new Error(`Response is missing required field 'hash': ${data}`);
    if (typeof data["result"] === "undefined")
      throw new Error(`Response is missing required field 'result': ${data}`);
    return new CompileResponse({
      hash: data["hash"],
      result: data["result"],
      sourcemap: data["sourcemap"]
    });
  }
};
var DisassembleResponse = class extends BaseModel {
  /**
   * Creates a new `DisassembleResponse` object.
   * @param result - disassembled Teal code
   */
  constructor({ result }) {
    super();
    this.result = result;
    this.attribute_map = {
      result: "result"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["result"] === "undefined")
      throw new Error(`Response is missing required field 'result': ${data}`);
    return new DisassembleResponse({
      result: data["result"]
    });
  }
};
var DryrunRequest = class extends BaseModel {
  /**
   * Creates a new `DryrunRequest` object.
   * @param accounts -
   * @param apps -
   * @param latestTimestamp - LatestTimestamp is available to some TEAL scripts. Defaults to the latest
   * confirmed timestamp this algod is attached to.
   * @param protocolVersion - ProtocolVersion specifies a specific version string to operate under, otherwise
   * whatever the current protocol of the network this algod is running in.
   * @param round - Round is available to some TEAL scripts. Defaults to the current round on the
   * network this algod is attached to.
   * @param sources -
   * @param txns -
   */
  constructor({ accounts, apps, latestTimestamp, protocolVersion, round, sources, txns }) {
    super();
    this.accounts = accounts;
    this.apps = apps;
    this.latestTimestamp = latestTimestamp;
    this.protocolVersion = protocolVersion;
    this.round = round;
    this.sources = sources;
    this.txns = txns;
    this.attribute_map = {
      accounts: "accounts",
      apps: "apps",
      latestTimestamp: "latest-timestamp",
      protocolVersion: "protocol-version",
      round: "round",
      sources: "sources",
      txns: "txns"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["accounts"]))
      throw new Error(`Response is missing required array field 'accounts': ${data}`);
    if (!Array.isArray(data["apps"]))
      throw new Error(`Response is missing required array field 'apps': ${data}`);
    if (typeof data["latest-timestamp"] === "undefined")
      throw new Error(`Response is missing required field 'latest-timestamp': ${data}`);
    if (typeof data["protocol-version"] === "undefined")
      throw new Error(`Response is missing required field 'protocol-version': ${data}`);
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    if (!Array.isArray(data["sources"]))
      throw new Error(`Response is missing required array field 'sources': ${data}`);
    if (!Array.isArray(data["txns"]))
      throw new Error(`Response is missing required array field 'txns': ${data}`);
    return new DryrunRequest({
      accounts: data["accounts"].map(Account.from_obj_for_encoding),
      apps: data["apps"].map(Application.from_obj_for_encoding),
      latestTimestamp: data["latest-timestamp"],
      protocolVersion: data["protocol-version"],
      round: data["round"],
      sources: data["sources"].map(DryrunSource.from_obj_for_encoding),
      txns: data["txns"]
    });
  }
};
var DryrunResponse = class extends BaseModel {
  /**
   * Creates a new `DryrunResponse` object.
   * @param error -
   * @param protocolVersion - Protocol version is the protocol version Dryrun was operated under.
   * @param txns -
   */
  constructor({ error, protocolVersion, txns }) {
    super();
    this.error = error;
    this.protocolVersion = protocolVersion;
    this.txns = txns;
    this.attribute_map = {
      error: "error",
      protocolVersion: "protocol-version",
      txns: "txns"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["error"] === "undefined")
      throw new Error(`Response is missing required field 'error': ${data}`);
    if (typeof data["protocol-version"] === "undefined")
      throw new Error(`Response is missing required field 'protocol-version': ${data}`);
    if (!Array.isArray(data["txns"]))
      throw new Error(`Response is missing required array field 'txns': ${data}`);
    return new DryrunResponse({
      error: data["error"],
      protocolVersion: data["protocol-version"],
      txns: data["txns"].map(DryrunTxnResult.from_obj_for_encoding)
    });
  }
};
var DryrunSource = class extends BaseModel {
  /**
   * Creates a new `DryrunSource` object.
   * @param fieldName - FieldName is what kind of sources this is. If lsig then it goes into the
   * transactions[this.TxnIndex].LogicSig. If approv or clearp it goes into the
   * Approval Program or Clear State Program of application[this.AppIndex].
   * @param source -
   * @param txnIndex -
   * @param appIndex -
   */
  constructor({ fieldName, source, txnIndex, appIndex }) {
    super();
    this.fieldName = fieldName;
    this.source = source;
    this.txnIndex = txnIndex;
    this.appIndex = appIndex;
    this.attribute_map = {
      fieldName: "field-name",
      source: "source",
      txnIndex: "txn-index",
      appIndex: "app-index"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["field-name"] === "undefined")
      throw new Error(`Response is missing required field 'field-name': ${data}`);
    if (typeof data["source"] === "undefined")
      throw new Error(`Response is missing required field 'source': ${data}`);
    if (typeof data["txn-index"] === "undefined")
      throw new Error(`Response is missing required field 'txn-index': ${data}`);
    if (typeof data["app-index"] === "undefined")
      throw new Error(`Response is missing required field 'app-index': ${data}`);
    return new DryrunSource({
      fieldName: data["field-name"],
      source: data["source"],
      txnIndex: data["txn-index"],
      appIndex: data["app-index"]
    });
  }
};
var DryrunState = class extends BaseModel {
  /**
   * Creates a new `DryrunState` object.
   * @param line - Line number
   * @param pc - Program counter
   * @param stack -
   * @param error - Evaluation error if any
   * @param scratch -
   */
  constructor({ line, pc, stack, error, scratch }) {
    super();
    this.line = line;
    this.pc = pc;
    this.stack = stack;
    this.error = error;
    this.scratch = scratch;
    this.attribute_map = {
      line: "line",
      pc: "pc",
      stack: "stack",
      error: "error",
      scratch: "scratch"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["line"] === "undefined")
      throw new Error(`Response is missing required field 'line': ${data}`);
    if (typeof data["pc"] === "undefined")
      throw new Error(`Response is missing required field 'pc': ${data}`);
    if (!Array.isArray(data["stack"]))
      throw new Error(`Response is missing required array field 'stack': ${data}`);
    return new DryrunState({
      line: data["line"],
      pc: data["pc"],
      stack: data["stack"].map(TealValue.from_obj_for_encoding),
      error: data["error"],
      scratch: typeof data["scratch"] !== "undefined" ? data["scratch"].map(TealValue.from_obj_for_encoding) : void 0
    });
  }
};
var DryrunTxnResult = class extends BaseModel {
  /**
   * Creates a new `DryrunTxnResult` object.
   * @param disassembly - Disassembled program line by line.
   * @param appCallMessages -
   * @param appCallTrace -
   * @param budgetAdded - Budget added during execution of app call transaction.
   * @param budgetConsumed - Budget consumed during execution of app call transaction.
   * @param globalDelta - Application state delta.
   * @param localDeltas -
   * @param logicSigDisassembly - Disassembled lsig program line by line.
   * @param logicSigMessages -
   * @param logicSigTrace -
   * @param logs -
   */
  constructor({ disassembly, appCallMessages, appCallTrace, budgetAdded, budgetConsumed, globalDelta, localDeltas, logicSigDisassembly, logicSigMessages, logicSigTrace, logs }) {
    super();
    this.disassembly = disassembly;
    this.appCallMessages = appCallMessages;
    this.appCallTrace = appCallTrace;
    this.budgetAdded = budgetAdded;
    this.budgetConsumed = budgetConsumed;
    this.globalDelta = globalDelta;
    this.localDeltas = localDeltas;
    this.logicSigDisassembly = logicSigDisassembly;
    this.logicSigMessages = logicSigMessages;
    this.logicSigTrace = logicSigTrace;
    this.logs = logs;
    this.attribute_map = {
      disassembly: "disassembly",
      appCallMessages: "app-call-messages",
      appCallTrace: "app-call-trace",
      budgetAdded: "budget-added",
      budgetConsumed: "budget-consumed",
      globalDelta: "globalThis-delta",
      localDeltas: "local-deltas",
      logicSigDisassembly: "logic-sig-disassembly",
      logicSigMessages: "logic-sig-messages",
      logicSigTrace: "logic-sig-trace",
      logs: "logs"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["disassembly"]))
      throw new Error(`Response is missing required array field 'disassembly': ${data}`);
    return new DryrunTxnResult({
      disassembly: data["disassembly"],
      appCallMessages: data["app-call-messages"],
      appCallTrace: typeof data["app-call-trace"] !== "undefined" ? data["app-call-trace"].map(DryrunState.from_obj_for_encoding) : void 0,
      budgetAdded: data["budget-added"],
      budgetConsumed: data["budget-consumed"],
      globalDelta: typeof data["globalThis-delta"] !== "undefined" ? data["globalThis-delta"].map(EvalDeltaKeyValue.from_obj_for_encoding) : void 0,
      localDeltas: typeof data["local-deltas"] !== "undefined" ? data["local-deltas"].map(AccountStateDelta.from_obj_for_encoding) : void 0,
      logicSigDisassembly: data["logic-sig-disassembly"],
      logicSigMessages: data["logic-sig-messages"],
      logicSigTrace: typeof data["logic-sig-trace"] !== "undefined" ? data["logic-sig-trace"].map(DryrunState.from_obj_for_encoding) : void 0,
      logs: data["logs"]
    });
  }
};
var ErrorResponse = class extends BaseModel {
  /**
   * Creates a new `ErrorResponse` object.
   * @param message -
   * @param data -
   */
  constructor({ message: message2, data }) {
    super();
    this.message = message2;
    this.data = data;
    this.attribute_map = {
      message: "message",
      data: "data"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["message"] === "undefined")
      throw new Error(`Response is missing required field 'message': ${data}`);
    return new ErrorResponse({
      message: data["message"],
      data: data["data"]
    });
  }
};
var EvalDelta = class extends BaseModel {
  /**
   * Creates a new `EvalDelta` object.
   * @param action - (at) delta action.
   * @param bytes - (bs) bytes value.
   * @param uint - (ui) uint value.
   */
  constructor({ action, bytes, uint }) {
    super();
    this.action = action;
    this.bytes = bytes;
    this.uint = uint;
    this.attribute_map = {
      action: "action",
      bytes: "bytes",
      uint: "uint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["action"] === "undefined")
      throw new Error(`Response is missing required field 'action': ${data}`);
    return new EvalDelta({
      action: data["action"],
      bytes: data["bytes"],
      uint: data["uint"]
    });
  }
};
var EvalDeltaKeyValue = class extends BaseModel {
  /**
   * Creates a new `EvalDeltaKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value delta.
   */
  constructor({ key, value: value2 }) {
    super();
    this.key = key;
    this.value = value2;
    this.attribute_map = {
      key: "key",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["key"] === "undefined")
      throw new Error(`Response is missing required field 'key': ${data}`);
    if (typeof data["value"] === "undefined")
      throw new Error(`Response is missing required field 'value': ${data}`);
    return new EvalDeltaKeyValue({
      key: data["key"],
      value: EvalDelta.from_obj_for_encoding(data["value"])
    });
  }
};
var LightBlockHeaderProof = class extends BaseModel {
  /**
   * Creates a new `LightBlockHeaderProof` object.
   * @param index - The index of the light block header in the vector commitment tree
   * @param proof - The encoded proof.
   * @param treedepth - Represents the depth of the tree that is being proven, i.e. the number of edges
   * from a leaf to the root.
   */
  constructor({ index: index2, proof, treedepth }) {
    super();
    this.index = index2;
    this.proof = typeof proof === "string" ? new Uint8Array(Buffer.from(proof, "base64")) : proof;
    this.treedepth = treedepth;
    this.attribute_map = {
      index: "index",
      proof: "proof",
      treedepth: "treedepth"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["index"] === "undefined")
      throw new Error(`Response is missing required field 'index': ${data}`);
    if (typeof data["proof"] === "undefined")
      throw new Error(`Response is missing required field 'proof': ${data}`);
    if (typeof data["treedepth"] === "undefined")
      throw new Error(`Response is missing required field 'treedepth': ${data}`);
    return new LightBlockHeaderProof({
      index: data["index"],
      proof: data["proof"],
      treedepth: data["treedepth"]
    });
  }
};
var NodeStatusResponse = class extends BaseModel {
  /**
   * Creates a new `NodeStatusResponse` object.
   * @param catchupTime - CatchupTime in nanoseconds
   * @param lastRound - LastRound indicates the last round seen
   * @param lastVersion - LastVersion indicates the last consensus version supported
   * @param nextVersion - NextVersion of consensus protocol to use
   * @param nextVersionRound - NextVersionRound is the round at which the next consensus version will apply
   * @param nextVersionSupported - NextVersionSupported indicates whether the next consensus version is supported
   * by this node
   * @param stoppedAtUnsupportedRound - StoppedAtUnsupportedRound indicates that the node does not support the new
   * rounds and has stopped making progress
   * @param timeSinceLastRound - TimeSinceLastRound in nanoseconds
   * @param catchpoint - The current catchpoint that is being caught up to
   * @param catchpointAcquiredBlocks - The number of blocks that have already been obtained by the node as part of the
   * catchup
   * @param catchpointProcessedAccounts - The number of accounts from the current catchpoint that have been processed so
   * far as part of the catchup
   * @param catchpointProcessedKvs - The number of key-values (KVs) from the current catchpoint that have been
   * processed so far as part of the catchup
   * @param catchpointTotalAccounts - The total number of accounts included in the current catchpoint
   * @param catchpointTotalBlocks - The total number of blocks that are required to complete the current catchpoint
   * catchup
   * @param catchpointTotalKvs - The total number of key-values (KVs) included in the current catchpoint
   * @param catchpointVerifiedAccounts - The number of accounts from the current catchpoint that have been verified so
   * far as part of the catchup
   * @param catchpointVerifiedKvs - The number of key-values (KVs) from the current catchpoint that have been
   * verified so far as part of the catchup
   * @param lastCatchpoint - The last catchpoint seen by the node
   */
  constructor({ catchupTime, lastRound, lastVersion, nextVersion, nextVersionRound, nextVersionSupported, stoppedAtUnsupportedRound, timeSinceLastRound, catchpoint, catchpointAcquiredBlocks, catchpointProcessedAccounts, catchpointProcessedKvs, catchpointTotalAccounts, catchpointTotalBlocks, catchpointTotalKvs, catchpointVerifiedAccounts, catchpointVerifiedKvs, lastCatchpoint }) {
    super();
    this.catchupTime = catchupTime;
    this.lastRound = lastRound;
    this.lastVersion = lastVersion;
    this.nextVersion = nextVersion;
    this.nextVersionRound = nextVersionRound;
    this.nextVersionSupported = nextVersionSupported;
    this.stoppedAtUnsupportedRound = stoppedAtUnsupportedRound;
    this.timeSinceLastRound = timeSinceLastRound;
    this.catchpoint = catchpoint;
    this.catchpointAcquiredBlocks = catchpointAcquiredBlocks;
    this.catchpointProcessedAccounts = catchpointProcessedAccounts;
    this.catchpointProcessedKvs = catchpointProcessedKvs;
    this.catchpointTotalAccounts = catchpointTotalAccounts;
    this.catchpointTotalBlocks = catchpointTotalBlocks;
    this.catchpointTotalKvs = catchpointTotalKvs;
    this.catchpointVerifiedAccounts = catchpointVerifiedAccounts;
    this.catchpointVerifiedKvs = catchpointVerifiedKvs;
    this.lastCatchpoint = lastCatchpoint;
    this.attribute_map = {
      catchupTime: "catchup-time",
      lastRound: "last-round",
      lastVersion: "last-version",
      nextVersion: "next-version",
      nextVersionRound: "next-version-round",
      nextVersionSupported: "next-version-supported",
      stoppedAtUnsupportedRound: "stopped-at-unsupported-round",
      timeSinceLastRound: "time-since-last-round",
      catchpoint: "catchpoint",
      catchpointAcquiredBlocks: "catchpoint-acquired-blocks",
      catchpointProcessedAccounts: "catchpoint-processed-accounts",
      catchpointProcessedKvs: "catchpoint-processed-kvs",
      catchpointTotalAccounts: "catchpoint-total-accounts",
      catchpointTotalBlocks: "catchpoint-total-blocks",
      catchpointTotalKvs: "catchpoint-total-kvs",
      catchpointVerifiedAccounts: "catchpoint-verified-accounts",
      catchpointVerifiedKvs: "catchpoint-verified-kvs",
      lastCatchpoint: "last-catchpoint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["catchup-time"] === "undefined")
      throw new Error(`Response is missing required field 'catchup-time': ${data}`);
    if (typeof data["last-round"] === "undefined")
      throw new Error(`Response is missing required field 'last-round': ${data}`);
    if (typeof data["last-version"] === "undefined")
      throw new Error(`Response is missing required field 'last-version': ${data}`);
    if (typeof data["next-version"] === "undefined")
      throw new Error(`Response is missing required field 'next-version': ${data}`);
    if (typeof data["next-version-round"] === "undefined")
      throw new Error(`Response is missing required field 'next-version-round': ${data}`);
    if (typeof data["next-version-supported"] === "undefined")
      throw new Error(`Response is missing required field 'next-version-supported': ${data}`);
    if (typeof data["stopped-at-unsupported-round"] === "undefined")
      throw new Error(`Response is missing required field 'stopped-at-unsupported-round': ${data}`);
    if (typeof data["time-since-last-round"] === "undefined")
      throw new Error(`Response is missing required field 'time-since-last-round': ${data}`);
    return new NodeStatusResponse({
      catchupTime: data["catchup-time"],
      lastRound: data["last-round"],
      lastVersion: data["last-version"],
      nextVersion: data["next-version"],
      nextVersionRound: data["next-version-round"],
      nextVersionSupported: data["next-version-supported"],
      stoppedAtUnsupportedRound: data["stopped-at-unsupported-round"],
      timeSinceLastRound: data["time-since-last-round"],
      catchpoint: data["catchpoint"],
      catchpointAcquiredBlocks: data["catchpoint-acquired-blocks"],
      catchpointProcessedAccounts: data["catchpoint-processed-accounts"],
      catchpointProcessedKvs: data["catchpoint-processed-kvs"],
      catchpointTotalAccounts: data["catchpoint-total-accounts"],
      catchpointTotalBlocks: data["catchpoint-total-blocks"],
      catchpointTotalKvs: data["catchpoint-total-kvs"],
      catchpointVerifiedAccounts: data["catchpoint-verified-accounts"],
      catchpointVerifiedKvs: data["catchpoint-verified-kvs"],
      lastCatchpoint: data["last-catchpoint"]
    });
  }
};
var PendingTransactionResponse = class extends BaseModel {
  /**
   * Creates a new `PendingTransactionResponse` object.
   * @param poolError - Indicates that the transaction was kicked out of this node's transaction pool
   * (and specifies why that happened). An empty string indicates the transaction
   * wasn't kicked out of this node's txpool due to an error.
   * @param txn - The raw signed transaction.
   * @param applicationIndex - The application index if the transaction was found and it created an
   * application.
   * @param assetClosingAmount - The number of the asset's unit that were transferred to the close-to address.
   * @param assetIndex - The asset index if the transaction was found and it created an asset.
   * @param closeRewards - Rewards in microalgos applied to the close remainder to account.
   * @param closingAmount - Closing amount for the transaction.
   * @param confirmedRound - The round where this transaction was confirmed, if present.
   * @param globalStateDelta - (gd) Global state key/value changes for the application being executed by this
   * transaction.
   * @param innerTxns - Inner transactions produced by application execution.
   * @param localStateDelta - (ld) Local state key/value changes for the application being executed by this
   * transaction.
   * @param logs - (lg) Logs for the application being executed by this transaction.
   * @param receiverRewards - Rewards in microalgos applied to the receiver account.
   * @param senderRewards - Rewards in microalgos applied to the sender account.
   */
  constructor({ poolError, txn, applicationIndex, assetClosingAmount, assetIndex, closeRewards, closingAmount, confirmedRound, globalStateDelta, innerTxns, localStateDelta, logs, receiverRewards, senderRewards }) {
    super();
    this.poolError = poolError;
    this.txn = txn;
    this.applicationIndex = applicationIndex;
    this.assetClosingAmount = assetClosingAmount;
    this.assetIndex = assetIndex;
    this.closeRewards = closeRewards;
    this.closingAmount = closingAmount;
    this.confirmedRound = confirmedRound;
    this.globalStateDelta = globalStateDelta;
    this.innerTxns = innerTxns;
    this.localStateDelta = localStateDelta;
    this.logs = logs;
    this.receiverRewards = receiverRewards;
    this.senderRewards = senderRewards;
    this.attribute_map = {
      poolError: "pool-error",
      txn: "txn",
      applicationIndex: "application-index",
      assetClosingAmount: "asset-closing-amount",
      assetIndex: "asset-index",
      closeRewards: "close-rewards",
      closingAmount: "closing-amount",
      confirmedRound: "confirmed-round",
      globalStateDelta: "globalThis-state-delta",
      innerTxns: "inner-txns",
      localStateDelta: "local-state-delta",
      logs: "logs",
      receiverRewards: "receiver-rewards",
      senderRewards: "sender-rewards"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["pool-error"] === "undefined")
      throw new Error(`Response is missing required field 'pool-error': ${data}`);
    if (typeof data["txn"] === "undefined")
      throw new Error(`Response is missing required field 'txn': ${data}`);
    return new PendingTransactionResponse({
      poolError: data["pool-error"],
      txn: data["txn"],
      applicationIndex: data["application-index"],
      assetClosingAmount: data["asset-closing-amount"],
      assetIndex: data["asset-index"],
      closeRewards: data["close-rewards"],
      closingAmount: data["closing-amount"],
      confirmedRound: data["confirmed-round"],
      globalStateDelta: typeof data["globalThis-state-delta"] !== "undefined" ? data["globalThis-state-delta"].map(EvalDeltaKeyValue.from_obj_for_encoding) : void 0,
      innerTxns: typeof data["inner-txns"] !== "undefined" ? data["inner-txns"].map(PendingTransactionResponse.from_obj_for_encoding) : void 0,
      localStateDelta: typeof data["local-state-delta"] !== "undefined" ? data["local-state-delta"].map(AccountStateDelta.from_obj_for_encoding) : void 0,
      logs: data["logs"],
      receiverRewards: data["receiver-rewards"],
      senderRewards: data["sender-rewards"]
    });
  }
};
var PendingTransactionsResponse = class extends BaseModel {
  /**
   * Creates a new `PendingTransactionsResponse` object.
   * @param topTransactions - An array of signed transaction objects.
   * @param totalTransactions - Total number of transactions in the pool.
   */
  constructor({ topTransactions, totalTransactions }) {
    super();
    this.topTransactions = topTransactions;
    this.totalTransactions = totalTransactions;
    this.attribute_map = {
      topTransactions: "top-transactions",
      totalTransactions: "total-transactions"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["top-transactions"]))
      throw new Error(`Response is missing required array field 'top-transactions': ${data}`);
    if (typeof data["total-transactions"] === "undefined")
      throw new Error(`Response is missing required field 'total-transactions': ${data}`);
    return new PendingTransactionsResponse({
      topTransactions: data["top-transactions"],
      totalTransactions: data["total-transactions"]
    });
  }
};
var PostTransactionsResponse = class extends BaseModel {
  /**
   * Creates a new `PostTransactionsResponse` object.
   * @param txid - encoding of the transaction hash.
   */
  constructor({ txid }) {
    super();
    this.txid = txid;
    this.attribute_map = {
      txid: "txId"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["txId"] === "undefined")
      throw new Error(`Response is missing required field 'txId': ${data}`);
    return new PostTransactionsResponse({
      txid: data["txId"]
    });
  }
};
var StateProof = class extends BaseModel {
  /**
   * Creates a new `StateProof` object.
   * @param message - Represents the message that the state proofs are attesting to.
   * @param stateproof - The encoded StateProof for the message.
   */
  constructor({ message: message2, stateproof }) {
    super();
    this.message = message2;
    this.stateproof = typeof stateproof === "string" ? new Uint8Array(Buffer.from(stateproof, "base64")) : stateproof;
    this.attribute_map = {
      message: "Message",
      stateproof: "StateProof"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["Message"] === "undefined")
      throw new Error(`Response is missing required field 'Message': ${data}`);
    if (typeof data["StateProof"] === "undefined")
      throw new Error(`Response is missing required field 'StateProof': ${data}`);
    return new StateProof({
      message: StateProofMessage.from_obj_for_encoding(data["Message"]),
      stateproof: data["StateProof"]
    });
  }
};
var StateProofMessage = class extends BaseModel {
  /**
   * Creates a new `StateProofMessage` object.
   * @param blockheaderscommitment - The vector commitment root on all light block headers within a state proof
   * interval.
   * @param firstattestedround - The first round the message attests to.
   * @param lastattestedround - The last round the message attests to.
   * @param lnprovenweight - An integer value representing the natural log of the proven weight with 16 bits
   * of precision. This value would be used to verify the next state proof.
   * @param voterscommitment - The vector commitment root of the top N accounts to sign the next StateProof.
   */
  constructor({ blockheaderscommitment, firstattestedround, lastattestedround, lnprovenweight, voterscommitment }) {
    super();
    this.blockheaderscommitment = typeof blockheaderscommitment === "string" ? new Uint8Array(Buffer.from(blockheaderscommitment, "base64")) : blockheaderscommitment;
    this.firstattestedround = firstattestedround;
    this.lastattestedround = lastattestedround;
    this.lnprovenweight = lnprovenweight;
    this.voterscommitment = typeof voterscommitment === "string" ? new Uint8Array(Buffer.from(voterscommitment, "base64")) : voterscommitment;
    this.attribute_map = {
      blockheaderscommitment: "BlockHeadersCommitment",
      firstattestedround: "FirstAttestedRound",
      lastattestedround: "LastAttestedRound",
      lnprovenweight: "LnProvenWeight",
      voterscommitment: "VotersCommitment"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["BlockHeadersCommitment"] === "undefined")
      throw new Error(`Response is missing required field 'BlockHeadersCommitment': ${data}`);
    if (typeof data["FirstAttestedRound"] === "undefined")
      throw new Error(`Response is missing required field 'FirstAttestedRound': ${data}`);
    if (typeof data["LastAttestedRound"] === "undefined")
      throw new Error(`Response is missing required field 'LastAttestedRound': ${data}`);
    if (typeof data["LnProvenWeight"] === "undefined")
      throw new Error(`Response is missing required field 'LnProvenWeight': ${data}`);
    if (typeof data["VotersCommitment"] === "undefined")
      throw new Error(`Response is missing required field 'VotersCommitment': ${data}`);
    return new StateProofMessage({
      blockheaderscommitment: data["BlockHeadersCommitment"],
      firstattestedround: data["FirstAttestedRound"],
      lastattestedround: data["LastAttestedRound"],
      lnprovenweight: data["LnProvenWeight"],
      voterscommitment: data["VotersCommitment"]
    });
  }
};
var SupplyResponse = class extends BaseModel {
  /**
   * Creates a new `SupplyResponse` object.
   * @param currentRound - Round
   * @param onlineMoney - OnlineMoney
   * @param totalMoney - TotalMoney
   */
  constructor({ currentRound, onlineMoney, totalMoney }) {
    super();
    this.currentRound = currentRound;
    this.onlineMoney = onlineMoney;
    this.totalMoney = totalMoney;
    this.attribute_map = {
      currentRound: "current_round",
      onlineMoney: "online-money",
      totalMoney: "total-money"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["current_round"] === "undefined")
      throw new Error(`Response is missing required field 'current_round': ${data}`);
    if (typeof data["online-money"] === "undefined")
      throw new Error(`Response is missing required field 'online-money': ${data}`);
    if (typeof data["total-money"] === "undefined")
      throw new Error(`Response is missing required field 'total-money': ${data}`);
    return new SupplyResponse({
      currentRound: data["current_round"],
      onlineMoney: data["online-money"],
      totalMoney: data["total-money"]
    });
  }
};
var TealKeyValue = class extends BaseModel {
  /**
   * Creates a new `TealKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value.
   */
  constructor({ key, value: value2 }) {
    super();
    this.key = key;
    this.value = value2;
    this.attribute_map = {
      key: "key",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["key"] === "undefined")
      throw new Error(`Response is missing required field 'key': ${data}`);
    if (typeof data["value"] === "undefined")
      throw new Error(`Response is missing required field 'value': ${data}`);
    return new TealKeyValue({
      key: data["key"],
      value: TealValue.from_obj_for_encoding(data["value"])
    });
  }
};
var TealValue = class extends BaseModel {
  /**
   * Creates a new `TealValue` object.
   * @param type - (tt) value type. Value `1` refers to **bytes**, value `2` refers to **uint**
   * @param bytes - (tb) bytes value.
   * @param uint - (ui) uint value.
   */
  constructor({ type, bytes, uint }) {
    super();
    this.type = type;
    this.bytes = bytes;
    this.uint = uint;
    this.attribute_map = {
      type: "type",
      bytes: "bytes",
      uint: "uint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["type"] === "undefined")
      throw new Error(`Response is missing required field 'type': ${data}`);
    if (typeof data["bytes"] === "undefined")
      throw new Error(`Response is missing required field 'bytes': ${data}`);
    if (typeof data["uint"] === "undefined")
      throw new Error(`Response is missing required field 'uint': ${data}`);
    return new TealValue({
      type: data["type"],
      bytes: data["bytes"],
      uint: data["uint"]
    });
  }
};
var TransactionParametersResponse = class extends BaseModel {
  /**
   * Creates a new `TransactionParametersResponse` object.
   * @param consensusVersion - ConsensusVersion indicates the consensus protocol version
   * as of LastRound.
   * @param fee - Fee is the suggested transaction fee
   * Fee is in units of micro-Algos per byte.
   * Fee may fall to zero but transactions must still have a fee of
   * at least MinTxnFee for the current network protocol.
   * @param genesisHash - GenesisHash is the hash of the genesis block.
   * @param genesisId - GenesisID is an ID listed in the genesis block.
   * @param lastRound - LastRound indicates the last round seen
   * @param minFee - The minimum transaction fee (not per byte) required for the
   * txn to validate for the current network protocol.
   */
  constructor({ consensusVersion, fee, genesisHash, genesisId, lastRound, minFee }) {
    super();
    this.consensusVersion = consensusVersion;
    this.fee = fee;
    this.genesisHash = typeof genesisHash === "string" ? new Uint8Array(Buffer.from(genesisHash, "base64")) : genesisHash;
    this.genesisId = genesisId;
    this.lastRound = lastRound;
    this.minFee = minFee;
    this.attribute_map = {
      consensusVersion: "consensus-version",
      fee: "fee",
      genesisHash: "genesis-hash",
      genesisId: "genesis-id",
      lastRound: "last-round",
      minFee: "min-fee"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["consensus-version"] === "undefined")
      throw new Error(`Response is missing required field 'consensus-version': ${data}`);
    if (typeof data["fee"] === "undefined")
      throw new Error(`Response is missing required field 'fee': ${data}`);
    if (typeof data["genesis-hash"] === "undefined")
      throw new Error(`Response is missing required field 'genesis-hash': ${data}`);
    if (typeof data["genesis-id"] === "undefined")
      throw new Error(`Response is missing required field 'genesis-id': ${data}`);
    if (typeof data["last-round"] === "undefined")
      throw new Error(`Response is missing required field 'last-round': ${data}`);
    if (typeof data["min-fee"] === "undefined")
      throw new Error(`Response is missing required field 'min-fee': ${data}`);
    return new TransactionParametersResponse({
      consensusVersion: data["consensus-version"],
      fee: data["fee"],
      genesisHash: data["genesis-hash"],
      genesisId: data["genesis-id"],
      lastRound: data["last-round"],
      minFee: data["min-fee"]
    });
  }
};
var TransactionProofResponse = class extends BaseModel {
  /**
   * Creates a new `TransactionProofResponse` object.
   * @param idx - Index of the transaction in the block's payset.
   * @param proof - Proof of transaction membership.
   * @param stibhash - Hash of SignedTxnInBlock for verifying proof.
   * @param treedepth - Represents the depth of the tree that is being proven, i.e. the number of edges
   * from a leaf to the root.
   * @param hashtype - The type of hash function used to create the proof, must be one of:
   * * sha512_256
   * * sha256
   */
  constructor({ idx, proof, stibhash, treedepth, hashtype }) {
    super();
    this.idx = idx;
    this.proof = typeof proof === "string" ? new Uint8Array(Buffer.from(proof, "base64")) : proof;
    this.stibhash = typeof stibhash === "string" ? new Uint8Array(Buffer.from(stibhash, "base64")) : stibhash;
    this.treedepth = treedepth;
    this.hashtype = hashtype;
    this.attribute_map = {
      idx: "idx",
      proof: "proof",
      stibhash: "stibhash",
      treedepth: "treedepth",
      hashtype: "hashtype"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["idx"] === "undefined")
      throw new Error(`Response is missing required field 'idx': ${data}`);
    if (typeof data["proof"] === "undefined")
      throw new Error(`Response is missing required field 'proof': ${data}`);
    if (typeof data["stibhash"] === "undefined")
      throw new Error(`Response is missing required field 'stibhash': ${data}`);
    if (typeof data["treedepth"] === "undefined")
      throw new Error(`Response is missing required field 'treedepth': ${data}`);
    return new TransactionProofResponse({
      idx: data["idx"],
      proof: data["proof"],
      stibhash: data["stibhash"],
      treedepth: data["treedepth"],
      hashtype: data["hashtype"]
    });
  }
};
var Version = class extends BaseModel {
  /**
   * Creates a new `Version` object.
   * @param build -
   * @param genesisHashB64 -
   * @param genesisId -
   * @param versions -
   */
  constructor({ build, genesisHashB64, genesisId, versions }) {
    super();
    this.build = build;
    this.genesisHashB64 = typeof genesisHashB64 === "string" ? new Uint8Array(Buffer.from(genesisHashB64, "base64")) : genesisHashB64;
    this.genesisId = genesisId;
    this.versions = versions;
    this.attribute_map = {
      build: "build",
      genesisHashB64: "genesis_hash_b64",
      genesisId: "genesis_id",
      versions: "versions"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["build"] === "undefined")
      throw new Error(`Response is missing required field 'build': ${data}`);
    if (typeof data["genesis_hash_b64"] === "undefined")
      throw new Error(`Response is missing required field 'genesis_hash_b64': ${data}`);
    if (typeof data["genesis_id"] === "undefined")
      throw new Error(`Response is missing required field 'genesis_id': ${data}`);
    if (!Array.isArray(data["versions"]))
      throw new Error(`Response is missing required array field 'versions': ${data}`);
    return new Version({
      build: BuildVersion.from_obj_for_encoding(data["build"]),
      genesisHashB64: data["genesis_hash_b64"],
      genesisId: data["genesis_id"],
      versions: data["versions"]
    });
  }
};
var GetApplicationBoxByName = class extends JSONRequest {
  constructor(c, intDecoding, index2, name9) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
    const encodedName = Buffer.from(name9).toString("base64");
    this.query.name = encodeURI(`b64:${encodedName}`);
  }
  /**
   * @returns `/v2/applications/${index}/box`
   */
  path() {
    return `/v2/applications/${this.index}/box`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    return Box.from_obj_for_encoding(body);
  }
};
var GetApplicationBoxes = class extends JSONRequest {
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
    this.query.max = 0;
  }
  /**
   * @returns `/v2/applications/${index}/boxes`
   */
  path() {
    return `/v2/applications/${this.index}/boxes`;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const boxesResult = await algodClient
   *        .GetApplicationBoxes(1234)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  max(max) {
    this.query.max = max;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    return BoxesResponse.from_obj_for_encoding(body);
  }
};
var HealthCheck = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/health";
  }
  async do(headers = {}) {
    const res = await this.c.get(this.path(), {}, headers);
    if (!res.ok) {
      throw new Error(`Health response: ${res.status}`);
    }
    return {};
  }
};
var PendingTransactionInformation = class extends JSONRequest {
  constructor(c, txid) {
    super(c);
    this.txid = txid;
    this.txid = txid;
    this.query.format = "msgpack";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    if (body && body.byteLength > 0) {
      return decode2(body);
    }
    return void 0;
  }
  path() {
    return `/v2/transactions/pending/${this.txid}`;
  }
  // max sets the maximum number of txs to return
  max(max) {
    this.query.max = max;
    return this;
  }
};
var PendingTransactions = class extends JSONRequest {
  constructor(c) {
    super(c);
    this.query.format = "msgpack";
  }
  /* eslint-disable class-methods-use-this */
  path() {
    return "/v2/transactions/pending";
  }
  prepare(body) {
    if (body && body.byteLength > 0) {
      return decode2(body);
    }
    return void 0;
  }
  /* eslint-enable class-methods-use-this */
  // max sets the maximum number of txs to return
  max(max) {
    this.query.max = max;
    return this;
  }
};
var PendingTransactionsByAddress = class extends JSONRequest {
  constructor(c, address) {
    super(c);
    this.address = address;
    this.address = address;
    this.query.format = "msgpack";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    if (body && body.byteLength > 0) {
      return decode2(body);
    }
    return void 0;
  }
  path() {
    return `/v2/accounts/${this.address}/transactions/pending`;
  }
  // max sets the maximum number of txs to return
  max(max) {
    this.query.max = max;
    return this;
  }
};
var GetTransactionProof = class extends JSONRequest {
  constructor(c, intDecoding, round, txID) {
    super(c, intDecoding);
    this.round = round;
    this.txID = txID;
    this.round = round;
    this.txID = txID;
  }
  path() {
    return `/v2/blocks/${this.round}/transactions/${this.txID}/proof`;
  }
  /**
   * Exclude assets and application data from results
   * The type of hash function used to create the proof, must be one of: "sha512_256", "sha256"
   *
   * #### Example
   * ```typescript
   * const hashType = "sha256";
   * const round = 123456;
   * const txId = "abc123;
   * const txProof = await algodClient.getTransactionProof(round, txId)
   *        .hashType(hashType)
   *        .do();
   * ```
   *
   * @param hashType
   * @category query
   */
  hashType(hashType) {
    this.query.hashtype = hashType;
    return this;
  }
};
function setSendTransactionHeaders(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "application/x-binary";
  }
  return hdrs;
}
function isByteArray(array) {
  return array && array.byteLength !== void 0;
}
var SendRawTransaction = class extends JSONRequest {
  constructor(c, stxOrStxs) {
    super(c);
    let forPosting = stxOrStxs;
    if (Array.isArray(stxOrStxs)) {
      if (!stxOrStxs.every(isByteArray)) {
        throw new TypeError("Array elements must be byte arrays");
      }
      forPosting = concatArrays(...stxOrStxs);
    } else if (!isByteArray(forPosting)) {
      throw new TypeError("Argument must be byte array");
    }
    this.txnBytesToPost = forPosting;
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/transactions";
  }
  async do(headers = {}) {
    const txHeaders = setSendTransactionHeaders(headers);
    const res = await this.c.post(this.path(), Buffer.from(this.txnBytesToPost), txHeaders);
    return res.body;
  }
};
var Status = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/status";
  }
};
var StatusAfterBlock = class extends JSONRequest {
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    if (!Number.isInteger(round))
      throw Error("round should be an integer");
    this.round = round;
  }
  path() {
    return `/v2/status/wait-for-block-after/${this.round}`;
  }
};
var SuggestedParamsRequest = class extends JSONRequest {
  /* eslint-disable class-methods-use-this */
  path() {
    return "/v2/transactions/params";
  }
  prepare(body) {
    return {
      flatFee: false,
      fee: body.fee,
      firstRound: body["last-round"],
      lastRound: body["last-round"] + 1e3,
      genesisID: body["genesis-id"],
      genesisHash: body["genesis-hash"]
    };
  }
};
var Supply = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/ledger/supply";
  }
};
var Versions = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/versions";
  }
};
var LightBlockHeaderProof2 = class extends JSONRequest {
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    this.round = round;
  }
  path() {
    return `/v2/blocks/${this.round}/lightheader/proof`;
  }
};
var StateProof2 = class extends JSONRequest {
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    this.round = round;
  }
  path() {
    return `/v2/stateproofs/${this.round}`;
  }
};
var AlgodClient = class extends ServiceClient {
  /**
   * Create an AlgodClient from
   * * either a token, baseServer, port, and optional headers
   * * or a base client server for interoperability with external dApp wallets
   *
   * #### Example
   * ```typescript
   * const token  = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
   * const server = "http://localhost";
   * const port   = 4001;
   * const algodClient = new algosdk.Algodv2(token, server, port);
   * ```
   * @remarks
   * The above configuration is for a sandbox private network.
   * For applications on production, you are encouraged to run your own node, or use an Algorand REST API provider with a dedicated API key.
   *
   * @param tokenOrBaseClient - The algod token from the Algorand node you are interacting with
   * @param baseServer - REST endpoint
   * @param port - Port number if specifically configured by the server
   * @param headers - Optional headers
   */
  constructor(tokenOrBaseClient, baseServer, port, headers = {}) {
    super("X-Algo-API-Token", tokenOrBaseClient, baseServer, port, headers);
  }
  /**
   * Returns OK if healthy.
   *
   * #### Example
   * ```typescript
   * const health = await algodClient.healthCheck().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-health)
   * @category GET
   */
  healthCheck() {
    return new HealthCheck(this.c);
  }
  /**
   * Retrieves the supported API versions, binary build versions, and genesis information.
   *
   * #### Example
   * ```typescript
   * const versionsDetails = await algodClient.versionsCheck().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-versions)
   * @category GET
   */
  versionsCheck() {
    return new Versions(this.c);
  }
  /**
   * Broadcasts a raw transaction to the network.
   *
   * #### Example
   * ```typescript
   * const { txId } = await algodClient.sendRawTransaction(signedTxns).do();
   * const result = await waitForConfirmation(algodClient, txid, 3);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#post-v2transactions)
   *
   * @remarks
   * Often used with {@linkcode waitForConfirmation}
   * @param stxOrStxs - Signed transactions
   * @category POST
   */
  sendRawTransaction(stxOrStxs) {
    return new SendRawTransaction(this.c, stxOrStxs);
  }
  /**
   * Returns the given account's status, balance and spendable amounts.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await algodClient.accountInformation(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2accountsaddress)
   * @param account - The address of the account to look up.
   * @category GET
   */
  accountInformation(account) {
    return new AccountInformation(this.c, this.intDecoding, account);
  }
  /**
   * Returns the given account's asset information for a specific asset.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const index = 60553466;
   * const accountAssetInfo = await algodClient.accountAssetInformation(address, index).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2accountsaddress)
   * @param account - The address of the account to look up.
   * @param index - The asset ID to look up.
   * @category GET
   */
  accountAssetInformation(account, index2) {
    return new AccountAssetInformation(this.c, this.intDecoding, account, index2);
  }
  /**
   * Returns the given account's application information for a specific application.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const index = 60553466;
   * const accountInfo = await algodClient.accountApplicationInformation(address, index).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2accountsaddress)
   * @param account - The address of the account to look up.
   * @param index - The application ID to look up.
   * @category GET
   */
  accountApplicationInformation(account, index2) {
    return new AccountApplicationInformation(this.c, this.intDecoding, account, index2);
  }
  /**
   * Gets the block info for the given round.
   *
   * #### Example
   * ```typescript
   * const roundNumber = 18038133;
   * const block = await algodClient.block(roundNumber).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2blocksround)
   * @param roundNumber - The round number of the block to get.
   * @category GET
   */
  block(roundNumber) {
    return new Block(this.c, roundNumber);
  }
  /**
   * Get the block hash for the block on the given round.
   *
   * #### Example
   * ```typescript
   * const roundNumber = 18038133;
   * const block = await algodClient.getBlockHash(roundNumber).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2blocksroundhash)
   * @param roundNumber - The round number of the block to get.
   * @category GET
   */
  getBlockHash(roundNumber) {
    return new GetBlockHash(this.c, this.intDecoding, roundNumber);
  }
  /**
   * Returns the transaction information for a specific pending transaction.
   *
   * #### Example
   * ```typescript
   * const txId = "DRJS6R745A7GFVMXEXWP4TGVDGKW7VILFTA7HC2BR2GRLHNY5CTA";
   * const pending = await algodClient.pendingTransactionInformation(txId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2transactionspendingtxid)
   *
   * @remarks
   * <br><br>
   * There are several cases when this might succeed:
   * - transaction committed (committed round > 0)
   * - transaction still in the pool (committed round = 0, pool error = "")
   * - transaction removed from pool due to error (committed round = 0, pool error != "")
   *
   * Or the transaction may have happened sufficiently long ago that the node no longer remembers it, and this will return an error.
   *
   * @param txid - The TxID string of the pending transaction to look up.
   * @category GET
   */
  pendingTransactionInformation(txid) {
    return new PendingTransactionInformation(this.c, txid);
  }
  /**
   * Returns the list of pending transactions in the pool, sorted by priority, in decreasing order, truncated at the end at MAX.
   * If MAX = 0, returns all pending transactions.
   *
   * #### Example 1
   * ```typescript
   * const pendingTxns = await algodClient.pendingTransactionsInformation().do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const maxTxns = 5;
   * const pendingTxns = await algodClient
   *     .pendingTransactionsInformation()
   *     .max(maxTxns)
   *     .do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2transactionspending)
   * @category GET
   */
  pendingTransactionsInformation() {
    return new PendingTransactions(this.c);
  }
  /**
   * Returns the list of pending transactions sent by the address, sorted by priority, in decreasing order, truncated at the end at MAX.
   * If MAX = 0, returns all pending transactions.
   *
   * #### Example 1
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const pendingTxnsByAddr = await algodClient.pendingTransactionByAddress(address).do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const maxTxns = 5;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const pendingTxns = await algodClient
   *     .pendingTransactionByAddress(address)
   *     .max(maxTxns)
   *     .do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2accountsaddresstransactionspending)
   * @param address - The address of the sender.
   * @category GET
   */
  pendingTransactionByAddress(address) {
    return new PendingTransactionsByAddress(this.c, address);
  }
  /**
   * Retrieves the StatusResponse from the running node.
   *
   * #### Example
   * ```typescript
   * const status = await algodClient.status().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2status)
   * @category GET
   */
  status() {
    return new Status(this.c, this.intDecoding);
  }
  /**
   * Waits for a specific round to occur then returns the `StatusResponse` for that round.
   *
   * #### Example
   * ```typescript
   * const round = 18038133;
   * const statusAfterBlock = await algodClient.statusAfterBlock(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2statuswait-for-block-afterround)
   * @param round - The number of the round to wait for.
   * @category GET
   */
  statusAfterBlock(round) {
    return new StatusAfterBlock(this.c, this.intDecoding, round);
  }
  /**
   * Returns the common needed parameters for a new transaction.
   *
   * #### Example
   * ```typescript
   * const suggestedParams = await algodClient.getTransactionParams().do();
   * const amountInMicroAlgos = algosdk.algosToMicroalgos(2); // 2 Algos
   * const unsignedTxn = algosdk.makePaymentTxnWithSuggestedParamsFromObject({
   *   from: senderAddress,
   *   to: receiverAddress,
   *   amount: amountInMicroAlgos,
   *   suggestedParams: suggestedParams,
   * });
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2transactionsparams)
   *
   * @remarks
   * Often used with
   * {@linkcode makePaymentTxnWithSuggestedParamsFromObject}, {@linkcode algosToMicroalgos}
   * @category GET
   */
  getTransactionParams() {
    return new SuggestedParamsRequest(this.c);
  }
  /**
   * Returns the supply details for the specified node's ledger.
   *
   * #### Example
   * ```typescript
   * const supplyDetails = await algodClient.supply().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2ledgersupply)
   * @category GET
   */
  supply() {
    return new Supply(this.c, this.intDecoding);
  }
  /**
   * Compiles TEAL source code to binary, returns base64 encoded program bytes and base32 SHA512_256 hash of program bytes (Address style).
   *
   * #### Example
   * ```typescript
   * const source = "TEAL SOURCE CODE";
   * const compiledSmartContract = await algodClient.compile(source).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#post-v2tealcompile)
   * @remarks
   * This endpoint is only enabled when a node's configuration file sets `EnableDeveloperAPI` to true.
   * @param source
   * @category POST
   */
  compile(source) {
    return new Compile(this.c, source);
  }
  /**
   * Provides debugging information for a transaction (or group).
   *
   * Executes TEAL program(s) in context and returns debugging information about the execution. This endpoint is only enabled when a node's configureation file sets `EnableDeveloperAPI` to true.
   *
   * #### Example
   * ```typescript
   * const dryRunResult = await algodClient.dryrun(dr).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#post-v2tealdryrun)
   * @param dr
   * @category POST
   */
  dryrun(dr) {
    return new Dryrun(this.c, dr);
  }
  /**
   * Given an asset ID, return asset information including creator, name, total supply and
   * special addresses.
   *
   * #### Example
   * ```typescript
   * const asset_id = 163650;
   * const asset = await algodClient.getAssetByID(asset_id).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2assetsasset-id)
   * @param index - The asset ID to look up.
   * @category GET
   */
  getAssetByID(index2) {
    return new GetAssetByID(this.c, this.intDecoding, index2);
  }
  /**
   * Given an application ID, return the application information including creator, approval
   * and clear programs, globalThis and local schemas, and globalThis state.
   *
   * #### Example
   * ```typescript
   * const index = 60553466;
   * const app = await algodClient.getApplicationByID(index).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2applicationsapplication-id)
   * @param index - The application ID to look up.
   * @category GET
   */
  getApplicationByID(index2) {
    return new GetApplicationByID(this.c, this.intDecoding, index2);
  }
  /**
   * Given an application ID and the box name (key), return the value stored in the box.
   *
   * #### Example
   * ```typescript
   * const index = 60553466;
   * const boxName = Buffer.from("foo");
   * const boxResponse = await algodClient.getApplicationBoxByName(index, boxName).do();
   * const boxValue = boxResponse.value;
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2applicationsapplication-idbox)
   * @param index - The application ID to look up.
   * @category GET
   */
  getApplicationBoxByName(index2, boxName) {
    return new GetApplicationBoxByName(this.c, this.intDecoding, index2, boxName);
  }
  /**
   * Given an application ID, return all the box names associated with the app.
   *
   * #### Example
   * ```typescript
   * const index = 60553466;
   * const boxesResponse = await algodClient.getApplicationBoxes(index).max(3).do();
   * const boxNames = boxesResponse.boxes.map(box => box.name);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2applicationsapplication-idboxes)
   * @param index - The application ID to look up.
   * @category GET
   */
  getApplicationBoxes(index2) {
    return new GetApplicationBoxes(this.c, this.intDecoding, index2);
  }
  /**
   * Returns the entire genesis file.
   *
   * #### Example
   * ```typescript
   * const genesis = await algodClient.genesis().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-genesis)
   * @category GET
   */
  genesis() {
    return new Genesis(this.c, this.intDecoding);
  }
  /**
   * Returns a Merkle proof for a given transaction in a block.
   *
   * #### Example
   * ```typescript
   * const round = 18038133;
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const proof = await algodClient.getTransactionProof(round, txId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2blocksroundtransactionstxidproof)
   * @param round - The round in which the transaction appears.
   * @param txID - The transaction ID for which to generate a proof.
   * @category GET
   */
  getTransactionProof(round, txID) {
    return new GetTransactionProof(this.c, this.intDecoding, round, txID);
  }
  /**
   * Gets a proof for a given light block header inside a state proof commitment.
   *
   * #### Example
   * ```typescript
   * const round = 11111111;
   * const lightBlockHeaderProof = await algodClient.getLightBlockHeaderProof(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2#get-v2blocksroundlightheaderproof)
   * @param round
   */
  getLightBlockHeaderProof(round) {
    return new LightBlockHeaderProof2(this.c, this.intDecoding, round);
  }
  /**
   * Gets a state proof that covers a given round.
   *
   * #### Example
   * ```typescript
   * const round = 11111111;
   * const stateProof = await algodClient.getStateProof(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2#get-v2stateproofsround)
   * @param round
   */
  getStateProof(round) {
    return new StateProof2(this.c, this.intDecoding, round);
  }
};
var Kmd = class extends ServiceClient {
  constructor(token, baseServer = "http://127.0.0.1", port = 7833, headers = {}) {
    super("X-KMD-API-Token", token, baseServer, port, headers);
  }
  /**
   * version returns a VersionResponse containing a list of kmd API versions supported by this running kmd instance.
   */
  async versions() {
    const res = await this.c.get("/versions");
    return res.body;
  }
  /**
   * listWallets returns a ListWalletsResponse containing the list of wallets known to kmd. Using a wallet ID
   * returned from this endpoint, you can initialize a wallet handle with client.InitWalletHandle
   */
  async listWallets() {
    const res = await this.c.get("/v1/wallets");
    return res.body;
  }
  /**
   * createWallet creates a wallet with the specified name, password, driver,
   * and master derivation key. If the master derivation key is blank, one is
   * generated internally to kmd. CreateWallet returns a CreateWalletResponse
   * containing information about the new wallet.
   * @param walletName
   * @param walletPassword
   * @param walletDriverName
   * @param walletMDK
   */
  async createWallet(walletName, walletPassword, walletMDK = new Uint8Array(), walletDriverName = "sqlite") {
    const req = {
      wallet_name: walletName,
      wallet_driver_name: walletDriverName,
      wallet_password: walletPassword,
      master_derivation_key: Buffer.from(walletMDK).toString("base64")
    };
    const res = await this.c.post("/v1/wallet", req);
    return res.body;
  }
  /**
   * initWalletHandle accepts a wallet ID and a wallet password, and returns an
   * initWalletHandleResponse containing a wallet handle token. This wallet
   * handle token can be used for subsequent operations on this wallet, like key
   * generation, transaction signing, etc.. WalletHandleTokens expire after a
   * configurable number of seconds, and must be renewed periodically with
   * RenewWalletHandle. It is good practice to call ReleaseWalletHandle when
   * you're done interacting with this wallet.
   * @param walletID
   * @param walletPassword
   */
  async initWalletHandle(walletID, walletPassword) {
    const req = {
      wallet_id: walletID,
      wallet_password: walletPassword
    };
    const res = await this.c.post("/v1/wallet/init", req);
    return res.body;
  }
  /**
   * releaseWalletHandle invalidates the passed wallet handle token, making
   * it unusuable for subsequent wallet operations.
   * @param walletHandle
   */
  async releaseWalletHandle(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/wallet/release", req);
    return res.body;
  }
  /**
   * renewWalletHandle accepts a wallet handle and attempts to renew it, moving
   * the expiration time to some number of seconds in the future. It returns a
   * RenewWalletHandleResponse containing the walletHandle and the number of
   * seconds until expiration
   * @param walletHandle
   */
  async renewWalletHandle(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/wallet/renew", req);
    return res.body;
  }
  /**
   * renameWallet accepts a wallet ID, wallet password, and a new wallet name,
   * and renames the underlying wallet.
   * @param walletID
   * @param walletPassword
   * @param newWalletName
   */
  async renameWallet(walletID, walletPassword, newWalletName) {
    const req = {
      wallet_id: walletID,
      wallet_password: walletPassword,
      wallet_name: newWalletName
    };
    const res = await this.c.post("/v1/wallet/rename", req);
    return res.body;
  }
  /**
   * getWallet accepts a wallet handle and returns high level information about
   * this wallet in a GetWalletResponse.
   * @param walletHandle
   */
  async getWallet(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/wallet/info", req);
    return res.body;
  }
  /**
   * exportMasterDerivationKey accepts a wallet handle and a wallet password, and
   * returns an ExportMasterDerivationKeyResponse containing the master
   * derivation key. This key can be used as an argument to CreateWallet in
   * order to recover the keys generated by this wallet. The master derivation
   * key can be encoded as a sequence of words using the mnemonic library, and
   * @param walletHandle
   * @param walletPassword
   */
  async exportMasterDerivationKey(walletHandle, walletPassword) {
    const req = {
      wallet_handle_token: walletHandle,
      wallet_password: walletPassword
    };
    const res = await this.c.post("/v1/master-key/export", req);
    return {
      master_derivation_key: Buffer.from(res.body.master_derivation_key, "base64")
    };
  }
  /**
   * importKey accepts a wallet handle and an ed25519 private key, and imports
   * the key into the wallet. It returns an ImportKeyResponse containing the
   * address corresponding to this private key.
   * @param walletHandle
   * @param secretKey
   */
  async importKey(walletHandle, secretKey) {
    const req = {
      wallet_handle_token: walletHandle,
      private_key: Buffer.from(secretKey).toString("base64")
    };
    const res = await this.c.post("/v1/key/import", req);
    return res.body;
  }
  /**
   * exportKey accepts a wallet handle, wallet password, and address, and returns
   * an ExportKeyResponse containing the ed25519 private key corresponding to the
   * address stored in the wallet.
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async exportKey(walletHandle, walletPassword, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr,
      wallet_password: walletPassword
    };
    const res = await this.c.post("/v1/key/export", req);
    return { private_key: Buffer.from(res.body.private_key, "base64") };
  }
  /**
   * generateKey accepts a wallet handle, and then generates the next key in the
   * wallet using its internal master derivation key. Two wallets with the same
   * master derivation key will generate the same sequence of keys.
   * @param walletHandle
   */
  async generateKey(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle,
      display_mnemonic: false
    };
    const res = await this.c.post("/v1/key", req);
    return res.body;
  }
  /**
   * deleteKey accepts a wallet handle, wallet password, and address, and deletes
   * the information about this address from the wallet (including address and
   * secret key). If DeleteKey is called on a key generated using GenerateKey,
   * the same key will not be generated again. However, if a wallet is recovered
   * using the master derivation key, a key generated in this way can be
   * recovered.
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async deleteKey(walletHandle, walletPassword, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr,
      wallet_password: walletPassword
    };
    const res = await this.c.delete("/v1/key", req);
    return res.body;
  }
  /**
   * ListKeys accepts a wallet handle and returns a ListKeysResponse containing
   * all of the addresses for which this wallet contains secret keys.
   * @param walletHandle
   */
  async listKeys(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/key/list", req);
    return res.body;
  }
  /**
   * signTransaction accepts a wallet handle, wallet password, and a transaction,
   * and returns and SignTransactionResponse containing an encoded, signed
   * transaction. The transaction is signed using the key corresponding to the
   * Sender field.
   * @param walletHandle
   * @param walletPassword
   * @param transaction
   */
  async signTransaction(walletHandle, walletPassword, transaction) {
    const tx = instantiateTxnIfNeeded(transaction);
    const req = {
      wallet_handle_token: walletHandle,
      wallet_password: walletPassword,
      transaction: Buffer.from(tx.toByte()).toString("base64")
    };
    const res = await this.c.post("/v1/transaction/sign", req);
    if (res.status === 200) {
      return Buffer.from(res.body.signed_transaction, "base64");
    }
    return res.body;
  }
  /**
   * signTransactionWithSpecificPublicKey accepts a wallet handle, wallet password, a transaction, and a public key,
   * and returns and SignTransactionResponse containing an encoded, signed
   * transaction. The transaction is signed using the key corresponding to the
   * publicKey arg.
   * @param walletHandle
   * @param walletPassword
   * @param transaction
   * @param publicKey - sign the txn with the key corresponding to publicKey (used for working with a rekeyed addr)
   */
  async signTransactionWithSpecificPublicKey(walletHandle, walletPassword, transaction, publicKey) {
    const tx = instantiateTxnIfNeeded(transaction);
    const req = {
      wallet_handle_token: walletHandle,
      wallet_password: walletPassword,
      transaction: Buffer.from(tx.toByte()).toString("base64"),
      public_key: Buffer.from(publicKey).toString("base64")
    };
    const res = await this.c.post("/v1/transaction/sign", req);
    if (res.status === 200) {
      return Buffer.from(res.body.signed_transaction, "base64");
    }
    return res.body;
  }
  /**
   * listMultisig accepts a wallet handle and returns a ListMultisigResponse
   * containing the multisig addresses whose preimages are stored in this wallet.
   * A preimage is the information needed to reconstruct this multisig address,
   * including multisig version information, threshold information, and a list
   * of public keys.
   * @param walletHandle
   */
  async listMultisig(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/multisig/list", req);
    return res.body;
  }
  /**
   * importMultisig accepts a wallet handle and the information required to
   * generate a multisig address. It derives this address, and stores all of the
   * information within the wallet. It returns a ImportMultisigResponse with the
   * derived address.
   * @param walletHandle
   * @param version
   * @param threshold
   * @param pks
   */
  async importMultisig(walletHandle, version3, threshold, pks) {
    const req = {
      wallet_handle_token: walletHandle,
      multisig_version: version3,
      threshold,
      pks
    };
    const res = await this.c.post("/v1/multisig/import", req);
    return res.body;
  }
  /**
   * exportMultisig accepts a wallet handle, wallet password, and multisig
   * address, and returns an ExportMultisigResponse containing the stored
   * multisig preimage. The preimage contains all of the information necessary
   * to derive the multisig address, including version, threshold, and a list of
   * public keys.
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async exportMultisig(walletHandle, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr
    };
    const res = await this.c.post("/v1/multisig/export", req);
    return res.body;
  }
  /**
   * signMultisigTransaction accepts a wallet handle, wallet password,
   * transaction, public key (*not* an address), and an optional partial
   * MultisigSig. It looks up the secret key corresponding to the public key, and
   * returns a SignMultisigTransactionResponse containing a MultisigSig with a
   * signature by the secret key included.
   * @param walletHandle
   * @param pw
   * @param tx
   * @param pk
   * @param partial
   */
  async signMultisigTransaction(walletHandle, pw, transaction, pk, partial) {
    const tx = instantiateTxnIfNeeded(transaction);
    const req = {
      wallet_handle_token: walletHandle,
      transaction: Buffer.from(tx.toByte()).toString("base64"),
      public_key: Buffer.from(pk).toString("base64"),
      partial_multisig: partial,
      wallet_password: pw
    };
    const res = await this.c.post("/v1/multisig/sign", req);
    return res.body;
  }
  /**
   * deleteMultisig accepts a wallet handle, wallet password, and multisig
   * address, and deletes the information about this multisig address from the
   * wallet (including address and secret key).
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async deleteMultisig(walletHandle, walletPassword, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr,
      wallet_password: walletPassword
    };
    const res = await this.c.delete("/v1/multisig", req);
    return res.body;
  }
};
var MakeHealthCheck = class extends JSONRequest {
  /**
   * @returns `/health`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/health";
  }
};
var LookupAssetBalances = class extends JSONRequest {
  /**
   * Returns the list of accounts which hold the given asset and their balance.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient.lookupAssetBalances(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idbalances)
   * @param index - The asset ID to look up.
   */
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  /**
   * @returns `/v2/assets/${index}/balances`
   */
  path() {
    return `/v2/assets/${this.index}/balances`;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const maxResults = 20;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Filtered results should have an asset balance greater than this value.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const minBalance = 1000000;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .currencyGreaterThan(minBalance)
   *        .do();
   * ```
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  /**
   * Filtered results should have an asset balance less than this value.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const maxBalance = 2000000;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .currencyLessThan(maxBalance)
   *        .do();
   * ```
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const maxResults = 20;
   *
   * const assetBalancesPage1 = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .limit(maxResults)
   *        .do();
   *
   * const assetBalancesPage2 = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .limit(maxResults)
   *        .nextToken(assetBalancesPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
   *
   * #### Example 1
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value
   * @category query
   */
  includeAll(value2 = true) {
    this.query["include-all"] = value2;
    return this;
  }
};
function base64StringFunnel(data) {
  if (typeof data === "string") {
    return data;
  }
  return Buffer.from(data).toString("base64");
}
var LookupAccountTransactions = class extends JSONRequest {
  /**
   * Returns transactions relating to the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient.lookupAccountTransactions(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idtransactions)
   * @param account - The address of the account.
   */
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  /**
   * @returns `/v2/accounts/${account}/transactions`
   */
  path() {
    return `/v2/accounts/${this.account}/transactions`;
  }
  /**
   * Specifies a prefix which must be contained in the note field.
   *
   * #### Example
   * ```typescript
   * const notePrefixBase64Encoded = "Y3JlYXRl";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .notePrefix(notePrefixBase64Encoded)
   *        .do();
   * ```
   *
   * @param prefix - base64 string or uint8array
   * @category query
   */
  notePrefix(prefix) {
    this.query["note-prefix"] = base64StringFunnel(prefix);
    return this;
  }
  /**
   * Type of transaction to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .txType("appl")
   *        .do();
   * ```
   *
   * @param type - one of `pay`, `keyreg`, `acfg`, `axfer`, `afrz`, `appl`, `stpf`
   * @category query
   */
  txType(type) {
    this.query["tx-type"] = type;
    return this;
  }
  /**
   * Type of signature to filter with.
   * - sig: Standard
   * - msig: MultiSig
   * - lsig: LogicSig
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .sigType("msig")
   *        .do();
   * ```
   *
   * @param type - one of `sig`, `msig`, `lsig`
   * @category query
   */
  sigType(type) {
    this.query["sig-type"] = type;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .txid(txId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupTransactionByID(txnId).do()`
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * Asset ID to filter with.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .assetID(assetID)
   *        .do();
   * ```
   *
   * @param id
   * @category query
   */
  assetID(id) {
    this.query["asset-id"] = id;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results before the given time.
   *
   * #### Example
   * ```typescript
   * const beforeTime = "2022-02-02T20:20:22.02Z";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .beforeTime(beforeTime)
   *        .do();
   * ```
   *
   * @param before - rfc3339 string
   * @category query
   */
  beforeTime(before) {
    this.query["before-time"] = before;
    return this;
  }
  /**
   * Include results after the given time.
   *
   * #### Example
   * ```typescript
   * const afterTime = "2022-10-21T00:00:11.55Z";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .afterTime(afterTime)
   *        .do();
   * ```
   *
   * @param after - rfc3339 string
   * @category query
   */
  afterTime(after) {
    this.query["after-time"] = after;
    return this;
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const minBalance = 300000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const minBalance = 300000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .assetID(assetID)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   * @remarks
   * If you are looking for transactions with the currency amount greater than 0, simply construct the query without `currencyGreaterThan` because it doesn't accept `-1`, and passing the `0` `currency-greater-than` value would exclude transactions with a 0 amount.
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const maxBalance = 500000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const maxBalance = 500000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .assetID(assetID)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * The next page of results. Use the next token provided by the previous results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   *
   * const accountTxnsPage1 = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountTxnsPage2 = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .limit(maxResults)
   *        .nextToken(accountTxnsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Whether or not to include rekeying transactions.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .rekeyTo(false)
   *        .do();
   * ```
   *
   * @param rekeyTo
   * @category query
   */
  rekeyTo(rekeyTo) {
    this.query["rekey-to"] = rekeyTo;
    return this;
  }
};
var LookupAssetTransactions = class extends JSONRequest {
  /**
   * Returns transactions relating to the given asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient.lookupAssetTransactions(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idtransactions)
   * @param index - The asset ID to look up.
   */
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  /**
   * @returns `/v2/assets/${index}/transactions`
   */
  path() {
    return `/v2/assets/${this.index}/transactions`;
  }
  /**
   * Specifies a prefix which must be contained in the note field.
   *
   * #### Example
   * ```typescript
   * const notePrefixBase64Encoded = "Y3JlYXRl";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .notePrefix(notePrefixBase64Encoded)
   *        .do();
   * ```
   *
   * @param prefix - base64 string or uint8array
   * @category query
   */
  notePrefix(prefix) {
    this.query["note-prefix"] = base64StringFunnel(prefix);
    return this;
  }
  /**
   * Type of transaction to filter with.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .txType("axfer")
   *        .do();
   * ```
   *
   * @param type - one of `pay`, `keyreg`, `acfg`, `axfer`, `afrz`, `appl`
   * @category query
   */
  txType(type) {
    this.query["tx-type"] = type;
    return this;
  }
  /**
   * Type of signature to filter with.
   * - sig: Standard
   * - msig: MultiSig
   * - lsig: LogicSig
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .sigType("lsig")
   *        .do();
   * ```
   *
   * @param type - one of `sig`, `msig`, `lsig`
   * @category query
   */
  sigType(type) {
    this.query["sig-type"] = type;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .txid(txId)
   *        .do();
   * ```
   *
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .round(targetBlock)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results before the given time.
   *
   * #### Example
   * ```typescript
   * const beforeTime = "2022-02-02T20:20:22.02Z";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .beforeTime(beforeTime)
   *        .do();
   * ```
   *
   * @param before - rfc3339 string
   * @category query
   */
  beforeTime(before) {
    this.query["before-time"] = before;
    return this;
  }
  /**
   * Include results after the given time.
   *
   * #### Example
   * ```typescript
   * const afterTime = "2022-10-21T00:00:11.55Z";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .afterTime(afterTime)
   *        .do();
   * ```
   *
   * @param after - rfc3339 string
   * @category query
   */
  afterTime(after) {
    this.query["after-time"] = after;
    return this;
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing asset units.
   *
   * #### Example
   * ```typescript
   * const minBalance = 300000;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * @remarks
   * If you are looking for transactions with the currency amount greater than 0, simply construct the query without `currencyGreaterThan` because it doesn't accept `-1`, and passing the `0` `currency-greater-than` value would exclude transactions with a 0 amount.
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing asset units.
   *
   * #### Example
   * ```typescript
   * const maxBalance = 500000;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * Combined with address, defines what address to filter on, as string.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const role = "sender";
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .address(address)
   *        .addressRole(role)
   *        .do();
   * ```
   *
   * @param role - one of `sender`, `receiver`, `freeze-target`
   * @category query
   */
  addressRole(role) {
    this.query["address-role"] = role;
    return this;
  }
  /**
   * Only include transactions with this address in one of the transaction fields.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .address(address)
   *        .do();
   * ```
   *
   * @param address
   * @category query
   */
  address(address) {
    this.query.address = address;
    return this;
  }
  /**
   * Whether or not to consider the `close-to` field as a receiver when filtering transactions, as bool. Set to `true` to ignore `close-to`.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .excludeCloseTo(true)
   *        .do();
   * ```
   *
   * @param exclude
   * @category query
   */
  excludeCloseTo(exclude) {
    this.query["exclude-close-to"] = exclude;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const assetId = 163650;
   *
   * const assetTxnsPage1 = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .limit(maxResults)
   *        .do();
   *
   * const assetTxnsPage2 = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .limit(maxResults)
   *        .nextToken(assetTxnsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Whether or not to include rekeying transactions.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .rekeyTo(false)
   *        .do();
   * ```
   *
   * @param rekeyTo
   * @category query
   */
  rekeyTo(rekeyTo) {
    this.query["rekey-to"] = rekeyTo;
    return this;
  }
};
var LookupBlock = class extends JSONRequest {
  /**
   * Returns the block for the passed round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const blockInfo = await indexerClient.lookupBlock(targetBlock).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2blocksround-number)
   * @param round - The number of the round to look up.
   * @category GET
   */
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    this.round = round;
  }
  /**
   * @returns `/v2/blocks/${round}`
   */
  path() {
    return `/v2/blocks/${this.round}`;
  }
  /**
   * Header only flag. When this is set to true, returned block does not contain the
   * transactions.
   */
  headerOnly(headerOnly) {
    this.query["header-only"] = headerOnly;
    return this;
  }
};
var LookupTransactionByID = class extends JSONRequest {
  /**
   * Returns information about the given transaction.
   *
   * #### Example
   * ```typescript
   * const txnId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const txnInfo = await indexerClient.lookupTransactionByID(txnId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactionstxid)
   * @param txID - The ID of the transaction to look up.
   * @category GET
   */
  constructor(c, intDecoding, txID) {
    super(c, intDecoding);
    this.txID = txID;
    this.txID = txID;
  }
  /**
   * @returns `/v2/transactions/${txID}`
   */
  path() {
    return `/v2/transactions/${this.txID}`;
  }
};
var LookupAccountByID = class extends JSONRequest {
  /**
   * Returns information about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient.lookupAccountByID(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-id)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  /**
   * @returns `/v2/accounts/${account}`
   */
  path() {
    return `/v2/accounts/${this.account}`;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
   *
   * #### Example 1
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .includeAll()
   *        .do();
   * ```
   * @param value
   */
  includeAll(value2 = true) {
    this.query["include-all"] = value2;
    return this;
  }
  /**
   * Exclude additional items such as asset holdings, application local data stored for this account, asset parameters created by this account, and application parameters created by this account.
   *
   * #### Example 1
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .exclude("all")
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .exclude("assets,created-assets")
   *        .do();
   * ```
   * @remarks By default, it behaves as exclude=none
   * @param exclude - Array of `all`, `assets`, `created-assets`, `apps-local-state`, `created-apps`, `none`
   * @category query
   */
  exclude(exclude) {
    this.query.exclude = exclude;
    return this;
  }
};
var LookupAccountAssets = class extends JSONRequest {
  /**
   * Returns asset about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient.lookupAccountAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idassets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  /**
   * @returns `/v2/accounts/${account}/assets`
   */
  path() {
    return `/v2/accounts/${this.account}/assets`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountAssets(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountAssets(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value2 = true) {
    this.query["include-all"] = value2;
    return this;
  }
  /**
   * Specify an assetID to search for.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assetAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .assetId(assetId)
   *        .do();
   * ```
   * @param index - the assetID
   * @category query
   */
  assetId(index2) {
    this.query["asset-id"] = index2;
    return this;
  }
};
var LookupAccountCreatedAssets = class extends JSONRequest {
  /**
   * Returns asset information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedAssets = await indexerClient.lookupAccountCreatedAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-assets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  /**
   * @returns `/v2/accounts/${account}/created-assets`
   */
  path() {
    return `/v2/accounts/${this.account}/created-assets`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value2 = true) {
    this.query["include-all"] = value2;
    return this;
  }
  /**
   * Specify an assetID to search for.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assetAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .assetID(assetID)
   *        .do();
   * ```
   * @param index - the assetID
   * @category query
   */
  assetID(index2) {
    this.query["asset-id"] = index2;
    return this;
  }
};
var LookupAccountAppLocalStates = class extends JSONRequest {
  /**
   * Returns application local state about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAppLocalStates = await indexerClient.lookupAccountAppLocalStates(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idapps-local-state)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  /**
   * @returns `/v2/accounts/${account}/apps-local-state`
   */
  path() {
    return `/v2/accounts/${this.account}/apps-local-state`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value2 = true) {
    this.query["include-all"] = value2;
    return this;
  }
  /**
   * Specify an applicationID to search for.
   *
   * #### Example
   * ```typescript
   * const applicationID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountApplications = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .applicationID(applicationID)
   *        .do();
   * ```
   * @param index - the applicationID
   * @category query
   */
  applicationID(index2) {
    this.query["application-id"] = index2;
    return this;
  }
};
var LookupAccountCreatedApplications = class extends JSONRequest {
  /**
   * Returns application information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedApps = await indexerClient.lookupAccountCreatedApplications(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-applications)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  /**
   * @returns `/v2/accounts/${account}/created-applications`
   */
  path() {
    return `/v2/accounts/${this.account}/created-applications`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value2 = true) {
    this.query["include-all"] = value2;
    return this;
  }
  /**
   * Specify an applicationID to search for.
   *
   * #### Example
   * ```typescript
   * const applicationID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountApplications = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .applicationID(applicationID)
   *        .do();
   * ```
   * @param index - the applicationID
   * @category query
   */
  applicationID(index2) {
    this.query["application-id"] = index2;
    return this;
  }
};
var LookupAssetByID = class extends JSONRequest {
  /**
   * Returns asset information of the queried asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient.lookupAssetByID(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-id)
   * @param index - The asset ID to look up.
   */
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  /**
   * @returns `/v2/assets/${index}`
   */
  path() {
    return `/v2/assets/${this.index}`;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient
   *        .lookupAssetByID(assetId)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient
   *        .lookupAssetByID(assetId)
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value2 = true) {
    this.query["include-all"] = value2;
    return this;
  }
};
var LookupApplications = class extends JSONRequest {
  /**
   * Returns information about the passed application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient.lookupApplications(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-id)
   * @param index - The ID of the application to look up.
   * @category GET
   */
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  /**
   * @returns `/v2/applications/${index}`
   */
  path() {
    return `/v2/applications/${this.index}`;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient
   *        .lookupApplications(appId)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient
   *        .lookupApplications(appId)
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value2 = true) {
    this.query["include-all"] = value2;
    return this;
  }
};
var LookupApplicationLogs = class extends JSONRequest {
  /**
   * Returns log messages generated by the passed in application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appLogs = await indexerClient.lookupApplicationLogs(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idlogs)
   * @param appID - The ID of the application which generated the logs.
   * @category GET
   */
  constructor(c, intDecoding, appID) {
    super(c, intDecoding);
    this.appID = appID;
    this.appID = appID;
  }
  /**
   * @returns `/v2/applications/${appID}/logs`
   */
  path() {
    return `/v2/applications/${this.appID}/logs`;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   *
   * const appLogsPage1 = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .limit(maxResults)
   *        .do();
   *
   * const appLogsPage2 = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .limit(maxResults)
   *        .nextToken(appLogsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Only include transactions with this sender address.
   *
   * #### Example
   * ```typescript
   * const sender = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .sender(sender)
   *        .do();
   * ```
   *
   * @param senderAddress
   * @category query
   */
  sender(senderAddress) {
    this.query["sender-address"] = senderAddress;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .txid(txId)
   *        .do();
   * ```
   *
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
};
var types_exports2 = {};
__export(types_exports2, {
  Account: () => Account2,
  AccountParticipation: () => AccountParticipation2,
  AccountResponse: () => AccountResponse,
  AccountStateDelta: () => AccountStateDelta2,
  AccountsResponse: () => AccountsResponse,
  Application: () => Application2,
  ApplicationLocalState: () => ApplicationLocalState2,
  ApplicationLocalStatesResponse: () => ApplicationLocalStatesResponse,
  ApplicationLogData: () => ApplicationLogData,
  ApplicationLogsResponse: () => ApplicationLogsResponse,
  ApplicationParams: () => ApplicationParams2,
  ApplicationResponse: () => ApplicationResponse,
  ApplicationStateSchema: () => ApplicationStateSchema2,
  ApplicationsResponse: () => ApplicationsResponse,
  Asset: () => Asset2,
  AssetBalancesResponse: () => AssetBalancesResponse,
  AssetHolding: () => AssetHolding2,
  AssetHoldingsResponse: () => AssetHoldingsResponse,
  AssetParams: () => AssetParams2,
  AssetResponse: () => AssetResponse,
  AssetsResponse: () => AssetsResponse,
  Block: () => Block2,
  BlockRewards: () => BlockRewards,
  BlockUpgradeState: () => BlockUpgradeState,
  BlockUpgradeVote: () => BlockUpgradeVote,
  Box: () => Box2,
  BoxDescriptor: () => BoxDescriptor2,
  BoxesResponse: () => BoxesResponse2,
  ErrorResponse: () => ErrorResponse2,
  EvalDelta: () => EvalDelta2,
  EvalDeltaKeyValue: () => EvalDeltaKeyValue2,
  HashFactory: () => HashFactory,
  HealthCheck: () => HealthCheck2,
  IndexerStateProofMessage: () => IndexerStateProofMessage,
  MerkleArrayProof: () => MerkleArrayProof,
  MiniAssetHolding: () => MiniAssetHolding,
  ParticipationUpdates: () => ParticipationUpdates,
  StateProofFields: () => StateProofFields,
  StateProofParticipant: () => StateProofParticipant,
  StateProofReveal: () => StateProofReveal,
  StateProofSigSlot: () => StateProofSigSlot,
  StateProofSignature: () => StateProofSignature,
  StateProofTracking: () => StateProofTracking,
  StateProofVerifier: () => StateProofVerifier,
  StateSchema: () => StateSchema,
  TealKeyValue: () => TealKeyValue2,
  TealValue: () => TealValue2,
  Transaction: () => Transaction2,
  TransactionApplication: () => TransactionApplication,
  TransactionAssetConfig: () => TransactionAssetConfig,
  TransactionAssetFreeze: () => TransactionAssetFreeze,
  TransactionAssetTransfer: () => TransactionAssetTransfer,
  TransactionKeyreg: () => TransactionKeyreg,
  TransactionPayment: () => TransactionPayment,
  TransactionResponse: () => TransactionResponse,
  TransactionSignature: () => TransactionSignature,
  TransactionSignatureLogicsig: () => TransactionSignatureLogicsig,
  TransactionSignatureMultisig: () => TransactionSignatureMultisig,
  TransactionSignatureMultisigSubsignature: () => TransactionSignatureMultisigSubsignature,
  TransactionStateProof: () => TransactionStateProof,
  TransactionsResponse: () => TransactionsResponse
});
var Account2 = class extends BaseModel {
  /**
   * Creates a new `Account` object.
   * @param address - the account public key
   * @param amount - (algo) total number of MicroAlgos in the account
   * @param amountWithoutPendingRewards - specifies the amount of MicroAlgos in the account, without the pending rewards.
   * @param pendingRewards - amount of MicroAlgos of pending rewards in this account.
   * @param rewards - (ern) total rewards of MicroAlgos the account has received, including pending
   * rewards.
   * @param round - The round for which this information is relevant.
   * @param status - (onl) delegation status of the account's MicroAlgos
   * * Offline - indicates that the associated account is delegated.
   * * Online - indicates that the associated account used as part of the delegation
   * pool.
   * * NotParticipating - indicates that the associated account is neither a
   * delegator nor a delegate.
   * @param totalAppsOptedIn - The count of all applications that have been opted in, equivalent to the count
   * of application local data (AppLocalState objects) stored in this account.
   * @param totalAssetsOptedIn - The count of all assets that have been opted in, equivalent to the count of
   * AssetHolding objects held by this account.
   * @param totalBoxBytes - For app-accounts only. The total number of bytes allocated for the keys and
   * values of boxes which belong to the associated application.
   * @param totalBoxes - For app-accounts only. The total number of boxes which belong to the associated
   * application.
   * @param totalCreatedApps - The count of all apps (AppParams objects) created by this account.
   * @param totalCreatedAssets - The count of all assets (AssetParams objects) created by this account.
   * @param appsLocalState - (appl) applications local data stored in this account.
   * Note the raw object uses `map[int] -> AppLocalState` for this type.
   * @param appsTotalExtraPages - (teap) the sum of all extra application program pages for this account.
   * @param appsTotalSchema - (tsch) stores the sum of all of the local schemas and globalThis schemas in this
   * account.
   * Note: the raw account uses `StateSchema` for this type.
   * @param assets - (asset) assets held by this account.
   * Note the raw object uses `map[int] -> AssetHolding` for this type.
   * @param authAddr - (spend) the address against which signing should be checked. If empty, the
   * address of the current account is used. This field can be updated in any
   * transaction by setting the RekeyTo field.
   * @param closedAtRound - Round during which this account was most recently closed.
   * @param createdApps - (appp) parameters of applications created by this account including app globalThis
   * data.
   * Note: the raw account uses `map[int] -> AppParams` for this type.
   * @param createdAssets - (apar) parameters of assets created by this account.
   * Note: the raw account uses `map[int] -> Asset` for this type.
   * @param createdAtRound - Round during which this account first appeared in a transaction.
   * @param deleted - Whether or not this account is currently closed.
   * @param participation - AccountParticipation describes the parameters used by this account in consensus
   * protocol.
   * @param rewardBase - (ebase) used as part of the rewards computation. Only applicable to accounts
   * which are participating.
   * @param sigType - Indicates what type of signature is used by this account, must be one of:
   * * sig
   * * msig
   * * lsig
   * * or null if unknown
   */
  constructor({ address, amount, amountWithoutPendingRewards, pendingRewards, rewards, round, status, totalAppsOptedIn, totalAssetsOptedIn, totalBoxBytes, totalBoxes, totalCreatedApps, totalCreatedAssets, appsLocalState, appsTotalExtraPages, appsTotalSchema, assets, authAddr, closedAtRound, createdApps, createdAssets, createdAtRound, deleted, participation, rewardBase, sigType }) {
    super();
    this.address = address;
    this.amount = amount;
    this.amountWithoutPendingRewards = amountWithoutPendingRewards;
    this.pendingRewards = pendingRewards;
    this.rewards = rewards;
    this.round = round;
    this.status = status;
    this.totalAppsOptedIn = totalAppsOptedIn;
    this.totalAssetsOptedIn = totalAssetsOptedIn;
    this.totalBoxBytes = totalBoxBytes;
    this.totalBoxes = totalBoxes;
    this.totalCreatedApps = totalCreatedApps;
    this.totalCreatedAssets = totalCreatedAssets;
    this.appsLocalState = appsLocalState;
    this.appsTotalExtraPages = appsTotalExtraPages;
    this.appsTotalSchema = appsTotalSchema;
    this.assets = assets;
    this.authAddr = authAddr;
    this.closedAtRound = closedAtRound;
    this.createdApps = createdApps;
    this.createdAssets = createdAssets;
    this.createdAtRound = createdAtRound;
    this.deleted = deleted;
    this.participation = participation;
    this.rewardBase = rewardBase;
    this.sigType = sigType;
    this.attribute_map = {
      address: "address",
      amount: "amount",
      amountWithoutPendingRewards: "amount-without-pending-rewards",
      pendingRewards: "pending-rewards",
      rewards: "rewards",
      round: "round",
      status: "status",
      totalAppsOptedIn: "total-apps-opted-in",
      totalAssetsOptedIn: "total-assets-opted-in",
      totalBoxBytes: "total-box-bytes",
      totalBoxes: "total-boxes",
      totalCreatedApps: "total-created-apps",
      totalCreatedAssets: "total-created-assets",
      appsLocalState: "apps-local-state",
      appsTotalExtraPages: "apps-total-extra-pages",
      appsTotalSchema: "apps-total-schema",
      assets: "assets",
      authAddr: "auth-addr",
      closedAtRound: "closed-at-round",
      createdApps: "created-apps",
      createdAssets: "created-assets",
      createdAtRound: "created-at-round",
      deleted: "deleted",
      participation: "participation",
      rewardBase: "reward-base",
      sigType: "sig-type"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["address"] === "undefined")
      throw new Error(`Response is missing required field 'address': ${data}`);
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["amount-without-pending-rewards"] === "undefined")
      throw new Error(`Response is missing required field 'amount-without-pending-rewards': ${data}`);
    if (typeof data["pending-rewards"] === "undefined")
      throw new Error(`Response is missing required field 'pending-rewards': ${data}`);
    if (typeof data["rewards"] === "undefined")
      throw new Error(`Response is missing required field 'rewards': ${data}`);
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    if (typeof data["status"] === "undefined")
      throw new Error(`Response is missing required field 'status': ${data}`);
    if (typeof data["total-apps-opted-in"] === "undefined")
      throw new Error(`Response is missing required field 'total-apps-opted-in': ${data}`);
    if (typeof data["total-assets-opted-in"] === "undefined")
      throw new Error(`Response is missing required field 'total-assets-opted-in': ${data}`);
    if (typeof data["total-box-bytes"] === "undefined")
      throw new Error(`Response is missing required field 'total-box-bytes': ${data}`);
    if (typeof data["total-boxes"] === "undefined")
      throw new Error(`Response is missing required field 'total-boxes': ${data}`);
    if (typeof data["total-created-apps"] === "undefined")
      throw new Error(`Response is missing required field 'total-created-apps': ${data}`);
    if (typeof data["total-created-assets"] === "undefined")
      throw new Error(`Response is missing required field 'total-created-assets': ${data}`);
    return new Account2({
      address: data["address"],
      amount: data["amount"],
      amountWithoutPendingRewards: data["amount-without-pending-rewards"],
      pendingRewards: data["pending-rewards"],
      rewards: data["rewards"],
      round: data["round"],
      status: data["status"],
      totalAppsOptedIn: data["total-apps-opted-in"],
      totalAssetsOptedIn: data["total-assets-opted-in"],
      totalBoxBytes: data["total-box-bytes"],
      totalBoxes: data["total-boxes"],
      totalCreatedApps: data["total-created-apps"],
      totalCreatedAssets: data["total-created-assets"],
      appsLocalState: typeof data["apps-local-state"] !== "undefined" ? data["apps-local-state"].map(ApplicationLocalState2.from_obj_for_encoding) : void 0,
      appsTotalExtraPages: data["apps-total-extra-pages"],
      appsTotalSchema: typeof data["apps-total-schema"] !== "undefined" ? ApplicationStateSchema2.from_obj_for_encoding(data["apps-total-schema"]) : void 0,
      assets: typeof data["assets"] !== "undefined" ? data["assets"].map(AssetHolding2.from_obj_for_encoding) : void 0,
      authAddr: data["auth-addr"],
      closedAtRound: data["closed-at-round"],
      createdApps: typeof data["created-apps"] !== "undefined" ? data["created-apps"].map(Application2.from_obj_for_encoding) : void 0,
      createdAssets: typeof data["created-assets"] !== "undefined" ? data["created-assets"].map(Asset2.from_obj_for_encoding) : void 0,
      createdAtRound: data["created-at-round"],
      deleted: data["deleted"],
      participation: typeof data["participation"] !== "undefined" ? AccountParticipation2.from_obj_for_encoding(data["participation"]) : void 0,
      rewardBase: data["reward-base"],
      sigType: data["sig-type"]
    });
  }
};
var AccountParticipation2 = class extends BaseModel {
  /**
   * Creates a new `AccountParticipation` object.
   * @param selectionParticipationKey - (sel) Selection public key (if any) currently registered for this round.
   * @param voteFirstValid - (voteFst) First round for which this participation is valid.
   * @param voteKeyDilution - (voteKD) Number of subkeys in each batch of participation keys.
   * @param voteLastValid - (voteLst) Last round for which this participation is valid.
   * @param voteParticipationKey - (vote) root participation public key (if any) currently registered for this
   * round.
   * @param stateProofKey - (stprf) Root of the state proof key (if any)
   */
  constructor({ selectionParticipationKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey, stateProofKey }) {
    super();
    this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? new Uint8Array(Buffer.from(selectionParticipationKey, "base64")) : selectionParticipationKey;
    this.voteFirstValid = voteFirstValid;
    this.voteKeyDilution = voteKeyDilution;
    this.voteLastValid = voteLastValid;
    this.voteParticipationKey = typeof voteParticipationKey === "string" ? new Uint8Array(Buffer.from(voteParticipationKey, "base64")) : voteParticipationKey;
    this.stateProofKey = typeof stateProofKey === "string" ? new Uint8Array(Buffer.from(stateProofKey, "base64")) : stateProofKey;
    this.attribute_map = {
      selectionParticipationKey: "selection-participation-key",
      voteFirstValid: "vote-first-valid",
      voteKeyDilution: "vote-key-dilution",
      voteLastValid: "vote-last-valid",
      voteParticipationKey: "vote-participation-key",
      stateProofKey: "state-proof-key"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["selection-participation-key"] === "undefined")
      throw new Error(`Response is missing required field 'selection-participation-key': ${data}`);
    if (typeof data["vote-first-valid"] === "undefined")
      throw new Error(`Response is missing required field 'vote-first-valid': ${data}`);
    if (typeof data["vote-key-dilution"] === "undefined")
      throw new Error(`Response is missing required field 'vote-key-dilution': ${data}`);
    if (typeof data["vote-last-valid"] === "undefined")
      throw new Error(`Response is missing required field 'vote-last-valid': ${data}`);
    if (typeof data["vote-participation-key"] === "undefined")
      throw new Error(`Response is missing required field 'vote-participation-key': ${data}`);
    return new AccountParticipation2({
      selectionParticipationKey: data["selection-participation-key"],
      voteFirstValid: data["vote-first-valid"],
      voteKeyDilution: data["vote-key-dilution"],
      voteLastValid: data["vote-last-valid"],
      voteParticipationKey: data["vote-participation-key"],
      stateProofKey: data["state-proof-key"]
    });
  }
};
var AccountResponse = class extends BaseModel {
  /**
   * Creates a new `AccountResponse` object.
   * @param account - Account information at a given round.
   * Definition:
   * data/basics/userBalance.go : AccountData
   * @param currentRound - Round at which the results were computed.
   */
  constructor({ account, currentRound }) {
    super();
    this.account = account;
    this.currentRound = currentRound;
    this.attribute_map = {
      account: "account",
      currentRound: "current-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["account"] === "undefined")
      throw new Error(`Response is missing required field 'account': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new AccountResponse({
      account: Account2.from_obj_for_encoding(data["account"]),
      currentRound: data["current-round"]
    });
  }
};
var AccountStateDelta2 = class extends BaseModel {
  /**
   * Creates a new `AccountStateDelta` object.
   * @param address -
   * @param delta - Application state delta.
   */
  constructor({ address, delta }) {
    super();
    this.address = address;
    this.delta = delta;
    this.attribute_map = {
      address: "address",
      delta: "delta"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["address"] === "undefined")
      throw new Error(`Response is missing required field 'address': ${data}`);
    if (!Array.isArray(data["delta"]))
      throw new Error(`Response is missing required array field 'delta': ${data}`);
    return new AccountStateDelta2({
      address: data["address"],
      delta: data["delta"].map(EvalDeltaKeyValue2.from_obj_for_encoding)
    });
  }
};
var AccountsResponse = class extends BaseModel {
  /**
   * Creates a new `AccountsResponse` object.
   * @param accounts -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ accounts, currentRound, nextToken }) {
    super();
    this.accounts = accounts;
    this.currentRound = currentRound;
    this.nextToken = nextToken;
    this.attribute_map = {
      accounts: "accounts",
      currentRound: "current-round",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["accounts"]))
      throw new Error(`Response is missing required array field 'accounts': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new AccountsResponse({
      accounts: data["accounts"].map(Account2.from_obj_for_encoding),
      currentRound: data["current-round"],
      nextToken: data["next-token"]
    });
  }
};
var Application2 = class extends BaseModel {
  /**
   * Creates a new `Application` object.
   * @param id - (appidx) application index.
   * @param params - (appparams) application parameters.
   * @param createdAtRound - Round when this application was created.
   * @param deleted - Whether or not this application is currently deleted.
   * @param deletedAtRound - Round when this application was deleted.
   */
  constructor({ id, params, createdAtRound, deleted, deletedAtRound }) {
    super();
    this.id = id;
    this.params = params;
    this.createdAtRound = createdAtRound;
    this.deleted = deleted;
    this.deletedAtRound = deletedAtRound;
    this.attribute_map = {
      id: "id",
      params: "params",
      createdAtRound: "created-at-round",
      deleted: "deleted",
      deletedAtRound: "deleted-at-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["id"] === "undefined")
      throw new Error(`Response is missing required field 'id': ${data}`);
    if (typeof data["params"] === "undefined")
      throw new Error(`Response is missing required field 'params': ${data}`);
    return new Application2({
      id: data["id"],
      params: ApplicationParams2.from_obj_for_encoding(data["params"]),
      createdAtRound: data["created-at-round"],
      deleted: data["deleted"],
      deletedAtRound: data["deleted-at-round"]
    });
  }
};
var ApplicationLocalState2 = class extends BaseModel {
  /**
   * Creates a new `ApplicationLocalState` object.
   * @param id - The application which this local state is for.
   * @param schema - (hsch) schema.
   * @param closedOutAtRound - Round when account closed out of the application.
   * @param deleted - Whether or not the application local state is currently deleted from its
   * account.
   * @param keyValue - (tkv) storage.
   * @param optedInAtRound - Round when the account opted into the application.
   */
  constructor({ id, schema, closedOutAtRound, deleted, keyValue, optedInAtRound }) {
    super();
    this.id = id;
    this.schema = schema;
    this.closedOutAtRound = closedOutAtRound;
    this.deleted = deleted;
    this.keyValue = keyValue;
    this.optedInAtRound = optedInAtRound;
    this.attribute_map = {
      id: "id",
      schema: "schema",
      closedOutAtRound: "closed-out-at-round",
      deleted: "deleted",
      keyValue: "key-value",
      optedInAtRound: "opted-in-at-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["id"] === "undefined")
      throw new Error(`Response is missing required field 'id': ${data}`);
    if (typeof data["schema"] === "undefined")
      throw new Error(`Response is missing required field 'schema': ${data}`);
    return new ApplicationLocalState2({
      id: data["id"],
      schema: ApplicationStateSchema2.from_obj_for_encoding(data["schema"]),
      closedOutAtRound: data["closed-out-at-round"],
      deleted: data["deleted"],
      keyValue: typeof data["key-value"] !== "undefined" ? data["key-value"].map(TealKeyValue2.from_obj_for_encoding) : void 0,
      optedInAtRound: data["opted-in-at-round"]
    });
  }
};
var ApplicationLocalStatesResponse = class extends BaseModel {
  /**
   * Creates a new `ApplicationLocalStatesResponse` object.
   * @param appsLocalStates -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ appsLocalStates, currentRound, nextToken }) {
    super();
    this.appsLocalStates = appsLocalStates;
    this.currentRound = currentRound;
    this.nextToken = nextToken;
    this.attribute_map = {
      appsLocalStates: "apps-local-states",
      currentRound: "current-round",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["apps-local-states"]))
      throw new Error(`Response is missing required array field 'apps-local-states': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new ApplicationLocalStatesResponse({
      appsLocalStates: data["apps-local-states"].map(ApplicationLocalState2.from_obj_for_encoding),
      currentRound: data["current-round"],
      nextToken: data["next-token"]
    });
  }
};
var ApplicationLogData = class extends BaseModel {
  /**
   * Creates a new `ApplicationLogData` object.
   * @param logs - (lg) Logs for the application being executed by the transaction.
   * @param txid - Transaction ID
   */
  constructor({ logs, txid }) {
    super();
    this.logs = logs;
    this.txid = txid;
    this.attribute_map = {
      logs: "logs",
      txid: "txid"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["logs"]))
      throw new Error(`Response is missing required array field 'logs': ${data}`);
    if (typeof data["txid"] === "undefined")
      throw new Error(`Response is missing required field 'txid': ${data}`);
    return new ApplicationLogData({
      logs: data["logs"],
      txid: data["txid"]
    });
  }
};
var ApplicationLogsResponse = class extends BaseModel {
  /**
   * Creates a new `ApplicationLogsResponse` object.
   * @param applicationId - (appidx) application index.
   * @param currentRound - Round at which the results were computed.
   * @param logData -
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ applicationId, currentRound, logData, nextToken }) {
    super();
    this.applicationId = applicationId;
    this.currentRound = currentRound;
    this.logData = logData;
    this.nextToken = nextToken;
    this.attribute_map = {
      applicationId: "application-id",
      currentRound: "current-round",
      logData: "log-data",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["application-id"] === "undefined")
      throw new Error(`Response is missing required field 'application-id': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new ApplicationLogsResponse({
      applicationId: data["application-id"],
      currentRound: data["current-round"],
      logData: typeof data["log-data"] !== "undefined" ? data["log-data"].map(ApplicationLogData.from_obj_for_encoding) : void 0,
      nextToken: data["next-token"]
    });
  }
};
var ApplicationParams2 = class extends BaseModel {
  /**
   * Creates a new `ApplicationParams` object.
   * @param approvalProgram - (approv) approval program.
   * @param clearStateProgram - (clearp) approval program.
   * @param creator - The address that created this application. This is the address where the
   * parameters and globalThis state for this application can be found.
   * @param extraProgramPages - (epp) the amount of extra program pages available to this app.
   * @param globalState - [\gs) globalThis schema
   * @param globalStateSchema - [\gsch) globalThis schema
   * @param localStateSchema - [\lsch) local schema
   */
  constructor({ approvalProgram, clearStateProgram, creator, extraProgramPages, globalState, globalStateSchema, localStateSchema }) {
    super();
    this.approvalProgram = typeof approvalProgram === "string" ? new Uint8Array(Buffer.from(approvalProgram, "base64")) : approvalProgram;
    this.clearStateProgram = typeof clearStateProgram === "string" ? new Uint8Array(Buffer.from(clearStateProgram, "base64")) : clearStateProgram;
    this.creator = creator;
    this.extraProgramPages = extraProgramPages;
    this.globalState = globalState;
    this.globalStateSchema = globalStateSchema;
    this.localStateSchema = localStateSchema;
    this.attribute_map = {
      approvalProgram: "approval-program",
      clearStateProgram: "clear-state-program",
      creator: "creator",
      extraProgramPages: "extra-program-pages",
      globalState: "globalThis-state",
      globalStateSchema: "globalThis-state-schema",
      localStateSchema: "local-state-schema"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["approval-program"] === "undefined")
      throw new Error(`Response is missing required field 'approval-program': ${data}`);
    if (typeof data["clear-state-program"] === "undefined")
      throw new Error(`Response is missing required field 'clear-state-program': ${data}`);
    return new ApplicationParams2({
      approvalProgram: data["approval-program"],
      clearStateProgram: data["clear-state-program"],
      creator: data["creator"],
      extraProgramPages: data["extra-program-pages"],
      globalState: typeof data["globalThis-state"] !== "undefined" ? data["globalThis-state"].map(TealKeyValue2.from_obj_for_encoding) : void 0,
      globalStateSchema: typeof data["globalThis-state-schema"] !== "undefined" ? ApplicationStateSchema2.from_obj_for_encoding(data["globalThis-state-schema"]) : void 0,
      localStateSchema: typeof data["local-state-schema"] !== "undefined" ? ApplicationStateSchema2.from_obj_for_encoding(data["local-state-schema"]) : void 0
    });
  }
};
var ApplicationResponse = class extends BaseModel {
  /**
   * Creates a new `ApplicationResponse` object.
   * @param currentRound - Round at which the results were computed.
   * @param application - Application index and its parameters
   */
  constructor({ currentRound, application }) {
    super();
    this.currentRound = currentRound;
    this.application = application;
    this.attribute_map = {
      currentRound: "current-round",
      application: "application"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new ApplicationResponse({
      currentRound: data["current-round"],
      application: typeof data["application"] !== "undefined" ? Application2.from_obj_for_encoding(data["application"]) : void 0
    });
  }
};
var ApplicationStateSchema2 = class extends BaseModel {
  /**
   * Creates a new `ApplicationStateSchema` object.
   * @param numByteSlice - (nbs) num of byte slices.
   * @param numUint - (nui) num of uints.
   */
  constructor({ numByteSlice, numUint }) {
    super();
    this.numByteSlice = numByteSlice;
    this.numUint = numUint;
    this.attribute_map = {
      numByteSlice: "num-byte-slice",
      numUint: "num-uint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["num-byte-slice"] === "undefined")
      throw new Error(`Response is missing required field 'num-byte-slice': ${data}`);
    if (typeof data["num-uint"] === "undefined")
      throw new Error(`Response is missing required field 'num-uint': ${data}`);
    return new ApplicationStateSchema2({
      numByteSlice: data["num-byte-slice"],
      numUint: data["num-uint"]
    });
  }
};
var ApplicationsResponse = class extends BaseModel {
  /**
   * Creates a new `ApplicationsResponse` object.
   * @param applications -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ applications, currentRound, nextToken }) {
    super();
    this.applications = applications;
    this.currentRound = currentRound;
    this.nextToken = nextToken;
    this.attribute_map = {
      applications: "applications",
      currentRound: "current-round",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["applications"]))
      throw new Error(`Response is missing required array field 'applications': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new ApplicationsResponse({
      applications: data["applications"].map(Application2.from_obj_for_encoding),
      currentRound: data["current-round"],
      nextToken: data["next-token"]
    });
  }
};
var Asset2 = class extends BaseModel {
  /**
   * Creates a new `Asset` object.
   * @param index - unique asset identifier
   * @param params - AssetParams specifies the parameters for an asset.
   * (apar) when part of an AssetConfig transaction.
   * Definition:
   * data/transactions/asset.go : AssetParams
   * @param createdAtRound - Round during which this asset was created.
   * @param deleted - Whether or not this asset is currently deleted.
   * @param destroyedAtRound - Round during which this asset was destroyed.
   */
  constructor({ index: index2, params, createdAtRound, deleted, destroyedAtRound }) {
    super();
    this.index = index2;
    this.params = params;
    this.createdAtRound = createdAtRound;
    this.deleted = deleted;
    this.destroyedAtRound = destroyedAtRound;
    this.attribute_map = {
      index: "index",
      params: "params",
      createdAtRound: "created-at-round",
      deleted: "deleted",
      destroyedAtRound: "destroyed-at-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["index"] === "undefined")
      throw new Error(`Response is missing required field 'index': ${data}`);
    if (typeof data["params"] === "undefined")
      throw new Error(`Response is missing required field 'params': ${data}`);
    return new Asset2({
      index: data["index"],
      params: AssetParams2.from_obj_for_encoding(data["params"]),
      createdAtRound: data["created-at-round"],
      deleted: data["deleted"],
      destroyedAtRound: data["destroyed-at-round"]
    });
  }
};
var AssetBalancesResponse = class extends BaseModel {
  /**
   * Creates a new `AssetBalancesResponse` object.
   * @param balances -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ balances, currentRound, nextToken }) {
    super();
    this.balances = balances;
    this.currentRound = currentRound;
    this.nextToken = nextToken;
    this.attribute_map = {
      balances: "balances",
      currentRound: "current-round",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["balances"]))
      throw new Error(`Response is missing required array field 'balances': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new AssetBalancesResponse({
      balances: data["balances"].map(MiniAssetHolding.from_obj_for_encoding),
      currentRound: data["current-round"],
      nextToken: data["next-token"]
    });
  }
};
var AssetHolding2 = class extends BaseModel {
  /**
   * Creates a new `AssetHolding` object.
   * @param amount - (a) number of units held.
   * @param assetId - Asset ID of the holding.
   * @param isFrozen - (f) whether or not the holding is frozen.
   * @param deleted - Whether or not the asset holding is currently deleted from its account.
   * @param optedInAtRound - Round during which the account opted into this asset holding.
   * @param optedOutAtRound - Round during which the account opted out of this asset holding.
   */
  constructor({ amount, assetId, isFrozen, deleted, optedInAtRound, optedOutAtRound }) {
    super();
    this.amount = amount;
    this.assetId = assetId;
    this.isFrozen = isFrozen;
    this.deleted = deleted;
    this.optedInAtRound = optedInAtRound;
    this.optedOutAtRound = optedOutAtRound;
    this.attribute_map = {
      amount: "amount",
      assetId: "asset-id",
      isFrozen: "is-frozen",
      deleted: "deleted",
      optedInAtRound: "opted-in-at-round",
      optedOutAtRound: "opted-out-at-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["asset-id"] === "undefined")
      throw new Error(`Response is missing required field 'asset-id': ${data}`);
    if (typeof data["is-frozen"] === "undefined")
      throw new Error(`Response is missing required field 'is-frozen': ${data}`);
    return new AssetHolding2({
      amount: data["amount"],
      assetId: data["asset-id"],
      isFrozen: data["is-frozen"],
      deleted: data["deleted"],
      optedInAtRound: data["opted-in-at-round"],
      optedOutAtRound: data["opted-out-at-round"]
    });
  }
};
var AssetHoldingsResponse = class extends BaseModel {
  /**
   * Creates a new `AssetHoldingsResponse` object.
   * @param assets -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ assets, currentRound, nextToken }) {
    super();
    this.assets = assets;
    this.currentRound = currentRound;
    this.nextToken = nextToken;
    this.attribute_map = {
      assets: "assets",
      currentRound: "current-round",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["assets"]))
      throw new Error(`Response is missing required array field 'assets': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new AssetHoldingsResponse({
      assets: data["assets"].map(AssetHolding2.from_obj_for_encoding),
      currentRound: data["current-round"],
      nextToken: data["next-token"]
    });
  }
};
var AssetParams2 = class extends BaseModel {
  /**
   * Creates a new `AssetParams` object.
   * @param creator - The address that created this asset. This is the address where the parameters
   * for this asset can be found, and also the address where unwanted asset units can
   * be sent in the worst case.
   * @param decimals - (dc) The number of digits to use after the decimal point when displaying this
   * asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in
   * tenths. If 2, the base unit of the asset is in hundredths, and so on. This value
   * must be between 0 and 19 (inclusive).
   * @param total - (t) The total number of units of this asset.
   * @param clawback - (c) Address of account used to clawback holdings of this asset. If empty,
   * clawback is not permitted.
   * @param defaultFrozen - (df) Whether holdings of this asset are frozen by default.
   * @param freeze - (f) Address of account used to freeze holdings of this asset. If empty, freezing
   * is not permitted.
   * @param manager - (m) Address of account used to manage the keys of this asset and to destroy it.
   * @param metadataHash - (am) A commitment to some unspecified asset metadata. The format of this
   * metadata is up to the application.
   * @param name - (an) Name of this asset, as supplied by the creator. Included only when the
   * asset name is composed of printable utf-8 characters.
   * @param nameB64 - Base64 encoded name of this asset, as supplied by the creator.
   * @param reserve - (r) Address of account holding reserve (non-minted) units of this asset.
   * @param unitName - (un) Name of a unit of this asset, as supplied by the creator. Included only
   * when the name of a unit of this asset is composed of printable utf-8 characters.
   * @param unitNameB64 - Base64 encoded name of a unit of this asset, as supplied by the creator.
   * @param url - (au) URL where more information about the asset can be retrieved. Included only
   * when the URL is composed of printable utf-8 characters.
   * @param urlB64 - Base64 encoded URL where more information about the asset can be retrieved.
   */
  constructor({ creator, decimals, total, clawback, defaultFrozen, freeze, manager, metadataHash, name: name9, nameB64, reserve, unitName, unitNameB64, url: url2, urlB64 }) {
    super();
    this.creator = creator;
    this.decimals = decimals;
    this.total = total;
    this.clawback = clawback;
    this.defaultFrozen = defaultFrozen;
    this.freeze = freeze;
    this.manager = manager;
    this.metadataHash = typeof metadataHash === "string" ? new Uint8Array(Buffer.from(metadataHash, "base64")) : metadataHash;
    this.name = name9;
    this.nameB64 = typeof nameB64 === "string" ? new Uint8Array(Buffer.from(nameB64, "base64")) : nameB64;
    this.reserve = reserve;
    this.unitName = unitName;
    this.unitNameB64 = typeof unitNameB64 === "string" ? new Uint8Array(Buffer.from(unitNameB64, "base64")) : unitNameB64;
    this.url = url2;
    this.urlB64 = typeof urlB64 === "string" ? new Uint8Array(Buffer.from(urlB64, "base64")) : urlB64;
    this.attribute_map = {
      creator: "creator",
      decimals: "decimals",
      total: "total",
      clawback: "clawback",
      defaultFrozen: "default-frozen",
      freeze: "freeze",
      manager: "manager",
      metadataHash: "metadata-hash",
      name: "name",
      nameB64: "name-b64",
      reserve: "reserve",
      unitName: "unit-name",
      unitNameB64: "unit-name-b64",
      url: "url",
      urlB64: "url-b64"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["creator"] === "undefined")
      throw new Error(`Response is missing required field 'creator': ${data}`);
    if (typeof data["decimals"] === "undefined")
      throw new Error(`Response is missing required field 'decimals': ${data}`);
    if (typeof data["total"] === "undefined")
      throw new Error(`Response is missing required field 'total': ${data}`);
    return new AssetParams2({
      creator: data["creator"],
      decimals: data["decimals"],
      total: data["total"],
      clawback: data["clawback"],
      defaultFrozen: data["default-frozen"],
      freeze: data["freeze"],
      manager: data["manager"],
      metadataHash: data["metadata-hash"],
      name: data["name"],
      nameB64: data["name-b64"],
      reserve: data["reserve"],
      unitName: data["unit-name"],
      unitNameB64: data["unit-name-b64"],
      url: data["url"],
      urlB64: data["url-b64"]
    });
  }
};
var AssetResponse = class extends BaseModel {
  /**
   * Creates a new `AssetResponse` object.
   * @param asset - Specifies both the unique identifier and the parameters for an asset
   * @param currentRound - Round at which the results were computed.
   */
  constructor({ asset, currentRound }) {
    super();
    this.asset = asset;
    this.currentRound = currentRound;
    this.attribute_map = {
      asset: "asset",
      currentRound: "current-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["asset"] === "undefined")
      throw new Error(`Response is missing required field 'asset': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new AssetResponse({
      asset: Asset2.from_obj_for_encoding(data["asset"]),
      currentRound: data["current-round"]
    });
  }
};
var AssetsResponse = class extends BaseModel {
  /**
   * Creates a new `AssetsResponse` object.
   * @param assets -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ assets, currentRound, nextToken }) {
    super();
    this.assets = assets;
    this.currentRound = currentRound;
    this.nextToken = nextToken;
    this.attribute_map = {
      assets: "assets",
      currentRound: "current-round",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["assets"]))
      throw new Error(`Response is missing required array field 'assets': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new AssetsResponse({
      assets: data["assets"].map(Asset2.from_obj_for_encoding),
      currentRound: data["current-round"],
      nextToken: data["next-token"]
    });
  }
};
var Block2 = class extends BaseModel {
  /**
   * Creates a new `Block` object.
   * @param genesisHash - (gh) hash to which this block belongs.
   * @param genesisId - (gen) ID to which this block belongs.
   * @param previousBlockHash - (prev) Previous block hash.
   * @param round - (rnd) Current round on which this block was appended to the chain.
   * @param seed - (seed) Sortition seed.
   * @param timestamp - (ts) Block creation timestamp in seconds since eposh
   * @param transactionsRoot - (txn) TransactionsRoot authenticates the set of transactions appearing in the
   * block. More specifically, it's the root of a merkle tree whose leaves are the
   * block's Txids, in lexicographic order. For the empty block, it's 0. Note that
   * the TxnRoot does not authenticate the signatures on the transactions, only the
   * transactions themselves. Two blocks with the same transactions but in a
   * different order and with different signatures will have the same TxnRoot.
   * @param transactionsRootSha256 - (txn256) TransactionsRootSHA256 is an auxiliary TransactionRoot, built using a
   * vector commitment instead of a merkle tree, and SHA256 hash function instead of
   * the default SHA512_256. This commitment can be used on environments where only
   * the SHA256 function exists.
   * @param participationUpdates - Participation account data that needs to be checked/acted on by the network.
   * @param rewards - Fields relating to rewards,
   * @param stateProofTracking - Tracks the status of state proofs.
   * @param transactions - (txns) list of transactions corresponding to a given round.
   * @param txnCounter - (tc) TxnCounter counts the number of transactions committed in the ledger, from
   * the time at which support for this feature was introduced.
   * Specifically, TxnCounter is the number of the next transaction that will be
   * committed after this block. It is 0 when no transactions have ever been
   * committed (since TxnCounter started being supported).
   * @param upgradeState - Fields relating to a protocol upgrade.
   * @param upgradeVote - Fields relating to voting for a protocol upgrade.
   */
  constructor({ genesisHash, genesisId, previousBlockHash, round, seed: seed2, timestamp, transactionsRoot, transactionsRootSha256, participationUpdates, rewards, stateProofTracking, transactions, txnCounter, upgradeState, upgradeVote }) {
    super();
    this.genesisHash = typeof genesisHash === "string" ? new Uint8Array(Buffer.from(genesisHash, "base64")) : genesisHash;
    this.genesisId = genesisId;
    this.previousBlockHash = typeof previousBlockHash === "string" ? new Uint8Array(Buffer.from(previousBlockHash, "base64")) : previousBlockHash;
    this.round = round;
    this.seed = typeof seed2 === "string" ? new Uint8Array(Buffer.from(seed2, "base64")) : seed2;
    this.timestamp = timestamp;
    this.transactionsRoot = typeof transactionsRoot === "string" ? new Uint8Array(Buffer.from(transactionsRoot, "base64")) : transactionsRoot;
    this.transactionsRootSha256 = typeof transactionsRootSha256 === "string" ? new Uint8Array(Buffer.from(transactionsRootSha256, "base64")) : transactionsRootSha256;
    this.participationUpdates = participationUpdates;
    this.rewards = rewards;
    this.stateProofTracking = stateProofTracking;
    this.transactions = transactions;
    this.txnCounter = txnCounter;
    this.upgradeState = upgradeState;
    this.upgradeVote = upgradeVote;
    this.attribute_map = {
      genesisHash: "genesis-hash",
      genesisId: "genesis-id",
      previousBlockHash: "previous-block-hash",
      round: "round",
      seed: "seed",
      timestamp: "timestamp",
      transactionsRoot: "transactions-root",
      transactionsRootSha256: "transactions-root-sha256",
      participationUpdates: "participation-updates",
      rewards: "rewards",
      stateProofTracking: "state-proof-tracking",
      transactions: "transactions",
      txnCounter: "txn-counter",
      upgradeState: "upgrade-state",
      upgradeVote: "upgrade-vote"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["genesis-hash"] === "undefined")
      throw new Error(`Response is missing required field 'genesis-hash': ${data}`);
    if (typeof data["genesis-id"] === "undefined")
      throw new Error(`Response is missing required field 'genesis-id': ${data}`);
    if (typeof data["previous-block-hash"] === "undefined")
      throw new Error(`Response is missing required field 'previous-block-hash': ${data}`);
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    if (typeof data["seed"] === "undefined")
      throw new Error(`Response is missing required field 'seed': ${data}`);
    if (typeof data["timestamp"] === "undefined")
      throw new Error(`Response is missing required field 'timestamp': ${data}`);
    if (typeof data["transactions-root"] === "undefined")
      throw new Error(`Response is missing required field 'transactions-root': ${data}`);
    if (typeof data["transactions-root-sha256"] === "undefined")
      throw new Error(`Response is missing required field 'transactions-root-sha256': ${data}`);
    return new Block2({
      genesisHash: data["genesis-hash"],
      genesisId: data["genesis-id"],
      previousBlockHash: data["previous-block-hash"],
      round: data["round"],
      seed: data["seed"],
      timestamp: data["timestamp"],
      transactionsRoot: data["transactions-root"],
      transactionsRootSha256: data["transactions-root-sha256"],
      participationUpdates: typeof data["participation-updates"] !== "undefined" ? ParticipationUpdates.from_obj_for_encoding(data["participation-updates"]) : void 0,
      rewards: typeof data["rewards"] !== "undefined" ? BlockRewards.from_obj_for_encoding(data["rewards"]) : void 0,
      stateProofTracking: typeof data["state-proof-tracking"] !== "undefined" ? data["state-proof-tracking"].map(StateProofTracking.from_obj_for_encoding) : void 0,
      transactions: typeof data["transactions"] !== "undefined" ? data["transactions"].map(Transaction2.from_obj_for_encoding) : void 0,
      txnCounter: data["txn-counter"],
      upgradeState: typeof data["upgrade-state"] !== "undefined" ? BlockUpgradeState.from_obj_for_encoding(data["upgrade-state"]) : void 0,
      upgradeVote: typeof data["upgrade-vote"] !== "undefined" ? BlockUpgradeVote.from_obj_for_encoding(data["upgrade-vote"]) : void 0
    });
  }
};
var BlockRewards = class extends BaseModel {
  /**
   * Creates a new `BlockRewards` object.
   * @param feeSink - (fees) accepts transaction fees, it can only spend to the incentive pool.
   * @param rewardsCalculationRound - (rwcalr) number of leftover MicroAlgos after the distribution of rewards-rate
   * MicroAlgos for every reward unit in the next round.
   * @param rewardsLevel - (earn) How many rewards, in MicroAlgos, have been distributed to each RewardUnit
   * of MicroAlgos since genesis.
   * @param rewardsPool - (rwd) accepts periodic injections from the fee-sink and continually
   * redistributes them as rewards.
   * @param rewardsRate - (rate) Number of new MicroAlgos added to the participation stake from rewards at
   * the next round.
   * @param rewardsResidue - (frac) Number of leftover MicroAlgos after the distribution of
   * RewardsRate/rewardUnits MicroAlgos for every reward unit in the next round.
   */
  constructor({ feeSink, rewardsCalculationRound, rewardsLevel, rewardsPool, rewardsRate, rewardsResidue }) {
    super();
    this.feeSink = feeSink;
    this.rewardsCalculationRound = rewardsCalculationRound;
    this.rewardsLevel = rewardsLevel;
    this.rewardsPool = rewardsPool;
    this.rewardsRate = rewardsRate;
    this.rewardsResidue = rewardsResidue;
    this.attribute_map = {
      feeSink: "fee-sink",
      rewardsCalculationRound: "rewards-calculation-round",
      rewardsLevel: "rewards-level",
      rewardsPool: "rewards-pool",
      rewardsRate: "rewards-rate",
      rewardsResidue: "rewards-residue"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["fee-sink"] === "undefined")
      throw new Error(`Response is missing required field 'fee-sink': ${data}`);
    if (typeof data["rewards-calculation-round"] === "undefined")
      throw new Error(`Response is missing required field 'rewards-calculation-round': ${data}`);
    if (typeof data["rewards-level"] === "undefined")
      throw new Error(`Response is missing required field 'rewards-level': ${data}`);
    if (typeof data["rewards-pool"] === "undefined")
      throw new Error(`Response is missing required field 'rewards-pool': ${data}`);
    if (typeof data["rewards-rate"] === "undefined")
      throw new Error(`Response is missing required field 'rewards-rate': ${data}`);
    if (typeof data["rewards-residue"] === "undefined")
      throw new Error(`Response is missing required field 'rewards-residue': ${data}`);
    return new BlockRewards({
      feeSink: data["fee-sink"],
      rewardsCalculationRound: data["rewards-calculation-round"],
      rewardsLevel: data["rewards-level"],
      rewardsPool: data["rewards-pool"],
      rewardsRate: data["rewards-rate"],
      rewardsResidue: data["rewards-residue"]
    });
  }
};
var BlockUpgradeState = class extends BaseModel {
  /**
   * Creates a new `BlockUpgradeState` object.
   * @param currentProtocol - (proto) The current protocol version.
   * @param nextProtocol - (nextproto) The next proposed protocol version.
   * @param nextProtocolApprovals - (nextyes) Number of blocks which approved the protocol upgrade.
   * @param nextProtocolSwitchOn - (nextswitch) Round on which the protocol upgrade will take effect.
   * @param nextProtocolVoteBefore - (nextbefore) Deadline round for this protocol upgrade (No votes will be consider
   * after this round).
   */
  constructor({ currentProtocol, nextProtocol, nextProtocolApprovals, nextProtocolSwitchOn, nextProtocolVoteBefore }) {
    super();
    this.currentProtocol = currentProtocol;
    this.nextProtocol = nextProtocol;
    this.nextProtocolApprovals = nextProtocolApprovals;
    this.nextProtocolSwitchOn = nextProtocolSwitchOn;
    this.nextProtocolVoteBefore = nextProtocolVoteBefore;
    this.attribute_map = {
      currentProtocol: "current-protocol",
      nextProtocol: "next-protocol",
      nextProtocolApprovals: "next-protocol-approvals",
      nextProtocolSwitchOn: "next-protocol-switch-on",
      nextProtocolVoteBefore: "next-protocol-vote-before"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["current-protocol"] === "undefined")
      throw new Error(`Response is missing required field 'current-protocol': ${data}`);
    return new BlockUpgradeState({
      currentProtocol: data["current-protocol"],
      nextProtocol: data["next-protocol"],
      nextProtocolApprovals: data["next-protocol-approvals"],
      nextProtocolSwitchOn: data["next-protocol-switch-on"],
      nextProtocolVoteBefore: data["next-protocol-vote-before"]
    });
  }
};
var BlockUpgradeVote = class extends BaseModel {
  /**
   * Creates a new `BlockUpgradeVote` object.
   * @param upgradeApprove - (upgradeyes) Indicates a yes vote for the current proposal.
   * @param upgradeDelay - (upgradedelay) Indicates the time between acceptance and execution.
   * @param upgradePropose - (upgradeprop) Indicates a proposed upgrade.
   */
  constructor({ upgradeApprove, upgradeDelay, upgradePropose }) {
    super();
    this.upgradeApprove = upgradeApprove;
    this.upgradeDelay = upgradeDelay;
    this.upgradePropose = upgradePropose;
    this.attribute_map = {
      upgradeApprove: "upgrade-approve",
      upgradeDelay: "upgrade-delay",
      upgradePropose: "upgrade-propose"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new BlockUpgradeVote({
      upgradeApprove: data["upgrade-approve"],
      upgradeDelay: data["upgrade-delay"],
      upgradePropose: data["upgrade-propose"]
    });
  }
};
var Box2 = class extends BaseModel {
  /**
   * Creates a new `Box` object.
   * @param name - (name) box name, base64 encoded
   * @param value - (value) box value, base64 encoded.
   */
  constructor({ name: name9, value: value2 }) {
    super();
    this.name = typeof name9 === "string" ? new Uint8Array(Buffer.from(name9, "base64")) : name9;
    this.value = typeof value2 === "string" ? new Uint8Array(Buffer.from(value2, "base64")) : value2;
    this.attribute_map = {
      name: "name",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["name"] === "undefined")
      throw new Error(`Response is missing required field 'name': ${data}`);
    if (typeof data["value"] === "undefined")
      throw new Error(`Response is missing required field 'value': ${data}`);
    return new Box2({
      name: data["name"],
      value: data["value"]
    });
  }
};
var BoxDescriptor2 = class extends BaseModel {
  /**
   * Creates a new `BoxDescriptor` object.
   * @param name - Base64 encoded box name
   */
  constructor({ name: name9 }) {
    super();
    this.name = typeof name9 === "string" ? new Uint8Array(Buffer.from(name9, "base64")) : name9;
    this.attribute_map = {
      name: "name"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["name"] === "undefined")
      throw new Error(`Response is missing required field 'name': ${data}`);
    return new BoxDescriptor2({
      name: data["name"]
    });
  }
};
var BoxesResponse2 = class extends BaseModel {
  /**
   * Creates a new `BoxesResponse` object.
   * @param applicationId - (appidx) application index.
   * @param boxes -
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ applicationId, boxes, nextToken }) {
    super();
    this.applicationId = applicationId;
    this.boxes = boxes;
    this.nextToken = nextToken;
    this.attribute_map = {
      applicationId: "application-id",
      boxes: "boxes",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["application-id"] === "undefined")
      throw new Error(`Response is missing required field 'application-id': ${data}`);
    if (!Array.isArray(data["boxes"]))
      throw new Error(`Response is missing required array field 'boxes': ${data}`);
    return new BoxesResponse2({
      applicationId: data["application-id"],
      boxes: data["boxes"].map(BoxDescriptor2.from_obj_for_encoding),
      nextToken: data["next-token"]
    });
  }
};
var ErrorResponse2 = class extends BaseModel {
  /**
   * Creates a new `ErrorResponse` object.
   * @param message -
   * @param data -
   */
  constructor({ message: message2, data }) {
    super();
    this.message = message2;
    this.data = data;
    this.attribute_map = {
      message: "message",
      data: "data"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["message"] === "undefined")
      throw new Error(`Response is missing required field 'message': ${data}`);
    return new ErrorResponse2({
      message: data["message"],
      data: data["data"]
    });
  }
};
var EvalDelta2 = class extends BaseModel {
  /**
   * Creates a new `EvalDelta` object.
   * @param action - (at) delta action.
   * @param bytes - (bs) bytes value.
   * @param uint - (ui) uint value.
   */
  constructor({ action, bytes, uint }) {
    super();
    this.action = action;
    this.bytes = bytes;
    this.uint = uint;
    this.attribute_map = {
      action: "action",
      bytes: "bytes",
      uint: "uint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["action"] === "undefined")
      throw new Error(`Response is missing required field 'action': ${data}`);
    return new EvalDelta2({
      action: data["action"],
      bytes: data["bytes"],
      uint: data["uint"]
    });
  }
};
var EvalDeltaKeyValue2 = class extends BaseModel {
  /**
   * Creates a new `EvalDeltaKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value delta.
   */
  constructor({ key, value: value2 }) {
    super();
    this.key = key;
    this.value = value2;
    this.attribute_map = {
      key: "key",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["key"] === "undefined")
      throw new Error(`Response is missing required field 'key': ${data}`);
    if (typeof data["value"] === "undefined")
      throw new Error(`Response is missing required field 'value': ${data}`);
    return new EvalDeltaKeyValue2({
      key: data["key"],
      value: EvalDelta2.from_obj_for_encoding(data["value"])
    });
  }
};
var HashFactory = class extends BaseModel {
  /**
   * Creates a new `HashFactory` object.
   * @param hashType - (t)
   */
  constructor({ hashType }) {
    super();
    this.hashType = hashType;
    this.attribute_map = {
      hashType: "hash-type"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new HashFactory({
      hashType: data["hash-type"]
    });
  }
};
var HealthCheck2 = class extends BaseModel {
  /**
   * Creates a new `HealthCheck` object.
   * @param dbAvailable -
   * @param isMigrating -
   * @param message -
   * @param round -
   * @param version - Current version.
   * @param data -
   * @param errors -
   */
  constructor({ dbAvailable, isMigrating, message: message2, round, version: version3, data, errors: errors2 }) {
    super();
    this.dbAvailable = dbAvailable;
    this.isMigrating = isMigrating;
    this.message = message2;
    this.round = round;
    this.version = version3;
    this.data = data;
    this.errors = errors2;
    this.attribute_map = {
      dbAvailable: "db-available",
      isMigrating: "is-migrating",
      message: "message",
      round: "round",
      version: "version",
      data: "data",
      errors: "errors"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["db-available"] === "undefined")
      throw new Error(`Response is missing required field 'db-available': ${data}`);
    if (typeof data["is-migrating"] === "undefined")
      throw new Error(`Response is missing required field 'is-migrating': ${data}`);
    if (typeof data["message"] === "undefined")
      throw new Error(`Response is missing required field 'message': ${data}`);
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    if (typeof data["version"] === "undefined")
      throw new Error(`Response is missing required field 'version': ${data}`);
    return new HealthCheck2({
      dbAvailable: data["db-available"],
      isMigrating: data["is-migrating"],
      message: data["message"],
      round: data["round"],
      version: data["version"],
      data: data["data"],
      errors: data["errors"]
    });
  }
};
var IndexerStateProofMessage = class extends BaseModel {
  /**
   * Creates a new `IndexerStateProofMessage` object.
   * @param blockHeadersCommitment - (b)
   * @param firstAttestedRound - (f)
   * @param latestAttestedRound - (l)
   * @param lnProvenWeight - (P)
   * @param votersCommitment - (v)
   */
  constructor({ blockHeadersCommitment, firstAttestedRound, latestAttestedRound, lnProvenWeight, votersCommitment }) {
    super();
    this.blockHeadersCommitment = typeof blockHeadersCommitment === "string" ? new Uint8Array(Buffer.from(blockHeadersCommitment, "base64")) : blockHeadersCommitment;
    this.firstAttestedRound = firstAttestedRound;
    this.latestAttestedRound = latestAttestedRound;
    this.lnProvenWeight = lnProvenWeight;
    this.votersCommitment = typeof votersCommitment === "string" ? new Uint8Array(Buffer.from(votersCommitment, "base64")) : votersCommitment;
    this.attribute_map = {
      blockHeadersCommitment: "block-headers-commitment",
      firstAttestedRound: "first-attested-round",
      latestAttestedRound: "latest-attested-round",
      lnProvenWeight: "ln-proven-weight",
      votersCommitment: "voters-commitment"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new IndexerStateProofMessage({
      blockHeadersCommitment: data["block-headers-commitment"],
      firstAttestedRound: data["first-attested-round"],
      latestAttestedRound: data["latest-attested-round"],
      lnProvenWeight: data["ln-proven-weight"],
      votersCommitment: data["voters-commitment"]
    });
  }
};
var MerkleArrayProof = class extends BaseModel {
  /**
   * Creates a new `MerkleArrayProof` object.
   * @param hashFactory -
   * @param path - (pth)
   * @param treeDepth - (td)
   */
  constructor({ hashFactory, path: path2, treeDepth }) {
    super();
    this.hashFactory = hashFactory;
    this.path = path2;
    this.treeDepth = treeDepth;
    this.attribute_map = {
      hashFactory: "hash-factory",
      path: "path",
      treeDepth: "tree-depth"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new MerkleArrayProof({
      hashFactory: typeof data["hash-factory"] !== "undefined" ? HashFactory.from_obj_for_encoding(data["hash-factory"]) : void 0,
      path: data["path"],
      treeDepth: data["tree-depth"]
    });
  }
};
var MiniAssetHolding = class extends BaseModel {
  /**
   * Creates a new `MiniAssetHolding` object.
   * @param address -
   * @param amount -
   * @param isFrozen -
   * @param deleted - Whether or not this asset holding is currently deleted from its account.
   * @param optedInAtRound - Round during which the account opted into the asset.
   * @param optedOutAtRound - Round during which the account opted out of the asset.
   */
  constructor({ address, amount, isFrozen, deleted, optedInAtRound, optedOutAtRound }) {
    super();
    this.address = address;
    this.amount = amount;
    this.isFrozen = isFrozen;
    this.deleted = deleted;
    this.optedInAtRound = optedInAtRound;
    this.optedOutAtRound = optedOutAtRound;
    this.attribute_map = {
      address: "address",
      amount: "amount",
      isFrozen: "is-frozen",
      deleted: "deleted",
      optedInAtRound: "opted-in-at-round",
      optedOutAtRound: "opted-out-at-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["address"] === "undefined")
      throw new Error(`Response is missing required field 'address': ${data}`);
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["is-frozen"] === "undefined")
      throw new Error(`Response is missing required field 'is-frozen': ${data}`);
    return new MiniAssetHolding({
      address: data["address"],
      amount: data["amount"],
      isFrozen: data["is-frozen"],
      deleted: data["deleted"],
      optedInAtRound: data["opted-in-at-round"],
      optedOutAtRound: data["opted-out-at-round"]
    });
  }
};
var ParticipationUpdates = class extends BaseModel {
  /**
   * Creates a new `ParticipationUpdates` object.
   * @param expiredParticipationAccounts - (partupdrmv) a list of online accounts that needs to be converted to offline
   * since their participation key expired.
   */
  constructor({ expiredParticipationAccounts }) {
    super();
    this.expiredParticipationAccounts = expiredParticipationAccounts;
    this.attribute_map = {
      expiredParticipationAccounts: "expired-participation-accounts"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new ParticipationUpdates({
      expiredParticipationAccounts: data["expired-participation-accounts"]
    });
  }
};
var StateProofFields = class extends BaseModel {
  /**
   * Creates a new `StateProofFields` object.
   * @param partProofs - (P)
   * @param positionsToReveal - (pr) Sequence of reveal positions.
   * @param reveals - (r) Note that this is actually stored as a map[uint64] - Reveal in the actual
   * msgp
   * @param saltVersion - (v) Salt version of the merkle signature.
   * @param sigCommit - (c)
   * @param sigProofs - (S)
   * @param signedWeight - (w)
   */
  constructor({ partProofs, positionsToReveal, reveals, saltVersion, sigCommit, sigProofs, signedWeight }) {
    super();
    this.partProofs = partProofs;
    this.positionsToReveal = positionsToReveal;
    this.reveals = reveals;
    this.saltVersion = saltVersion;
    this.sigCommit = typeof sigCommit === "string" ? new Uint8Array(Buffer.from(sigCommit, "base64")) : sigCommit;
    this.sigProofs = sigProofs;
    this.signedWeight = signedWeight;
    this.attribute_map = {
      partProofs: "part-proofs",
      positionsToReveal: "positions-to-reveal",
      reveals: "reveals",
      saltVersion: "salt-version",
      sigCommit: "sig-commit",
      sigProofs: "sig-proofs",
      signedWeight: "signed-weight"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofFields({
      partProofs: typeof data["part-proofs"] !== "undefined" ? MerkleArrayProof.from_obj_for_encoding(data["part-proofs"]) : void 0,
      positionsToReveal: data["positions-to-reveal"],
      reveals: typeof data["reveals"] !== "undefined" ? data["reveals"].map(StateProofReveal.from_obj_for_encoding) : void 0,
      saltVersion: data["salt-version"],
      sigCommit: data["sig-commit"],
      sigProofs: typeof data["sig-proofs"] !== "undefined" ? MerkleArrayProof.from_obj_for_encoding(data["sig-proofs"]) : void 0,
      signedWeight: data["signed-weight"]
    });
  }
};
var StateProofParticipant = class extends BaseModel {
  /**
   * Creates a new `StateProofParticipant` object.
   * @param verifier - (p)
   * @param weight - (w)
   */
  constructor({ verifier, weight }) {
    super();
    this.verifier = verifier;
    this.weight = weight;
    this.attribute_map = {
      verifier: "verifier",
      weight: "weight"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofParticipant({
      verifier: typeof data["verifier"] !== "undefined" ? StateProofVerifier.from_obj_for_encoding(data["verifier"]) : void 0,
      weight: data["weight"]
    });
  }
};
var StateProofReveal = class extends BaseModel {
  /**
   * Creates a new `StateProofReveal` object.
   * @param participant - (p)
   * @param position - The position in the signature and participants arrays corresponding to this
   * entry.
   * @param sigSlot - (s)
   */
  constructor({ participant, position, sigSlot }) {
    super();
    this.participant = participant;
    this.position = position;
    this.sigSlot = sigSlot;
    this.attribute_map = {
      participant: "participant",
      position: "position",
      sigSlot: "sig-slot"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofReveal({
      participant: typeof data["participant"] !== "undefined" ? StateProofParticipant.from_obj_for_encoding(data["participant"]) : void 0,
      position: data["position"],
      sigSlot: typeof data["sig-slot"] !== "undefined" ? StateProofSigSlot.from_obj_for_encoding(data["sig-slot"]) : void 0
    });
  }
};
var StateProofSigSlot = class extends BaseModel {
  /**
   * Creates a new `StateProofSigSlot` object.
   * @param lowerSigWeight - (l) The total weight of signatures in the lower-numbered slots.
   * @param signature -
   */
  constructor({ lowerSigWeight, signature }) {
    super();
    this.lowerSigWeight = lowerSigWeight;
    this.signature = signature;
    this.attribute_map = {
      lowerSigWeight: "lower-sig-weight",
      signature: "signature"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofSigSlot({
      lowerSigWeight: data["lower-sig-weight"],
      signature: typeof data["signature"] !== "undefined" ? StateProofSignature.from_obj_for_encoding(data["signature"]) : void 0
    });
  }
};
var StateProofSignature = class extends BaseModel {
  /**
   * Creates a new `StateProofSignature` object.
   * @param falconSignature -
   * @param merkleArrayIndex -
   * @param proof -
   * @param verifyingKey - (vkey)
   */
  constructor({ falconSignature, merkleArrayIndex, proof, verifyingKey }) {
    super();
    this.falconSignature = typeof falconSignature === "string" ? new Uint8Array(Buffer.from(falconSignature, "base64")) : falconSignature;
    this.merkleArrayIndex = merkleArrayIndex;
    this.proof = proof;
    this.verifyingKey = typeof verifyingKey === "string" ? new Uint8Array(Buffer.from(verifyingKey, "base64")) : verifyingKey;
    this.attribute_map = {
      falconSignature: "falcon-signature",
      merkleArrayIndex: "merkle-array-index",
      proof: "proof",
      verifyingKey: "verifying-key"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofSignature({
      falconSignature: data["falcon-signature"],
      merkleArrayIndex: data["merkle-array-index"],
      proof: typeof data["proof"] !== "undefined" ? MerkleArrayProof.from_obj_for_encoding(data["proof"]) : void 0,
      verifyingKey: data["verifying-key"]
    });
  }
};
var StateProofTracking = class extends BaseModel {
  /**
   * Creates a new `StateProofTracking` object.
   * @param nextRound - (n) Next round for which we will accept a state proof transaction.
   * @param onlineTotalWeight - (t) The total number of microalgos held by the online accounts during the
   * StateProof round.
   * @param type - State Proof Type. Note the raw object uses map with this as key.
   * @param votersCommitment - (v) Root of a vector commitment containing online accounts that will help sign
   * the proof.
   */
  constructor({ nextRound, onlineTotalWeight, type, votersCommitment }) {
    super();
    this.nextRound = nextRound;
    this.onlineTotalWeight = onlineTotalWeight;
    this.type = type;
    this.votersCommitment = typeof votersCommitment === "string" ? new Uint8Array(Buffer.from(votersCommitment, "base64")) : votersCommitment;
    this.attribute_map = {
      nextRound: "next-round",
      onlineTotalWeight: "online-total-weight",
      type: "type",
      votersCommitment: "voters-commitment"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofTracking({
      nextRound: data["next-round"],
      onlineTotalWeight: data["online-total-weight"],
      type: data["type"],
      votersCommitment: data["voters-commitment"]
    });
  }
};
var StateProofVerifier = class extends BaseModel {
  /**
   * Creates a new `StateProofVerifier` object.
   * @param commitment - (cmt) Represents the root of the vector commitment tree.
   * @param keyLifetime - (lf) Key lifetime.
   */
  constructor({ commitment, keyLifetime }) {
    super();
    this.commitment = typeof commitment === "string" ? new Uint8Array(Buffer.from(commitment, "base64")) : commitment;
    this.keyLifetime = keyLifetime;
    this.attribute_map = {
      commitment: "commitment",
      keyLifetime: "key-lifetime"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofVerifier({
      commitment: data["commitment"],
      keyLifetime: data["key-lifetime"]
    });
  }
};
var StateSchema = class extends BaseModel {
  /**
   * Creates a new `StateSchema` object.
   * @param numByteSlice - Maximum number of TEAL byte slices that may be stored in the key/value store.
   * @param numUint - Maximum number of TEAL uints that may be stored in the key/value store.
   */
  constructor({ numByteSlice, numUint }) {
    super();
    this.numByteSlice = numByteSlice;
    this.numUint = numUint;
    this.attribute_map = {
      numByteSlice: "num-byte-slice",
      numUint: "num-uint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["num-byte-slice"] === "undefined")
      throw new Error(`Response is missing required field 'num-byte-slice': ${data}`);
    if (typeof data["num-uint"] === "undefined")
      throw new Error(`Response is missing required field 'num-uint': ${data}`);
    return new StateSchema({
      numByteSlice: data["num-byte-slice"],
      numUint: data["num-uint"]
    });
  }
};
var TealKeyValue2 = class extends BaseModel {
  /**
   * Creates a new `TealKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value.
   */
  constructor({ key, value: value2 }) {
    super();
    this.key = key;
    this.value = value2;
    this.attribute_map = {
      key: "key",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["key"] === "undefined")
      throw new Error(`Response is missing required field 'key': ${data}`);
    if (typeof data["value"] === "undefined")
      throw new Error(`Response is missing required field 'value': ${data}`);
    return new TealKeyValue2({
      key: data["key"],
      value: TealValue2.from_obj_for_encoding(data["value"])
    });
  }
};
var TealValue2 = class extends BaseModel {
  /**
   * Creates a new `TealValue` object.
   * @param bytes - (tb) bytes value.
   * @param type - (tt) value type. Value `1` refers to **bytes**, value `2` refers to **uint**
   * @param uint - (ui) uint value.
   */
  constructor({ bytes, type, uint }) {
    super();
    this.bytes = bytes;
    this.type = type;
    this.uint = uint;
    this.attribute_map = {
      bytes: "bytes",
      type: "type",
      uint: "uint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["bytes"] === "undefined")
      throw new Error(`Response is missing required field 'bytes': ${data}`);
    if (typeof data["type"] === "undefined")
      throw new Error(`Response is missing required field 'type': ${data}`);
    if (typeof data["uint"] === "undefined")
      throw new Error(`Response is missing required field 'uint': ${data}`);
    return new TealValue2({
      bytes: data["bytes"],
      type: data["type"],
      uint: data["uint"]
    });
  }
};
var Transaction2 = class extends BaseModel {
  /**
   * Creates a new `Transaction` object.
   * @param fee - (fee) Transaction fee.
   * @param firstValid - (fv) First valid round for this transaction.
   * @param lastValid - (lv) Last valid round for this transaction.
   * @param sender - (snd) Sender's address.
   * @param applicationTransaction - Fields for application transactions.
   * Definition:
   * data/transactions/application.go : ApplicationCallTxnFields
   * @param assetConfigTransaction - Fields for asset allocation, re-configuration, and destruction.
   * A zero value for asset-id indicates asset creation.
   * A zero value for the params indicates asset destruction.
   * Definition:
   * data/transactions/asset.go : AssetConfigTxnFields
   * @param assetFreezeTransaction - Fields for an asset freeze transaction.
   * Definition:
   * data/transactions/asset.go : AssetFreezeTxnFields
   * @param assetTransferTransaction - Fields for an asset transfer transaction.
   * Definition:
   * data/transactions/asset.go : AssetTransferTxnFields
   * @param authAddr - (sgnr) this is included with signed transactions when the signing address does
   * not equal the sender. The backend can use this to ensure that auth addr is equal
   * to the accounts auth addr.
   * @param closeRewards - (rc) rewards applied to close-remainder-to account.
   * @param closingAmount - (ca) closing amount for transaction.
   * @param confirmedRound - Round when the transaction was confirmed.
   * @param createdApplicationIndex - Specifies an application index (ID) if an application was created with this
   * transaction.
   * @param createdAssetIndex - Specifies an asset index (ID) if an asset was created with this transaction.
   * @param genesisHash - (gh) Hash of genesis block.
   * @param genesisId - (gen) genesis block ID.
   * @param globalStateDelta - (gd) Global state key/value changes for the application being executed by this
   * transaction.
   * @param group - (grp) Base64 encoded byte array of a sha512/256 digest. When present indicates
   * that this transaction is part of a transaction group and the value is the
   * sha512/256 hash of the transactions in that group.
   * @param id - Transaction ID
   * @param innerTxns - Inner transactions produced by application execution.
   * @param intraRoundOffset - Offset into the round where this transaction was confirmed.
   * @param keyregTransaction - Fields for a keyreg transaction.
   * Definition:
   * data/transactions/keyreg.go : KeyregTxnFields
   * @param lease - (lx) Base64 encoded 32-byte array. Lease enforces mutual exclusion of
   * transactions. If this field is nonzero, then once the transaction is confirmed,
   * it acquires the lease identified by the (Sender, Lease) pair of the transaction
   * until the LastValid round passes. While this transaction possesses the lease, no
   * other transaction specifying this lease can be confirmed.
   * @param localStateDelta - (ld) Local state key/value changes for the application being executed by this
   * transaction.
   * @param logs - (lg) Logs for the application being executed by this transaction.
   * @param note - (note) Free form data.
   * @param paymentTransaction - Fields for a payment transaction.
   * Definition:
   * data/transactions/payment.go : PaymentTxnFields
   * @param receiverRewards - (rr) rewards applied to receiver account.
   * @param rekeyTo - (rekey) when included in a valid transaction, the accounts auth addr will be
   * updated with this value and future signatures must be signed with the key
   * represented by this address.
   * @param roundTime - Time when the block this transaction is in was confirmed.
   * @param senderRewards - (rs) rewards applied to sender account.
   * @param signature - Validation signature associated with some data. Only one of the signatures
   * should be provided.
   * @param stateProofTransaction - Fields for a state proof transaction.
   * Definition:
   * data/transactions/stateproof.go : StateProofTxnFields
   * @param txType - (type) Indicates what type of transaction this is. Different types have
   * different fields.
   * Valid types, and where their fields are stored:
   * * (pay) payment-transaction
   * * (keyreg) keyreg-transaction
   * * (acfg) asset-config-transaction
   * * (axfer) asset-transfer-transaction
   * * (afrz) asset-freeze-transaction
   * * (appl) application-transaction
   * * (stpf) state-proof-transaction
   */
  constructor({ fee, firstValid, lastValid, sender, applicationTransaction, assetConfigTransaction, assetFreezeTransaction, assetTransferTransaction, authAddr, closeRewards, closingAmount, confirmedRound, createdApplicationIndex, createdAssetIndex, genesisHash, genesisId, globalStateDelta, group, id, innerTxns, intraRoundOffset, keyregTransaction, lease, localStateDelta, logs, note, paymentTransaction, receiverRewards, rekeyTo, roundTime, senderRewards, signature, stateProofTransaction, txType }) {
    super();
    this.fee = fee;
    this.firstValid = firstValid;
    this.lastValid = lastValid;
    this.sender = sender;
    this.applicationTransaction = applicationTransaction;
    this.assetConfigTransaction = assetConfigTransaction;
    this.assetFreezeTransaction = assetFreezeTransaction;
    this.assetTransferTransaction = assetTransferTransaction;
    this.authAddr = authAddr;
    this.closeRewards = closeRewards;
    this.closingAmount = closingAmount;
    this.confirmedRound = confirmedRound;
    this.createdApplicationIndex = createdApplicationIndex;
    this.createdAssetIndex = createdAssetIndex;
    this.genesisHash = typeof genesisHash === "string" ? new Uint8Array(Buffer.from(genesisHash, "base64")) : genesisHash;
    this.genesisId = genesisId;
    this.globalStateDelta = globalStateDelta;
    this.group = typeof group === "string" ? new Uint8Array(Buffer.from(group, "base64")) : group;
    this.id = id;
    this.innerTxns = innerTxns;
    this.intraRoundOffset = intraRoundOffset;
    this.keyregTransaction = keyregTransaction;
    this.lease = typeof lease === "string" ? new Uint8Array(Buffer.from(lease, "base64")) : lease;
    this.localStateDelta = localStateDelta;
    this.logs = logs;
    this.note = typeof note === "string" ? new Uint8Array(Buffer.from(note, "base64")) : note;
    this.paymentTransaction = paymentTransaction;
    this.receiverRewards = receiverRewards;
    this.rekeyTo = rekeyTo;
    this.roundTime = roundTime;
    this.senderRewards = senderRewards;
    this.signature = signature;
    this.stateProofTransaction = stateProofTransaction;
    this.txType = txType;
    this.attribute_map = {
      fee: "fee",
      firstValid: "first-valid",
      lastValid: "last-valid",
      sender: "sender",
      applicationTransaction: "application-transaction",
      assetConfigTransaction: "asset-config-transaction",
      assetFreezeTransaction: "asset-freeze-transaction",
      assetTransferTransaction: "asset-transfer-transaction",
      authAddr: "auth-addr",
      closeRewards: "close-rewards",
      closingAmount: "closing-amount",
      confirmedRound: "confirmed-round",
      createdApplicationIndex: "created-application-index",
      createdAssetIndex: "created-asset-index",
      genesisHash: "genesis-hash",
      genesisId: "genesis-id",
      globalStateDelta: "globalThis-state-delta",
      group: "group",
      id: "id",
      innerTxns: "inner-txns",
      intraRoundOffset: "intra-round-offset",
      keyregTransaction: "keyreg-transaction",
      lease: "lease",
      localStateDelta: "local-state-delta",
      logs: "logs",
      note: "note",
      paymentTransaction: "payment-transaction",
      receiverRewards: "receiver-rewards",
      rekeyTo: "rekey-to",
      roundTime: "round-time",
      senderRewards: "sender-rewards",
      signature: "signature",
      stateProofTransaction: "state-proof-transaction",
      txType: "tx-type"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["fee"] === "undefined")
      throw new Error(`Response is missing required field 'fee': ${data}`);
    if (typeof data["first-valid"] === "undefined")
      throw new Error(`Response is missing required field 'first-valid': ${data}`);
    if (typeof data["last-valid"] === "undefined")
      throw new Error(`Response is missing required field 'last-valid': ${data}`);
    if (typeof data["sender"] === "undefined")
      throw new Error(`Response is missing required field 'sender': ${data}`);
    return new Transaction2({
      fee: data["fee"],
      firstValid: data["first-valid"],
      lastValid: data["last-valid"],
      sender: data["sender"],
      applicationTransaction: typeof data["application-transaction"] !== "undefined" ? TransactionApplication.from_obj_for_encoding(data["application-transaction"]) : void 0,
      assetConfigTransaction: typeof data["asset-config-transaction"] !== "undefined" ? TransactionAssetConfig.from_obj_for_encoding(data["asset-config-transaction"]) : void 0,
      assetFreezeTransaction: typeof data["asset-freeze-transaction"] !== "undefined" ? TransactionAssetFreeze.from_obj_for_encoding(data["asset-freeze-transaction"]) : void 0,
      assetTransferTransaction: typeof data["asset-transfer-transaction"] !== "undefined" ? TransactionAssetTransfer.from_obj_for_encoding(data["asset-transfer-transaction"]) : void 0,
      authAddr: data["auth-addr"],
      closeRewards: data["close-rewards"],
      closingAmount: data["closing-amount"],
      confirmedRound: data["confirmed-round"],
      createdApplicationIndex: data["created-application-index"],
      createdAssetIndex: data["created-asset-index"],
      genesisHash: data["genesis-hash"],
      genesisId: data["genesis-id"],
      globalStateDelta: typeof data["globalThis-state-delta"] !== "undefined" ? data["globalThis-state-delta"].map(EvalDeltaKeyValue2.from_obj_for_encoding) : void 0,
      group: data["group"],
      id: data["id"],
      innerTxns: typeof data["inner-txns"] !== "undefined" ? data["inner-txns"].map(Transaction2.from_obj_for_encoding) : void 0,
      intraRoundOffset: data["intra-round-offset"],
      keyregTransaction: typeof data["keyreg-transaction"] !== "undefined" ? TransactionKeyreg.from_obj_for_encoding(data["keyreg-transaction"]) : void 0,
      lease: data["lease"],
      localStateDelta: typeof data["local-state-delta"] !== "undefined" ? data["local-state-delta"].map(AccountStateDelta2.from_obj_for_encoding) : void 0,
      logs: data["logs"],
      note: data["note"],
      paymentTransaction: typeof data["payment-transaction"] !== "undefined" ? TransactionPayment.from_obj_for_encoding(data["payment-transaction"]) : void 0,
      receiverRewards: data["receiver-rewards"],
      rekeyTo: data["rekey-to"],
      roundTime: data["round-time"],
      senderRewards: data["sender-rewards"],
      signature: typeof data["signature"] !== "undefined" ? TransactionSignature.from_obj_for_encoding(data["signature"]) : void 0,
      stateProofTransaction: typeof data["state-proof-transaction"] !== "undefined" ? TransactionStateProof.from_obj_for_encoding(data["state-proof-transaction"]) : void 0,
      txType: data["tx-type"]
    });
  }
};
var TransactionApplication = class extends BaseModel {
  /**
   * Creates a new `TransactionApplication` object.
   * @param applicationId - (apid) ID of the application being configured or empty if creating.
   * @param accounts - (apat) List of accounts in addition to the sender that may be accessed from the
   * application's approval-program and clear-state-program.
   * @param applicationArgs - (apaa) transaction specific arguments accessed from the application's
   * approval-program and clear-state-program.
   * @param approvalProgram - (apap) Logic executed for every application transaction, except when
   * on-completion is set to "clear". It can read and write globalThis state for the
   * application, as well as account-specific local state. Approval programs may
   * reject the transaction.
   * @param clearStateProgram - (apsu) Logic executed for application transactions with on-completion set to
   * "clear". It can read and write globalThis state for the application, as well as
   * account-specific local state. Clear state programs cannot reject the
   * transaction.
   * @param extraProgramPages - (epp) specifies the additional app program len requested in pages.
   * @param foreignApps - (apfa) Lists the applications in addition to the application-id whose globalThis
   * states may be accessed by this application's approval-program and
   * clear-state-program. The access is read-only.
   * @param foreignAssets - (apas) lists the assets whose parameters may be accessed by this application's
   * ApprovalProgram and ClearStateProgram. The access is read-only.
   * @param globalStateSchema - Represents a (apls) local-state or (apgs) globalThis-state schema. These schemas
   * determine how much storage may be used in a local-state or globalThis-state for an
   * application. The more space used, the larger minimum balance must be maintained
   * in the account holding the data.
   * @param localStateSchema - Represents a (apls) local-state or (apgs) globalThis-state schema. These schemas
   * determine how much storage may be used in a local-state or globalThis-state for an
   * application. The more space used, the larger minimum balance must be maintained
   * in the account holding the data.
   * @param onCompletion - (apan) defines the what additional actions occur with the transaction.
   * Valid types:
   * * noop
   * * optin
   * * closeout
   * * clear
   * * update
   * * update
   * * delete
   */
  constructor({ applicationId, accounts, applicationArgs, approvalProgram, clearStateProgram, extraProgramPages, foreignApps, foreignAssets, globalStateSchema, localStateSchema, onCompletion }) {
    super();
    this.applicationId = applicationId;
    this.accounts = accounts;
    this.applicationArgs = applicationArgs;
    this.approvalProgram = typeof approvalProgram === "string" ? new Uint8Array(Buffer.from(approvalProgram, "base64")) : approvalProgram;
    this.clearStateProgram = typeof clearStateProgram === "string" ? new Uint8Array(Buffer.from(clearStateProgram, "base64")) : clearStateProgram;
    this.extraProgramPages = extraProgramPages;
    this.foreignApps = foreignApps;
    this.foreignAssets = foreignAssets;
    this.globalStateSchema = globalStateSchema;
    this.localStateSchema = localStateSchema;
    this.onCompletion = onCompletion;
    this.attribute_map = {
      applicationId: "application-id",
      accounts: "accounts",
      applicationArgs: "application-args",
      approvalProgram: "approval-program",
      clearStateProgram: "clear-state-program",
      extraProgramPages: "extra-program-pages",
      foreignApps: "foreign-apps",
      foreignAssets: "foreign-assets",
      globalStateSchema: "globalThis-state-schema",
      localStateSchema: "local-state-schema",
      onCompletion: "on-completion"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["application-id"] === "undefined")
      throw new Error(`Response is missing required field 'application-id': ${data}`);
    return new TransactionApplication({
      applicationId: data["application-id"],
      accounts: data["accounts"],
      applicationArgs: data["application-args"],
      approvalProgram: data["approval-program"],
      clearStateProgram: data["clear-state-program"],
      extraProgramPages: data["extra-program-pages"],
      foreignApps: data["foreign-apps"],
      foreignAssets: data["foreign-assets"],
      globalStateSchema: typeof data["globalThis-state-schema"] !== "undefined" ? StateSchema.from_obj_for_encoding(data["globalThis-state-schema"]) : void 0,
      localStateSchema: typeof data["local-state-schema"] !== "undefined" ? StateSchema.from_obj_for_encoding(data["local-state-schema"]) : void 0,
      onCompletion: data["on-completion"]
    });
  }
};
var TransactionAssetConfig = class extends BaseModel {
  /**
   * Creates a new `TransactionAssetConfig` object.
   * @param assetId - (xaid) ID of the asset being configured or empty if creating.
   * @param params - AssetParams specifies the parameters for an asset.
   * (apar) when part of an AssetConfig transaction.
   * Definition:
   * data/transactions/asset.go : AssetParams
   */
  constructor({ assetId, params }) {
    super();
    this.assetId = assetId;
    this.params = params;
    this.attribute_map = {
      assetId: "asset-id",
      params: "params"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new TransactionAssetConfig({
      assetId: data["asset-id"],
      params: typeof data["params"] !== "undefined" ? AssetParams2.from_obj_for_encoding(data["params"]) : void 0
    });
  }
};
var TransactionAssetFreeze = class extends BaseModel {
  /**
   * Creates a new `TransactionAssetFreeze` object.
   * @param address - (fadd) Address of the account whose asset is being frozen or thawed.
   * @param assetId - (faid) ID of the asset being frozen or thawed.
   * @param newFreezeStatus - (afrz) The new freeze status.
   */
  constructor({ address, assetId, newFreezeStatus }) {
    super();
    this.address = address;
    this.assetId = assetId;
    this.newFreezeStatus = newFreezeStatus;
    this.attribute_map = {
      address: "address",
      assetId: "asset-id",
      newFreezeStatus: "new-freeze-status"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["address"] === "undefined")
      throw new Error(`Response is missing required field 'address': ${data}`);
    if (typeof data["asset-id"] === "undefined")
      throw new Error(`Response is missing required field 'asset-id': ${data}`);
    if (typeof data["new-freeze-status"] === "undefined")
      throw new Error(`Response is missing required field 'new-freeze-status': ${data}`);
    return new TransactionAssetFreeze({
      address: data["address"],
      assetId: data["asset-id"],
      newFreezeStatus: data["new-freeze-status"]
    });
  }
};
var TransactionAssetTransfer = class extends BaseModel {
  /**
   * Creates a new `TransactionAssetTransfer` object.
   * @param amount - (aamt) Amount of asset to transfer. A zero amount transferred to self allocates
   * that asset in the account's Assets map.
   * @param assetId - (xaid) ID of the asset being transferred.
   * @param receiver - (arcv) Recipient address of the transfer.
   * @param closeAmount - Number of assets transfered to the close-to account as part of the transaction.
   * @param closeTo - (aclose) Indicates that the asset should be removed from the account's Assets
   * map, and specifies where the remaining asset holdings should be transferred.
   * It's always valid to transfer remaining asset holdings to the creator account.
   * @param sender - (asnd) The effective sender during a clawback transactions. If this is not a
   * zero value, the real transaction sender must be the Clawback address from the
   * AssetParams.
   */
  constructor({ amount, assetId, receiver, closeAmount, closeTo, sender }) {
    super();
    this.amount = amount;
    this.assetId = assetId;
    this.receiver = receiver;
    this.closeAmount = closeAmount;
    this.closeTo = closeTo;
    this.sender = sender;
    this.attribute_map = {
      amount: "amount",
      assetId: "asset-id",
      receiver: "receiver",
      closeAmount: "close-amount",
      closeTo: "close-to",
      sender: "sender"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["asset-id"] === "undefined")
      throw new Error(`Response is missing required field 'asset-id': ${data}`);
    if (typeof data["receiver"] === "undefined")
      throw new Error(`Response is missing required field 'receiver': ${data}`);
    return new TransactionAssetTransfer({
      amount: data["amount"],
      assetId: data["asset-id"],
      receiver: data["receiver"],
      closeAmount: data["close-amount"],
      closeTo: data["close-to"],
      sender: data["sender"]
    });
  }
};
var TransactionKeyreg = class extends BaseModel {
  /**
   * Creates a new `TransactionKeyreg` object.
   * @param nonParticipation - (nonpart) Mark the account as participating or non-participating.
   * @param selectionParticipationKey - (selkey) Public key used with the Verified Random Function (VRF) result during
   * committee selection.
   * @param stateProofKey - (sprfkey) State proof key used in key registration transactions.
   * @param voteFirstValid - (votefst) First round this participation key is valid.
   * @param voteKeyDilution - (votekd) Number of subkeys in each batch of participation keys.
   * @param voteLastValid - (votelst) Last round this participation key is valid.
   * @param voteParticipationKey - (votekey) Participation public key used in key registration transactions.
   */
  constructor({ nonParticipation, selectionParticipationKey, stateProofKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey }) {
    super();
    this.nonParticipation = nonParticipation;
    this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? new Uint8Array(Buffer.from(selectionParticipationKey, "base64")) : selectionParticipationKey;
    this.stateProofKey = typeof stateProofKey === "string" ? new Uint8Array(Buffer.from(stateProofKey, "base64")) : stateProofKey;
    this.voteFirstValid = voteFirstValid;
    this.voteKeyDilution = voteKeyDilution;
    this.voteLastValid = voteLastValid;
    this.voteParticipationKey = typeof voteParticipationKey === "string" ? new Uint8Array(Buffer.from(voteParticipationKey, "base64")) : voteParticipationKey;
    this.attribute_map = {
      nonParticipation: "non-participation",
      selectionParticipationKey: "selection-participation-key",
      stateProofKey: "state-proof-key",
      voteFirstValid: "vote-first-valid",
      voteKeyDilution: "vote-key-dilution",
      voteLastValid: "vote-last-valid",
      voteParticipationKey: "vote-participation-key"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new TransactionKeyreg({
      nonParticipation: data["non-participation"],
      selectionParticipationKey: data["selection-participation-key"],
      stateProofKey: data["state-proof-key"],
      voteFirstValid: data["vote-first-valid"],
      voteKeyDilution: data["vote-key-dilution"],
      voteLastValid: data["vote-last-valid"],
      voteParticipationKey: data["vote-participation-key"]
    });
  }
};
var TransactionPayment = class extends BaseModel {
  /**
   * Creates a new `TransactionPayment` object.
   * @param amount - (amt) number of MicroAlgos intended to be transferred.
   * @param receiver - (rcv) receiver's address.
   * @param closeAmount - Number of MicroAlgos that were sent to the close-remainder-to address when
   * closing the sender account.
   * @param closeRemainderTo - (close) when set, indicates that the sending account should be closed and all
   * remaining funds be transferred to this address.
   */
  constructor({ amount, receiver, closeAmount, closeRemainderTo }) {
    super();
    this.amount = amount;
    this.receiver = receiver;
    this.closeAmount = closeAmount;
    this.closeRemainderTo = closeRemainderTo;
    this.attribute_map = {
      amount: "amount",
      receiver: "receiver",
      closeAmount: "close-amount",
      closeRemainderTo: "close-remainder-to"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["receiver"] === "undefined")
      throw new Error(`Response is missing required field 'receiver': ${data}`);
    return new TransactionPayment({
      amount: data["amount"],
      receiver: data["receiver"],
      closeAmount: data["close-amount"],
      closeRemainderTo: data["close-remainder-to"]
    });
  }
};
var TransactionResponse = class extends BaseModel {
  /**
   * Creates a new `TransactionResponse` object.
   * @param currentRound - Round at which the results were computed.
   * @param transaction - Contains all fields common to all transactions and serves as an envelope to all
   * transactions type. Represents both regular and inner transactions.
   * Definition:
   * data/transactions/signedtxn.go : SignedTxn
   * data/transactions/transaction.go : Transaction
   */
  constructor({ currentRound, transaction }) {
    super();
    this.currentRound = currentRound;
    this.transaction = transaction;
    this.attribute_map = {
      currentRound: "current-round",
      transaction: "transaction"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    if (typeof data["transaction"] === "undefined")
      throw new Error(`Response is missing required field 'transaction': ${data}`);
    return new TransactionResponse({
      currentRound: data["current-round"],
      transaction: Transaction2.from_obj_for_encoding(data["transaction"])
    });
  }
};
var TransactionSignature = class extends BaseModel {
  /**
   * Creates a new `TransactionSignature` object.
   * @param logicsig - (lsig) Programatic transaction signature.
   * Definition:
   * data/transactions/logicsig.go
   * @param multisig - (msig) structure holding multiple subsignatures.
   * Definition:
   * crypto/multisig.go : MultisigSig
   * @param sig - (sig) Standard ed25519 signature.
   */
  constructor({ logicsig, multisig, sig }) {
    super();
    this.logicsig = logicsig;
    this.multisig = multisig;
    this.sig = typeof sig === "string" ? new Uint8Array(Buffer.from(sig, "base64")) : sig;
    this.attribute_map = {
      logicsig: "logicsig",
      multisig: "multisig",
      sig: "sig"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new TransactionSignature({
      logicsig: typeof data["logicsig"] !== "undefined" ? TransactionSignatureLogicsig.from_obj_for_encoding(data["logicsig"]) : void 0,
      multisig: typeof data["multisig"] !== "undefined" ? TransactionSignatureMultisig.from_obj_for_encoding(data["multisig"]) : void 0,
      sig: data["sig"]
    });
  }
};
var TransactionSignatureLogicsig = class extends BaseModel {
  /**
   * Creates a new `TransactionSignatureLogicsig` object.
   * @param logic - (l) Program signed by a signature or multi signature, or hashed to be the
   * address of ana ccount. Base64 encoded TEAL program.
   * @param args - (arg) Logic arguments, base64 encoded.
   * @param multisigSignature - (msig) structure holding multiple subsignatures.
   * Definition:
   * crypto/multisig.go : MultisigSig
   * @param signature - (sig) ed25519 signature.
   */
  constructor({ logic, args, multisigSignature, signature }) {
    super();
    this.logic = typeof logic === "string" ? new Uint8Array(Buffer.from(logic, "base64")) : logic;
    this.args = args;
    this.multisigSignature = multisigSignature;
    this.signature = typeof signature === "string" ? new Uint8Array(Buffer.from(signature, "base64")) : signature;
    this.attribute_map = {
      logic: "logic",
      args: "args",
      multisigSignature: "multisig-signature",
      signature: "signature"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["logic"] === "undefined")
      throw new Error(`Response is missing required field 'logic': ${data}`);
    return new TransactionSignatureLogicsig({
      logic: data["logic"],
      args: data["args"],
      multisigSignature: typeof data["multisig-signature"] !== "undefined" ? TransactionSignatureMultisig.from_obj_for_encoding(data["multisig-signature"]) : void 0,
      signature: data["signature"]
    });
  }
};
var TransactionSignatureMultisig = class extends BaseModel {
  /**
   * Creates a new `TransactionSignatureMultisig` object.
   * @param subsignature - (subsig) holds pairs of public key and signatures.
   * @param threshold - (thr)
   * @param version - (v)
   */
  constructor({ subsignature, threshold, version: version3 }) {
    super();
    this.subsignature = subsignature;
    this.threshold = threshold;
    this.version = version3;
    this.attribute_map = {
      subsignature: "subsignature",
      threshold: "threshold",
      version: "version"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new TransactionSignatureMultisig({
      subsignature: typeof data["subsignature"] !== "undefined" ? data["subsignature"].map(TransactionSignatureMultisigSubsignature.from_obj_for_encoding) : void 0,
      threshold: data["threshold"],
      version: data["version"]
    });
  }
};
var TransactionSignatureMultisigSubsignature = class extends BaseModel {
  /**
   * Creates a new `TransactionSignatureMultisigSubsignature` object.
   * @param publicKey - (pk)
   * @param signature - (s)
   */
  constructor({ publicKey, signature }) {
    super();
    this.publicKey = typeof publicKey === "string" ? new Uint8Array(Buffer.from(publicKey, "base64")) : publicKey;
    this.signature = typeof signature === "string" ? new Uint8Array(Buffer.from(signature, "base64")) : signature;
    this.attribute_map = {
      publicKey: "public-key",
      signature: "signature"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new TransactionSignatureMultisigSubsignature({
      publicKey: data["public-key"],
      signature: data["signature"]
    });
  }
};
var TransactionStateProof = class extends BaseModel {
  /**
   * Creates a new `TransactionStateProof` object.
   * @param message - (spmsg)
   * @param stateProof - (sp) represents a state proof.
   * Definition:
   * crypto/stateproof/structs.go : StateProof
   * @param stateProofType - (sptype) Type of the state proof. Integer representing an entry defined in
   * protocol/stateproof.go
   */
  constructor({ message: message2, stateProof, stateProofType }) {
    super();
    this.message = message2;
    this.stateProof = stateProof;
    this.stateProofType = stateProofType;
    this.attribute_map = {
      message: "message",
      stateProof: "state-proof",
      stateProofType: "state-proof-type"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new TransactionStateProof({
      message: typeof data["message"] !== "undefined" ? IndexerStateProofMessage.from_obj_for_encoding(data["message"]) : void 0,
      stateProof: typeof data["state-proof"] !== "undefined" ? StateProofFields.from_obj_for_encoding(data["state-proof"]) : void 0,
      stateProofType: data["state-proof-type"]
    });
  }
};
var TransactionsResponse = class extends BaseModel {
  /**
   * Creates a new `TransactionsResponse` object.
   * @param currentRound - Round at which the results were computed.
   * @param transactions -
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ currentRound, transactions, nextToken }) {
    super();
    this.currentRound = currentRound;
    this.transactions = transactions;
    this.nextToken = nextToken;
    this.attribute_map = {
      currentRound: "current-round",
      transactions: "transactions",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    if (!Array.isArray(data["transactions"]))
      throw new Error(`Response is missing required array field 'transactions': ${data}`);
    return new TransactionsResponse({
      currentRound: data["current-round"],
      transactions: data["transactions"].map(Transaction2.from_obj_for_encoding),
      nextToken: data["next-token"]
    });
  }
};
var LookupApplicationBoxByIDandName = class extends JSONRequest {
  /**
   * Returns information about indexed application boxes.
   *
   * #### Example
   * ```typescript
   * const boxName = Buffer.from("foo");
   * const boxResponse = await indexerClient
   *        .LookupApplicationBoxByIDandName(1234, boxName)
   *        .do();
   * const boxValue = boxResponse.value;
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idbox)
   * @oaram index - application index.
   * @category GET
   */
  constructor(c, intDecoding, index2, boxName) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
    const encodedName = Buffer.from(boxName).toString("base64");
    this.query.name = encodeURI(`b64:${encodedName}`);
  }
  /**
   * @returns `/v2/applications/${index}/box`
   */
  path() {
    return `/v2/applications/${this.index}/box`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    return Box2.from_obj_for_encoding(body);
  }
};
var SearchAccounts = class extends JSONRequest {
  /**
   * @returns `/v2/accounts`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/accounts";
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const minBalance = 300000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const minBalance = 300000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .assetID(assetID)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   * @remarks
   * If you are looking for accounts with the currency amount greater than 0, simply construct the query without `currencyGreaterThan` because it doesn't accept `-1`, and passing the `0` `currency-greater-than` value would exclude accounts with a 0 amount.
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const maxBalance = 500000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const maxBalance = 500000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .assetID(assetID)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Asset ID to filter with.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .assetID(assetID)
   *        .do();
   * ```
   *
   * @param id
   * @category query
   */
  assetID(id) {
    this.query["asset-id"] = id;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   *
   * const accountsPage1 = await indexerClient
   *        .searchAccounts()
   *        .limit(maxResults)
   *        .do();
   *
   * const accountsPage2 = await indexerClient
   *        .searchAccounts()
   *        .limit(maxResults)
   *        .nextToken(accountsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .round(targetBlock)
   *        .do();
   * ```
   * @remarks For performance reasons, this parameter may be disabled on some configurations.
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include accounts that use this spending key.
   *
   * #### Example
   * ```typescript
   * const authAddr = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .authAddr(authAddr)
   *        .do();
   * ```
   *
   * @param authAddr
   */
  authAddr(authAddr) {
    this.query["auth-addr"] = authAddr;
    return this;
  }
  /**
   * Filter for this application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .applicationID(appId)
   *        .do();
   * ```
   *
   * @param applicationID
   * @category query
   */
  applicationID(applicationID) {
    this.query["application-id"] = applicationID;
    return this;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const assetId = 163650;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetId = 163650;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value2 = true) {
    this.query["include-all"] = value2;
    return this;
  }
  /**
   * Exclude additional items such as asset holdings, application local data stored for this account, asset parameters created by this account, and application parameters created by this account.
   *
   * #### Example 1
   * ```typescript
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .exclude("all")
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .exclude("assets,created-assets")
   *        .do();
   * ```
   * @remarks By default, it behaves as exclude=none
   * @param exclude - Array of `all`, `assets`, `created-assets`, `apps-local-state`, `created-apps`, `none`
   * @category query
   */
  exclude(exclude) {
    this.query.exclude = exclude;
    return this;
  }
};
var SearchForTransactions = class extends JSONRequest {
  /**
   * @returns `/v2/transactions`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/transactions";
  }
  /**
   * Specifies a prefix which must be contained in the note field.
   *
   * #### Example
   * ```typescript
   * const notePrefixBase64Encoded = "Y3JlYXRl";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .notePrefix(notePrefixBase64Encoded)
   *        .do();
   * ```
   *
   * @param prefix - base64 string or uint8array
   * @category query
   */
  notePrefix(prefix) {
    this.query["note-prefix"] = base64StringFunnel(prefix);
    return this;
  }
  /**
   * Type of transaction to filter with.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .txType("keyreg")
   *        .do();
   * ```
   *
   * @param type - one of `pay`, `keyreg`, `acfg`, `axfer`, `afrz`, `appl`, `stpf`
   * @category query
   */
  txType(type) {
    this.query["tx-type"] = type;
    return this;
  }
  /**
   * Type of signature to filter with.
   * - sig: Standard
   * - msig: MultiSig
   * - lsig: LogicSig
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .sigType("sig")
   *        .do();
   * ```
   *
   * @param type - one of `sig`, `msig`, `lsig`
   * @category query
   */
  sigType(type) {
    this.query["sig-type"] = type;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .txid(txId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupTransactionByID(txnId).do()`
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .round(targetBlock)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupBlock(targetBlock).do()`
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * Asset ID to filter with.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .assetID(assetID)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupAssetTransactions(assetId).do()`
   * @param id
   * @category query
   */
  assetID(id) {
    this.query["asset-id"] = id;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results before the given time.
   *
   * #### Example
   * ```typescript
   * const beforeTime = "2022-02-02T20:20:22.02Z";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .beforeTime(beforeTime)
   *        .do();
   * ```
   *
   * @param before - rfc3339 string
   * @category query
   */
  beforeTime(before) {
    this.query["before-time"] = before;
    return this;
  }
  /**
   * Include results after the given time.
   *
   * #### Example
   * ```typescript
   * const afterTime = "2022-10-21T00:00:11.55Z";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .afterTime(afterTime)
   *        .do();
   * ```
   *
   * @param after - rfc3339 string
   * @category query
   */
  afterTime(after) {
    this.query["after-time"] = after;
    return this;
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const minBalance = 300000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const minBalance = 300000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .assetID(assetID)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   * @remarks
   * If you are looking for transactions with the currency amount greater than 0, simply construct the query without `currencyGreaterThan` because it doesn't accept `-1`, and passing the `0` `currency-greater-than` value would exclude transactions with a 0 amount.
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const maxBalance = 500000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const maxBalance = 500000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .assetID(assetID)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * Combined with address, defines what address to filter on, as string.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const role = "freeze-target";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .address(address)
   *        .addressRole(role)
   *        .do();
   * ```
   *
   * @param role - one of `sender`, `receiver`, `freeze-target`
   * @category query
   */
  addressRole(role) {
    this.query["address-role"] = role;
    return this;
  }
  /**
   * Only include transactions with this address in one of the transaction fields.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .address(address)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupAccountTransactions(address).do()`
   * @param address
   * @category query
   */
  address(address) {
    this.query.address = address;
    return this;
  }
  /**
   * Whether or not to consider the `close-to` field as a receiver when filtering transactions, as bool. Set to `true` to ignore `close-to`.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .excludeCloseTo(true)
   *        .do();
   * ```
   *
   * @param exclude
   * @category query
   */
  excludeCloseTo(exclude) {
    this.query["exclude-close-to"] = exclude;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   *
   * const txnsPage1 = await indexerClient
   *        .searchForTransactions()
   *        .limit(maxResults)
   *        .do();
   *
   * const txnsPage2 = await indexerClient
   *        .searchForTransactions()
   *        .limit(maxResults)
   *        .nextToken(txnsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Whether or not to include rekeying transactions.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .rekeyTo(false)
   *        .do();
   * ```
   *
   * @param rekeyTo
   * @category query
   */
  rekeyTo(rekeyTo) {
    this.query["rekey-to"] = rekeyTo;
    return this;
  }
  /**
   * Filter for this application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .applicationID(appId)
   *        .do();
   * ```
   *
   * @param applicationID
   * @category query
   */
  applicationID(applicationID) {
    this.query["application-id"] = applicationID;
    return this;
  }
};
var SearchForAssets = class extends JSONRequest {
  /**
   * @returns `/v2/assets`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/assets";
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Filter just assets with the given creator address.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .creator(address)
   *        .do();
   * ```
   *
   * @param creator
   * @category query
   */
  creator(creator) {
    this.query.creator = creator;
    return this;
  }
  /**
   * Filter just assets with the given name.
   *
   * #### Example
   * ```typescript
   * const name = "Test Token";
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .name(name)
   *        .do();
   * ```
   *
   * @param name
   * @category query
   */
  name(name9) {
    this.query.name = name9;
    return this;
  }
  /**
   * Filter just assets with the given unit.
   *
   * #### Example
   * ```typescript
   * const unit = "test";
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .unit(unit)
   *        .do();
   * ```
   *
   * @param unit
   * @category query
   */
  unit(unit) {
    this.query.unit = unit;
    return this;
  }
  /**
   * Asset ID for filter, as int.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .index(assetId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupAssetByID(assetId).do();`
   * @param index
   * @category query
   */
  index(index2) {
    this.query["asset-id"] = index2;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   *
   * const assetsPage1 = await indexerClient
   *        .searchForAssets()
   *        .limit(maxResults)
   *        .do();
   *
   * const assetsPage2 = await indexerClient
   *        .searchForAssets()
   *        .limit(maxResults)
   *        .nextToken(assetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value2 = true) {
    this.query["include-all"] = value2;
    return this;
  }
};
var SearchForApplications = class extends JSONRequest {
  /**
   * @returns `/v2/applications`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/applications";
  }
  /**
   * Application ID for filter, as int
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .index(appId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupApplications(appId).do()`
   * @param index
   * @category query
   */
  index(index2) {
    this.query["application-id"] = index2;
    return this;
  }
  /**
   * Creator for filter, as string
   *
   * #### Example
   * ```typescript
   * const creator = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .creator(creator)
   *        .do();
   * ```
   * @param creator
   * @category query
   */
  creator(creator) {
    this.query.creator = creator;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   *
   * const appsPage1 = await indexerClient
   *        .searchForApplications()
   *        .limit(maxResults)
   *        .do();
   *
   * const appsPage2 = await indexerClient
   *        .searchForApplications()
   *        .limit(maxResults)
   *        .nextToken(appsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(next) {
    this.query.next = next;
    return this;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value2 = true) {
    this.query["include-all"] = value2;
    return this;
  }
};
var SearchForApplicationBoxes = class extends JSONRequest {
  /**
   * Returns information about indexed application boxes.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appID = 1234;
   *
   * const responsePage1 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .do();
   * const boxNamesPage1 = responsePage1.boxes.map(box => box.name);
   *
   * const responsePage2 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .nextToken(responsePage1.nextToken)
   *        .do();
   * const boxNamesPage2 = responsePage2.boxes.map(box => box.name);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idboxes)
   * @oaram index - application index.
   * @category GET
   */
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  /**
   * @returns `/v2/applications/${index}/boxes`
   */
  path() {
    return `/v2/applications/${this.index}/boxes`;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appID = 1234;
   *
   * const responsePage1 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .do();
   * const boxNamesPage1 = responsePage1.boxes.map(box => box.name);
   *
   * const responsePage2 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .nextToken(responsePage1.nextToken)
   *        .do();
   * const boxNamesPage2 = responsePage2.boxes.map(box => box.name);
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(next) {
    this.query.next = next;
    return this;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const boxesResponse = await indexerClient
   *        .searchForApplicationBoxes(1234)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    return BoxesResponse2.from_obj_for_encoding(body);
  }
};
var IndexerClient = class extends ServiceClient {
  /**
   * Create an IndexerClient from
   * * either a token, baseServer, port, and optional headers
   * * or a base client server for interoperability with external dApp wallets
   *
   * #### Example
   * ```typescript
   * const token  = "";
   * const server = "http://localhost";
   * const port   = 8980;
   * const indexerClient = new algosdk.Indexer(token, server, port);
   * ```
   * @remarks
   * The above configuration is for a sandbox private network.
   * For applications on production, you are encouraged to run your own node with indexer, or use an Algorand REST API provider with a dedicated API key.
   *
   * @param tokenOrBaseClient - The API token for the Indexer API
   * @param baseServer - REST endpoint
   * @param port - Port number if specifically configured by the server
   * @param headers - Optional headers
   */
  constructor(tokenOrBaseClient, baseServer = "http://127.0.0.1", port = 8080, headers = {}) {
    super("X-Indexer-API-Token", tokenOrBaseClient, baseServer, port, headers);
  }
  /**
   * Returns the health object for the service.
   * Returns 200 if healthy.
   *
   * #### Example
   * ```typescript
   * const health = await indexerClient.makeHealthCheck().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-health)
   * @category GET
   */
  makeHealthCheck() {
    return new MakeHealthCheck(this.c, this.intDecoding);
  }
  /**
   * Returns the list of accounts who hold the given asset and their balance.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient.lookupAssetBalances(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idbalances)
   * @param index - The asset ID to look up.
   * @category GET
   */
  lookupAssetBalances(index2) {
    return new LookupAssetBalances(this.c, this.intDecoding, index2);
  }
  /**
   * Returns transactions relating to the given asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient.lookupAssetTransactions(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idtransactions)
   * @param index - The asset ID to look up.
   * @category GET
   */
  lookupAssetTransactions(index2) {
    return new LookupAssetTransactions(this.c, this.intDecoding, index2);
  }
  /**
   * Returns transactions relating to the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient.lookupAccountTransactions(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idtransactions)
   * @param account - The address of the account.
   * @category GET
   */
  lookupAccountTransactions(account) {
    return new LookupAccountTransactions(this.c, this.intDecoding, account);
  }
  /**
   * Returns the block for the passed round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const blockInfo = await indexerClient.lookupBlock(targetBlock).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2blocksround-number)
   * @param round - The number of the round to look up.
   * @category GET
   */
  lookupBlock(round) {
    return new LookupBlock(this.c, this.intDecoding, round);
  }
  /**
   * Returns information about the given transaction.
   *
   * #### Example
   * ```typescript
   * const txnId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const txnInfo = await indexerClient.lookupTransactionByID(txnId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactionstxid)
   * @param txID - The ID of the transaction to look up.
   * @category GET
   */
  lookupTransactionByID(txID) {
    return new LookupTransactionByID(this.c, this.intDecoding, txID);
  }
  /**
   * Returns information about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient.lookupAccountByID(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-id)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountByID(account) {
    return new LookupAccountByID(this.c, this.intDecoding, account);
  }
  /**
   * Returns asset about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient.lookupAccountAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idassets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountAssets(account) {
    return new LookupAccountAssets(this.c, this.intDecoding, account);
  }
  /**
   * Returns asset information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedAssets = await indexerClient.lookupAccountCreatedAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-assets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountCreatedAssets(account) {
    return new LookupAccountCreatedAssets(this.c, this.intDecoding, account);
  }
  /**
   * Returns application local state about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAppLocalStates = await indexerClient.lookupAccountAppLocalStates(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idapps-local-state)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountAppLocalStates(account) {
    return new LookupAccountAppLocalStates(this.c, this.intDecoding, account);
  }
  /**
   * Returns application information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedApps = await indexerClient.lookupAccountCreatedApplications(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-applications)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountCreatedApplications(account) {
    return new LookupAccountCreatedApplications(this.c, this.intDecoding, account);
  }
  /**
   * Returns information about the passed asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient.lookupAssetByID(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-id)
   * @param index - The ID of the asset ot look up.
   * @category GET
   */
  lookupAssetByID(index2) {
    return new LookupAssetByID(this.c, this.intDecoding, index2);
  }
  /**
   * Returns information about the passed application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient.lookupApplications(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-id)
   * @param index - The ID of the application to look up.
   * @category GET
   */
  lookupApplications(index2) {
    return new LookupApplications(this.c, this.intDecoding, index2);
  }
  /**
   * Returns log messages generated by the passed in application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appLogs = await indexerClient.lookupApplicationLogs(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idlogs)
   * @param appID - The ID of the application which generated the logs.
   * @category GET
   */
  lookupApplicationLogs(appID) {
    return new LookupApplicationLogs(this.c, this.intDecoding, appID);
  }
  /**
   * Returns information about indexed accounts.
   *
   * #### Example
   * ```typescript
   * const accounts = await indexerClient.searchAccounts().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accounts)
   * @category GET
   */
  searchAccounts() {
    return new SearchAccounts(this.c, this.intDecoding);
  }
  /**
   * Returns information about indexed transactions.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient.searchForTransactions().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactions)
   * @category GET
   */
  searchForTransactions() {
    return new SearchForTransactions(this.c, this.intDecoding);
  }
  /**
   * Returns information about indexed assets.
   *
   * #### Example
   * ```typescript
   * const assets = await indexerClient.searchForAssets().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assets)
   * @category GET
   */
  searchForAssets() {
    return new SearchForAssets(this.c, this.intDecoding);
  }
  /**
   * Returns information about indexed applications.
   *
   * #### Example
   * ```typescript
   * const apps = await indexerClient.searchForApplications().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applications)
   * @category GET
   */
  searchForApplications() {
    return new SearchForApplications(this.c, this.intDecoding);
  }
  /**
   * Returns information about indexed application boxes.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appID = 1234;
   *
   * const responsePage1 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .do();
   * const boxNamesPage1 = responsePage1.boxes.map(box => box.name);
   *
   * const responsePage2 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .nextToken(responsePage1.nextToken)
   *        .do();
   * const boxNamesPage2 = responsePage2.boxes.map(box => box.name);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idboxes)
   * @param appID - The ID of the application with boxes.
   * @category GET
   */
  searchForApplicationBoxes(appID) {
    return new SearchForApplicationBoxes(this.c, this.intDecoding, appID);
  }
  /**
   * Returns information about the application box given its name.
   *
   * #### Example
   * ```typescript
   * const boxName = Buffer.from("foo");
   * const boxResponse = await indexerClient
   *        .LookupApplicationBoxByIDandName(1234, boxName)
   *        .do();
   * const boxValue = boxResponse.value;
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idbox)
   * @param appID - The ID of the application with boxes.
   * @category GET
   */
  lookupApplicationBoxByIDandName(appID, boxName) {
    return new LookupApplicationBoxByIDandName(this.c, this.intDecoding, appID, boxName);
  }
};
async function waitForConfirmation(client, txid, waitRounds) {
  const status = await client.status().do();
  if (typeof status === "undefined") {
    throw new Error("Unable to get node status");
  }
  const startRound = status["last-round"] + 1;
  let currentRound = startRound;
  while (currentRound < startRound + waitRounds) {
    let poolError = false;
    try {
      const pendingInfo = await client.pendingTransactionInformation(txid).do();
      if (pendingInfo["confirmed-round"]) {
        return pendingInfo;
      }
      if (pendingInfo["pool-error"]) {
        poolError = true;
        throw new Error(`Transaction Rejected: ${pendingInfo["pool-error"]}`);
      }
    } catch (err2) {
      if (poolError) {
        throw err2;
      }
    }
    await client.statusAfterBlock(currentRound).do();
    currentRound += 1;
  }
  throw new Error(`Transaction not confirmed after ${waitRounds} rounds`);
}
function bigIntToBytes(bi, size) {
  let hex = bi.toString(16);
  if (hex.length !== size * 2) {
    hex = hex.padStart(size * 2, "0");
  }
  const byteArray = new Uint8Array(hex.length / 2);
  for (let i2 = 0, j = 0; i2 < hex.length / 2; i2++, j += 2) {
    byteArray[i2] = parseInt(hex.slice(j, j + 2), 16);
  }
  return byteArray;
}
function bytesToBigInt(bytes) {
  let res = BigInt(0);
  const buf2 = Buffer.from(bytes);
  for (let i2 = 0; i2 < bytes.length; i2++) {
    res = BigInt(Number(buf2.readUIntBE(i2, 1))) + res * BigInt(256);
  }
  return res;
}
function generateAccount() {
  const keys = keyPair();
  const encodedPk = encodeAddress(keys.publicKey);
  return { addr: encodedPk, sk: keys.secretKey };
}
var english = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];
var english_default = english;
var FAIL_TO_DECODE_MNEMONIC_ERROR_MSG = "failed to decode mnemonic";
var NOT_IN_WORDS_LIST_ERROR_MSG = "the mnemonic contains a word that is not in the wordlist";
function toUint11Array(buffer8) {
  const buffer11 = [];
  let acc = 0;
  let accBits = 0;
  function add(octet) {
    acc |= octet << accBits;
    accBits += 8;
    if (accBits >= 11) {
      buffer11.push(acc & 2047);
      acc >>= 11;
      accBits -= 11;
    }
  }
  function flush3() {
    if (accBits) {
      buffer11.push(acc);
    }
  }
  buffer8.forEach(add);
  flush3();
  return buffer11;
}
function applyWords(nums) {
  return nums.map((n) => english_default[n]);
}
function computeChecksum(seed2) {
  const hashBuffer = genericHash(seed2);
  const uint11Hash = toUint11Array(hashBuffer);
  const words = applyWords(uint11Hash);
  return words[0];
}
function mnemonicFromSeed(seed2) {
  if (seed2.length !== SEED_BTYES_LENGTH) {
    throw new RangeError(`Seed length must be ${SEED_BTYES_LENGTH}`);
  }
  const uint11Array = toUint11Array(seed2);
  const words = applyWords(uint11Array);
  const checksumWord = computeChecksum(seed2);
  return `${words.join(" ")} ${checksumWord}`;
}
function toUint8Array(buffer11) {
  const buffer8 = [];
  let acc = 0;
  let accBits = 0;
  function add(ui11) {
    acc |= ui11 << accBits;
    accBits += 11;
    while (accBits >= 8) {
      buffer8.push(acc & 255);
      acc >>= 8;
      accBits -= 8;
    }
  }
  function flush3() {
    if (accBits) {
      buffer8.push(acc);
    }
  }
  buffer11.forEach(add);
  flush3();
  return new Uint8Array(buffer8);
}
function seedFromMnemonic(mnemonic) {
  const words = mnemonic.split(" ");
  const key = words.slice(0, 24);
  for (const w of key) {
    if (english_default.indexOf(w) === -1)
      throw new Error(NOT_IN_WORDS_LIST_ERROR_MSG);
  }
  const checksum = words[words.length - 1];
  const uint11Array = key.map((word2) => english_default.indexOf(word2));
  let uint8Array = toUint8Array(uint11Array);
  if (uint8Array.length !== 33)
    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
  if (uint8Array[uint8Array.length - 1] !== 0)
    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
  uint8Array = uint8Array.slice(0, uint8Array.length - 1);
  const cs = computeChecksum(uint8Array);
  if (cs === checksum)
    return uint8Array;
  throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
}
function mnemonicToSecretKey(mn) {
  const seed2 = seedFromMnemonic(mn);
  const keys = keyPairFromSeed(seed2);
  const encodedPk = encodeAddress(keys.publicKey);
  return { addr: encodedPk, sk: keys.secretKey };
}
function secretKeyToMnemonic(sk) {
  const seed2 = sk.slice(0, SEED_BTYES_LENGTH);
  return mnemonicFromSeed(seed2);
}
function mnemonicToMasterDerivationKey(mn) {
  return seedFromMnemonic(mn);
}
function masterDerivationKeyToMnemonic(mdk) {
  return mnemonicFromSeed(mdk);
}
var ALGORAND_MAX_TX_GROUP_SIZE = 16;
var TxGroup = class {
  constructor(hashes2) {
    this.name = "Transaction group";
    this.tag = Buffer.from("TG");
    if (hashes2.length > ALGORAND_MAX_TX_GROUP_SIZE) {
      const errorMsg = `${hashes2.length.toString()} transactions grouped together but max group size is ${ALGORAND_MAX_TX_GROUP_SIZE.toString()}`;
      throw Error(errorMsg);
    }
    this.txGroupHashes = hashes2;
  }
  // eslint-disable-next-line camelcase
  get_obj_for_encoding() {
    const txgroup = {
      txlist: this.txGroupHashes
    };
    return txgroup;
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(txgroupForEnc) {
    const txn = Object.create(this.prototype);
    txn.name = "Transaction group";
    txn.tag = Buffer.from("TG");
    txn.txGroupHashes = [];
    for (const hash2 of txgroupForEnc.txlist) {
      txn.txGroupHashes.push(Buffer.from(hash2));
    }
    return txn;
  }
  toByte() {
    return encode2(this.get_obj_for_encoding());
  }
};
function computeGroupID(txns) {
  const hashes2 = [];
  for (const txn of txns) {
    const tx = instantiateTxnIfNeeded(txn);
    hashes2.push(tx.rawTxID());
  }
  const txgroup = new TxGroup(hashes2);
  const bytes = txgroup.toByte();
  const toBeHashed = Buffer.from(concatArrays(txgroup.tag, bytes));
  const gid = genericHash(toBeHashed);
  return Buffer.from(gid);
}
function assignGroupID(txns, from2) {
  const gid = computeGroupID(txns);
  const result = [];
  for (const txn of txns) {
    const tx = instantiateTxnIfNeeded(txn);
    if (!from2 || encodeAddress(tx.from.publicKey) === from2) {
      tx.group = gid;
      result.push(tx);
    }
  }
  return result;
}
var MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = "Not enough multisig transactions to merge. Need at least two";
var MULTISIG_MERGE_MISMATCH_ERROR_MSG = "Cannot merge txs. txIDs differ";
var MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG = "Cannot merge txs. Auth addrs differ";
var MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = "Cannot merge txs. Multisig preimages differ";
var MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = "Cannot merge txs. subsigs are mismatched.";
var MULTISIG_KEY_NOT_EXIST_ERROR_MSG = "Key does not exist";
var MULTISIG_NO_MUTATE_ERROR_MSG = "Cannot mutate a multisig field as it would invalidate all existing signatures.";
var MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG = "Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.";
var MULTISIG_SIGNATURE_LENGTH_ERROR_MSG = "Cannot add multisig signature. Signature is not of the correct length.";
function createMultisigTransaction(txn, { version: version3, threshold, addrs }) {
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  const subsigs = pks.map((pk) => ({ pk: Buffer.from(pk) }));
  const msig = {
    v: version3,
    thr: threshold,
    subsig: subsigs
  };
  const txnForEncoding = txn.get_obj_for_encoding();
  const signedTxn = {
    msig,
    txn: txnForEncoding
  };
  const msigAddr = fromMultisigPreImg({
    version: version3,
    threshold,
    pks
  });
  if (encodeAddress(txnForEncoding.snd) !== encodeAddress(msigAddr)) {
    signedTxn.sgnr = Buffer.from(msigAddr);
  }
  return new Uint8Array(encode2(signedTxn));
}
function createMultisigTransactionWithSignature(txn, { rawSig, myPk }, { version: version3, threshold, pks }) {
  const encodedMsig = createMultisigTransaction(txn, {
    version: version3,
    threshold,
    addrs: pks.map((pk) => encodeAddress(pk))
  });
  const signedTxn = decode2(encodedMsig);
  let keyExist = false;
  signedTxn.msig.subsig.forEach((subsig, i2) => {
    if (bytesEqual(subsig.pk, myPk)) {
      keyExist = true;
      signedTxn.msig.subsig[i2].s = rawSig;
    }
  });
  if (keyExist === false) {
    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);
  }
  const msigAddr = fromMultisigPreImg({
    version: version3,
    threshold,
    pks
  });
  if (encodeAddress(signedTxn.txn.snd) !== encodeAddress(msigAddr)) {
    signedTxn.sgnr = Buffer.from(msigAddr);
  }
  return new Uint8Array(encode2(signedTxn));
}
var MultisigTransaction = class extends Transaction {
  /* eslint-disable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */
  /**
   * Override inherited method to throw an error, as mutating transactions are prohibited in this context
   */
  addLease() {
    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);
  }
  /**
   * Override inherited method to throw an error, as mutating transactions are prohibited in this context
   */
  addRekey() {
    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);
  }
  signTxn(sk) {
    throw new Error(MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG);
  }
  /* eslint-enable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */
  /**
   * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,
   * encoded with msgpack as a typed array.
   * @param version - multisig version
   * @param threshold - multisig threshold
   * @param pks - multisig public key list, order is important.
   * @param sk - an Algorand secret key to sign with.
   * @returns an encoded, partially signed multisig transaction.
   */
  partialSignTxn({ version: version3, threshold, pks }, sk) {
    const myPk = keyPairFromSecretKey(sk).publicKey;
    return createMultisigTransactionWithSignature(this, { rawSig: this.rawSignTxn(sk), myPk }, { version: version3, threshold, pks });
  }
  /**
   * partialSignWithMultisigSignature partially signs this transaction with an external raw multisig signature and returns
   * a partially-signed multisig transaction, encoded with msgpack as a typed array.
   * @param metadata - multisig metadata
   * @param signerAddr - address of the signer
   * @param signature - raw multisig signature
   * @returns an encoded, partially signed multisig transaction.
   */
  partialSignWithMultisigSignature(metadata, signerAddr, signature) {
    if (!isValidSignatureLength(signature.length)) {
      throw new Error(MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);
    }
    return createMultisigTransactionWithSignature(this, {
      rawSig: signature,
      myPk: decodeAddress(signerAddr).publicKey
    }, metadata);
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(txnForEnc) {
    return super.from_obj_for_encoding(txnForEnc);
  }
};
function mergeMultisigTransactions(multisigTxnBlobs) {
  if (multisigTxnBlobs.length < 2) {
    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);
  }
  const refSigTx = decode2(multisigTxnBlobs[0]);
  const refTxID = MultisigTransaction.from_obj_for_encoding(refSigTx.txn).txID();
  const refAuthAddr = refSigTx.sgnr ? encodeAddress(refSigTx.sgnr) : void 0;
  const refPreImage = {
    version: refSigTx.msig.v,
    threshold: refSigTx.msig.thr,
    pks: refSigTx.msig.subsig.map((subsig) => subsig.pk)
  };
  const refMsigAddr = encodeAddress(fromMultisigPreImg(refPreImage));
  const newSubsigs = refSigTx.msig.subsig.map((sig) => ({ ...sig }));
  for (let i2 = 1; i2 < multisigTxnBlobs.length; i2++) {
    const unisig = decode2(multisigTxnBlobs[i2]);
    const unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);
    if (unisigAlgoTxn.txID() !== refTxID) {
      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);
    }
    const authAddr = unisig.sgnr ? encodeAddress(unisig.sgnr) : void 0;
    if (refAuthAddr !== authAddr) {
      throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);
    }
    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {
      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
    }
    const preimg = {
      version: unisig.msig.v,
      threshold: unisig.msig.thr,
      pks: unisig.msig.subsig.map((subsig) => subsig.pk)
    };
    const msgigAddr = encodeAddress(fromMultisigPreImg(preimg));
    if (refMsigAddr !== msgigAddr) {
      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
    }
    unisig.msig.subsig.forEach((uniSubsig, index2) => {
      if (!uniSubsig.s)
        return;
      const current = newSubsigs[index2];
      if (current.s && Buffer.compare(Buffer.from(uniSubsig.s), Buffer.from(current.s)) !== 0) {
        throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);
      }
      current.s = uniSubsig.s;
    });
  }
  const msig = {
    v: refSigTx.msig.v,
    thr: refSigTx.msig.thr,
    subsig: newSubsigs
  };
  const signedTxn = {
    msig,
    txn: refSigTx.txn
  };
  if (typeof refAuthAddr !== "undefined") {
    signedTxn.sgnr = Buffer.from(decodeAddress(refAuthAddr).publicKey);
  }
  return new Uint8Array(encode2(signedTxn));
}
function verifyMultisig(toBeVerified, msig, publicKey) {
  const version3 = msig.v;
  const threshold = msig.thr;
  const subsigs = msig.subsig;
  const pks = subsigs.map((subsig) => subsig.pk);
  if (msig.subsig.length < threshold) {
    return false;
  }
  let pk;
  try {
    pk = fromMultisigPreImg({ version: version3, threshold, pks });
  } catch (e) {
    return false;
  }
  if (!arrayEqual(pk, publicKey)) {
    return false;
  }
  let counter = 0;
  for (const subsig of subsigs) {
    if (subsig.s !== void 0) {
      counter += 1;
    }
  }
  if (counter < threshold) {
    return false;
  }
  let verifiedCounter = 0;
  for (const subsig of subsigs) {
    if (subsig.s !== void 0) {
      if (verify(toBeVerified, subsig.s, subsig.pk)) {
        verifiedCounter += 1;
      }
    }
  }
  if (verifiedCounter < threshold) {
    return false;
  }
  return true;
}
function signMultisigTransaction(txn, { version: version3, threshold, addrs }, sk) {
  const expectedFromRaw = fromMultisigPreImgAddrs({
    version: version3,
    threshold,
    addrs
  });
  if (!Object.prototype.hasOwnProperty.call(txn, "from")) {
    txn.from = expectedFromRaw;
  }
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  const txnAlreadyBuilt = txn instanceof Transaction;
  let algoTxn;
  let blob;
  if (txnAlreadyBuilt) {
    algoTxn = txn;
    blob = MultisigTransaction.prototype.partialSignTxn.call(algoTxn, { version: version3, threshold, pks }, sk);
  } else {
    algoTxn = new MultisigTransaction(txn);
    blob = algoTxn.partialSignTxn({ version: version3, threshold, pks }, sk);
  }
  return {
    txID: algoTxn.txID().toString(),
    blob
  };
}
function appendSignMultisigTransaction(multisigTxnBlob, { version: version3, threshold, addrs }, sk) {
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  const multisigTxObj = decode2(multisigTxnBlob);
  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);
  const partialSignedBlob = msigTxn.partialSignTxn({ version: version3, threshold, pks }, sk);
  return {
    txID: msigTxn.txID().toString(),
    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])
  };
}
function appendSignRawMultisigSignature(multisigTxnBlob, { version: version3, threshold, addrs }, signerAddr, signature) {
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  const multisigTxObj = decode2(multisigTxnBlob);
  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);
  const partialSignedBlob = msigTxn.partialSignWithMultisigSignature({ version: version3, threshold, pks }, signerAddr, signature);
  return {
    txID: msigTxn.txID().toString(),
    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])
  };
}
function multisigAddress({ version: version3, threshold, addrs }) {
  return fromMultisigPreImgAddrs({ version: version3, threshold, addrs });
}
function sanityCheckProgram(program) {
  if (!program || program.length === 0)
    throw new Error("empty program");
  const lineBreakOrd = "\n".charCodeAt(0);
  const blankSpaceOrd = " ".charCodeAt(0);
  const tildeOrd = "~".charCodeAt(0);
  const isPrintable = (x) => blankSpaceOrd <= x && x <= tildeOrd;
  const isAsciiPrintable = program.every((x) => x === lineBreakOrd || isPrintable(x));
  if (isAsciiPrintable) {
    const programStr = Buffer.from(program).toString();
    if (isValidAddress(programStr))
      throw new Error("requesting program bytes, get Algorand address");
    if (Buffer.from(programStr, "base64").toString("base64") === programStr)
      throw new Error("program should not be b64 encoded");
    throw new Error("program bytes are all ASCII printable characters, not looking like Teal byte code");
  }
}
var LogicSig = class {
  constructor(program, programArgs) {
    this.tag = Buffer.from("Program");
    if (programArgs && (!Array.isArray(programArgs) || !programArgs.every((arg) => arg.constructor === Uint8Array || Buffer.isBuffer(arg)))) {
      throw new TypeError("Invalid arguments");
    }
    let args;
    if (programArgs != null)
      args = programArgs.map((arg) => new Uint8Array(arg));
    sanityCheckProgram(program);
    this.logic = program;
    this.args = args;
    this.sig = void 0;
    this.msig = void 0;
  }
  // eslint-disable-next-line camelcase
  get_obj_for_encoding() {
    const obj = {
      l: this.logic
    };
    if (this.args) {
      obj.arg = this.args;
    }
    if (this.sig) {
      obj.sig = this.sig;
    } else if (this.msig) {
      obj.msig = this.msig;
    }
    return obj;
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(encoded) {
    const lsig = new LogicSig(encoded.l, encoded.arg);
    lsig.sig = encoded.sig;
    lsig.msig = encoded.msig;
    return lsig;
  }
  /**
   * Performs signature verification
   * @param publicKey - Verification key (derived from sender address or escrow address)
   */
  verify(publicKey) {
    if (this.sig && this.msig) {
      return false;
    }
    try {
      sanityCheckProgram(this.logic);
    } catch (e) {
      return false;
    }
    const toBeSigned = concatArrays(this.tag, this.logic);
    if (!this.sig && !this.msig) {
      const hash2 = genericHash(toBeSigned);
      return arrayEqual(hash2, publicKey);
    }
    if (this.sig) {
      return verify(toBeSigned, this.sig, publicKey);
    }
    return verifyMultisig(toBeSigned, this.msig, publicKey);
  }
  /**
   * Compute hash of the logic sig program (that is the same as escrow account address) as string address
   * @returns String representation of the address
   */
  address() {
    const toBeSigned = concatArrays(this.tag, this.logic);
    const hash2 = genericHash(toBeSigned);
    return encodeAddress(new Uint8Array(hash2));
  }
  /**
   * Creates signature (if no msig provided) or multi signature otherwise
   * @param secretKey - Secret key to sign with
   * @param msig - Multisig account as \{version, threshold, addrs\}
   */
  sign(secretKey, msig) {
    if (msig == null) {
      this.sig = this.signProgram(secretKey);
    } else {
      const subsigs = msig.addrs.map((addr) => ({
        pk: decodeAddress(addr).publicKey
      }));
      this.msig = {
        v: msig.version,
        thr: msig.threshold,
        subsig: subsigs
      };
      const [sig, index2] = this.singleSignMultisig(secretKey, this.msig);
      this.msig.subsig[index2].s = sig;
    }
  }
  /**
   * Appends a signature to multi signature
   * @param secretKey - Secret key to sign with
   */
  appendToMultisig(secretKey) {
    if (this.msig === void 0) {
      throw new Error("no multisig present");
    }
    const [sig, index2] = this.singleSignMultisig(secretKey, this.msig);
    this.msig.subsig[index2].s = sig;
  }
  signProgram(secretKey) {
    const toBeSigned = concatArrays(this.tag, this.logic);
    const sig = sign(toBeSigned, secretKey);
    return sig;
  }
  singleSignMultisig(secretKey, msig) {
    let index2 = -1;
    const myPk = keyPairFromSecretKey(secretKey).publicKey;
    for (let i2 = 0; i2 < msig.subsig.length; i2++) {
      const { pk } = msig.subsig[i2];
      if (arrayEqual(pk, myPk)) {
        index2 = i2;
        break;
      }
    }
    if (index2 === -1) {
      throw new Error("invalid secret key");
    }
    const sig = this.signProgram(secretKey);
    return [sig, index2];
  }
  toByte() {
    return encode2(this.get_obj_for_encoding());
  }
  static fromByte(encoded) {
    const decodedObj = decode2(encoded);
    return LogicSig.from_obj_for_encoding(decodedObj);
  }
};
var LogicSigAccount = class {
  /**
   * Create a new LogicSigAccount. By default this will create an escrow
   * LogicSig account. Call `sign` or `signMultisig` on the newly created
   * LogicSigAccount to make it a delegated account.
   *
   * @param program - The compiled TEAL program which contains the logic for
   *   this LogicSig.
   * @param args - An optional array of arguments for the program.
   */
  constructor(program, args) {
    this.lsig = new LogicSig(program, args);
    this.sigkey = void 0;
  }
  // eslint-disable-next-line camelcase
  get_obj_for_encoding() {
    const obj = {
      lsig: this.lsig.get_obj_for_encoding()
    };
    if (this.sigkey) {
      obj.sigkey = this.sigkey;
    }
    return obj;
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(encoded) {
    const lsigAccount = new LogicSigAccount(encoded.lsig.l, encoded.lsig.arg);
    lsigAccount.lsig = LogicSig.from_obj_for_encoding(encoded.lsig);
    lsigAccount.sigkey = encoded.sigkey;
    return lsigAccount;
  }
  /**
   * Encode this object into msgpack.
   */
  toByte() {
    return encode2(this.get_obj_for_encoding());
  }
  /**
   * Decode a msgpack object into a LogicSigAccount.
   * @param encoded - The encoded LogicSigAccount.
   */
  static fromByte(encoded) {
    const decodedObj = decode2(encoded);
    return LogicSigAccount.from_obj_for_encoding(decodedObj);
  }
  /**
   * Check if this LogicSigAccount has been delegated to another account with a
   * signature.
   *
   * Note this function only checks for the presence of a delegation signature.
   * To verify the delegation signature, use `verify`.
   */
  isDelegated() {
    return !!(this.lsig.sig || this.lsig.msig);
  }
  /**
   * Verifies this LogicSig's program and signatures.
   * @returns true if and only if the LogicSig program and signatures are valid.
   */
  verify() {
    const addr = this.address();
    return this.lsig.verify(decodeAddress(addr).publicKey);
  }
  /**
   * Get the address of this LogicSigAccount.
   *
   * If the LogicSig is delegated to another account, this will return the
   * address of that account.
   *
   * If the LogicSig is not delegated to another account, this will return an
   *  escrow address that is the hash of the LogicSig's program code.
   */
  address() {
    if (this.lsig.sig && this.lsig.msig) {
      throw new Error("LogicSig has too many signatures. At most one of sig or msig may be present");
    }
    if (this.lsig.sig) {
      if (!this.sigkey) {
        throw new Error("Signing key for delegated account is missing");
      }
      return encodeAddress(this.sigkey);
    }
    if (this.lsig.msig) {
      const msigMetadata = {
        version: this.lsig.msig.v,
        threshold: this.lsig.msig.thr,
        pks: this.lsig.msig.subsig.map((subsig) => subsig.pk)
      };
      return encodeAddress(fromMultisigPreImg(msigMetadata));
    }
    return this.lsig.address();
  }
  /**
   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig
   * has the authority to sign transactions on behalf of another account, called
   * the delegating account. Use this function if the delegating account is a
   * multisig account.
   *
   * @param msig - The multisig delegating account
   * @param secretKey - The secret key of one of the members of the delegating
   *   multisig account. Use `appendToMultisig` to add additional signatures
   *   from other members.
   */
  signMultisig(msig, secretKey) {
    this.lsig.sign(secretKey, msig);
  }
  /**
   * Adds an additional signature from a member of the delegating multisig
   * account.
   *
   * @param secretKey - The secret key of one of the members of the delegating
   *   multisig account.
   */
  appendToMultisig(secretKey) {
    this.lsig.appendToMultisig(secretKey);
  }
  /**
   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig
   * has the authority to sign transactions on behalf of another account, called
   * the delegating account. If the delegating account is a multisig account,
   * use `signMultisig` instead.
   *
   * @param secretKey - The secret key of the delegating account.
   */
  sign(secretKey) {
    this.lsig.sign(secretKey);
    this.sigkey = keyPairFromSecretKey(secretKey).publicKey;
  }
};
function signLogicSigTransactionWithAddress(txn, lsig, lsigAddress) {
  if (!lsig.verify(lsigAddress)) {
    throw new Error("Logic signature verification failed. Ensure the program and signature are valid.");
  }
  const signedTxn = {
    lsig: lsig.get_obj_for_encoding(),
    txn: txn.get_obj_for_encoding()
  };
  if (!bytesEqual(lsigAddress, txn.from.publicKey)) {
    signedTxn.sgnr = Buffer.from(lsigAddress);
  }
  return {
    txID: txn.txID().toString(),
    blob: encode2(signedTxn)
  };
}
function signLogicSigTransactionObject(txn, lsigObject) {
  let lsig;
  let lsigAddress;
  if (lsigObject instanceof LogicSigAccount) {
    lsig = lsigObject.lsig;
    lsigAddress = decodeAddress(lsigObject.address()).publicKey;
  } else {
    lsig = lsigObject;
    if (lsig.sig) {
      lsigAddress = txn.from.publicKey;
    } else if (lsig.msig) {
      const msigMetadata = {
        version: lsig.msig.v,
        threshold: lsig.msig.thr,
        pks: lsig.msig.subsig.map((subsig) => subsig.pk)
      };
      lsigAddress = fromMultisigPreImg(msigMetadata);
    } else {
      lsigAddress = decodeAddress(lsig.address()).publicKey;
    }
  }
  return signLogicSigTransactionWithAddress(txn, lsig, lsigAddress);
}
function signLogicSigTransaction(txn, lsigObject) {
  const algoTxn = instantiateTxnIfNeeded(txn);
  return signLogicSigTransactionObject(algoTxn, lsigObject);
}
function logicSigFromByte(encoded) {
  return LogicSig.fromByte(encoded);
}
var SIGN_PROGRAM_DATA_PREFIX = Buffer.from("ProgData");
function tealSign(sk, data, programHash) {
  const parts2 = concatArrays(decodeAddress(programHash).publicKey, data);
  const toBeSigned = Buffer.from(concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts2));
  return sign(toBeSigned, sk);
}
function tealSignFromProgram(sk, data, program) {
  const lsig = new LogicSig(program);
  const contractAddress = lsig.address();
  return tealSign(sk, data, contractAddress);
}
var char_to_integer = {};
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("").forEach(function(char, i2) {
  char_to_integer[char] = i2;
});
function decode3(string2) {
  let result = [];
  let shift = 0;
  let value2 = 0;
  for (let i2 = 0; i2 < string2.length; i2 += 1) {
    let integer = char_to_integer[string2[i2]];
    if (integer === void 0) {
      throw new Error("Invalid character (" + string2[i2] + ")");
    }
    const has_continuation_bit = integer & 32;
    integer &= 31;
    value2 += integer << shift;
    if (has_continuation_bit) {
      shift += 5;
    } else {
      const should_negate = value2 & 1;
      value2 >>>= 1;
      if (should_negate) {
        result.push(value2 === 0 ? -2147483648 : -value2);
      } else {
        result.push(value2);
      }
      value2 = shift = 0;
    }
  }
  return result;
}
var SourceMap = class {
  constructor({ version: version3, sources, names: names3, mappings }) {
    this.version = version3;
    this.sources = sources;
    this.names = names3;
    this.mappings = mappings;
    if (this.version !== 3)
      throw new Error(`Only version 3 is supported, got ${this.version}`);
    if (this.mappings === void 0)
      throw new Error("mapping undefined, cannot build source map without `mapping`");
    const pcList = this.mappings.split(";").map((m) => {
      const decoded = decode3(m);
      if (decoded.length > 2)
        return decoded[2];
      return void 0;
    });
    this.pcToLine = {};
    this.lineToPc = {};
    let lastLine = 0;
    for (const [pc, lineDelta] of pcList.entries()) {
      if (lineDelta !== void 0) {
        lastLine += lineDelta;
      }
      if (!(lastLine in this.lineToPc))
        this.lineToPc[lastLine] = [];
      this.lineToPc[lastLine].push(pc);
      this.pcToLine[pc] = lastLine;
    }
  }
  getLineForPc(pc) {
    return this.pcToLine[pc];
  }
  getPcsForLine(line) {
    return this.lineToPc[line];
  }
};
var defaultAppId = 1380011588;
var defaultMaxWidth = 30;
function decodePrograms(ap) {
  ap.params["approval-program"] = Buffer.from(ap.params["approval-program"].toString(), "base64");
  ap.params["clear-state-program"] = Buffer.from(ap.params["clear-state-program"].toString(), "base64");
  return ap;
}
async function createDryrun({ client, txns, protocolVersion, latestTimestamp, round, sources }) {
  const appInfos = [];
  const acctInfos = [];
  const apps = [];
  const assets = [];
  const accts = [];
  for (const t of txns) {
    if (t.txn.type === TransactionType.appl) {
      accts.push(encodeAddress(t.txn.from.publicKey));
      if (t.txn.appAccounts)
        accts.push(...t.txn.appAccounts.map((a) => encodeAddress(a.publicKey)));
      if (t.txn.appForeignApps) {
        apps.push(...t.txn.appForeignApps);
        accts.push(...t.txn.appForeignApps.map((aidx) => getApplicationAddress(aidx)));
      }
      if (t.txn.appForeignAssets)
        assets.push(...t.txn.appForeignAssets);
      if (t.txn.appIndex === void 0 || t.txn.appIndex === 0) {
        appInfos.push(new Application({
          id: defaultAppId,
          params: new ApplicationParams({
            creator: encodeAddress(t.txn.from.publicKey),
            approvalProgram: t.txn.appApprovalProgram,
            clearStateProgram: t.txn.appClearProgram,
            localStateSchema: new ApplicationStateSchema({
              numUint: t.txn.appLocalInts,
              numByteSlice: t.txn.appLocalByteSlices
            }),
            globalStateSchema: new ApplicationStateSchema({
              numUint: t.txn.appGlobalInts,
              numByteSlice: t.txn.appGlobalByteSlices
            })
          })
        }));
      } else {
        apps.push(t.txn.appIndex);
        accts.push(getApplicationAddress(t.txn.appIndex));
      }
    }
  }
  const assetPromises = [];
  for (const assetId of [...new Set(assets)]) {
    assetPromises.push(client.getAssetByID(assetId).do().then((assetInfo) => {
      accts.push(assetInfo.params.creator);
    }));
  }
  await Promise.all(assetPromises);
  const appPromises = [];
  for (const appId of [...new Set(apps)]) {
    appPromises.push(client.getApplicationByID(appId).do().then((appInfo) => {
      const ai = decodePrograms(appInfo);
      appInfos.push(ai);
      accts.push(ai.params.creator);
    }));
  }
  await Promise.all(appPromises);
  const acctPromises = [];
  for (const acct of [...new Set(accts)]) {
    acctPromises.push(client.accountInformation(acct).do().then((acctInfo) => {
      if ("created-apps" in acctInfo) {
        acctInfo["created-apps"] = acctInfo["created-apps"].map((app) => decodePrograms(app));
      }
      acctInfos.push(acctInfo);
    }));
  }
  await Promise.all(acctPromises);
  return new DryrunRequest({
    txns: txns.map((st) => ({ ...st, txn: st.txn.get_obj_for_encoding() })),
    accounts: acctInfos,
    apps: appInfos,
    latestTimestamp,
    round,
    protocolVersion,
    sources
  });
}
var DryrunStackValue = class {
  constructor(sv) {
    this.type = 0;
    this.bytes = "";
    this.uint = 0;
    this.type = sv.type;
    this.bytes = sv.bytes;
    this.uint = sv.uint;
  }
  toString() {
    if (this.type === 1) {
      return `0x${Buffer.from(this.bytes, "base64").toString("hex")}`;
    }
    return this.uint.toString();
  }
};
var DryrunTraceLine = class {
  constructor(line) {
    this.error = "";
    this.line = 0;
    this.pc = 0;
    this.scratch = [];
    this.stack = [];
    this.error = line.error === void 0 ? "" : line.error;
    this.line = line.line;
    this.pc = line.pc;
    this.scratch = line.scratch;
    this.stack = line.stack.map((sv) => new DryrunStackValue(sv));
  }
};
var DryrunTrace = class {
  constructor(t) {
    this.trace = [];
    if (t == null)
      return;
    this.trace = t.map((line) => new DryrunTraceLine(line));
  }
};
function truncate(str, maxValueWidth) {
  if (str.length > maxValueWidth && maxValueWidth > 0) {
    return `${str.slice(0, maxValueWidth)}...`;
  }
  return str;
}
function scratchToString(prevScratch, currScratch) {
  if (currScratch.length === 0)
    return "";
  let newScratchIdx = null;
  for (let idx = 0; idx < currScratch.length; idx++) {
    if (idx > prevScratch.length) {
      newScratchIdx = idx;
      continue;
    }
    if (JSON.stringify(prevScratch[idx]) !== JSON.stringify(currScratch[idx])) {
      newScratchIdx = idx;
    }
  }
  if (newScratchIdx == null)
    return "";
  const newScratch = currScratch[newScratchIdx];
  if (newScratch.bytes.length > 0) {
    return `${newScratchIdx} = 0x${Buffer.from(newScratch.bytes, "base64").toString("hex")}`;
  }
  return `${newScratchIdx} = ${newScratch.uint.toString()}`;
}
function stackToString(stack, reverse) {
  const svs = reverse ? stack.reverse() : stack;
  return `[${svs.map((sv) => {
    switch (sv.type) {
      case 1:
        return `0x${Buffer.from(sv.bytes, "base64").toString("hex")}`;
      case 2:
        return `${sv.uint.toString()}`;
      default:
        return "";
    }
  }).join(", ")}]`;
}
var DryrunTransactionResult = class {
  constructor(dtr) {
    this.disassembly = [];
    this.appCallMessages = [];
    this.localDeltas = [];
    this.globalDelta = [];
    this.cost = 0;
    this.logicSigMessages = [];
    this.logicSigDisassembly = [];
    this.logs = [];
    this.appCallTrace = void 0;
    this.logicSigTrace = void 0;
    this.required = ["disassembly"];
    this.optionals = [
      "app-call-messages",
      "local-deltas",
      "globalThis-delta",
      "cost",
      "logic-sig-messages",
      "logic-sig-disassembly",
      "logs"
    ];
    this.traces = ["app-call-trace", "logic-sig-trace"];
    this.disassembly = dtr.disassembly;
    this.appCallMessages = dtr["app-call-messages"];
    this.localDeltas = dtr["local-deltas"];
    this.globalDelta = dtr["globalThis-delta"];
    this.cost = dtr.cost;
    this.logicSigMessages = dtr["logic-sig-messages"];
    this.logicSigDisassembly = dtr["logic-sig-disassembly"];
    this.logs = dtr.logs;
    this.appCallTrace = new DryrunTrace(dtr["app-call-trace"]);
    this.logicSigTrace = new DryrunTrace(dtr["logic-sig-trace"]);
  }
  appCallRejected() {
    return this.appCallMessages !== void 0 && this.appCallMessages.includes("REJECT");
  }
  logicSigRejected() {
    return this.logicSigMessages !== void 0 && this.logicSigMessages.includes("REJECT");
  }
  static trace(drt, disassembly, spc) {
    const maxWidth = spc.maxValueWidth || defaultMaxWidth;
    const lines = [["pc#", "ln#", "source", "scratch", "stack"]];
    for (let idx = 0; idx < drt.trace.length; idx++) {
      const { line, error, pc, scratch, stack } = drt.trace[idx];
      const currScratch = scratch !== void 0 ? scratch : [];
      const prevScratch = idx > 0 && drt.trace[idx - 1].scratch !== void 0 ? drt.trace[idx - 1].scratch : [];
      const src2 = error === "" ? disassembly[line] : `!! ${error} !!`;
      lines.push([
        pc.toString().padEnd(3, " "),
        line.toString().padEnd(3, " "),
        truncate(src2, maxWidth),
        truncate(scratchToString(prevScratch, currScratch), maxWidth),
        truncate(stackToString(stack, spc.topOfStackFirst), maxWidth)
      ]);
    }
    const maxLengths = lines.reduce((prev2, curr) => {
      const newVal = new Array(lines[0].length).fill(0);
      for (let idx = 0; idx < prev2.length; idx++) {
        newVal[idx] = curr[idx].length > prev2[idx] ? curr[idx].length : prev2[idx];
      }
      return newVal;
    }, new Array(lines[0].length).fill(0));
    return `${lines.map((line) => line.map((v, idx) => v.padEnd(maxLengths[idx] + 1, " ")).join("|").trim()).join("\n")}
`;
  }
  appTrace(spc) {
    if (this.appCallTrace === void 0 || !this.disassembly)
      return "";
    let conf = spc;
    if (spc === void 0)
      conf = {
        maxValueWidth: defaultMaxWidth,
        topOfStackFirst: false
      };
    return DryrunTransactionResult.trace(this.appCallTrace, this.disassembly, conf);
  }
  lsigTrace(spc) {
    if (this.logicSigTrace === void 0 || this.logicSigDisassembly === void 0)
      return "";
    let conf = spc;
    if (spc === void 0)
      conf = {
        maxValueWidth: defaultMaxWidth,
        topOfStackFirst: true
      };
    return DryrunTransactionResult.trace(this.logicSigTrace, this.logicSigDisassembly, conf);
  }
};
var DryrunResult = class {
  constructor(drrResp) {
    this.error = "";
    this.protocolVersion = "";
    this.txns = [];
    this.error = drrResp.error;
    this.protocolVersion = drrResp["protocol-version"];
    this.txns = drrResp.txns.map((txn) => new DryrunTransactionResult(txn));
  }
};
function makePaymentTxnWithSuggestedParams(from2, to, amount, closeRemainderTo, note, suggestedParams, rekeyTo) {
  const o = {
    from: from2,
    to,
    amount,
    closeRemainderTo,
    note,
    suggestedParams,
    type: TransactionType.pay,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makePaymentTxnWithSuggestedParamsFromObject(o) {
  return makePaymentTxnWithSuggestedParams(o.from, o.to, o.amount, o.closeRemainderTo, o.note, o.suggestedParams, o.rekeyTo);
}
function makeKeyRegistrationTxnWithSuggestedParams(from2, note, voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution, suggestedParams, rekeyTo, nonParticipation = false, stateProofKey = void 0) {
  const o = {
    from: from2,
    note,
    voteKey,
    selectionKey,
    voteFirst,
    voteLast,
    voteKeyDilution,
    suggestedParams,
    type: TransactionType.keyreg,
    reKeyTo: rekeyTo,
    nonParticipation,
    stateProofKey
  };
  return new Transaction(o);
}
function makeKeyRegistrationTxnWithSuggestedParamsFromObject(o) {
  return makeKeyRegistrationTxnWithSuggestedParams(o.from, o.note, o.voteKey, o.selectionKey, o.voteFirst, o.voteLast, o.voteKeyDilution, o.suggestedParams, o.rekeyTo, o.nonParticipation, o.stateProofKey);
}
function makeAssetCreateTxnWithSuggestedParams(from2, note, total, decimals, defaultFrozen, manager, reserve, freeze, clawback, unitName, assetName, assetURL, assetMetadataHash, suggestedParams, rekeyTo) {
  const o = {
    from: from2,
    note,
    suggestedParams,
    assetTotal: total,
    assetDecimals: decimals,
    assetDefaultFrozen: defaultFrozen,
    assetUnitName: unitName,
    assetName,
    assetURL,
    assetMetadataHash,
    assetManager: manager,
    assetReserve: reserve,
    assetFreeze: freeze,
    assetClawback: clawback,
    type: TransactionType.acfg,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeAssetCreateTxnWithSuggestedParamsFromObject(o) {
  return makeAssetCreateTxnWithSuggestedParams(o.from, o.note, o.total, o.decimals, o.defaultFrozen, o.manager, o.reserve, o.freeze, o.clawback, o.unitName, o.assetName, o.assetURL, o.assetMetadataHash, o.suggestedParams, o.rekeyTo);
}
function makeAssetConfigTxnWithSuggestedParams(from2, note, assetIndex, manager, reserve, freeze, clawback, suggestedParams, strictEmptyAddressChecking = true, rekeyTo) {
  if (strictEmptyAddressChecking && (manager === void 0 || reserve === void 0 || freeze === void 0 || clawback === void 0)) {
    throw Error("strict empty address checking was turned on, but at least one empty address was provided");
  }
  const o = {
    from: from2,
    suggestedParams,
    assetIndex,
    assetManager: manager,
    assetReserve: reserve,
    assetFreeze: freeze,
    assetClawback: clawback,
    type: TransactionType.acfg,
    note,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeAssetConfigTxnWithSuggestedParamsFromObject(o) {
  return makeAssetConfigTxnWithSuggestedParams(o.from, o.note, o.assetIndex, o.manager, o.reserve, o.freeze, o.clawback, o.suggestedParams, o.strictEmptyAddressChecking, o.rekeyTo);
}
function makeAssetDestroyTxnWithSuggestedParams(from2, note, assetIndex, suggestedParams, rekeyTo) {
  const o = {
    from: from2,
    suggestedParams,
    assetIndex,
    type: TransactionType.acfg,
    note,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeAssetDestroyTxnWithSuggestedParamsFromObject(o) {
  return makeAssetDestroyTxnWithSuggestedParams(o.from, o.note, o.assetIndex, o.suggestedParams, o.rekeyTo);
}
function makeAssetFreezeTxnWithSuggestedParams(from2, note, assetIndex, freezeTarget, freezeState, suggestedParams, rekeyTo) {
  const o = {
    from: from2,
    type: TransactionType.afrz,
    freezeAccount: freezeTarget,
    assetIndex,
    freezeState,
    note,
    suggestedParams,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeAssetFreezeTxnWithSuggestedParamsFromObject(o) {
  return makeAssetFreezeTxnWithSuggestedParams(o.from, o.note, o.assetIndex, o.freezeTarget, o.freezeState, o.suggestedParams, o.rekeyTo);
}
function makeAssetTransferTxnWithSuggestedParams(from2, to, closeRemainderTo, revocationTarget, amount, note, assetIndex, suggestedParams, rekeyTo) {
  const o = {
    type: TransactionType.axfer,
    from: from2,
    to,
    amount,
    suggestedParams,
    assetIndex,
    note,
    assetRevocationTarget: revocationTarget,
    closeRemainderTo,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeAssetTransferTxnWithSuggestedParamsFromObject(o) {
  return makeAssetTransferTxnWithSuggestedParams(o.from, o.to, o.closeRemainderTo, o.revocationTarget, o.amount, o.note, o.assetIndex, o.suggestedParams, o.rekeyTo);
}
function makeApplicationCreateTxn(from2, suggestedParams, onComplete, approvalProgram, clearProgram, numLocalInts, numLocalByteSlices, numGlobalInts, numGlobalByteSlices, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, extraPages, boxes) {
  const o = {
    type: TransactionType.appl,
    from: from2,
    suggestedParams,
    appIndex: 0,
    appOnComplete: onComplete,
    appLocalInts: numLocalInts,
    appLocalByteSlices: numLocalByteSlices,
    appGlobalInts: numGlobalInts,
    appGlobalByteSlices: numGlobalByteSlices,
    appApprovalProgram: approvalProgram,
    appClearProgram: clearProgram,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo,
    extraPages
  };
  return new Transaction(o);
}
function makeApplicationCreateTxnFromObject(o) {
  return makeApplicationCreateTxn(o.from, o.suggestedParams, o.onComplete, o.approvalProgram, o.clearProgram, o.numLocalInts, o.numLocalByteSlices, o.numGlobalInts, o.numGlobalByteSlices, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.extraPages, o.boxes);
}
function makeApplicationUpdateTxn(from2, suggestedParams, appIndex, approvalProgram, clearProgram, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, boxes) {
  const o = {
    type: TransactionType.appl,
    from: from2,
    suggestedParams,
    appIndex,
    appApprovalProgram: approvalProgram,
    appOnComplete: OnApplicationComplete.UpdateApplicationOC,
    appClearProgram: clearProgram,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeApplicationUpdateTxnFromObject(o) {
  return makeApplicationUpdateTxn(o.from, o.suggestedParams, o.appIndex, o.approvalProgram, o.clearProgram, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.boxes);
}
function makeApplicationDeleteTxn(from2, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, boxes) {
  const o = {
    type: TransactionType.appl,
    from: from2,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.DeleteApplicationOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeApplicationDeleteTxnFromObject(o) {
  return makeApplicationDeleteTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.boxes);
}
function makeApplicationOptInTxn(from2, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, boxes) {
  const o = {
    type: TransactionType.appl,
    from: from2,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.OptInOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeApplicationOptInTxnFromObject(o) {
  return makeApplicationOptInTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.boxes);
}
function makeApplicationCloseOutTxn(from2, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, boxes) {
  const o = {
    type: TransactionType.appl,
    from: from2,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.CloseOutOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeApplicationCloseOutTxnFromObject(o) {
  return makeApplicationCloseOutTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.boxes);
}
function makeApplicationClearStateTxn(from2, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, boxes) {
  const o = {
    type: TransactionType.appl,
    from: from2,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.ClearStateOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeApplicationClearStateTxnFromObject(o) {
  return makeApplicationClearStateTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.boxes);
}
function makeApplicationNoOpTxn(from2, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, boxes) {
  const o = {
    type: TransactionType.appl,
    from: from2,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.NoOpOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeApplicationNoOpTxnFromObject(o) {
  return makeApplicationNoOpTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.boxes);
}
function makeApplicationCallTxnFromObject(options) {
  const o = {
    type: TransactionType.appl,
    from: options.from,
    suggestedParams: options.suggestedParams,
    appIndex: options.appIndex,
    appOnComplete: options.onComplete,
    appLocalInts: options.numLocalInts,
    appLocalByteSlices: options.numLocalByteSlices,
    appGlobalInts: options.numGlobalInts,
    appGlobalByteSlices: options.numGlobalByteSlices,
    appApprovalProgram: options.approvalProgram,
    appClearProgram: options.clearProgram,
    appArgs: options.appArgs,
    appAccounts: options.accounts,
    appForeignApps: options.foreignApps,
    appForeignAssets: options.foreignAssets,
    boxes: options.boxes,
    note: options.note,
    lease: options.lease,
    reKeyTo: options.rekeyTo,
    extraPages: options.extraPages
  };
  return new Transaction(o);
}
function makeBasicAccountTransactionSigner(account) {
  return (txnGroup, indexesToSign) => {
    const signed = [];
    for (const index2 of indexesToSign) {
      signed.push(txnGroup[index2].signTxn(account.sk));
    }
    return Promise.resolve(signed);
  };
}
function makeLogicSigAccountTransactionSigner(account) {
  return (txnGroup, indexesToSign) => {
    const signed = [];
    for (const index2 of indexesToSign) {
      const { blob } = signLogicSigTransactionObject(txnGroup[index2], account);
      signed.push(blob);
    }
    return Promise.resolve(signed);
  };
}
function makeMultiSigAccountTransactionSigner(msig, sks) {
  return (txnGroup, indexesToSign) => {
    const signed = [];
    for (const index2 of indexesToSign) {
      const txn = txnGroup[index2];
      const partialSigs = [];
      for (const sk of sks) {
        const { blob } = signMultisigTransaction(txn, msig, sk);
        partialSigs.push(blob);
      }
      signed.push(mergeMultisigTransactions(partialSigs));
    }
    return Promise.resolve(signed);
  };
}
function isTransactionWithSigner(value2) {
  return typeof value2 === "object" && Object.keys(value2).length === 2 && typeof value2.txn === "object" && typeof value2.signer === "function";
}
var MAX_LEN = 2 ** 16 - 1;
var ADDR_BYTE_SIZE = 32;
var SINGLE_BYTE_SIZE = 1;
var SINGLE_BOOL_SIZE = 1;
var LENGTH_ENCODE_BYTE_SIZE = 2;
var staticArrayRegexp = /^([a-z\d[\](),]+)\[(0|[1-9][\d]*)]$/;
var ufixedRegexp = /^ufixed([1-9][\d]*)x([1-9][\d]*)$/;
var ABIType = class {
  // De-serializes the ABI type from a string using the ABI specs
  static from(str) {
    if (str.endsWith("[]")) {
      const arrayArgType = ABIType.from(str.slice(0, str.length - 2));
      return new ABIArrayDynamicType(arrayArgType);
    }
    if (str.endsWith("]")) {
      const stringMatches = str.match(staticArrayRegexp);
      if (stringMatches.length !== 3) {
        throw new Error(`malformed static array string: ${str}`);
      }
      const arrayLengthStr = stringMatches[2];
      const arrayLength = parseInt(arrayLengthStr, 10);
      if (arrayLength > MAX_LEN) {
        throw new Error(`array length exceeds limit ${MAX_LEN}`);
      }
      const arrayType = ABIType.from(stringMatches[1]);
      return new ABIArrayStaticType(arrayType, arrayLength);
    }
    if (str.startsWith("uint")) {
      const digitsOnly = (string2) => [...string2].every((c) => "0123456789".includes(c));
      const typeSizeStr = str.slice(4, str.length);
      if (!digitsOnly(typeSizeStr)) {
        throw new Error(`malformed uint string: ${typeSizeStr}`);
      }
      const typeSize = parseInt(typeSizeStr, 10);
      if (typeSize > MAX_LEN) {
        throw new Error(`malformed uint string: ${typeSize}`);
      }
      return new ABIUintType(typeSize);
    }
    if (str === "byte") {
      return new ABIByteType();
    }
    if (str.startsWith("ufixed")) {
      const stringMatches = str.match(ufixedRegexp);
      if (stringMatches.length !== 3) {
        throw new Error(`malformed ufixed type: ${str}`);
      }
      const ufixedSize = parseInt(stringMatches[1], 10);
      const ufixedPrecision = parseInt(stringMatches[2], 10);
      return new ABIUfixedType(ufixedSize, ufixedPrecision);
    }
    if (str === "bool") {
      return new ABIBoolType();
    }
    if (str === "address") {
      return new ABIAddressType();
    }
    if (str === "string") {
      return new ABIStringType();
    }
    if (str.length >= 2 && str[0] === "(" && str[str.length - 1] === ")") {
      const tupleContent = ABITupleType.parseTupleContent(str.slice(1, str.length - 1));
      const tupleTypes = [];
      for (let i2 = 0; i2 < tupleContent.length; i2++) {
        const ti = ABIType.from(tupleContent[i2]);
        tupleTypes.push(ti);
      }
      return new ABITupleType(tupleTypes);
    }
    throw new Error(`cannot convert a string ${str} to an ABI type`);
  }
};
var ABIUintType = class extends ABIType {
  constructor(size) {
    super();
    if (size % 8 !== 0 || size < 8 || size > 512) {
      throw new Error(`unsupported uint type bitSize: ${size}`);
    }
    this.bitSize = size;
  }
  toString() {
    return `uint${this.bitSize}`;
  }
  equals(other) {
    return other instanceof ABIUintType && this.bitSize === other.bitSize;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return this.bitSize / 8;
  }
  encode(value2) {
    if (typeof value2 !== "bigint" && typeof value2 !== "number") {
      throw new Error(`Cannot encode value as uint${this.bitSize}: ${value2}`);
    }
    if (value2 >= BigInt(2 ** this.bitSize) || value2 < BigInt(0)) {
      throw new Error(`${value2} is not a non-negative int or too big to fit in size uint${this.bitSize}`);
    }
    if (typeof value2 === "number" && !Number.isSafeInteger(value2)) {
      throw new Error(`${value2} should be converted into a BigInt before it is encoded`);
    }
    return bigIntToBytes(value2, this.bitSize / 8);
  }
  decode(byteString) {
    if (byteString.length !== this.bitSize / 8) {
      throw new Error(`byte string must correspond to a uint${this.bitSize}`);
    }
    return bytesToBigInt(byteString);
  }
};
var ABIUfixedType = class extends ABIType {
  constructor(size, denominator) {
    super();
    if (size % 8 !== 0 || size < 8 || size > 512) {
      throw new Error(`unsupported ufixed type bitSize: ${size}`);
    }
    if (denominator > 160 || denominator < 1) {
      throw new Error(`unsupported ufixed type precision: ${denominator}`);
    }
    this.bitSize = size;
    this.precision = denominator;
  }
  toString() {
    return `ufixed${this.bitSize}x${this.precision}`;
  }
  equals(other) {
    return other instanceof ABIUfixedType && this.bitSize === other.bitSize && this.precision === other.precision;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return this.bitSize / 8;
  }
  encode(value2) {
    if (typeof value2 !== "bigint" && typeof value2 !== "number") {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value2}`);
    }
    if (value2 >= BigInt(2 ** this.bitSize) || value2 < BigInt(0)) {
      throw new Error(`${value2} is not a non-negative int or too big to fit in size ${this.toString()}`);
    }
    if (typeof value2 === "number" && !Number.isSafeInteger(value2)) {
      throw new Error(`${value2} should be converted into a BigInt before it is encoded`);
    }
    return bigIntToBytes(value2, this.bitSize / 8);
  }
  decode(byteString) {
    if (byteString.length !== this.bitSize / 8) {
      throw new Error(`byte string must correspond to a ${this.toString()}`);
    }
    return bytesToBigInt(byteString);
  }
};
var ABIAddressType = class extends ABIType {
  toString() {
    return "address";
  }
  equals(other) {
    return other instanceof ABIAddressType;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return ADDR_BYTE_SIZE;
  }
  encode(value2) {
    if (typeof value2 !== "string" && !(value2 instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value2}`);
    }
    if (typeof value2 === "string") {
      const decodedAddress = decodeAddress(value2);
      return decodedAddress.publicKey;
    }
    if (value2.byteLength !== 32) {
      throw new Error(`byte string must be 32 bytes long for an address`);
    }
    return value2;
  }
  decode(byteString) {
    if (byteString.byteLength !== 32) {
      throw new Error(`byte string must be 32 bytes long for an address`);
    }
    return encodeAddress(byteString);
  }
};
var ABIBoolType = class extends ABIType {
  toString() {
    return "bool";
  }
  equals(other) {
    return other instanceof ABIBoolType;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return SINGLE_BOOL_SIZE;
  }
  encode(value2) {
    if (typeof value2 !== "boolean") {
      throw new Error(`Cannot encode value as bool: ${value2}`);
    }
    if (value2) {
      return new Uint8Array([128]);
    }
    return new Uint8Array([0]);
  }
  decode(byteString) {
    if (byteString.byteLength !== 1) {
      throw new Error(`bool string must be 1 byte long`);
    }
    const value2 = byteString[0];
    if (value2 === 128) {
      return true;
    }
    if (value2 === 0) {
      return false;
    }
    throw new Error(`boolean could not be decoded from the byte string`);
  }
};
var ABIByteType = class extends ABIType {
  toString() {
    return "byte";
  }
  equals(other) {
    return other instanceof ABIByteType;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return SINGLE_BYTE_SIZE;
  }
  encode(value2) {
    if (typeof value2 !== "number" && typeof value2 !== "bigint") {
      throw new Error(`Cannot encode value as byte: ${value2}`);
    }
    if (typeof value2 === "bigint") {
      value2 = Number(value2);
    }
    if (value2 < 0 || value2 > 255) {
      throw new Error(`${value2} cannot be encoded into a byte`);
    }
    return new Uint8Array([value2]);
  }
  decode(byteString) {
    if (byteString.byteLength !== 1) {
      throw new Error(`byte string must be 1 byte long`);
    }
    return byteString[0];
  }
};
var ABIStringType = class extends ABIType {
  toString() {
    return "string";
  }
  equals(other) {
    return other instanceof ABIStringType;
  }
  isDynamic() {
    return true;
  }
  byteLen() {
    throw new Error(`${this.toString()} is a dynamic type`);
  }
  encode(value2) {
    if (typeof value2 !== "string" && !(value2 instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as string: ${value2}`);
    }
    const encodedBytes = Buffer.from(value2);
    const encodedLength = bigIntToBytes(encodedBytes.length, LENGTH_ENCODE_BYTE_SIZE);
    const mergedBytes = new Uint8Array(encodedBytes.length + LENGTH_ENCODE_BYTE_SIZE);
    mergedBytes.set(encodedLength);
    mergedBytes.set(encodedBytes, LENGTH_ENCODE_BYTE_SIZE);
    return mergedBytes;
  }
  decode(byteString) {
    if (byteString.length < LENGTH_ENCODE_BYTE_SIZE) {
      throw new Error(`byte string is too short to be decoded. Actual length is ${byteString.length}, but expected at least ${LENGTH_ENCODE_BYTE_SIZE}`);
    }
    const buf2 = Buffer.from(byteString);
    const byteLength2 = buf2.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);
    const byteValue = byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length);
    if (byteLength2 !== byteValue.length) {
      throw new Error(`string length bytes do not match the actual length of string. Expected ${byteLength2}, got ${byteValue.length}`);
    }
    return Buffer.from(byteValue).toString("utf-8");
  }
};
var ABIArrayStaticType = class extends ABIType {
  constructor(argType, arrayLength) {
    super();
    if (arrayLength < 0) {
      throw new Error(`static array must have a non negative length: ${arrayLength}`);
    }
    this.childType = argType;
    this.staticLength = arrayLength;
  }
  toString() {
    return `${this.childType.toString()}[${this.staticLength}]`;
  }
  equals(other) {
    return other instanceof ABIArrayStaticType && this.staticLength === other.staticLength && this.childType.equals(other.childType);
  }
  isDynamic() {
    return this.childType.isDynamic();
  }
  byteLen() {
    if (this.childType.constructor === ABIBoolType) {
      return Math.ceil(this.staticLength / 8);
    }
    return this.staticLength * this.childType.byteLen();
  }
  encode(value2) {
    if (!Array.isArray(value2) && !(value2 instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value2}`);
    }
    if (value2.length !== this.staticLength) {
      throw new Error(`Value array does not match static array length. Expected ${this.staticLength}, got ${value2.length}`);
    }
    const convertedTuple = this.toABITupleType();
    return convertedTuple.encode(value2);
  }
  decode(byteString) {
    const convertedTuple = this.toABITupleType();
    return convertedTuple.decode(byteString);
  }
  toABITupleType() {
    return new ABITupleType(Array(this.staticLength).fill(this.childType));
  }
};
var ABIArrayDynamicType = class extends ABIType {
  constructor(argType) {
    super();
    this.childType = argType;
  }
  toString() {
    return `${this.childType.toString()}[]`;
  }
  equals(other) {
    return other instanceof ABIArrayDynamicType && this.childType.equals(other.childType);
  }
  isDynamic() {
    return true;
  }
  byteLen() {
    throw new Error(`${this.toString()} is a dynamic type`);
  }
  encode(value2) {
    if (!Array.isArray(value2) && !(value2 instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value2}`);
    }
    const convertedTuple = this.toABITupleType(value2.length);
    const encodedTuple = convertedTuple.encode(value2);
    const encodedLength = bigIntToBytes(convertedTuple.childTypes.length, LENGTH_ENCODE_BYTE_SIZE);
    const mergedBytes = concatArrays(encodedLength, encodedTuple);
    return mergedBytes;
  }
  decode(byteString) {
    const buf2 = Buffer.from(byteString);
    const byteLength2 = buf2.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);
    const convertedTuple = this.toABITupleType(byteLength2);
    return convertedTuple.decode(byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length));
  }
  toABITupleType(length3) {
    return new ABITupleType(Array(length3).fill(this.childType));
  }
};
var ABITupleType = class extends ABIType {
  constructor(argTypes) {
    super();
    if (argTypes.length >= MAX_LEN) {
      throw new Error("tuple type child type number larger than maximum uint16 error");
    }
    this.childTypes = argTypes;
  }
  toString() {
    const typeStrings = [];
    for (let i2 = 0; i2 < this.childTypes.length; i2++) {
      typeStrings[i2] = this.childTypes[i2].toString();
    }
    return `(${typeStrings.join(",")})`;
  }
  equals(other) {
    return other instanceof ABITupleType && this.childTypes.length === other.childTypes.length && this.childTypes.every((child, index2) => child.equals(other.childTypes[index2]));
  }
  isDynamic() {
    const isDynamic = (child) => child.isDynamic();
    return this.childTypes.some(isDynamic);
  }
  byteLen() {
    let size = 0;
    for (let i2 = 0; i2 < this.childTypes.length; i2++) {
      if (this.childTypes[i2].constructor === ABIBoolType) {
        const after = findBoolLR(this.childTypes, i2, 1);
        const boolNum = after + 1;
        i2 += after;
        size += Math.trunc((boolNum + 7) / 8);
      } else {
        const childByteSize = this.childTypes[i2].byteLen();
        size += childByteSize;
      }
    }
    return size;
  }
  encode(value2) {
    if (!Array.isArray(value2) && !(value2 instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value2}`);
    }
    const values = Array.from(value2);
    if (value2.length > MAX_LEN) {
      throw new Error("length of tuple array should not exceed a uint16");
    }
    const tupleTypes = this.childTypes;
    const heads = [];
    const tails = [];
    const isDynamicIndex = /* @__PURE__ */ new Map();
    let i2 = 0;
    while (i2 < tupleTypes.length) {
      const tupleType = tupleTypes[i2];
      if (tupleType.isDynamic()) {
        isDynamicIndex.set(heads.length, true);
        heads.push(new Uint8Array([0, 0]));
        tails.push(tupleType.encode(values[i2]));
      } else {
        if (tupleType.constructor === ABIBoolType) {
          const before = findBoolLR(tupleTypes, i2, -1);
          let after = findBoolLR(tupleTypes, i2, 1);
          if (before % 8 !== 0) {
            throw new Error("expected before index should have number of bool mod 8 equal 0");
          }
          after = Math.min(7, after);
          const compressedInt = compressMultipleBool(values.slice(i2, i2 + after + 1));
          heads.push(bigIntToBytes(compressedInt, 1));
          i2 += after;
        } else {
          const encodedTupleValue = tupleType.encode(values[i2]);
          heads.push(encodedTupleValue);
        }
        isDynamicIndex.set(i2, false);
        tails.push(new Uint8Array());
      }
      i2 += 1;
    }
    let headLength = 0;
    for (const headElement of heads) {
      headLength += headElement.length;
    }
    let tailLength = 0;
    for (let j = 0; j < heads.length; j++) {
      if (isDynamicIndex.get(j)) {
        const headValue = headLength + tailLength;
        if (headValue > MAX_LEN) {
          throw new Error(`byte length of ${headValue} should not exceed a uint16`);
        }
        heads[j] = bigIntToBytes(headValue, LENGTH_ENCODE_BYTE_SIZE);
      }
      tailLength += tails[j].length;
    }
    return concatArrays(...heads, ...tails);
  }
  decode(byteString) {
    const tupleTypes = this.childTypes;
    const dynamicSegments = [];
    const valuePartition = [];
    let i2 = 0;
    let iterIndex = 0;
    const buf2 = Buffer.from(byteString);
    while (i2 < tupleTypes.length) {
      const tupleType = tupleTypes[i2];
      if (tupleType.isDynamic()) {
        if (byteString.slice(iterIndex, byteString.length).length < LENGTH_ENCODE_BYTE_SIZE) {
          throw new Error("dynamic type in tuple is too short to be decoded");
        }
        const dynamicIndex = buf2.readUIntBE(iterIndex, LENGTH_ENCODE_BYTE_SIZE);
        if (dynamicSegments.length > 0) {
          dynamicSegments[dynamicSegments.length - 1].right = dynamicIndex;
          if (dynamicIndex < dynamicSegments[dynamicSegments.length - 1].left) {
            throw new Error("dynamic index segment miscalculation: left is greater than right index");
          }
        }
        const seg = {
          left: dynamicIndex,
          right: -1
        };
        dynamicSegments.push(seg);
        valuePartition.push(null);
        iterIndex += LENGTH_ENCODE_BYTE_SIZE;
      } else {
        if (tupleType.constructor === ABIBoolType) {
          const before = findBoolLR(this.childTypes, i2, -1);
          let after = findBoolLR(this.childTypes, i2, 1);
          if (before % 8 !== 0) {
            throw new Error("expected before bool number mod 8 === 0");
          }
          after = Math.min(7, after);
          for (let boolIndex = 0; boolIndex <= after; boolIndex++) {
            const boolMask = 128 >> boolIndex;
            if ((byteString[iterIndex] & boolMask) > 0) {
              valuePartition.push(new Uint8Array([128]));
            } else {
              valuePartition.push(new Uint8Array([0]));
            }
          }
          i2 += after;
          iterIndex += 1;
        } else {
          const currLen = tupleType.byteLen();
          valuePartition.push(byteString.slice(iterIndex, iterIndex + currLen));
          iterIndex += currLen;
        }
      }
      if (i2 !== tupleTypes.length - 1 && iterIndex >= byteString.length) {
        throw new Error("input byte not enough to decode");
      }
      i2 += 1;
    }
    if (dynamicSegments.length > 0) {
      dynamicSegments[dynamicSegments.length - 1].right = byteString.length;
      iterIndex = byteString.length;
    }
    if (iterIndex < byteString.length) {
      throw new Error("input byte not fully consumed");
    }
    for (let j = 0; j < dynamicSegments.length; j++) {
      const seg = dynamicSegments[j];
      if (seg.left > seg.right) {
        throw new Error("dynamic segment should display a [l, r] space with l <= r");
      }
      if (j !== dynamicSegments.length - 1 && seg.right !== dynamicSegments[j + 1].left) {
        throw new Error("dynamic segment should be consecutive");
      }
    }
    let segIndex = 0;
    for (let j = 0; j < tupleTypes.length; j++) {
      if (tupleTypes[j].isDynamic()) {
        valuePartition[j] = byteString.slice(dynamicSegments[segIndex].left, dynamicSegments[segIndex].right);
        segIndex += 1;
      }
    }
    const returnValues = [];
    for (let j = 0; j < tupleTypes.length; j++) {
      const valueTi = tupleTypes[j].decode(valuePartition[j]);
      returnValues.push(valueTi);
    }
    return returnValues;
  }
  static parseTupleContent(str) {
    if (str.length === 0) {
      return [];
    }
    if (str.endsWith(",") || str.startsWith(",")) {
      throw new Error("tuple string should not start with comma");
    }
    if (str.includes(",,")) {
      throw new Error("tuple string should not have consecutive commas");
    }
    const tupleStrings = [];
    let depth = 0;
    let word2 = "";
    for (const char of str) {
      word2 += char;
      if (char === "(") {
        depth += 1;
      } else if (char === ")") {
        depth -= 1;
      } else if (char === ",") {
        if (depth === 0) {
          tupleStrings.push(word2.slice(0, word2.length - 1));
          word2 = "";
        }
      }
    }
    if (word2.length !== 0) {
      tupleStrings.push(word2);
    }
    if (depth !== 0) {
      throw new Error("tuple string has mismatched parentheses");
    }
    return tupleStrings;
  }
};
function compressMultipleBool(valueList) {
  let res = 0;
  if (valueList.length > 8) {
    throw new Error("value list passed in should be no greater than length 8");
  }
  for (let i2 = 0; i2 < valueList.length; i2++) {
    const boolVal = valueList[i2];
    if (typeof boolVal !== "boolean") {
      throw new Error("non-boolean values cannot be compressed into a byte");
    }
    if (boolVal) {
      res |= 1 << 7 - i2;
    }
  }
  return res;
}
function findBoolLR(typeList, index2, delta) {
  let until = 0;
  while (true) {
    const curr = index2 + delta * until;
    if (typeList[curr].constructor === ABIBoolType) {
      if (curr !== typeList.length - 1 && delta === 1) {
        until += 1;
      } else if (curr > 0 && delta === -1) {
        until += 1;
      } else {
        break;
      }
    } else {
      until -= 1;
      break;
    }
  }
  return until;
}
var ABITransactionType;
(function(ABITransactionType2) {
  ABITransactionType2["any"] = "txn";
  ABITransactionType2["pay"] = "pay";
  ABITransactionType2["keyreg"] = "keyreg";
  ABITransactionType2["acfg"] = "acfg";
  ABITransactionType2["axfer"] = "axfer";
  ABITransactionType2["afrz"] = "afrz";
  ABITransactionType2["appl"] = "appl";
})(ABITransactionType || (ABITransactionType = {}));
function abiTypeIsTransaction(type) {
  return type === ABITransactionType.any || type === ABITransactionType.pay || type === ABITransactionType.keyreg || type === ABITransactionType.acfg || type === ABITransactionType.axfer || type === ABITransactionType.afrz || type === ABITransactionType.appl;
}
function abiCheckTransactionType(type, txn) {
  if (type === ABITransactionType.any) {
    return true;
  }
  return txn.type && txn.type.toString() === type.toString();
}
var ABIReferenceType;
(function(ABIReferenceType2) {
  ABIReferenceType2["account"] = "account";
  ABIReferenceType2["application"] = "application";
  ABIReferenceType2["asset"] = "asset";
})(ABIReferenceType || (ABIReferenceType = {}));
function abiTypeIsReference(type) {
  return type === ABIReferenceType.account || type === ABIReferenceType.application || type === ABIReferenceType.asset;
}
function parseMethodSignature(signature) {
  const argsStart = signature.indexOf("(");
  if (argsStart === -1) {
    throw new Error(`Invalid method signature: ${signature}`);
  }
  let argsEnd = -1;
  let depth = 0;
  for (let i2 = argsStart; i2 < signature.length; i2++) {
    const char = signature[i2];
    if (char === "(") {
      depth += 1;
    } else if (char === ")") {
      if (depth === 0) {
        break;
      }
      depth -= 1;
      if (depth === 0) {
        argsEnd = i2;
        break;
      }
    }
  }
  if (argsEnd === -1) {
    throw new Error(`Invalid method signature: ${signature}`);
  }
  return {
    name: signature.slice(0, argsStart),
    args: ABITupleType.parseTupleContent(signature.slice(argsStart + 1, argsEnd)),
    returns: signature.slice(argsEnd + 1)
  };
}
var ABIMethod = class {
  constructor(params) {
    if (typeof params.name !== "string" || typeof params.returns !== "object" || !Array.isArray(params.args)) {
      throw new Error("Invalid ABIMethod parameters");
    }
    this.name = params.name;
    this.description = params.desc;
    this.args = params.args.map(({ type, name: name9, desc }) => {
      if (abiTypeIsTransaction(type) || abiTypeIsReference(type)) {
        return {
          type,
          name: name9,
          description: desc
        };
      }
      return {
        type: ABIType.from(type),
        name: name9,
        description: desc
      };
    });
    this.returns = {
      type: params.returns.type === "void" ? params.returns.type : ABIType.from(params.returns.type),
      description: params.returns.desc
    };
  }
  getSignature() {
    const args = this.args.map((arg) => arg.type.toString()).join(",");
    const returns = this.returns.type.toString();
    return `${this.name}(${args})${returns}`;
  }
  getSelector() {
    const hash2 = genericHash(this.getSignature());
    return new Uint8Array(hash2.slice(0, 4));
  }
  txnCount() {
    let count = 1;
    for (const arg of this.args) {
      if (typeof arg.type === "string" && abiTypeIsTransaction(arg.type)) {
        count += 1;
      }
    }
    return count;
  }
  toJSON() {
    return {
      name: this.name,
      desc: this.description,
      args: this.args.map(({ type, name: name9, description }) => ({
        type: type.toString(),
        name: name9,
        desc: description
      })),
      returns: {
        type: this.returns.type.toString(),
        desc: this.returns.description
      }
    };
  }
  static fromSignature(signature) {
    const { name: name9, args, returns } = parseMethodSignature(signature);
    return new ABIMethod({
      name: name9,
      args: args.map((arg) => ({ type: arg })),
      returns: { type: returns }
    });
  }
};
function getMethodByName(methods2, name9) {
  if (methods2 === null || !Array.isArray(methods2) || !methods2.every((item) => item instanceof ABIMethod))
    throw new Error("Methods list provided is null or not the correct type");
  const filteredMethods = methods2.filter((m) => m.name === name9);
  if (filteredMethods.length > 1)
    throw new Error(`found ${filteredMethods.length} methods with the same name ${filteredMethods.map((m) => m.getSignature()).join(",")}`);
  if (filteredMethods.length === 0)
    throw new Error(`found 0 methods with the name ${name9}`);
  return filteredMethods[0];
}
var ABIContract = class {
  constructor(params) {
    if (typeof params.name !== "string" || !Array.isArray(params.methods) || params.networks && typeof params.networks !== "object") {
      throw new Error("Invalid ABIContract parameters");
    }
    this.name = params.name;
    this.description = params.desc;
    this.networks = params.networks ? { ...params.networks } : {};
    this.methods = params.methods.map((method) => new ABIMethod(method));
  }
  toJSON() {
    return {
      name: this.name,
      desc: this.description,
      networks: this.networks,
      methods: this.methods.map((method) => method.toJSON())
    };
  }
  getMethodByName(name9) {
    return getMethodByName(this.methods, name9);
  }
};
var ABIInterface = class {
  constructor(params) {
    if (typeof params.name !== "string" || !Array.isArray(params.methods)) {
      throw new Error("Invalid ABIInterface parameters");
    }
    this.name = params.name;
    this.description = params.desc;
    this.methods = params.methods.map((method) => new ABIMethod(method));
  }
  toJSON() {
    return {
      name: this.name,
      desc: this.description,
      methods: this.methods.map((method) => method.toJSON())
    };
  }
  getMethodByName(name9) {
    return getMethodByName(this.methods, name9);
  }
};
var RETURN_PREFIX = Buffer.from([21, 31, 124, 117]);
var MAX_APP_ARGS = 16;
var AtomicTransactionComposerStatus;
(function(AtomicTransactionComposerStatus2) {
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILDING"] = 0] = "BUILDING";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILT"] = 1] = "BUILT";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SIGNED"] = 2] = "SIGNED";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SUBMITTED"] = 3] = "SUBMITTED";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["COMMITTED"] = 4] = "COMMITTED";
})(AtomicTransactionComposerStatus || (AtomicTransactionComposerStatus = {}));
function populateForeignArray(valueToAdd, array, zeroValue) {
  if (zeroValue != null && valueToAdd === zeroValue) {
    return 0;
  }
  const offset = zeroValue == null ? 0 : 1;
  for (let i2 = 0; i2 < array.length; i2++) {
    if (valueToAdd === array[i2]) {
      return i2 + offset;
    }
  }
  array.push(valueToAdd);
  return array.length - 1 + offset;
}
var AtomicTransactionComposer = class {
  constructor() {
    this.status = AtomicTransactionComposerStatus.BUILDING;
    this.transactions = [];
    this.methodCalls = /* @__PURE__ */ new Map();
    this.signedTxns = [];
    this.txIDs = [];
  }
  /**
   * Get the status of this composer's transaction group.
   */
  getStatus() {
    return this.status;
  }
  /**
   * Get the number of transactions currently in this atomic group.
   */
  count() {
    return this.transactions.length;
  }
  /**
   * Create a new composer with the same underlying transactions. The new composer's status will be
   * BUILDING, so additional transactions may be added to it.
   */
  clone() {
    const theClone = new AtomicTransactionComposer();
    theClone.transactions = this.transactions.map(({ txn, signer }) => ({
      // not quite a deep copy, but good enough for our purposes (modifying txn.group in buildGroup)
      txn: Transaction.from_obj_for_encoding({
        ...txn.get_obj_for_encoding(),
        // erase the group ID
        grp: void 0
      }),
      signer
    }));
    theClone.methodCalls = new Map(this.methodCalls);
    return theClone;
  }
  /**
   * Add a transaction to this atomic group.
   *
   * An error will be thrown if the transaction has a nonzero group ID, the composer's status is
   * not BUILDING, or if adding this transaction causes the current group to exceed MAX_GROUP_SIZE.
   */
  addTransaction(txnAndSigner) {
    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {
      throw new Error("Cannot add transactions when composer status is not BUILDING");
    }
    if (this.transactions.length === AtomicTransactionComposer.MAX_GROUP_SIZE) {
      throw new Error(`Adding an additional transaction exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);
    }
    if (txnAndSigner.txn.group && txnAndSigner.txn.group.some((v) => v !== 0)) {
      throw new Error("Cannot add a transaction with nonzero group ID");
    }
    this.transactions.push(txnAndSigner);
  }
  /**
   * Add a smart contract method call to this atomic group.
   *
   * An error will be thrown if the composer's status is not BUILDING, if adding this transaction
   * causes the current group to exceed MAX_GROUP_SIZE, or if the provided arguments are invalid
   * for the given method.
   */
  addMethodCall({ appID, method, methodArgs, sender, suggestedParams, onComplete, approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages, boxes, note, lease, rekeyTo, signer }) {
    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {
      throw new Error("Cannot add transactions when composer status is not BUILDING");
    }
    if (this.transactions.length + method.txnCount() > AtomicTransactionComposer.MAX_GROUP_SIZE) {
      throw new Error(`Adding additional transactions exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);
    }
    if (appID === 0) {
      if (approvalProgram == null || clearProgram == null || numGlobalInts == null || numGlobalByteSlices == null || numLocalInts == null || numLocalByteSlices == null) {
        throw new Error("One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices");
      }
    } else if (onComplete === OnApplicationComplete.UpdateApplicationOC) {
      if (approvalProgram == null || clearProgram == null) {
        throw new Error("One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram");
      }
      if (numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {
        throw new Error("One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
      }
    } else if (approvalProgram != null || clearProgram != null || numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {
      throw new Error("One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
    }
    if (methodArgs == null) {
      methodArgs = [];
    }
    if (methodArgs.length !== method.args.length) {
      throw new Error(`Incorrect number of method arguments. Expected ${method.args.length}, got ${methodArgs.length}`);
    }
    let basicArgTypes = [];
    let basicArgValues = [];
    const txnArgs = [];
    const refArgTypes = [];
    const refArgValues = [];
    const refArgIndexToBasicArgIndex = /* @__PURE__ */ new Map();
    const boxReferences = !boxes ? [] : boxes;
    for (let i2 = 0; i2 < methodArgs.length; i2++) {
      let argType = method.args[i2].type;
      const argValue = methodArgs[i2];
      if (abiTypeIsTransaction(argType)) {
        if (!isTransactionWithSigner(argValue) || !abiCheckTransactionType(argType, argValue.txn)) {
          throw new Error(`Expected ${argType} transaction for argument at index ${i2}`);
        }
        if (argValue.txn.group && argValue.txn.group.some((v) => v !== 0)) {
          throw new Error("Cannot add a transaction with nonzero group ID");
        }
        txnArgs.push(argValue);
        continue;
      }
      if (isTransactionWithSigner(argValue)) {
        throw new Error(`Expected non-transaction value for argument at index ${i2}`);
      }
      if (abiTypeIsReference(argType)) {
        refArgIndexToBasicArgIndex.set(refArgTypes.length, basicArgTypes.length);
        refArgTypes.push(argType);
        refArgValues.push(argValue);
        argType = new ABIUintType(8);
      }
      if (typeof argType === "string") {
        throw new Error(`Unknown ABI type: ${argType}`);
      }
      basicArgTypes.push(argType);
      basicArgValues.push(argValue);
    }
    const resolvedRefIndexes = [];
    const foreignAccounts = [];
    const foreignApps = [];
    const foreignAssets = [];
    for (let i2 = 0; i2 < refArgTypes.length; i2++) {
      const refType = refArgTypes[i2];
      const refValue = refArgValues[i2];
      let resolved = 0;
      switch (refType) {
        case ABIReferenceType.account: {
          const addressType = new ABIAddressType();
          const address = addressType.decode(addressType.encode(refValue));
          resolved = populateForeignArray(address, foreignAccounts, sender);
          break;
        }
        case ABIReferenceType.application: {
          const uint64Type = new ABIUintType(64);
          const refAppID = uint64Type.decode(uint64Type.encode(refValue));
          if (refAppID > Number.MAX_SAFE_INTEGER) {
            throw new Error(`Expected safe integer for application value, got ${refAppID}`);
          }
          resolved = populateForeignArray(Number(refAppID), foreignApps, appID);
          break;
        }
        case ABIReferenceType.asset: {
          const uint64Type = new ABIUintType(64);
          const refAssetID = uint64Type.decode(uint64Type.encode(refValue));
          if (refAssetID > Number.MAX_SAFE_INTEGER) {
            throw new Error(`Expected safe integer for asset value, got ${refAssetID}`);
          }
          resolved = populateForeignArray(Number(refAssetID), foreignAssets);
          break;
        }
        default:
          throw new Error(`Unknown reference type: ${refType}`);
      }
      resolvedRefIndexes.push(resolved);
    }
    for (let i2 = 0; i2 < resolvedRefIndexes.length; i2++) {
      const basicArgIndex = refArgIndexToBasicArgIndex.get(i2);
      basicArgValues[basicArgIndex] = resolvedRefIndexes[i2];
    }
    if (basicArgTypes.length > MAX_APP_ARGS - 1) {
      const lastArgTupleTypes = basicArgTypes.slice(MAX_APP_ARGS - 2);
      const lastArgTupleValues = basicArgValues.slice(MAX_APP_ARGS - 2);
      basicArgTypes = basicArgTypes.slice(0, MAX_APP_ARGS - 2);
      basicArgValues = basicArgValues.slice(0, MAX_APP_ARGS - 2);
      basicArgTypes.push(new ABITupleType(lastArgTupleTypes));
      basicArgValues.push(lastArgTupleValues);
    }
    const appArgsEncoded = [method.getSelector()];
    for (let i2 = 0; i2 < basicArgTypes.length; i2++) {
      appArgsEncoded.push(basicArgTypes[i2].encode(basicArgValues[i2]));
    }
    const appCall = {
      txn: makeApplicationCallTxnFromObject({
        from: sender,
        appIndex: appID,
        appArgs: appArgsEncoded,
        accounts: foreignAccounts,
        foreignApps,
        foreignAssets,
        boxes: boxReferences,
        onComplete: onComplete == null ? OnApplicationComplete.NoOpOC : onComplete,
        approvalProgram,
        clearProgram,
        numGlobalInts,
        numGlobalByteSlices,
        numLocalInts,
        numLocalByteSlices,
        extraPages,
        lease,
        note,
        rekeyTo,
        suggestedParams
      }),
      signer
    };
    this.transactions.push(...txnArgs, appCall);
    this.methodCalls.set(this.transactions.length - 1, method);
  }
  /**
   * Finalize the transaction group and returned the finalized transactions.
   *
   * The composer's status will be at least BUILT after executing this method.
   */
  buildGroup() {
    if (this.status === AtomicTransactionComposerStatus.BUILDING) {
      if (this.transactions.length === 0) {
        throw new Error("Cannot build a group with 0 transactions");
      }
      if (this.transactions.length > 1) {
        assignGroupID(this.transactions.map((txnWithSigner) => txnWithSigner.txn));
      }
      this.status = AtomicTransactionComposerStatus.BUILT;
    }
    return this.transactions;
  }
  /**
   * Obtain signatures for each transaction in this group. If signatures have already been obtained,
   * this method will return cached versions of the signatures.
   *
   * The composer's status will be at least SIGNED after executing this method.
   *
   * An error will be thrown if signing any of the transactions fails.
   *
   * @returns A promise that resolves to an array of signed transactions.
   */
  async gatherSignatures() {
    if (this.status >= AtomicTransactionComposerStatus.SIGNED) {
      return this.signedTxns;
    }
    const txnsWithSigners = this.buildGroup();
    const txnGroup = txnsWithSigners.map((txnWithSigner) => txnWithSigner.txn);
    const indexesPerSigner = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < txnsWithSigners.length; i2++) {
      const { signer } = txnsWithSigners[i2];
      if (!indexesPerSigner.has(signer)) {
        indexesPerSigner.set(signer, []);
      }
      indexesPerSigner.get(signer).push(i2);
    }
    const orderedSigners = Array.from(indexesPerSigner);
    const batchedSigs = await Promise.all(orderedSigners.map(([signer, indexes]) => signer(txnGroup, indexes)));
    const signedTxns = txnsWithSigners.map(() => null);
    for (let signerIndex = 0; signerIndex < orderedSigners.length; signerIndex++) {
      const indexes = orderedSigners[signerIndex][1];
      const sigs = batchedSigs[signerIndex];
      for (let i2 = 0; i2 < indexes.length; i2++) {
        signedTxns[indexes[i2]] = sigs[i2];
      }
    }
    if (!signedTxns.every((sig) => sig != null)) {
      throw new Error(`Missing signatures. Got ${signedTxns}`);
    }
    const txIDs = signedTxns.map((stxn, index2) => {
      try {
        return decodeSignedTransaction(stxn).txn.txID();
      } catch (err2) {
        throw new Error(`Cannot decode signed transaction at index ${index2}. ${err2}`);
      }
    });
    this.signedTxns = signedTxns;
    this.txIDs = txIDs;
    this.status = AtomicTransactionComposerStatus.SIGNED;
    return signedTxns;
  }
  /**
   * Send the transaction group to the network, but don't wait for it to be committed to a block. An
   * error will be thrown if submission fails.
   *
   * The composer's status must be SUBMITTED or lower before calling this method. If submission is
   * successful, this composer's status will update to SUBMITTED.
   *
   * Note: a group can only be submitted again if it fails.
   *
   * @param client - An Algodv2 client
   *
   * @returns A promise that, upon success, resolves to a list of TxIDs of the submitted transactions.
   */
  async submit(client) {
    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {
      throw new Error("Transaction group cannot be resubmitted");
    }
    const stxns = await this.gatherSignatures();
    await client.sendRawTransaction(stxns).do();
    this.status = AtomicTransactionComposerStatus.SUBMITTED;
    return this.txIDs;
  }
  /**
   * Send the transaction group to the network and wait until it's committed to a block. An error
   * will be thrown if submission or execution fails.
   *
   * The composer's status must be SUBMITTED or lower before calling this method, since execution is
   * only allowed once. If submission is successful, this composer's status will update to SUBMITTED.
   * If the execution is also successful, this composer's status will update to COMMITTED.
   *
   * Note: a group can only be submitted again if it fails.
   *
   * @param client - An Algodv2 client
   * @param waitRounds - The maximum number of rounds to wait for transaction confirmation
   *
   * @returns A promise that, upon success, resolves to an object containing the confirmed round for
   *   this transaction, the txIDs of the submitted transactions, and an array of results containing
   *   one element for each method call transaction in this group.
   */
  async execute(client, waitRounds) {
    if (this.status === AtomicTransactionComposerStatus.COMMITTED) {
      throw new Error("Transaction group has already been executed successfully");
    }
    const txIDs = await this.submit(client);
    this.status = AtomicTransactionComposerStatus.SUBMITTED;
    const firstMethodCallIndex = this.transactions.findIndex((_, index2) => this.methodCalls.has(index2));
    const indexToWaitFor = firstMethodCallIndex === -1 ? 0 : firstMethodCallIndex;
    const confirmedTxnInfo = await waitForConfirmation(client, txIDs[indexToWaitFor], waitRounds);
    this.status = AtomicTransactionComposerStatus.COMMITTED;
    const confirmedRound = confirmedTxnInfo["confirmed-round"];
    const methodResults = [];
    for (const [txnIndex, method] of this.methodCalls) {
      const txID = txIDs[txnIndex];
      const methodResult = {
        txID,
        rawReturnValue: new Uint8Array(),
        method
      };
      try {
        const pendingInfo = txnIndex === firstMethodCallIndex ? confirmedTxnInfo : (
          // eslint-disable-next-line no-await-in-loop
          await client.pendingTransactionInformation(txID).do()
        );
        methodResult.txInfo = pendingInfo;
        if (method.returns.type !== "void") {
          const logs = pendingInfo.logs || [];
          if (logs.length === 0) {
            throw new Error("App call transaction did not log a return value");
          }
          const lastLog = Buffer.from(logs[logs.length - 1], "base64");
          if (lastLog.byteLength < 4 || !lastLog.slice(0, 4).equals(RETURN_PREFIX)) {
            throw new Error("App call transaction did not log a return value");
          }
          methodResult.rawReturnValue = new Uint8Array(lastLog.slice(4));
          methodResult.returnValue = method.returns.type.decode(methodResult.rawReturnValue);
        }
      } catch (err2) {
        methodResult.decodeError = err2;
      }
      methodResults.push(methodResult);
    }
    return {
      confirmedRound,
      txIDs,
      methodResults
    };
  }
};
AtomicTransactionComposer.MAX_GROUP_SIZE = 16;
var SIGN_BYTES_PREFIX = Buffer.from([77, 88]);
var MULTISIG_BAD_SENDER_ERROR_MSG = "The transaction sender address and multisig preimage do not match.";
function signTransaction(txn, sk) {
  if (typeof txn.from === "undefined") {
    const key = keyPairFromSecretKey(sk);
    txn.from = encodeAddress(key.publicKey);
  }
  const algoTxn = instantiateTxnIfNeeded(txn);
  return {
    txID: algoTxn.txID().toString(),
    blob: algoTxn.signTxn(sk)
  };
}
function signBid(bid, sk) {
  const signedBid = new Bid(bid);
  return signedBid.signBid(sk);
}
function signBytes(bytes, sk) {
  const toBeSigned = Buffer.from(concatArrays(SIGN_BYTES_PREFIX, bytes));
  const sig = sign(toBeSigned, sk);
  return sig;
}
function verifyBytes(bytes, signature, addr) {
  const toBeVerified = Buffer.from(concatArrays(SIGN_BYTES_PREFIX, bytes));
  const pk = decodeAddress(addr).publicKey;
  return verify(toBeVerified, signature, pk);
}
function encodeObj(o) {
  return new Uint8Array(encode2(o));
}
function decodeObj(o) {
  return decode2(o);
}
var ERROR_MULTISIG_BAD_SENDER = new Error(MULTISIG_BAD_SENDER_ERROR_MSG);
var ERROR_INVALID_MICROALGOS = new Error(INVALID_MICROALGOS_ERROR_MSG);
var esm_default = main_exports;
/*! Bundled license information:

js-sha512/src/sha512.js:
  (*
   * [js-sha512]{@link https://github.com/emn178/js-sha512}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2018
   * @license MIT
   *)

hi-base32/src/base32.js:
  (*
   * [hi-base32]{@link https://github.com/emn178/hi-base32}
   *
   * @version 0.5.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)
*/
class Algorand {
  constructor() {
    this.indexerClient = new esm_default.Indexer("", "https://algoindexer.algoexplorerapi.io", 443);
  }
  getAssets(creator) {
    const indexerClient = this.indexerClient;
    const execute = function(page) {
      return new Promise((resolve7, reject) => {
        indexerClient.lookupAccountCreatedAssets(creator).nextToken(page).do().then((response) => {
          if (response["next-token"] === void 0) {
            resolve7(response.assets);
          } else {
            execute(response["next-token"]).then((assets) => resolve7([...assets, ...response.assets])).catch((error) => reject(error));
          }
        }).catch((error) => reject(error));
      });
    };
    return execute();
  }
  getAssetConfigTransactions(creator) {
    const indexerClient = this.indexerClient;
    const execute = function(page) {
      return new Promise((resolve7, reject) => {
        indexerClient.searchForTransactions().address(creator).addressRole("sender").txType("acfg").nextToken(page).do().then((response) => {
          if (response["next-token"] === void 0) {
            resolve7(response.transactions);
          } else {
            execute(response["next-token"]).then((transactions) => resolve7([...transactions, ...response.transactions])).catch((error) => reject(error));
          }
        }).catch((error) => reject(error));
      });
    };
    return execute();
  }
  getAccountAssets(account) {
    const indexerClient = this.indexerClient;
    const execute = function(page) {
      return new Promise((resolve7, reject) => {
        indexerClient.lookupAccountAssets(account).nextToken(page).do().then((response) => {
          if (response["next-token"] === void 0) {
            resolve7(response.assets);
          } else {
            execute(response["next-token"]).then((assets) => resolve7([...assets, ...response.assets])).catch((error) => reject(error));
          }
        }).catch((error) => reject(error));
      });
    };
    return execute();
  }
}
class Graph {
  constructor() {
    __publicField2(this, "graph", []);
  }
  /**
   * Add a new root node to the graph.
   * @param {object} node The new root node
   */
  addRoot(node) {
    this.graph.push(node);
  }
  /**
   * Retrieve a node from the graph based on the value of its `id`
   * attribute. If no matching node is found then an exception will be
   * thrown.
   * @param {string} id The id of the node to locate
   * @returns {object} The node, if it exists
   */
  findById(id) {
    const queue = [];
    queue.push(...this.graph);
    while (queue.length > 0) {
      var node = queue.shift();
      if (node.id === id)
        return node;
      if (node.children)
        queue.push(...node.children);
    }
    throw "Unknown node: " + id;
  }
  /**
   * Caculate the height of the provided node in the graph.
   * @param {object} node The node to check
   * @returns {number} The height of the node
   **/
  height(node) {
    var max = 0;
    for (var i2 = 0; i2 < node.children.length; i2++) {
      max = Math.max(max, this.height(node.children[i2]));
    }
    return max + 1;
  }
  descendants(node) {
    if (!node.children)
      return 0;
    var count = node.children.length;
    for (var i2 = 0; i2 < node.children.length; i2++) {
      count += this.descendants(node.children[i2]);
    }
    return count;
  }
}
const _ARC19 = class {
  static parse(url2, reserveAddress) {
    var cid = _ARC19.parseCID(url2, reserveAddress);
    var ipfsUrl = "ipfs://" + cid.toString();
    return ipfsUrl;
  }
  static parseCID(url2, reserveAddress) {
    var matches = url2.match(_ARC19.REGEX);
    if (!matches) {
      if (url2.startsWith("template-ipfs://"))
        throw "unsupported template-ipfs spec";
      return url2;
    }
    const version3 = parseInt(matches.groups.version);
    const codec = matches.groups.codec;
    const field = matches.groups.field;
    const hash2 = matches.groups.hash;
    if (field != "reserve")
      throw "unsupported ipfscid field '" + field + "', only reserve is currently supported";
    var codecId;
    switch (codec) {
      case "raw":
        codecId = 85;
        break;
      case "dag-pb":
        codecId = 112;
        break;
      default:
        throw "unknown multicodec type '" + codec + "' in ipfscid spec";
    }
    const address = esm_default.decodeAddress(reserveAddress);
    var mhdigest;
    switch (hash2) {
      case "sha2-256":
        mhdigest = create(sha256.code, address.publicKey);
        break;
      default:
        throw "unknown hash type '" + hash2 + "' in ipfscid spec";
    }
    if (version3 == 0) {
      if (codec != "dag-pb" || hash2 != "sha2-256")
        throw "cid v0 must always be dag-pb and sha2-256 codec/hash type";
      return CID.createV0(mhdigest);
    } else {
      return CID.createV1(codecId, mhdigest);
    }
  }
};
let ARC19 = _ARC19;
__publicField2(ARC19, "REGEX", "template-ipfs://{ipfscid:(?<version>[01]):(?<codec>[a-z0-9-]+):(?<field>[a-z0-9-]+):(?<hash>[a-z0-9-]+)}");
const creatorAddress = "KANIGZX2NQKJKYJ425BWYKCT5EUHSPBRLXEJLIT2JHGTWOJ2MLYCNIVHFI";
const algorandClient$2 = new Algorand();
const cloudflareUrl = "https://cloudflare-ipfs.com";
const arguteUrl = "https://ipfs.argute.io";
function httpGetIPFSResource(baseUrl, cid) {
  return axios_default.get(`${baseUrl}/ipfs/${cid}`).then((response) => response.data);
}
function resolveIPFS(cid, ipfsClient) {
  console.log(`Loading ${cid} from IPFS...`);
  return toBuffer(ipfsClient.cat(cid, { timeout: 1e3 })).then((contents) => new TextDecoder("utf-8").decode(contents)).then((text) => JSON.parse(text)).catch((ipfsError) => {
    console.log(`WARN: Failed to load ${cid} via IPFS, falling back to ${arguteUrl}.`);
    return httpGetIPFSResource(arguteUrl, cid).catch((arguteError) => {
      console.log(`WARN: Failed to load ${cid} via ${arguteUrl}, falling back to ${cloudflareUrl}.`);
      return httpGetIPFSResource(cloudflareUrl, cid).catch((cloudflareError) => {
        console.log(`Failed to load data for ${cid}!`);
        console.log("IPFS Error:");
        console.log(ipfsError);
        console.log("Argute Error:");
        console.log(arguteError);
        console.log("Cloudflare Error:");
        console.log(cloudflareError);
        throw `Unable to load ${cid} from IPFS or a public HTTP gateway.`;
      });
    });
  });
}
function parseName(description) {
  if (!description) {
    return "";
  } else if (/^\s*Kani World -\s+Kani[ -][0-9]+$/.test(description)) {
    return description.replace(/^\s*Kani World -\s*/i, "");
  } else {
    return description.replace(/^\s*Kani World - (Kani )?/i, "");
  }
}
function metadataToNode(id, asset, metadata) {
  return {
    id,
    children: [],
    asset,
    metadata,
    name: parseName(metadata.description)
  };
}
function loadKani(ipfsPromise) {
  console.log("Loading assets created by " + creatorAddress + "...");
  const assetsPromise = algorandClient$2.getAssets(creatorAddress).then((assets) => {
    console.log("Loaded " + assets.length + " asset(s).");
    return assets;
  });
  console.log("Loading asset config transactions...");
  const transactionsPromise = algorandClient$2.getAssetConfigTransactions(creatorAddress).then((transactions) => {
    console.log("Loaded " + transactions.length + " transaction(s).");
    return transactions;
  });
  console.log("Connecting to IPFS...");
  ipfsPromise = ipfsPromise.then((ipfs2) => {
    console.log("Connected to IPFS.");
    return ipfs2;
  });
  return Promise.all([assetsPromise, transactionsPromise, ipfsPromise]).then((values) => {
    var assets = values[0];
    var transactions = values[1];
    var ipfs2 = values[2];
    transactions.sort((a, b) => a["confirmed-round"] - b["confirmed-round"]);
    return Promise.all(assets.map((asset) => {
      var id = String(asset.index);
      var name9 = asset["params"]["unit-name"];
      if (asset.params.url.startsWith("template-ipfs://")) {
        var cid = ARC19.parseCID(asset.params.url, asset.params.reserve).toString();
        console.log(name9 + " (" + id + ") uses ARC19, loading " + cid + " from IPFS...");
        return resolveIPFS(cid, ipfs2).then((json) => metadataToNode(id, asset, json)).catch((error) => {
          console.log("Error loading metadata for " + name9 + " (" + id + ")! IPFS CID: " + cid);
          console.log(error);
        });
      } else {
        var tx = transactions.findLast((tx2) => tx2.hasOwnProperty("note") && id == String(tx2["created-asset-index"] || tx2["asset-config-transaction"]["asset-id"]));
        var metadata = JSON.parse(window.atob(tx.note));
        return metadataToNode(id, asset, metadata);
      }
    }));
  }).then((nodes) => nodes.filter((e) => e !== void 0)).then((nodes) => {
    nodes.sort((a, b) => a["asset"]["params"]["unit-name"].toLowerCase().localeCompare(b["asset"]["params"]["unit-name"].toLowerCase()));
    return nodes;
  }).then((nodes) => {
    console.log("Loaded " + nodes.length + " kani assets.");
    return nodes;
  });
}
const algorandClient$1 = new Algorand();
const queens = ["394248226", "394250676", "394243491", "394251425"];
function familyTree(nodes) {
  const ownedAssets = [];
  var root2 = { id: "Original8", name: "Original8", children: [] };
  var graph = new Graph();
  graph.addRoot(root2);
  nodes.forEach((node, i3) => {
    if (!node.children)
      node.children = [];
    if (queens.includes(node.id))
      return;
    var fatherId = String(node.metadata.properties["Father"]);
    var father = fatherId == "Original8" ? root2 : nodes.find((e) => String(e.id) == fatherId);
    if (!father)
      throw "Unknown father: " + fatherId;
    if (!father.children)
      father.children = [];
    if (!father.children.find((e) => String(e.id) == String(node.id)))
      father.children.push(node);
  });
  [root2, ...nodes].forEach((node) => {
    node.children.sort((a, b) => -1 * (graph.descendants(a) - graph.descendants(b)));
  });
  var height = graph.height(root2);
  var diameter = height * 250;
  var i2 = 0;
  var duration = 350;
  var tree2 = d3.layout.tree().size([360, diameter / 2 - 80]).separation(function(a, b) {
    return (a.parent == b.parent ? 2 : 10) / a.depth;
  });
  var diagonal = d3.svg.diagonal.radial().projection(function(d) {
    return [d.y, d.x / 180 * Math.PI];
  });
  $("#content").empty();
  var div = d3.select("#content").append("div").attr("class", "tooltip").style("opacity", 0);
  var svg = d3.select("#content").append("svg").attr("width", diameter).attr("height", diameter).append("g").attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");
  root2.x0 = diameter / 2;
  root2.y0 = 0;
  drawGraph2(root2);
  $("#owner-address-search [disabled]").prop("disabled", false);
  $("#owner-address-search").on("submit", (event) => {
    if ($("#content svg").length < 1)
      return;
    event.preventDefault();
    event.stopPropagation();
    $("#owner-address-search");
    var input = $("#owner-address");
    var feedback = $("#owner-address-validation-feedback");
    algorandClient$1.getAccountAssets(input.val()).then((assets) => {
      ownedAssets.length = 0;
      for (var i3 = 0; i3 < assets.length; i3++) {
        var asset = assets[i3];
        if (asset.amount <= 0)
          continue;
        ownedAssets.push(String(asset["asset-id"]));
      }
      input.removeClass("is-invalid");
      input.addClass("is-valid");
      feedback.text("");
      drawGraph2(root2);
    }).catch((e) => {
      input.removeClass("is-valid");
      input.addClass("is-invalid");
      feedback.text(e);
      ownedAssets.length = 0;
      drawGraph2(root2);
    });
    return false;
  });
  function drawGraph2(source) {
    var nodes2 = tree2.nodes(root2);
    var links3 = tree2.links(nodes2);
    nodes2.forEach(function(d) {
      d.y = d.depth * 125;
    });
    var node = svg.selectAll("g.node").data(nodes2, function(d) {
      return d.id || (d.id = ++i2);
    });
    var nodeEnter = node.enter().append("g").attr("class", "node").attr("data-toggle", "modal").attr("data-target", "#kaniModal").on("mouseover", function(d) {
      if (d == root2)
        return;
      div.transition().duration(200).style("opacity", 0.9);
      var html = "<dl><dt>Asset ID:</dt><dd>" + d.id + "</dd><dt>Asset Name:</dt><dd>" + d.asset.params.name + "</dd><dt>Name:</dt><dd>" + d.name + "</dd>";
      for (var property in d.metadata.properties) {
        if (d.metadata.properties.hasOwnProperty(property)) {
          html += "<dt>" + property + ":</dt><dd>" + d.metadata.properties[property] + "</dd>";
        }
      }
      html += "<dt>Children:</dt><dd>" + (d.children ? d.children.length : 0) + "</dd><dt>Descendants:</dt><dd>" + graph.descendants(d) + "</dd></dl>";
      div.html(html).style("left", d3.event.pageX + "px").style("top", d3.event.pageY - 75 + "px");
    }).on("mouseout", function(d) {
      div.transition().duration(500).style("opacity", 0);
    });
    nodeEnter.append("circle").attr("r", 1e-6).style("fill", function(d) {
      return d._children ? "lightsteelblue" : "#fff";
    });
    nodeEnter.append("text").attr("dx", 10).attr("dy", ".35em").attr("text-anchor", "start").text(function(d) {
      return d.name;
    }).style("fill-opacity", 1e-6);
    var nodeUpdate = node.transition().duration(duration).attr("transform", function(d) {
      return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")";
    });
    nodeUpdate.select("circle").attr("r", 4.5).style("stroke", function(d) {
      return ownedAssets.includes(d.id) ? "red" : "steelblue";
    }).style("fill", function(d) {
      return d._children ? "lightsteelblue" : "#fff";
    });
    nodeUpdate.select("text").style("fill-opacity", 1).attr("dx", (d) => d.x < 180 ? 8 : -8).attr("text-anchor", (d) => d.x < 180 ? "start" : "end").attr("transform", (d) => d.x < 180 ? null : "rotate(180)");
    var nodeExit = node.exit().transition().duration(duration).remove();
    nodeExit.select("circle").attr("r", 1e-6);
    nodeExit.select("text").style("fill-opacity", 1e-6);
    var link = svg.selectAll("path.link").data(links3, function(d) {
      return d.target.id;
    });
    link.enter().insert("path", "g").attr("class", "link").attr("d", function(d) {
      var o = { x: source.x0, y: source.y0 };
      return diagonal({ source: o, target: o });
    });
    link.transition().duration(duration).attr("d", diagonal);
    link.exit().transition().duration(duration).attr("d", function(d) {
      var o = { x: source.x, y: source.y };
      return diagonal({ source: o, target: o });
    }).remove();
    nodes2.forEach(function(d) {
      d.x0 = d.x;
      d.y0 = d.y;
    });
  }
  $("#kaniModal").on("show.bs.modal", function(d) {
    var d = d3.select(".info").data().pop();
    let modalTitle = d3.selectAll("h4.modal-title");
    modalTitle.text("test");
    let modalBody = d3.selectAll(".modal-body");
    modalBody.html(d);
    console.log(d);
  });
}
const algorandClient = new Algorand();
function rank(value2, mid) {
  return parseInt(value2) - mid;
}
function intWithSign(i2) {
  return (i2 < 0 ? "" : "+") + i2;
}
function attributeRankSpan(value2, rank2) {
  var buffOrBuffs = "buff" + (Math.abs(rank2) == 1 ? "" : "s");
  var title = "This attribute is " + (rank2 == 0 ? "equal to" : Math.abs(rank2) + " " + buffOrBuffs + " " + (rank2 < 0 ? "below" : "above")) + " the median value.";
  return "<span class='attribute' title='" + title + "'>" + value2 + "<sup class='rank'>" + intWithSign(rank2) + "</sup></span>";
}
function mutationResult(mutation) {
  switch (mutation) {
    case "False":
      return "";
    case "Power Claw":
      return "+3 Power";
    case "Weak Claw":
      return "-3 Power";
    case "Grippy Claw":
      return "+3 Wrestle";
    case "Slippery Claw":
      return "-3 Wrestle";
    case "Spotted Claw":
      return "+3 Appeal";
    case "Plain Claw":
      return "-3 Appeal";
    default:
      return "Unknown";
  }
}
function mutationBackground(mutation) {
  switch (mutation) {
    case "False":
      return "";
    case "Power Claw":
      return "success";
    case "Weak Claw":
      return "warning";
    case "Grippy Claw":
      return "success";
    case "Slippery Claw":
      return "warning";
    case "Spotted Claw":
      return "success";
    case "Plain Claw":
      return "warning";
    default:
      return "";
  }
}
function nftExplorerLink(id, text) {
  if (!text)
    text = id;
  return "<a href='https://www.nftexplorer.app/asset/" + id + "' title='View on NFT Explorer' target='_blank'>" + text + "</a>";
}
function parentLink(data, parentId) {
  if (parentId == "Original8")
    return "";
  var name9 = parentId;
  var parent2 = data.find((e) => e.id == parentId);
  if (parent2)
    name9 = parent2.name;
  return nftExplorerLink(parentId, name9);
}
function countChildren(data, parentId) {
  return data.filter((e) => e["metadata"]["properties"]["Mother"] == parentId || e["metadata"]["properties"]["Father"] == parentId).length;
}
function rankBackground(rank2, set2) {
  var min = Math.min(...set2);
  var max = Math.max(...set2);
  var offset = -1 * min;
  var gradient = new Color("white").range(new Color("#28a745"));
  return gradient((rank2 + offset) / ((max + offset) * 1.25)).to("sRGB").toString();
}
function specialMoveAttribute(move) {
  switch (move) {
    case "Claw Crush":
      return "Power";
    case "Crab Grab":
      return "Wrestle";
    case "Shell Quake":
      return "Stamina";
    case "Shell Shine":
      return "Appeal";
    case "Rapid Strike":
      return "Speed";
    default:
      return "Unknown";
  }
}
function specialMoveBackground(kani) {
  var attributes = ["power", "wrestle", "stamina", "appeal", "speed"];
  var bestAttribute = attributes.sort((a, b) => -1 * (parseInt(kani.ranks[a]) - parseInt(kani.ranks[b])))[0];
  var specialMoveAttr = specialMoveAttribute(kani["metadata"]["properties"]["Special Move"]);
  if (bestAttribute == specialMoveAttr.toLowerCase())
    return "";
  return "warning";
}
function generationIndex(generationStr) {
  if (generationStr == "Original8")
    return 0;
  if (!generationStr || generationStr == "")
    return -1;
  return parseInt(generationStr.match(/[0-9]+/)[0]);
}
function drawTable(data, fullDataset) {
  if (!fullDataset)
    fullDataset = data;
  $("#content").empty();
  var table2 = d3.select("#content").append("table").attr("class", "mykani table table-striped table-sm table-hover compact");
  var columns = [
    { head: "Unit", html: (k) => k["asset"]["params"]["unit-name"] },
    { head: "Asset ID", html: (k) => nftExplorerLink(k.id) },
    { head: "Name", html: (k) => "<span title='" + k.metadata.description + "'>" + k.name + "</span>" },
    // { head: "Image", html: k => {} },
    { head: "Power", bg: (k) => k.rankColors.power, html: (k) => attributeRankSpan(k.power, k.ranks.power), sort: (k) => k.power },
    { head: "Wrestle", bg: (k) => k.rankColors.wrestle, html: (k) => attributeRankSpan(k.wrestle, k.ranks.wrestle), sort: (k) => k.wrestle },
    { head: "Stamina", bg: (k) => k.rankColors.stamina, html: (k) => attributeRankSpan(k.stamina, k.ranks.stamina), sort: (k) => k.stamina },
    { head: "Appeal", bg: (k) => k.rankColors.appeal, html: (k) => attributeRankSpan(k.appeal, k.ranks.appeal), sort: (k) => k.appeal },
    { head: "Speed", bg: (k) => k.rankColors.speed, html: (k) => attributeRankSpan(k.speed, k.ranks.speed), sort: (k) => k.speed },
    { head: "Fight Rank", html: (k) => intWithSign(k.ranks.power + k.ranks.wrestle + k.ranks.stamina) },
    { head: "Total Rank", html: (k) => intWithSign(k.ranks.power + k.ranks.wrestle + k.ranks.stamina + k.ranks.appeal + k.ranks.speed) },
    { head: "Special Move", html: (k) => k["metadata"]["properties"]["Special Move"] },
    { head: "Special Move Attr", cl: (k) => specialMoveBackground(k), html: (k) => specialMoveAttribute(k["metadata"]["properties"]["Special Move"]) },
    { head: "Region", html: (k) => k["metadata"]["properties"]["Region"] },
    { head: "Power Bonus", html: (k) => k["metadata"]["properties"]["Power Bonus"] },
    { head: "Wrestle Bonus", html: (k) => k["metadata"]["properties"]["Wrestle Bonus"] },
    { head: "Mutation", cl: (k) => mutationBackground(k.mutation), html: (k) => k.mutation == "False" ? "" : "<span title='" + mutationResult(k.mutation) + "'>" + k.mutation + "</span>" },
    { head: "Mother", html: (k) => parentLink(fullDataset, k["metadata"]["properties"]["Mother"]) },
    { head: "Father", html: (k) => parentLink(fullDataset, k["metadata"]["properties"]["Father"]) },
    { head: "Highlights", html: (k) => k["metadata"]["properties"]["Highlights"] },
    { head: "Background", html: (k) => k["metadata"]["properties"]["Background"] },
    { head: "Generation", html: (k) => k["metadata"]["properties"]["Generation"], sort: (k) => generationIndex(k["metadata"]["properties"]["Generation"]) },
    { head: "Children", html: (k) => countChildren(fullDataset, k.id) }
  ];
  table2.append("thead").append("tr").selectAll("th").data(columns).enter().append("th").attr("class", (c) => c.cl).text((c) => c.head);
  table2.append("tbody").selectAll("tr").data(data).enter().append("tr").selectAll("td").data((row, i2) => {
    return columns.map((c) => {
      var cell = {};
      Object.keys(c).forEach((k) => {
        cell[k] = typeof c[k] == "function" ? c[k](row, i2) : c[k];
      });
      return cell;
    });
  }).enter().append("td").html((c) => c.html).attr("class", (c) => c.cl).style("background-color", (c) => c.bg).attr("data-sort", (c) => c.sort);
  $("#content > table").DataTable({
    paging: false
  });
}
function kaniList(data) {
  data.forEach((k) => {
    k["power"] = k["metadata"]["properties"]["Power"];
    k["wrestle"] = k["metadata"]["properties"]["Wrestle"];
    k["stamina"] = k["metadata"]["properties"]["Stamina"];
    k["appeal"] = k["metadata"]["properties"]["Appeal"];
    k["speed"] = k["metadata"]["properties"]["Speed"];
    k["mutation"] = k["metadata"]["properties"]["Mutation"];
    k["ranks"] = {
      power: rank(k.power, 10),
      wrestle: rank(k.wrestle, 10),
      stamina: rank(k.stamina, 10),
      appeal: rank(k.appeal, 10),
      speed: rank(k.speed, 15)
    };
  });
  data.forEach((k) => {
    k["rankColors"] = {
      power: rankBackground(k.ranks.power, data.map((k2) => k2.ranks.power)),
      wrestle: rankBackground(k.ranks.wrestle, data.map((k2) => k2.ranks.wrestle)),
      stamina: rankBackground(k.ranks.stamina, data.map((k2) => k2.ranks.stamina)),
      appeal: rankBackground(k.ranks.appeal, data.map((k2) => k2.ranks.appeal)),
      speed: rankBackground(k.ranks.speed, data.map((k2) => k2.ranks.speed))
    };
  });
  drawTable(data);
  $("#owner-address-search [disabled]").prop("disabled", false);
  $("#owner-address-search").on("submit", (event) => {
    if ($("#content table").length < 1)
      return;
    event.preventDefault();
    event.stopPropagation();
    $("#owner-address-search");
    var input = $("#owner-address");
    var feedback = $("#owner-address-validation-feedback");
    var address = input.val();
    if (address == "") {
      drawTable(data);
      return;
    }
    algorandClient.getAccountAssets(address).then((assets) => {
      var ownedAssets = [];
      for (var i2 = 0; i2 < assets.length; i2++) {
        var asset = assets[i2];
        if (asset.amount <= 0)
          continue;
        ownedAssets.push(String(asset["asset-id"]));
      }
      input.removeClass("is-invalid");
      input.addClass("is-valid");
      feedback.text("");
      drawTable(data.filter((kani) => ownedAssets.includes(kani.id)), data);
    }).catch((e) => {
      input.removeClass("is-valid");
      input.addClass("is-invalid");
      feedback.text(e);
      drawTable(data);
      drawGraph(root);
    });
    return false;
  });
}
const App = () => {
  $(document).ready((e) => {
    console.log("Loading data...");
    loadKani(create9()).then((kaniData) => {
      activateView(urlView(), kaniData);
      $(window).on("hashchange", () => activateView(urlView(), kaniData));
    });
  });
  function urlView() {
    switch (window.location.hash) {
      case "#kani-list":
        return "kani-list";
      default:
        return "family-tree";
    }
  }
  function activateView(view, kaniData) {
    $("#content").text("Loading data...");
    $(".nav-link").removeClass("active");
    $(".nav-link[href='#" + view + "']").addClass("active");
    switch (view) {
      case "kani-list":
        console.log("Starting kaniList...");
        kaniList(kaniData);
        break;
      default:
        console.log("Starting familyTree...");
        familyTree(kaniData);
        break;
    }
  }
};
App();
const index = "";
